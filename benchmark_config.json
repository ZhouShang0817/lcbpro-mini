{
  "templates_dir": "template",
  "output_dir": "tasks",
  "tasks": [
    {
      "TASK_NAME": "lcbpro-2121h",
      "PROBLEM_ID": "2121H",
      "PROBLEM_STATEMENT": "The longest non-decreasing subsequence of an array of integers $a_1, a_2, \\ldots, a_n$ is the longest sequence of indices $1 \\leq i_1 < i_2 < \\ldots < i_k \\leq n$ such that $a_{i_1} \\leq a_{i_2} \\leq \\ldots \\leq a_{i_k}$. The length of the sequence is defined as the number of elements in the sequence. For example, the length of the longest non-decreasing subsequence of the array $a = [3, 1, 4, 1, 2]$ is $3$.\n\nYou are given two arrays of integers $l_1, l_2, \\ldots, l_n$ and $r_1, r_2, \\ldots, r_n$. For each $1 \\le k \\le n$, solve the following problem:\n\n- Consider all arrays of integers $a$ of length $k$, such that for each $1 \\leq i \\leq k$, it holds that $l_i \\leq a_i \\leq r_i$. Find the maximum length of the longest non-decreasing subsequence among all such arrays.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the length of the arrays $l$ and $r$.\n\nThe next $n$ lines of each test case contain two integers $l_i$ and $r_i$ ($1 \\leq l_i \\leq r_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n$ integers: for each $k$ from $1$ to $n$, output the maximum length of the longest non-decreasing subsequence among all suitable arrays.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1\n\n1 1\n\n2\n\n3 4\n\n1 2\n\n4\n\n4 5\n\n3 4\n\n1 3\n\n3 3\n\n8\n\n6 8\n\n4 6\n\n3 5\n\n5 5\n\n3 4\n\n1 3\n\n2 4\n\n3 3\n\n5\n\n1 2\n\n6 8\n\n4 5\n\n2 3\n\n3 3\n\n11\n\n35 120\n\n66 229\n\n41 266\n\n98 164\n\n55 153\n\n125 174\n\n139 237\n\n30 72\n\n138 212\n\n109 123\n\n174 196\n\n```\n\n#### Output #1\n\n```\n1\n1 1\n1 2 2 3\n1 2 2 3 3 3 4 5\n1 2 2 2 3\n1 2 3 4 5 6 7 7 8 8 9\n```\n\n### Note\n\nIn the first test case, the only possible array is $a = [1]$. The length of the longest non-decreasing subsequence of this array is $1$.\n\nIn the second test case, for $k = 2$, no matter how we choose the values of $a_1$ and $a_2$, the condition $a_1 > a_2$ will always hold. Therefore, the answer for $k = 2$ will be $1$.\n\nIn the third test case, for $k = 4$, we can choose the array $a = [5, 3, 3, 3]$. The length of the longest non-decreasing subsequence of this array is $3$.\n\nIn the fourth test case, for $k = 8$, we can choose the array $a = [7, 5, 3, 5, 3, 3, 3, 3]$. The length of the longest non-decreasing subsequence of this array is $5$.\n\nIn the fifth test case, for $k = 5$, we can choose the array $a = [2, 8, 5, 3, 3]$. The length of the longest non-decreasing subsequence of this array is $3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int INF_NEG = -1000000000;\n\nstruct SegmentTree {\n    int n;\n    vector<int> st, lz;\n    SegmentTree(int _n = 0) { init(_n); }\n    void init(int _n) {\n        n = _n;\n        if (n <= 0) return;\n        st.assign(4*n, INF_NEG);\n        lz.assign(4*n, 0);\n        build(1, 0, n-1);\n    }\n    void build(int p, int l, int r) {\n        lz[p] = 0;\n        if (l == r) {\n            // dp[0] = 0, others = -inf\n            st[p] = (l == 0 ? 0 : INF_NEG);\n            return;\n        }\n        int m = (l + r) >> 1;\n        build(p<<1, l, m);\n        build(p<<1|1, m+1, r);\n        st[p] = max(st[p<<1], st[p<<1|1]);\n    }\n    inline void apply(int p, int v) {\n        st[p] += v;\n        lz[p] += v;\n    }\n    inline void push(int p) {\n        if (lz[p] != 0) {\n            apply(p<<1, lz[p]);\n            apply(p<<1|1, lz[p]);\n            lz[p] = 0;\n        }\n    }\n    void update_range(int p, int l, int r, int i, int j, int v) {\n        if (i > r || j < l) return;\n        if (i <= l && r <= j) {\n            apply(p, v);\n            return;\n        }\n        push(p);\n        int m = (l + r) >> 1;\n        update_range(p<<1, l, m, i, j, v);\n        update_range(p<<1|1, m+1, r, i, j, v);\n        st[p] = max(st[p<<1], st[p<<1|1]);\n    }\n    int query_max(int p, int l, int r, int i, int j) {\n        if (i > r || j < l) return INF_NEG;\n        if (i <= l && r <= j) {\n            return st[p];\n        }\n        push(p);\n        int m = (l + r) >> 1;\n        return max(query_max(p<<1, l, m, i, j),\n                   query_max(p<<1|1, m+1, r, i, j));\n    }\n    // wrappers\n    // add v to [i..j]\n    void add_range(int i, int j, int v) {\n        if (i > j) return;\n        update_range(1, 0, n-1, i, j, v);\n    }\n    // query max in [i..j]\n    int get_max(int i, int j) {\n        if (i > j) return INF_NEG;\n        return query_max(1, 0, n-1, i, j);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> l(n), r(n);\n        for (int i = 0; i < n; i++) {\n            cin >> l[i] >> r[i];\n        }\n        // compress l-values plus dummy 0\n        vector<int> V;\n        V.reserve(n + 1);\n        V.push_back(0);\n        for (int i = 0; i < n; i++) {\n            V.push_back(l[i]);\n        }\n        sort(V.begin(), V.end());\n        V.erase(unique(V.begin(), V.end()), V.end());\n        int m = V.size();\n\n        SegmentTree st(m);\n\n        vector<int> ans(n);\n        for (int i = 0; i < n; i++) {\n            // find idx_l, idx_r\n            int idx_l = int(lower_bound(V.begin(), V.end(), l[i]) - V.begin());\n            int idx_r = int(upper_bound(V.begin(), V.end(), r[i]) - V.begin()) - 1;\n            // 1) compute best1 = max dp[0..idx_l] + 1\n            int best1 = st.get_max(0, idx_l) + 1;\n            // 2) range add +1 for thresholds M in (l_i, r_i] => indices [idx_l+1..idx_r]\n            if (idx_l + 1 <= idx_r) {\n                st.add_range(idx_l+1, idx_r, 1);\n            }\n            // 3) update dp[idx_l] = max(dp[idx_l], best1)\n            int cur = st.get_max(idx_l, idx_l);\n            if (best1 > cur) {\n                st.add_range(idx_l, idx_l, best1 - cur);\n            }\n            // 4) current answer is global max\n            ans[i] = st.get_max(0, m-1);\n        }\n        // output\n        for (int i = 0; i < n; i++) {\n            if (i) cout << ' ';\n            cout << ans[i];\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2121g",
      "PROBLEM_ID": "2121G",
      "PROBLEM_STATEMENT": "You are given a binary string $s_1s_2 \\ldots s_n$ of length $n$. A string $s$ is called binary if it consists only of zeros and ones.\n\nFor a string $p$, we define the function $f(p)$ as the maximum number of occurrences of any character in the string $p$. For example, $f(00110) = 3$, $f(01) = 1$.\n\nYou need to find the sum $f(s_ls_{l+1} \\ldots s_r)$ for all pairs $1 \\leq l \\leq r \\leq n$.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. Then follows their descriptions.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of the binary string.\n\nThe second line of each test case contains a string of length $n$, consisting of $0$s and $1$s\u00a0\u2014 the binary string $s$.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the sum $f(s_ls_{l+1} \\ldots s_r)$ for all pairs $1 \\leq l \\leq r \\leq n$.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1\n\n0\n\n2\n\n01\n\n4\n\n0110\n\n6\n\n110001\n\n8\n\n10011100\n\n11\n\n01011011100\n\n```\n\n#### Output #1\n\n```\n1\n3\n14\n40\n78\n190\n```\n\n### Note\n\nIn the first test case, the string $s$ has one substring, and the value $f(0) = 1$.\n\nIn the second test case, all substrings of the string $s$ are $0$, $01$, $1$. And the answer is $1 + 1 + 1 = 3$, respectively.\n\nIn the third test case, all substrings of the string $s$ are $0$, $01$, $011$, $0110$, $1$, $11$, $110$, $1$, $10$, $0$. And the answer is $1 + 1 + 2 + 2 + 1 + 2 + 2 + 1 + 1 + 1 = 14$, respectively.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        \n        // Build prefix difference array.\n        // d[0] = 0; for each char, add +1 for '0' and -1 for '1'.\n        vector<long long> d(n+1, 0);\n        for (int i = 0; i < n; i++){\n            if(s[i] == '0') \n                d[i+1] = d[i] + 1;\n            else \n                d[i+1] = d[i] - 1;\n        }\n        \n        // Total length of all substrings = n*(n+1)*(n+2)/6.\n        long long totalSubLength = (long long)n * (n+1) * (n+2) / 6;\n        \n        // Compute sum_{0<=i<j<=n} |d[j]-d[i]|.\n        // Sort the prefix array.\n        vector<long long> sorted_d = d;\n        sort(sorted_d.begin(), sorted_d.end());\n        long long sumAbs = 0;\n        int m = sorted_d.size();\n        for (int i = 0; i < m; i++){\n            sumAbs += sorted_d[i] * (2LL * i - (m - 1));\n        }\n        \n        // Answer = (totalSubLength + sumAbs) / 2.\n        long long ans = (totalSubLength + sumAbs) / 2;\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2121e",
      "PROBLEM_ID": "2121E",
      "PROBLEM_STATEMENT": "For two integers $a$ and $b$, we define $f(a, b)$ as the number of positions in the decimal representation of the numbers $a$ and $b$ where their digits are the same. For example, $f(12, 21) = 0$, $f(31, 37) = 1$, $f(19891, 18981) = 2$, $f(54321, 24361) = 3$.\n\nYou are given two integers $l$ and $r$ of the same length in decimal representation. Consider all integers $l \\leq x \\leq r$. Your task is to find the minimum value of $f(l, x) + f(x, r)$.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nEach test case consists of a single line containing two integers $l$ and $r$ ($1 \\leq l \\leq r < 10^9$).\n\nIt is guaranteed that the numbers $l$ and $r$ have the same length in decimal representation and do not have leading zeros.\n\n### Output\n\nFor each test case, output the minimum value of $f(l, x) + f(x, r)$ among all integer values $l \\leq x \\leq r$.\n\n### Example\n\n#### Input #1\n\n```\n\n14\n\n1 1\n\n2 3\n\n4 6\n\n15 16\n\n17 19\n\n199 201\n\n899 999\n\n1990 2001\n\n6309 6409\n\n12345 12501\n\n19987 20093\n\n746814 747932\n\n900990999 900991010\n\n999999999 999999999\n\n```\n\n#### Output #1\n\n```\n2\n1\n0\n3\n2\n2\n1\n3\n3\n4\n3\n5\n12\n18\n```\n\n### Note\n\nIn the first test case, you can choose $x = 1$. Then $f(1, 1) + f(1, 1) = 1 + 1 = 2$.\n\nIn the second test case, you can choose $x = 2$. Then $f(2, 2) + f(2, 3) = 1 + 0 = 1$.\n\nIn the third test case, you can choose $x = 5$. Then $f(4, 5) + f(5, 6) = 0 + 0 = 0$.\n\nIn the fourth test case, you can choose $x = 15$. Then $f(15, 15) + f(15, 16) = 2 + 1 = 3$.\n\nIn the fifth test case, you can choose $x = 18$. Then $f(17, 18) + f(18, 19) = 1 + 1 = 2$.\n\nIn the sixth test case, you can choose $x = 200$. Then $f(199, 200) + f(200, 201) = 0 + 2 = 2$.\n\nIn the seventh test case, you can choose $x = 900$. Then $f(899, 900) + f(900, 999) = 0 + 1 = 1$.\n\nIn the eighth test case, you can choose $x = 1992$. Then $f(1990, 1992) + f(1992, 2001) = 3 + 0 = 3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long l, r;\n        cin >> l >> r;\n        \n        // Convert l and r to strings for easier manipulation\n        string l_str = to_string(l);\n        string r_str = to_string(r);\n        \n        int n = l_str.length(); // Length of l (and r)\n        \n        // dp[i][jl][jr] = minimum value of f(l, x) + f(x, r) for the first i positions,\n        // where jl is 0 if prefix of x is equal to prefix of l, 1 if greater\n        // jr is 0 if prefix of x is equal to prefix of r, 1 if less\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2, vector<int>(2, 1e9)));\n        \n        // Base case\n        dp[0][0][0] = 0;\n        \n        for (int i = 0; i < n; i++) {\n            for (int jl = 0; jl < 2; jl++) {\n                for (int jr = 0; jr < 2; jr++) {\n                    if (dp[i][jl][jr] == 1e9) continue;\n                    \n                    int l_digit = l_str[i] - '0';\n                    int r_digit = r_str[i] - '0';\n                    \n                    // Define the range of possible digits for x at position i\n                    int min_digit = (jl == 0) ? l_digit : 0;\n                    int max_digit = (jr == 0) ? r_digit : 9;\n                    \n                    for (int digit = min_digit; digit <= max_digit; digit++) {\n                        int match_l = (digit == l_digit) ? 1 : 0;\n                        int match_r = (digit == r_digit) ? 1 : 0;\n                        \n                        int new_jl = jl;\n                        int new_jr = jr;\n                        \n                        if (jl == 0 && digit > l_digit) new_jl = 1;\n                        if (jr == 0 && digit < r_digit) new_jr = 1;\n                        \n                        dp[i + 1][new_jl][new_jr] = min(dp[i + 1][new_jl][new_jr], \n                                                      dp[i][jl][jr] + match_l + match_r);\n                    }\n                }\n            }\n        }\n        \n        int result = 1e9;\n        for (int jl = 0; jl < 2; jl++) {\n            for (int jr = 0; jr < 2; jr++) {\n                result = min(result, dp[n][jl][jr]);\n            }\n        }\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2121d",
      "PROBLEM_ID": "2121D",
      "PROBLEM_STATEMENT": "You are given two arrays of integers $a_1, a_2, \\ldots, a_n$ and $b_1, b_2, \\ldots, b_n$. It is guaranteed that each integer from $1$ to $2 \\cdot n$ appears in exactly one of the arrays.\n\nYou need to perform a certain number of operations (possibly zero) so that both of the following conditions are satisfied:\n\n- For each $1 \\leq i < n$, it holds that $a_i < a_{i + 1}$ and $b_i < b_{i + 1}$.\n- For each $1 \\leq i \\leq n$, it holds that $a_i < b_i$.\n\nDuring each operation, you can perform exactly one of the following three actions:\n\n1. Choose an index $1 \\leq i < n$ and swap the values $a_i$ and $a_{i + 1}$.\n2. Choose an index $1 \\leq i < n$ and swap the values $b_i$ and $b_{i + 1}$.\n3. Choose an index $1 \\leq i \\leq n$ and swap the values $a_i$ and $b_i$.\n\nYou do not need to minimize the number of operations, but the total number must not exceed $1709$. Find any sequence of operations that satisfies both conditions.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 40$) \u2014 the length of the arrays $a$ and $b$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 2 \\cdot n$).\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq 2 \\cdot n$).\n\nIt is guaranteed that each integer from $1$ to $2 \\cdot n$ appears either in array $a$ or in array $b$.\n\n### Output\n\nFor each test case, output the sequence of operations.\n\nIn the first line for each test case, output the number of operations $k$. Note that $0 \\leq k \\leq 1709$.\n\nIn the following $k$ lines for each test case, output the operations themselves:\n\n- If you want to swap the values $a_i$ and $a_{i + 1}$, output two integers $1$ and $i$. Note that $1 \\leq i < n$.\n- If you want to swap the values $b_i$ and $b_{i + 1}$, output two integers $2$ and $i$. Note that $1 \\leq i < n$.\n- If you want to swap the values $a_i$ and $b_i$, output two integers $3$ and $i$. Note that $1 \\leq i \\leq n$.\n\nIt can be shown that under the given constraints, a solution always exists.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1\n\n1\n\n2\n\n1\n\n2\n\n1\n\n2\n\n1 3\n\n4 2\n\n2\n\n1 4\n\n3 2\n\n3\n\n6 5 4\n\n3 2 1\n\n3\n\n5 3 4\n\n2 6 1\n\n```\n\n#### Output #1\n\n```\n0\n1\n3 1\n1\n2 1\n1\n3 2\n9\n3 1\n3 2\n3 3\n1 1\n2 1\n2 2\n1 2\n1 1\n2 1\n6\n2 2\n1 1\n1 2\n2 1\n3 1\n3 2\n```\n\n### Note\n\nIn the first test case, $a_1 < b_1$, so no operations need to be applied.\n\nIn the second test case, $a_1 > b_1$. After applying the operation, these values will be swapped.\n\nIn the third test case, after applying the operation, $a = [1, 3]$ and $b = [2, 4]$.\n\nIn the fourth test case, after applying the operation, $a = [1, 2]$ and $b = [3, 4]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<int> a(n+1), b(n+1);\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        for (int i = 1; i <= n; i++) {\n            cin >> b[i];\n        }\n        \n        vector<pair<int, int>> operations;\n        \n        // Swap a_i and b_i if a_i > b_i\n        for (int i = 1; i <= n; i++) {\n            if (a[i] > b[i]) {\n                swap(a[i], b[i]);\n                operations.push_back({3, i});\n            }\n        }\n        \n        // Sort array a using bubble sort\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n - i + 1; j++) {\n                if (a[j] > a[j+1]) {\n                    swap(a[j], a[j+1]);\n                    operations.push_back({1, j});\n                }\n            }\n        }\n        \n        // Sort array b using bubble sort\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n - i + 1; j++) {\n                if (b[j] > b[j+1]) {\n                    swap(b[j], b[j+1]);\n                    operations.push_back({2, j});\n                }\n            }\n        }\n        \n        // Output the operations\n        cout << operations.size() << \"\\n\";\n        for (auto op : operations) {\n            cout << op.first << \" \" << op.second << \"\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2121a",
      "PROBLEM_ID": "2121A",
      "PROBLEM_STATEMENT": "You are given an array of distinct integers $x_1, x_2, \\ldots, x_n$ and an integer $s$.\n\nInitially, you are at position $pos = s$ on the $X$ axis. In one step, you can perform exactly one of the following two actions:\n\n- Move from position $pos$ to position $pos + 1$.\n- Move from position $pos$ to position $pos - 1$.\n\nA sequence of steps will be considered successful if, during the entire journey, you visit each position $x_i$ on the $X$ axis at least once. Note that the initial position $pos = s$ is also considered visited.\n\nYour task is to determine the minimum number of steps in any successful sequence of steps.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 1000$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $s$ ($1 \\leq n \\leq 10$, $1 \\leq s \\leq 100$)\u00a0\u2014 the number of positions to visit and the starting position.\n\nThe second line of each test case contains $n$ integers $x_1, x_2, \\ldots, x_n$ ($1 \\leq x_i \\leq 100$). It is guaranteed that for all $1 \\leq i < n$, it holds that $x_i < x_{i + 1}$.\n\n### Output\n\nFor each test case, output the minimum number of steps in any successful sequence of steps.\n\n### Example\n\n#### Input #1\n\n```\n\n12\n\n1 1\n\n1\n\n1 2\n\n1\n\n1 1\n\n2\n\n2 1\n\n2 3\n\n2 2\n\n1 3\n\n2 3\n\n1 2\n\n3 1\n\n1 2 3\n\n3 2\n\n1 3 4\n\n3 3\n\n1 2 3\n\n4 3\n\n1 2 3 10\n\n5 5\n\n1 2 3 6 7\n\n6 6\n\n1 2 3 9 10 11\n\n```\n\n#### Output #1\n\n```\n0\n1\n1\n2\n3\n2\n2\n4\n2\n11\n8\n15\n```\n\n### Note\n\nIn the first test case, no steps need to be taken, so the only visited position will be $1$.\n\nIn the second test case, the following path can be taken: $2 \\rightarrow 1$. The number of steps is $1$.\n\nIn the third test case, the following path can be taken: $1 \\rightarrow 2$. The number of steps is $1$.\n\nIn the fifth test case, the following path can be taken: $2 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3$. The number of steps is $3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, s;\n        cin >> n >> s;\n        \n        vector<int> x(n);\n        for (int i = 0; i < n; i++) {\n            cin >> x[i];\n        }\n        \n        int L = x[0];     // Leftmost position to visit\n        int R = x[n-1];   // Rightmost position to visit\n        \n        int answer;\n        \n        if (s < L) {\n            // Starting position is to the left of all required positions\n            // Just move right to cover all positions\n            answer = R - s;\n        } else if (s > R) {\n            // Starting position is to the right of all required positions\n            // Just move left to cover all positions\n            answer = s - L;\n        } else {\n            // Starting position is somewhere between the leftmost and rightmost positions\n            // We have two options:\n            // 1. Go left to L first, then right to R\n            int option1 = (s - L) + (R - L);\n            \n            // 2. Go right to R first, then left to L\n            int option2 = (R - s) + (R - L);\n            \n            answer = min(option1, option2);\n        }\n        \n        cout << answer << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2120g",
      "PROBLEM_ID": "2120G",
      "PROBLEM_STATEMENT": "Aryan loves graph theory more than anything. Well, no, he likes to flex his research paper on line graphs to everyone more. To start a conversation with you, he decides to give you a problem on line graphs. In the mathematical discipline of graph theory, the line graph of a simple undirected graph $G$ is another simple undirected graph $L(G)$ that represents the adjacency between every two edges in $G$.\n\nPrecisely speaking, for an undirected graph $G$ without self-loops or multiple edges, its line graph $L(G)$ is a graph such that\n\n- Each vertex of $L(G)$ represents an edge of $G$.\n- Two vertices of $L(G)$ are adjacent if and only if their corresponding edges share a common endpoint in $G$.\n\n![](https://espresso.codeforces.com/7c4456d69ec30bde9274559f9dca34dcf6879258.png)\n\nAlso, $L^0(G)=G$ and $L^k(G)=L(L^{k-1}(G))$ for $k\\geq 1$.\n\nAn Euler trail is a sequence of edges that visits every edge of the graph exactly once. This trail can be either a path (starting and ending at different vertices) or a cycle (starting and ending at the same vertex). Vertices may be revisited during the trail, but each edge must be used exactly once.\n\nAryan gives you a simple connected graph $G$ with $n$ vertices and $m$ edges and an integer $k$, and it is guaranteed that $G$ has an Euler trail and it is not a path graph$^{\\text{\u2217}}$. He asks you to determine if $L^k(G)$ has an Euler trail.\n\n$^{\\text{\u2217}}$A path graph is a tree where every vertex is connected to atmost two other vertices.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three space-separated integers $n$, $m$, and $k$ ($5 \\le n \\le 2 \\cdot 10^5$, $n-1 \\le m \\le \\min(\\frac{n\\cdot(n-1)}{2} ,2 \\cdot 10^5)$, $1 \\le k \\le 2 \\cdot 10^5$).\n\nThe next $m$ lines of each test case contain two space-separated integers $u$ and $v$ ($1 \\le u,v \\le n$, $u \\neq v$), denoting that an edge connects vertices $u$ and $v$.\n\nIt is guaranteed that the sum of $n$ and $m$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each testcase, print \"YES\" if $L^k(G)$ has an Euler trail; otherwise, \"NO\".\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n5 5 2\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n5 1\n\n5 6 1\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n5 1\n\n1 3\n\n10 11 3\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n4 6\n\n4 7\n\n5 7\n\n6 7\n\n7 8\n\n8 9\n\n9 10\n\n7 8 2\n\n1 3\n\n2 3\n\n1 4\n\n4 5\n\n2 5\n\n1 6\n\n6 7\n\n2 7\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nNO\n```\n\n### Note\n\nFor the first test case, $L^2(G)$ is isomorphic to $G$ itself. So, since $G$ has an Euler trail, $L^2(G)$ also has an Euler trail.\n\nFor the second test case, $L(G)$ looks as follows(Vertex $i-j$ of $L(G)$ in figure corresponds to edge between vertices $i$ and $j$ of $G$). It can be proven that this doesn't have an Euler trail.\n\n![](https://espresso.codeforces.com/b376c533b0c565921bd0995db02694519661b79c.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 222222;\nint n,m,k,a[N],b[N],d[N],r[N][2];\nvector<int> v[N],c;\nLL solve1(){\n\tint i;\n\tLL s=0;\n\tfor(i=1;i<=m;i++)\n\t\ts+=d[a[i]]%2!=d[b[i]]%2;\n\treturn s;\n}\nLL solve2(){\n\tint i;\n\tLL s=0;\n\tfor(i=1;i<=n;i++)\n\t\ts+=(LL)r[i][0]*r[i][1];\n\treturn s;\n}\nLL solve3(){\n\tint i,o;\n\tLL s=0;\n\tfor(i=1;i<=n;i++)\n\t\ts+=(LL)r[i][0]*r[i][1]*(d[i]-2);\n\tfor(i=1;i<=m;i++){\n\t\to=(d[a[i]]+d[b[i]])%2;\n\t\ts+=(LL)(r[a[i]][0]-(d[b[i]]%2==0))*(r[b[i]][o^1]-(d[a[i]]%2==(o^1)))+(LL)(r[a[i]][1]-(d[b[i]]%2==1))*(r[b[i]][o]-(d[a[i]]%2==o));\n\t}\n\treturn s;\n}\nint dfs(int u,int fa=0){\n\tif(d[u]>=3)\n\t\treturn 0;\n\tif(d[u]==1)\n\t\treturn N;\n\tint i,x,r=N;\n\tfor(i=0;i<v[u].size();i++){\n\t\tx=v[u][i];\n\t\tif(x!=fa)\n\t\t\tr=min(r,dfs(x,u)+1);\n\t}\n\treturn r;\n}\nint main(){\n\tint T,i,f;\n\tLL s,t;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tfor(i=1;i<=m;i++)\n\t\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tfor(i=1;i<=m;i++)\n\t\t\td[a[i]]++,d[b[i]]++;\n\t\tfor(i=1;i<=m;i++)\n\t\t\tr[a[i]][d[b[i]]%2]++,r[b[i]][d[a[i]]%2]++;\n\t\tfor(i=1;i<=m;i++)\n\t\t\tv[a[i]].push_back(b[i]),v[b[i]].push_back(a[i]);\n\t\tif(k==1)\n\t\t\tf=solve1()<=2;\n\t\tif(k==2)\n\t\t\tf=solve2()<=2;\n\t\tif(k==3)\n\t\t\tf=solve3()<=2;\n\t\tif(k>3){\n\t\t\ts=solve2();\n\t\t\tif(s==0)\n\t\t\t\tf=1;\n\t\t\tif(s>=4)\n\t\t\t\tf=0;\n\t\t\tif(s==2){\n\t\t\t\tt=solve3();\n\t\t\t\tif(t==0)\n\t\t\t\t\tf=1;\n\t\t\t\tif(t>=4)\n\t\t\t\t\tf=0;\n\t\t\t\tif(t==2){\n\t\t\t\t\tc.clear();\n\t\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\t\tif(r[i][0]&&r[i][1])\n\t\t\t\t\t\t\tc.push_back(i);\n\t\t\t\t\tif(c.size()!=2)\n\t\t\t\t\t\tf=0;\n\t\t\t\t\telse\n\t\t\t\t\t\tf=k<=min(dfs(c[0]),dfs(c[1]))+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\tfor(i=1;i<=n;i++)\n\t\t\td[i]=0,r[i][0]=0,r[i][1]=0,v[i].clear();\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2120f",
      "PROBLEM_ID": "2120F",
      "PROBLEM_STATEMENT": "As we all know, Aryan is a funny guy. He decides to create fun graphs. For a graph $G$, he defines fun graph $G'$ of $G$ as follows:\n\n- Every vertex $v'$ of $G'$ maps to a non-empty independent set$^{\\text{\u2217}}$ or clique$^{\\text{\u2020}}$ in $G$.\n- The sets of vertices of $G$ that the vertices of $G'$ map to are pairwise disjoint and combined cover all the vertices of $G$, i.e., the sets of vertices of $G$ mapped by vertices of $G'$ form a partition of the vertex set of $G$.\n- If an edge connects two vertices $v_1'$ and $v_2'$ in $G'$, then there is an edge between every vertex of $G$ in the set mapped to $v_1'$ and every vertex of $G$ in the set mapped to $v_2'$.\n- If an edge does not connect two vertices $v_1'$ and $v_2'$ in $G'$, then there is not an edge between any vertex of $G$ in the set mapped to $v_1'$ and any vertex of $G$ in the set mapped to $v_2'$.\n\nAs we all know again, Harshith is a superb guy. He decides to use fun graphs to create his own superb graphs. For a graph $G$, a fun graph $G' '$ is called a superb graph of $G$ if $G' '$ has the minimum number of vertices among all possible fun graphs of $G$.\n\nAryan gives Harshith $k$ simple undirected graphs$^{\\text{\u2021}}$ $G_1, G_2,\\ldots,G_k$, all on the same vertex set $V$. Harshith then wonders if there exist $k$ other graphs $H_1, H_2,\\ldots,H_k$, all on some other vertex set $V'$ such that:\n\n- $G_i$ is a superb graph of $H_i$ for all $i\\in \\{1,2,\\ldots,k\\}$.\n- If a vertex $v\\in V$ maps to an independent set of size greater than $1$ in one $G_i, H_i$ ($1\\leq i\\leq k$) pair, then there exists no pair $G_j, H_j$ ($1\\leq j\\leq k, j\\neq i$) where $v$ maps to a clique of size greater than $1$.\n\nHelp Harshith solve his wonder.\n\n$^{\\text{\u2217}}$For a graph $G$, a subset $S$ of vertices is called an independent set if no two vertices of $S$ are connected with an edge.\n\n$^{\\text{\u2020}}$For a graph $G$, a subset $S$ of vertices is called a clique if every vertex of $S$ is connected to every other vertex of $S$ with an edge.\n\n$^{\\text{\u2021}}$A graph is a simple undirected graph if its edges are undirected and there are no self-loops or multiple edges between the same pair of vertices.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1\\leq n\\leq 300, 1\\leq k\\leq 10$).\n\nThen, there are $k$ graphs described. The first line of each graph description contains a single integer $m$ ($0\\leq m\\leq \\frac{n\\cdot(n-1)}{2} $).\n\nNext $m$ lines each contain two space-separated integers $u$ and $v$ ($1\\leq u, v\\leq n, u\\neq v$), denoting that an edge connects vertices $u$ and $v$.\n\nIt is guaranteed that the sum of $m$ over all graphs over all test cases does not exceed $2\\cdot 10^5$, and the sum of $n$ over all test cases does not exceed $300$.\n\n### Output\n\nFor each testcase, print \"Yes\" if there exists $k$ graphs satisfying the conditions; otherwise, \"No\".\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5 2\n\n3\n\n3 4\n\n5 3\n\n5 1\n\n6\n\n3 5\n\n3 4\n\n1 4\n\n1 2\n\n2 3\n\n4 2\n\n4 3\n\n0\n\n3\n\n3 1\n\n1 4\n\n1 2\n\n4\n\n4 2\n\n4 3\n\n1 2\n\n2 3\n\n3 2\n\n0\n\n3\n\n3 1\n\n3 2\n\n1 2\n\n```\n\n#### Output #1\n\n```\nYes\nYes\nNo\n```\n\n### Note\n\nFor the first test case, the following are the graphs of $G_1, H_1$ and $G_2, H_2$ such that $G_1$ is superb graph of $H_1$ and $G_2$ is superb graph of $H_2$.\n\n![](https://espresso.codeforces.com/452753955813c595256b6b1fee9c2f4329c082e5.png)\n\nIn each graph, vertex $2$ of $G_i$ corresonds to independent set $\\{2\\_1, 2\\_2\\}$ of corresponding $H_i$ and remaining vertices $v\\in\\{1,3,4,5\\}$ of $G_i$ correspond to independent set/clique $\\{v\\}$ in corresponding $H_i$(a single vertex set can be considered both an independent set and a clique).\n\nIn the third test case, it can be proven that the answer is \"No\".",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TwoSAT {\n    int n;                               // number of variables\n    vector<vector<int>> g, rg;           // implication graph and reverse\n    vector<int> comp, order, val;        // SCC id, topo order, assignment\n\n    TwoSAT(int _n = 0) { init(_n); }\n    void init(int _n) {\n        n = _n;\n        g.assign(2 * n, {});\n        rg.assign(2 * n, {});\n    }\n    /* literal:  (v , isTrue)   node = 2*v + isTrue */\n    static int node(int v, bool isTrue) { return v * 2 + (isTrue ? 1 : 0); }\n\n    void addImplication(int a, int b) {      // a -> b\n        g[a].push_back(b);\n        rg[b].push_back(a);\n    }\n    void addOr(int v1, bool s1, int v2, bool s2) {   // (v1==s1) OR (v2==s2)\n        int a  = node(v1, s1);\n        int na = node(v1, !s1);\n        int b  = node(v2, s2);\n        int nb = node(v2, !s2);\n        addImplication(na, b);      // \u00acv1 -> v2\n        addImplication(nb, a);      // \u00acv2 -> v1\n    }\n    bool satisfiable() {\n        int N = 2 * n;\n        order.clear();\n        vector<int> vis(N, 0);\n        function<void(int)> dfs1 = [&](int u) {\n            vis[u] = 1;\n            for (int v : g[u]) if (!vis[v]) dfs1(v);\n            order.push_back(u);\n        };\n        for (int i = 0; i < N; ++i) if (!vis[i]) dfs1(i);\n\n        comp.assign(N, -1);\n        int cid = 0;\n        function<void(int)> dfs2 = [&](int u) {\n            comp[u] = cid;\n            for (int v : rg[u]) if (comp[v] == -1) dfs2(v);\n        };\n        for (int i = N - 1; i >= 0; --i)\n            if (comp[order[i]] == -1) { dfs2(order[i]); ++cid; }\n\n        val.assign(n, 0);\n        for (int v = 0; v < n; ++v) {\n            if (comp[2 * v] == comp[2 * v + 1]) return false; // unsat\n            val[v] = comp[2 * v] < comp[2 * v + 1];           // topological\n        }\n        return true;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    const int MAXN = 305;\n\n    int T;\n    if (!(cin >> T)) return 0;\n    while (T--) {\n        int n, k;\n        cin >> n >> k;\n\n        /* store every graph as vector< bitset > */\n        vector<vector< bitset<MAXN> >> adj(k, vector< bitset<MAXN> >(n));\n        for (int gi = 0; gi < k; ++gi) {\n            int m; cin >> m;\n            for (int e = 0; e < m; ++e) {\n                int u, v; cin >> u >> v; --u; --v;\n                adj[gi][u].set(v);\n                adj[gi][v].set(u);\n            }\n        }\n\n        TwoSAT sat(n);\n\n        /* build all clauses */\n        for (int gi = 0; gi < k; ++gi) {\n            for (int u = 0; u < n; ++u)\n                for (int v = u + 1; v < n; ++v) {\n                    // identical neighbourhood outside {u,v} ?\n                    bitset<MAXN> diff = adj[gi][u] ^ adj[gi][v];\n                    diff.reset(u);\n                    diff.reset(v);\n                    if (diff.any()) continue;          // not twins\n\n                    bool edgeUV = adj[gi][u].test(v);\n                    if (edgeUV) {\n                        /* true twins : not both C  ->  (\u00acXu \u2228 \u00acXv) */\n                        sat.addOr(u, false, v, false);\n                    } else {\n                        /* false twins: not both I  ->  (Xu \u2228 Xv) */\n                        sat.addOr(u, true, v, true);\n                    }\n                }\n        }\n\n        cout << (sat.satisfiable() ? \"Yes\\n\" : \"No\\n\");\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2120d",
      "PROBLEM_ID": "2120D",
      "PROBLEM_STATEMENT": "Aryan and Harshith play a game. They both start with three integers $a$, $b$, and $k$. Aryan then gives Harshith two integers $n$ and $m$. Harshith then gives Aryan a matrix $X$ with $n$ rows and $m$ columns, such that each of the elements of $X$ is between $1$ and $k$(inclusive). After that, Aryan wins if he can find a submatrix$^{\\text{\u2217}}$ $Y$ of $X$ with $a$ rows and $b$ columns such that all elements of $Y$ are equal.\n\nFor example, when $a=2, b=2, k=6, n=3$ and $m=3$, if Harshith gives Aryan the matrix below, it is a win for Aryan as it has a submatrix of size $2\\times 2$ with all elements equal to $1$ as shown below.\n\n![](https://espresso.codeforces.com/69d24173a1df27d03c8b9991eba30c6d7e1b139e.png) Example of a matrix where Aryan wins\n\nAryan gives you the values of $a$, $b$, and $k$. He asks you to find the lexicographically minimum tuple $(n,m)$ that he should give to Harshith such that Aryan always wins. Help Aryan win the game. Assume that Harshith plays optimally. The values of $n$ and $m$ can be large, so output them modulo $10^9+7$. A tuple $(n_1, m_1)$ is said to be lexicographically smaller than $(n_2, m_2)$ if either $n_1<n_2$ or $n_1=n_2$ and $m_1<m_2$.\n\n$^{\\text{\u2217}}$A submatrix of a matrix is obtained by removing some rows and/or columns from the original matrix.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nEach test case contains a single line with three space-separated integers $a, b$ and $k$ ($1\\leq a,b,k\\leq 10^5$).\n\nIt is guaranteed that the sum of $\\max(a, b, k)$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single line containing two space-separated integers $n$ and $m$, denoting the answer to the problem. The values of $n$ and $m$ can be large, so output them modulo $10^9+7$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n1 1 5\n\n2 2 2\n\n90000 80000 70000\n\n```\n\n#### Output #1\n\n```\n1 1\n3 7\n299929959 603196135\n```\n\n### Note\n\nFor the first test case, every $n\\times m$ matrix contains a $1\\times 1$ submatrix with all elements equal. $(1,1)$ is the lexicographically minimum tuple among all of them.\n\nFor the second test case, it can be verified that whatever $3\\times 7$ matrix Harshith gives to Aryan, Aryan can always win by finding a $2\\times 2$ submatrix with all elements equal. $(3,7)$ is also the lexicographically minimum tuple among all possible tuples where Aryan always wins.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\nconst ll MOD = 1000000007;\n \n// fast modular exponentiation\nll modexp(ll base, ll exp, ll mod = MOD){\n    ll res = 1 % mod;\n    base %= mod;\n    while(exp){\n        if(exp & 1) res = (res * base) % mod;\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n    return res;\n}\n \n// Main \u2013 precomputing factorials for denominator (up to max a needed)\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t; \n    cin >> t;\n    int maxA = 0;\n    vector<tuple<int,int,int>> tests;\n    for(int i = 0; i < t; i++){\n        int a, b, k;\n        cin >> a >> b >> k;\n        tests.push_back({a, b, k});\n        maxA = max(maxA, a);\n    }\n    // Precompute factorials and their inverses up to maxA.\n    vector<ll> fact(maxA+1), invfact(maxA+1);\n    fact[0] = 1;\n    for (int i = 1; i <= maxA; i++){\n        fact[i] = (fact[i-1] * i) % MOD;\n    }\n    invfact[maxA] = modexp(fact[maxA], MOD - 2, MOD);\n    for (int i = maxA - 1; i >= 0; i--){\n        invfact[i] = (invfact[i + 1] * (i + 1)) % MOD;\n    }\n \n    // Process each test case.\n    // We choose: n = k*(a-1) + 1.\n    // Then compute C(n, a) = (n*(n-1)*...*(n-a+1))/a!   (mod MOD).\n    // Finally, we output:\n    //     n (mod MOD) and m = (k * C(n, a) * (b-1) + 1) (mod MOD)\n    for(auto &test : tests){\n        int a, b, k;\n        tie(a, b, k) = test;\n        ll n_val = ((ll)k * (a - 1) + 1);  // may be large; we only need it mod MOD later.\n        // Compute numerator = n*(n-1)*...*(n-a+1) mod MOD\n        ll num = 1;\n        for (int i = 0; i < a; i++){\n            ll term = ((n_val - i) % MOD + MOD) % MOD;\n            num = (num * term) % MOD;\n        }\n        ll comb = (num * invfact[a]) % MOD;\n \n        // Harshith can avoid a monochromatic a\u00d7b submatrix if he keeps, for every a\u2013subset, at most (b-1) columns \u201cmonochromatic\u201d\n        // In the best case for him (with our optimal choice of n) the column \u201ccost\u201d is L(n)=1.\n        // So the maximum m he can hope to achieve without a win for Aryan is m_max = k * C(n, a) * (b - 1).\n        // Hence, to force a win, set m = m_max + 1.\n        ll m_val = (((ll)k * comb) % MOD * ((b - 1) % MOD)) % MOD;\n        m_val = (m_val + 1) % MOD;\n \n        ll n_mod = n_val % MOD;\n        cout << n_mod << \" \" << m_val << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2120c",
      "PROBLEM_ID": "2120C",
      "PROBLEM_STATEMENT": "Harshith attained enlightenment in Competitive Programming by training under a Divine Tree. A divine tree is a rooted tree$^{\\text{\u2217}}$ with $n$ nodes, labelled from $1$ to $n$. The divineness of a node $v$, denoted $d(v)$, is defined as the smallest node label on the unique simple path from the root to node $v$.\n\nAryan, being a hungry Competitive Programmer, asked Harshith to pass on the knowledge. Harshith agreed on the condition that Aryan would be given two positive integers $n$ and $m$, and he had to construct a divine tree with $n$ nodes such that the total divineness of the tree is $m$, i.e., $\\displaystyle\\sum\\limits_{i=1}^n d(i)=m$. If no such tree exists, Aryan must report that it is impossible.\n\nDesperate for knowledge, Aryan turned to you for help in completing this task. As a good friend of his, help him solve the task.\n\n$^{\\text{\u2217}}$A tree is a connected graph without cycles. A rooted tree is a tree where one vertex is special and called the root.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 10^6$, $1 \\le m \\le 10^{12}$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output a single integer $k$ in one line \u2014 the root of the tree.\n\nThen $n-1$ lines follow, each containing a description of an edge of the tree \u2014 a pair of positive integers $u_i,v_i$ ($1\\le u_i,v_i\\le n$, $u_i\\ne v_i$), denoting the $i$-th edge connects vertices $u_i$ and $v_i$.\n\nThe edges and vertices of the edges can be printed in any order. If there are multiple solutions, print any of them.\n\nIf there is no solution, print \"-1\" instead.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n1 2\n\n4 6\n\n```\n\n#### Output #1\n\n```\n-1\n3\n3 1\n1 2\n2 4\n```\n\n### Note\n\nIn the first test case, there is a single node with a value of $1$, so getting a sum of $2$ is impossible.\n\nIn the second test case, getting a sum of $6$ is possible with the given tree rooted at $3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t; \n    cin >> t;\n    while(t--){\n        long long n, m; \n        cin >> n >> m;\n \n        int chosenR = -1;\n        // Try possible r from 1 to n.\n        for (int r = 1; r <= n; r++){\n            if(r == 1){\n                // For root=1, the only possibility is if the sum is exactly n.\n                if(m == n){\n                    chosenR = 1;\n                    break;\n                }\n            } else {\n                // For r>=2:\n                // Define:\n                // starMin = r + (1+2+...+(r-1)) + (n - r)*1 = r + (r-1)*r/2 + (n - r)\n                // starMax = r + (r-1)*r/2 + (n - r)*r\n                long long starMin = r + ((long long)(r-1) * r) / 2 + (n - r);\n                long long starMax = r + ((long long)(r-1) * r) / 2 + (n - r) * r;\n                if(m >= starMin && m <= starMax){\n                    chosenR = r;\n                    break;\n                }\n            }\n        }\n \n        if(chosenR == -1){\n            cout << -1 << \"\\n\";\n            continue;\n        }\n \n        int r = chosenR;\n        // Prepare parent array: par[i] will store the parent of vertex i.\n        vector<int> par(n+1, 0);\n        // Build the initial star: every vertex except the root r has parent r.\n        for (int i = 1; i <= n; i++){\n            if(i==r) continue;\n            par[i] = r;\n        }\n \n        // Compute starMax (when all vertices v>r have d(v)=r).\n        long long starMax = r + ((long long)(r-1)*r)/2 + (n - r) * r;\n        // We want a final sum m; so let D be the total reduction needed.\n        long long D = starMax - m;\n \n        // We will \u201cfix\u201d the vertices that are in A = {v: v > r}\n        vector<int> A;\n        for (int v = r+1; v <= n; v++){\n            A.push_back(v);\n        }\n        int idx = 0; // index in A of vertices still attached as child of r.\n \n        // For vertices in B = {1, 2, \u2026, r-1} consider reattaching some vertices from A to b.\n        // Reattaching a vertex from A under b changes its parent's label from r to b\n        // and hence reduces its contribution by (r - b). Process b in increasing order\n        for (int b = 1; b < r && D > 0 && idx < (int)A.size(); b++){\n            int cost = r - b; // reduction per vertex reattached under b\n            int available = (int)A.size() - idx;\n            int x = (int) min((long long) available, D / cost);\n            for (int j = 0; j < x; j++){\n                int vertex = A[idx++];\n                par[vertex] = b;\n            }\n            D -= (long long)x * cost;\n        }\n \n        // At this point by our feasibility argument D should be 0.\n        // Output: first output the chosen root\u2019s label then output the n\u20131 edges.\n        cout << r << \"\\n\";\n        for (int i = 1; i <= n; i++){\n            if(i == r) continue;\n            cout << par[i] << \" \" << i << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2120b",
      "PROBLEM_ID": "2120B",
      "PROBLEM_STATEMENT": "Aryan and Harshith are playing pool in universe AX120 on a fixed square pool table of side $s$ with pockets at its $4$ corners. The corners are situated at $(0,0)$, $(0,s)$, $(s,0)$, and $(s,s)$. In this game variation, $n$ identical balls are placed on the table with integral coordinates such that no ball lies on the edge or corner of the table. Then, they are all simultaneously shot at $10^{100}$ units/sec speed (only at $45$ degrees with the axes).\n\nIn universe AX120, balls and pockets are almost point-sized, and the collisions are elastic, i.e., the ball, on hitting any surface, bounces off at the same angle and with the same speed.\n\n![](https://espresso.codeforces.com/03698e95411a27b6d9ed22ef294c00b49125be41.png)\n\nHarshith shot the balls, and he provided Aryan with the balls' positions and the angles at which he shot them. Help Aryan determine the number of balls potted into the pockets by Harshith.\n\nIt is guaranteed that multiple collisions do not occur at the same moment and position.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $s$ ($1 \\le n \\le 10^3$, $2 \\le s\\le 10^9$) \u2014 the number of balls placed on the table and the side length of the square pool table.\n\nThe $i$-th of the next $n$ lines contains four integers $d_x$, $d_y$, $x_i$, and $y_i$ ($d_x,d_y \\in \\{-1, 1\\}$, $0 \\lt x_i, y_i \\lt s$) \u2014 the direction vectors of the launch on the $X$-axis and $Y$-axis respectively, and the coordinates of the location where the $i$-th ball was placed. It is guaranteed that no two balls coincide at the initial moment.\n\nIt is also guaranteed that the sum of $n$ over all test cases does not exceed $10^3$.\n\n### Output\n\nFor each test case, print a single integer \u2014 the number of balls potted in that game.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n1 2\n\n1 1 1 1\n\n5 4\n\n1 -1 1 1\n\n1 -1 2 2\n\n-1 1 2 3\n\n1 -1 1 3\n\n-1 1 3 1\n\n```\n\n#### Output #1\n\n```\n1\n3\n```\n\n### Note\n\nIn the first test case, there is a single ball and it's shot directly towards the pocket at $(2, 2)$, thus potted.\n\nIn the second test case, the state progresses as\n\n![](https://espresso.codeforces.com/277925e8c841d4b0517ff0b6c8561252258511eb.png)$\\rightarrow$![](https://espresso.codeforces.com/44f2f377936021e233b12e14f5dba0e6d1d000e9.png)![](https://espresso.codeforces.com/9a80571022f338294cd4ac9550a4c0daa39dfd87.png)$\\rightarrow$![](https://espresso.codeforces.com/51469a70832c0ea702ea3cae0a23f7a02a03e9f8.png)![](https://espresso.codeforces.com/34ce4b1e26c93608354db73a1fa858ec6f750908.png)$\\rightarrow$![](https://espresso.codeforces.com/0174e1fba22cc3437a8783afa0e59b94a2f56cc3.png)![](https://espresso.codeforces.com/5ffdf60ffaaf63625debb70d5e8b9040ef9a496b.png)$\\rightarrow$![](https://espresso.codeforces.com/520e6431370faf82a9f177c2dfc707b39e191c9b.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        long long s;\n        cin >> n >> s;\n        int potted = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int dx, dy;\n            long long x, y;\n            cin >> dx >> dy >> x >> y;\n            \n            bool isPotted = false;\n            for (int a = 0; a <= 1; a++) {\n                for (int b = 0; b <= 1; b++) {\n                    // Check if trajectory passes through corner (a*s, b*s)\n                    if ((a * s - x) * dy == (b * s - y) * dx && (a * s - x) * dx > 0) {\n                        isPotted = true;\n                        break;\n                    }\n                }\n                if (isPotted) break;\n            }\n            \n            if (isPotted) potted++;\n        }\n        \n        cout << potted << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2120a",
      "PROBLEM_ID": "2120A",
      "PROBLEM_STATEMENT": "Aryan is an ardent lover of squares but a hater of rectangles (Yes, he knows all squares are rectangles). But Harshith likes to mess with Aryan. Harshith gives Aryan three rectangles of sizes $l_1\\times b_1$, $l_2\\times b_2$, and $l_3\\times b_3$ such that $l_3\\leq l_2\\leq l_1$ and $b_3\\leq b_2\\leq b_1$. Aryan, in order to defeat Harshith, decides to arrange these three rectangles to form a square such that no two rectangles overlap and the rectangles are aligned along edges. Rotating rectangles is not allowed. Help Aryan determine if he can defeat Harshith.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nEach test case contains a single line with $6$ space-separated integers $l_1, b_1, l_2, b_2, l_3$, and $b_3$ ($1 \\leq l_3\\le l_2\\le l_1\\le 100$, $1\\le b_3\\le b_2\\le b_1 \\leq 100$) \u2014 the dimensions of the three rectangles.\n\n### Output\n\nFor each testcase, print \"YES\" if the rectangles can be arranged to form a square; otherwise, \"NO\".\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n100 100 10 10 1 1\n\n5 3 5 1 5 1\n\n2 3 1 2 1 1\n\n8 5 3 5 3 3\n\n3 3 3 3 2 1\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nYES\nNO\nNO\n```\n\n### Note\n\nIn the second test case, the three rectangles $5\\times 3$, $5\\times 1$, and $5\\times 1$ can be arranged as follows to form a square.\n\n![](https://espresso.codeforces.com/fbd9b47dd2b494552b66f9254bd5f01de239c196.png)\n\nIn the fourth test case, it can be proven that the rectangles can't be arranged to form a square with the given constraints.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool check_configuration(int l1, int b1, int l2, int b2, int l3, int b3, int side_length) {\n    // Configuration 1: Three rectangles in a row\n    if (b1 == b2 && b2 == b3 && b1 == side_length && l1 + l2 + l3 == side_length) {\n        return true;\n    }\n    \n    // Configuration 2: Three rectangles in a column\n    if (l1 == l2 && l2 == l3 && l1 == side_length && b1 + b2 + b3 == side_length) {\n        return true;\n    }\n    \n    // Configuration 3: Two rectangles on top and one below spanning the width\n    if (l1 + l2 == side_length && l3 == side_length && b1 == b2 && b1 + b3 == side_length) {\n        return true;\n    }\n    \n    // Configuration 4: One rectangle on top spanning the width and two below\n    if (l1 == side_length && l2 + l3 == side_length && b2 == b3 && b1 + b2 == side_length) {\n        return true;\n    }\n    \n    // Configuration 5: Two rectangles on the left and one on the right spanning the height\n    if (b1 + b2 == side_length && b3 == side_length && l1 == l2 && l1 + l3 == side_length) {\n        return true;\n    }\n    \n    // Configuration 6: One rectangle on the left spanning the height and two on the right\n    if (b1 == side_length && b2 + b3 == side_length && l2 == l3 && l1 + l2 == side_length) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool can_form_square(int l1, int b1, int l2, int b2, int l3, int b3) {\n    long long total_area = (long long)l1 * b1 + (long long)l2 * b2 + (long long)l3 * b3;\n    int side_length = sqrt(total_area);\n    \n    if ((long long)side_length * side_length != total_area) {\n        return false;  // The total area is not a perfect square\n    }\n    \n    // Check all permutations of the three rectangles\n    if (check_configuration(l1, b1, l2, b2, l3, b3, side_length)) return true;\n    if (check_configuration(l1, b1, l3, b3, l2, b2, side_length)) return true;\n    if (check_configuration(l2, b2, l1, b1, l3, b3, side_length)) return true;\n    if (check_configuration(l2, b2, l3, b3, l1, b1, side_length)) return true;\n    if (check_configuration(l3, b3, l1, b1, l2, b2, side_length)) return true;\n    if (check_configuration(l3, b3, l2, b2, l1, b1, side_length)) return true;\n    \n    return false;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int l1, b1, l2, b2, l3, b3;\n        cin >> l1 >> b1 >> l2 >> b2 >> l3 >> b3;\n        \n        if (can_form_square(l1, b1, l2, b2, l3, b3)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2118f",
      "PROBLEM_ID": "2118F",
      "PROBLEM_STATEMENT": "You are given arrays $a$ and $b$ of length $n$ and an integer $m$.\n\nThe arrays only contain integers from $1$ to $m$, and both arrays contain all integers from $1$ to $m$.\n\nYou may repeatedly perform either of the following operations on $a$:\n\n- cyclic shift$^{\\text{\u2217}}$ the array to the left\n- swap two neighboring elements if their difference is at least $2$.\n\nIs it possible to transform the first array into the second?\n\n$^{\\text{\u2217}}$A left cyclic shift of a zero-indexed array $p$ of length $n$ is an array $q$ such that $q_i = p_{(i + 1) \\bmod n}$ for all $0 \\le i < n$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($2 \\le m \\le n \\le 5\\cdot10^5$)\u00a0\u2014 the length of the arrays and the number of distinct elements in $a$.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le m$)\u00a0\u2014 denoting the array $a$.\n\nThe third line contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le m$)\u00a0\u2014 denoting the array $b$.\n\nIt is guaranteed that both arrays contain all integers from $1$ to $m$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5\\cdot10^5$.\n\n### Output\n\nFor each test case, output \"YES\" if it is possible to transform the first array into the second and \"NO\" otherwise. You can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n3 3\n\n1 2 3\n\n3 2 1\n\n4 3\n\n1 1 2 3\n\n1 2 2 3\n\n4 4\n\n1 3 2 4\n\n2 3 4 1\n\n6 3\n\n1 1 2 1 2 3\n\n2 1 1 2 3 1\n\n5 4\n\n2 3 4 1 1\n\n3 2 1 1 4\n\n9 7\n\n2 4 6 7 3 1 5 4 6\n\n6 7 3 5 6 4 2 4 1\n\n9 8\n\n8 3 5 6 5 4 1 7 2\n\n7 5 3 5 8 4 6 2 1\n\n8 6\n\n2 1 5 4 6 3 5 4\n\n6 1 5 2 4 5 3 4\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nNO\nYES\nYES\nNO\nNO\n```\n\n### Note\n\nIn the first test case, you can transform array $a$ into array $b$ with the following steps:\n\n- \\[$1$, $2$, $3$\\] \u2014 shift to the left\n- \\[$2$, $3$, $1$\\] \u2014 swap indices $2$ and $3$\n- \\[$2$, $1$, $3$\\] \u2014 shift to the left\n- \\[$1$, $3$, $2$\\] \u2014 shift to the left\n- \\[$3$, $2$, $1$\\]\n\nIn the second test case, it can be proven that it is impossible to transform array $a$ into array $b$ with the given operations.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n \n \ninline int sign_of_non_zero(const int x) {\n    return x > 0 ? 1 : -1;\n}\n \nstruct IllegalTransformationException : public std::runtime_error {\n    using std::runtime_error::runtime_error;\n};\n \ntemplate <\n    std::uint64_t ELEMENT_MULTIPLIER,\n    std::uint64_t HASH_MULTIPLIER,\n    std::uint64_t OFFSET\n>\ninline std::uint64_t circular_hash(const std::vector<std::uint64_t>& arr) {\n    std::uint64_t current_hash = 0;\n \n    for (const std::uint64_t& elem : arr) {\n        current_hash *= ELEMENT_MULTIPLIER;\n        current_hash += elem;\n    }\n \n    std::uint64_t first_multiplier = 1;\n    for (int i = 0; i + 1 < arr.size(); i++)\n        first_multiplier *= ELEMENT_MULTIPLIER;\n \n    std::vector<std::uint64_t> hashes;\n \n    for (const std::uint64_t& elem : arr) {\n        hashes.push_back(current_hash);\n \n        current_hash -= first_multiplier * elem;\n        current_hash *= ELEMENT_MULTIPLIER;\n        current_hash += elem;\n    }\n \n    sort(hashes.begin(), hashes.end());\n \n    std::uint64_t result = 0;\n    std::uint64_t hash_multipler = 1;\n \n    for (const std::uint64_t& hash : hashes) {\n        result += hash * hash + hash * hash_multipler + OFFSET;\n \n        hash_multipler *= HASH_MULTIPLIER;\n    }\n \n    return result;\n}\n \n \n// VEC must support indexing and have `.size()`.\ntemplate <typename VEC = std::vector<int>>\nclass braid_graph {\n    VEC braid;\n    int strand_count;\n    std::vector<std::vector<int>> children;\n \n    template <\n        std::uint64_t CHILD_MULTIPLIER,\n        std::uint64_t OFFSET,\n        std::uint64_t NEGATIVE_MULTIPLIER,\n        std::uint64_t NEGATIVE_OFFSET\n    >\n    std::uint64_t hash_of_vertex(std::vector<std::uint64_t>& hashes, const int& v) const {\n        if (hashes[v] == 0) {\n            std::uint64_t result = 0;\n            std::uint64_t multiplier = 1;\n \n            for (const int& child : children[v]) {\n                const std::uint64_t base_hash = hash_of_vertex<CHILD_MULTIPLIER, OFFSET, NEGATIVE_MULTIPLIER, NEGATIVE_OFFSET>(hashes, child);\n                result += base_hash * base_hash + base_hash * multiplier + OFFSET;\n \n                multiplier *= CHILD_MULTIPLIER;\n            }\n \n            if (braid[v] < 0)\n                result = result * result + result * NEGATIVE_MULTIPLIER + NEGATIVE_OFFSET;\n \n            hashes[v] = result;\n        }\n \n        return hashes[v];\n    }\n \n    template <\n        std::uint64_t CHILD_MULTIPLIER,\n        std::uint64_t OFFSET,\n        std::uint64_t NEGATIVE_MULTIPLIER,\n        std::uint64_t NEGATIVE_OFFSET,\n        std::uint64_t CIRCULAR_HASH_ELEMENT_MULTIPLIER,\n        std::uint64_t CIRCULAR_HASH_HASH_MULTIPLIER,\n        std::uint64_t CIRCULAR_HASH_OFFSET\n    >\n    std::uint64_t hash_more_than_two_strands() const {\n        // Implementation based on: https://codeforces.com/blog/entry/113465\n \n        // Since C++20 is not supported, instead of `optional<int>`, `0` will be used as semantic value for non-existance.\n        std::vector<std::uint64_t> hashes(braid.size());\n \n        std::vector<std::uint64_t> top_hashes;\n        // Not tested if faster.\n        top_hashes.reserve(braid.size());\n \n        for (int i = 0; i < braid.size(); i++) {\n            if (abs(braid[i]) != strand_count - 1)\n                continue;\n \n            top_hashes.push_back(hash_of_vertex<CHILD_MULTIPLIER, OFFSET, NEGATIVE_MULTIPLIER, NEGATIVE_OFFSET>(hashes, i));\n        }\n \n        return circular_hash<CIRCULAR_HASH_ELEMENT_MULTIPLIER, CIRCULAR_HASH_HASH_MULTIPLIER, CIRCULAR_HASH_OFFSET>(top_hashes);\n    }\n \n    template <\n        std::uint64_t MULTIPLIER,\n        std::uint64_t POSITIVE,\n        std::uint64_t NEGATIVE,\n        std::uint64_t CIRCULAR_HASH_ELEMENT_MULTIPLIER,\n        std::uint64_t CIRCULAR_HASH_HASH_MULTIPLIER,\n        std::uint64_t CIRCULAR_HASH_OFFSET\n    >\n    std::uint64_t hash_two_strands() const {\n        std::vector<std::uint64_t> hashes(braid.size());\n \n        for (int i = 0; i < braid.size(); i++)\n            hashes[i] = braid[i] == 1 ? POSITIVE : NEGATIVE;\n \n        const std::uint64_t result = circular_hash<CIRCULAR_HASH_ELEMENT_MULTIPLIER, CIRCULAR_HASH_HASH_MULTIPLIER, CIRCULAR_HASH_OFFSET>(hashes);\n \n        return result;\n    }\n \npublic:\n    braid_graph(\n        const VEC braid,\n        const int strand_count\n    ) :\n        braid(braid),\n        strand_count(strand_count)\n    {\n        if (strand_count == 2)\n            return;\n \n        children.resize(braid.size());\n \n        // Since C++20 is not supported, instead of `optional<int>`, `-1` will be used as semantic value for non-existance.\n        std::vector<std::vector<int>> last_occurence(strand_count);\n \n        for (int i = 0; i < braid.size(); i++) {\n            const int cur = abs(braid[i]);\n \n            // Because sigmas start from 1, this is fine.\n            last_occurence[cur - 1].clear();\n            last_occurence[cur].push_back(i);\n        }\n \n        for (int i = 0; i < braid.size(); i++) {\n            const int cur = abs(braid[i]);\n \n            // Because sigmas start from 1, this is fine.\n            children[i] = last_occurence[cur - 1];\n            last_occurence[cur - 1].clear();\n \n            last_occurence[cur].push_back(i);\n        }\n    }\n \n    // It is recommended that CHILD_MULTIPLIER be a prime and all template parameters are sufficiently different.\n    template <\n        std::uint64_t MULTIPLIER = 1'000'000'007,\n        std::uint64_t OFFSET = 42,\n        std::uint64_t NEGATIVE_MULTIPLIER = 3'141'592,\n        std::uint64_t NEGATIVE_OFFSET = 2'622'057,\n        // Only used for `strand_count == 2`.\n        std::uint64_t POSITIVE = 2'718'281,\n        std::uint64_t EMPTY_HASH = 1'618'033,\n        std::uint64_t CIRCULAR_HASH_ELEMENT_MULTIPLIER = MULTIPLIER,\n        std::uint64_t CIRCULAR_HASH_HASH_MULTIPLIER = 693'147,\n        std::uint64_t CIRCULAR_HASH_OFFSET = 1'414'213\n    >\n    std::uint64_t hash() const {\n        if (strand_count == 1)\n            return EMPTY_HASH;\n        if (strand_count == 2)\n            return hash_two_strands<\n                MULTIPLIER,\n                POSITIVE,\n                NEGATIVE_OFFSET,\n                CIRCULAR_HASH_ELEMENT_MULTIPLIER,\n                CIRCULAR_HASH_HASH_MULTIPLIER,\n                CIRCULAR_HASH_OFFSET\n            >();\n        else\n            return hash_more_than_two_strands<\n                MULTIPLIER,\n                OFFSET,\n                NEGATIVE_MULTIPLIER,\n                NEGATIVE_OFFSET,\n                CIRCULAR_HASH_ELEMENT_MULTIPLIER,\n                CIRCULAR_HASH_HASH_MULTIPLIER,\n                CIRCULAR_HASH_OFFSET\n            >();\n    }\n};\n \n \nstd::uint64_t sim_single_hash(const vector<ll> input, const int strand_count) {\n    const braid_graph<vector<ll>> g(input, strand_count+1);\n    return g.hash();\n}\n \nvoid solve() {\n    int n, m; cin >> n >> m;\n    vector<ll> a(n), b(n);\n    for (ll &x : a) cin >> x;\n    for (ll &x : b) cin >> x;\n    cout << (sim_single_hash(a, m) == sim_single_hash(b, m) ? \"YES\\n\" : \"NO\\n\");\n}\n \nint main() {\n    ios::sync_with_stdio(0); cin.tie(0);\n    int t = 1; \n    cin >> t;\n    while (t--) solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2118e",
      "PROBLEM_ID": "2118E",
      "PROBLEM_STATEMENT": "There is a $n\\times m$ grid with each cell initially white. You have to color all the cells one-by-one. After you color a cell, all the colored cells furthest from it receive a penalty. Find a coloring order, where no cell has more than $3$ penalties.\n\nNote that $n$ and $m$ are both odd.\n\nThe distance metric used is the [chessboard distance](https://en.wikipedia.org/wiki/Chebyshev_distance) while we decide ties between cells with [Manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry#Formal_definition). Formally, a cell $(x_2, y_2)$ is further away than $(x_3, y_3)$ from a cell $(x_1, y_1)$ if one of the following holds:\n\n- $\\max\\big(\\lvert x_1 - x_2 \\rvert, \\lvert y_1 - y_2 \\rvert\\big)>\\max\\big(\\lvert x_1 - x_3 \\rvert, \\lvert y_1 - y_3 \\rvert\\big)$\n- $\\max\\big(\\lvert x_1 - x_2 \\rvert, \\lvert y_1 - y_2 \\rvert\\big)=\\max\\big(\\lvert x_1 - x_3 \\rvert, \\lvert y_1 - y_3 \\rvert\\big)$ and $\\lvert x_1 - x_2 \\rvert + \\lvert y_1 - y_2 \\rvert>\\lvert x_1 - x_3 \\rvert + \\lvert y_1 - y_3 \\rvert$\n\nIt can be proven that at least one solution always exists.\n\n![](https://espresso.codeforces.com/426e6caed4dd02a8735e6ae056f6458c2ef70599.png)Example showing penalty changes after coloring the center of a $5 \\times 5$ grid. The numbers indicate the penalty of the cells.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains two odd integers $n$ and $m$ ($1 \\le n, m \\le 4999$) \u2014 the number of rows and columns.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, output $n \\cdot m$ lines where the $i$-th line should contain the coordinates of the $i$-th cell in your coloring order. If there are multiple solutions, print any of them.\n\nThe empty lines in the example output are just for increased readability. You're not required to print them.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3 3\n\n1 1\n\n1 5\n\n```\n\n#### Output #1\n\n```\n2 1\n2 3\n2 2\n1 1\n3 2\n3 3\n3 1\n1 3\n1 2\n\n1 1\n\n1 2\n1 4\n1 5\n1 1\n1 3```\n\n### Note\n\nIn the first test case, the grid can be colored as follows:\n\n![](https://espresso.codeforces.com/fcb29d564cde5c0f485e668c35cf05566b558ec8.png)The numbers indicate the penalty of the cells.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate coloring order for a grid of size n x m\nvector<pair<int, int>> spiralOrder(int n, int m) {\n    vector<pair<int, int>> order;\n    int centerX = n / 2, centerY = m / 2; // Center of the grid\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    \n    // Directions for moving in a spiral: down, right, up, left\n    vector<pair<int, int>> directions = { {1, 0}, {0, 1}, {-1, 0}, {0, -1} };\n    \n    // Priority queue to handle spiral order\n    auto cmp = [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {\n        int distA = max(abs(a.first - centerX), abs(a.second - centerY));\n        int distB = max(abs(b.first - centerX), abs(b.second - centerY));\n        if (distA != distB) return distA > distB;\n        return abs(a.first - centerX) + abs(a.second - centerY) > abs(b.first - centerX) + abs(b.second - centerY);\n    };\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);\n    \n    // Start from the center\n    pq.push({centerX, centerY});\n    visited[centerX][centerY] = true;\n    \n    while (!pq.empty()) {\n        auto [x, y] = pq.top();\n        pq.pop();\n        order.emplace_back(x + 1, y + 1); // Convert to 1-based indexing\n        \n        // Explore neighbors in all 4 directions\n        for (auto [dx, dy] : directions) {\n            int nx = x + dx, ny = y + dy;\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                pq.push({nx, ny});\n            }\n        }\n    }\n    \n    return order;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        // Generate the spiral coloring order\n        vector<pair<int, int>> order = spiralOrder(n, m);\n        \n        // Output the order\n        for (auto [x, y] : order) {\n            cout << x << \" \" << y << \"\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2118d2",
      "PROBLEM_ID": "2118D2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The only difference is the constraint on $k$ and the total sum of $n$ and $q$ across all test cases. You can make hacks only if both versions of the problem are solved.\n\nYou are given a strip of length $10^{15}$ and a constant $k$. There are exactly $n$ cells that contain a traffic light; each has a position $p_i$ and an initial delay $d_i$ for which $d_i < k$. The $i$-th traffic light works the following way:\n\n- it shows red at the $l \\cdot k + d_i$-th second, where $l$ is an integer,\n- it shows green otherwise.\n\nAt second $0$, you are initially positioned at some cell on the strip, facing the positive direction. At each second, you perform the following actions in order:\n\n- If the current cell contains a red traffic light, you turn around.\n- Move one cell in the direction you are currently facing.\n\nYou are given $q$ different starting positions. For each one, determine whether you will eventually leave the strip within $10^{100}$ seconds.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2\\cdot10^5$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $k$ ($\\mathbf{1 \\le n \\le 2\\cdot10^5}$ and $\\mathbf{1 \\le k \\le 10^{15}}$)\u00a0\u2014 the number of traffic lights and the length of the period.\n\nThe second line of each test case contains $n$ integers $p_1, p_2, \\ldots p_n$ ($1 \\le p_1 < p_2 < \\ldots < p_n \\le 10^{15}$)\u00a0\u2014 the positions of the traffic lights.\n\nThe third line of each test case contains $n$ integers $d_1, d_2, \\ldots d_n$ ($0 \\le d_i < k$)\u00a0\u2014 the delays of the traffic lights.\n\nThe fourth line of each test case contains one integer $q$ ($\\mathbf{1 \\le q \\le 2\\cdot10^5}$)\u00a0\u2014 the number of queries.\n\nThe fifth line of each test case contains $q$ integers $a_1, a_2, \\ldots, a_q$ ($1 \\leq a_i \\leq 10^{15}$)\u00a0\u2014 the starting positions.\n\nIt is guaranteed that the sum of $n$ and $q$ over all test cases does not exceed $\\mathbf{2\\cdot10^5}$.\n\n### Output\n\nFor each test case, output $q$ lines. Each line should contain \"YES\" if you will eventually leave the strip and \"NO\" otherwise. You can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 2\n\n1 4\n\n1 0\n\n3\n\n1 2 3\n\n9 4\n\n1 2 3 4 5 6 7 8 9\n\n3 2 1 0 1 3 3 1 1\n\n5\n\n2 5 6 7 8\n\n4 2\n\n1 2 3 4\n\n0 0 0 0\n\n4\n\n1 2 3 4\n\n3 4\n\n1 2 3\n\n3 1 1\n\n3\n\n1 2 3\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nNO\nNO\nYES\nNO\nYES\n```\n\n### Note\n\nIn the first test case, the following happens at starting positions $1$, $2$, and $3$:\n\n![](https://espresso.codeforces.com/63db34c82cbed1e62971514d85a4a6bf71302a79.png)\n\nAnd the following in the second test case at starting position $2$:\n\n![](https://espresso.codeforces.com/70971ec2952940a09246b1e55290386a0dec24a1.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        ll k;\n        cin >> n >> k;\n        vector<ll> p(n), d(n);\n        for(int i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n        for(int i = 0; i < n; i++) {\n            cin >> d[i];\n        }\n        // Build the (p_i - d_i) mod k and (p_i + d_i) mod k arrays\n        vector<pair<ll,int>> arrAr;\n        arrAr.reserve(n);\n        vector<pair<ll,int>> arrBl;\n        arrBl.reserve(n);\n        for(int i = 0; i < n; i++){\n            ll pm = p[i] % k;\n            ll di = d[i] % k;\n            ll ar = pm - di;\n            if(ar < 0) ar += k;\n            ll bl = pm + di;\n            if(bl >= k) bl -= k;\n            arrAr.emplace_back(ar, i);\n            arrBl.emplace_back(bl, i);\n        }\n        // Sort by key then by index\n        sort(arrAr.begin(), arrAr.end());\n        sort(arrBl.begin(), arrBl.end());\n        // Build nextR and prevL transitions\n        vector<int> nextR(n, -1), prevL(n, -1);\n        // nextR[i] = smallest j>i with Ar[j] == Ar[i]\n        for(int idx = 0; idx < n; idx++){\n            if(idx + 1 < n && arrAr[idx].first == arrAr[idx+1].first){\n                nextR[arrAr[idx].second] = arrAr[idx+1].second;\n            } else {\n                nextR[arrAr[idx].second] = -1;\n            }\n        }\n        // prevL[i] = largest j<i with Bl[j] == Bl[i]\n        for(int idx = 0; idx < n; idx++){\n            if(idx > 0 && arrBl[idx].first == arrBl[idx-1].first){\n                prevL[arrBl[idx].second] = arrBl[idx-1].second;\n            } else {\n                prevL[arrBl[idx].second] = -1;\n            }\n        }\n        // We build a reverse graph on 2*n + 1 nodes (the extra node is EXIT)\n        int EXIT = 2 * n;\n        int totalNodes = EXIT + 1;\n        vector<vector<int>> rev_adj(totalNodes);\n        // For each light i, add reverse edges\n        for(int i = 0; i < n; i++){\n            // State (i, dir=+1) has id = i\n            int uR = i;\n            if(nextR[i] != -1){\n                // it goes to (nextR[i], dir=-1) whose id is nextR[i] + n\n                rev_adj[nextR[i] + n].push_back(uR);\n            } else {\n                // goes to EXIT\n                rev_adj[EXIT].push_back(uR);\n            }\n            // State (i, dir=-1) has id = i + n\n            int uL = i + n;\n            if(prevL[i] != -1){\n                // goes to (prevL[i], dir=+1) id = prevL[i]\n                rev_adj[prevL[i]].push_back(uL);\n            } else {\n                // goes to EXIT\n                rev_adj[EXIT].push_back(uL);\n            }\n        }\n        // BFS from EXIT in the reverse graph to mark all states that can reach EXIT\n        vector<char> visited(totalNodes, 0);\n        visited[EXIT] = 1;\n        vector<int> que;\n        que.reserve(totalNodes);\n        que.push_back(EXIT);\n        for(int qi = 0; qi < (int)que.size(); qi++){\n            int u = que[qi];\n            for(int v: rev_adj[u]){\n                if(!visited[v]){\n                    visited[v] = 1;\n                    que.push_back(v);\n                }\n            }\n        }\n        // Now answer queries\n        int q;\n        cin >> q;\n        while(q--){\n            ll a;\n            cin >> a;\n            // Find the first light index hi with p[hi] >= a\n            int hi = int(std::lower_bound(p.begin(), p.end(), a) - p.begin());\n            ll X0 = a % k;\n            // Find in arrAr the first pair >= (X0, hi) lex-order\n            auto it = std::lower_bound(\n                arrAr.begin(), arrAr.end(),\n                pair<ll,int>(X0, hi)\n            );\n            if(it == arrAr.end() || it->first != X0){\n                // No bounce to the right => immediate exit\n                cout << \"YES\\n\";\n            } else {\n                // We bounce at light j0, new state is (j0, dir=-1)\n                int j0 = it->second;\n                int stateId = j0 + n;  // dir = -1\n                cout << (visited[stateId] ? \"YES\\n\" : \"NO\\n\");\n            }\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2118d1",
      "PROBLEM_ID": "2118D1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The only difference is the constraint on $k$ and the total sum of $n$ and $q$ across all test cases. You can make hacks only if both versions of the problem are solved.\n\nYou are given a strip of length $10^{15}$ and a constant $k$. There are exactly $n$ cells that contain a traffic light; each has a position $p_i$ and an initial delay $d_i$ for which $d_i < k$. The $i$-th traffic light works the following way:\n\n- it shows red at the $l \\cdot k + d_i$-th second, where $l$ is an integer,\n- it shows green otherwise.\n\nAt second $0$, you are initially positioned at some cell on the strip, facing the positive direction. At each second, you perform the following actions in order:\n\n- If the current cell contains a red traffic light, you turn around.\n- Move one cell in the direction you are currently facing.\n\nYou are given $q$ different starting positions. For each one, determine whether you will eventually leave the strip within $10^{100}$ seconds.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $k$ ($\\mathbf{1 \\le n \\le 500}$ and $\\mathbf{1 \\le k \\le 500}$)\u00a0\u2014 the number of traffic lights and the length of the period.\n\nThe second line of each test case contains $n$ integers $p_1, p_2, \\ldots p_n$ ($1 \\le p_1 < p_2 < \\cdots < p_n \\le 10^{15}$)\u00a0\u2014 the positions of the traffic lights.\n\nThe third line of each test case contains $n$ integers $d_1, d_2, \\ldots d_n$ ($0 \\le d_i < k$)\u00a0\u2014 the delays of the traffic lights.\n\nThe fourth line of each test case contains one integer $q$ ($\\mathbf{1 \\le q \\le 500}$)\u00a0\u2014 the number of queries.\n\nThe fifth line of each test case contains $q$ integers $a_1, a_2, \\ldots, a_q$ ($1 \\leq a_i \\leq 10^{15}$)\u00a0\u2014 the starting positions.\n\nIt is guaranteed that the sum of $n$ and $q$ over all test cases does not exceed $\\mathbf{500}$.\n\n### Output\n\nFor each test case, output $q$ lines. Each line should contain \"YES\" if you will eventually leave the strip and \"NO\" otherwise. You can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 2\n\n1 4\n\n1 0\n\n3\n\n1 2 3\n\n9 4\n\n1 2 3 4 5 6 7 8 9\n\n3 2 1 0 1 3 3 1 1\n\n5\n\n2 5 6 7 8\n\n4 2\n\n1 2 3 4\n\n0 0 0 0\n\n4\n\n1 2 3 4\n\n3 4\n\n1 2 3\n\n3 1 1\n\n3\n\n1 2 3\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nNO\nNO\nYES\nNO\nYES\n```\n\n### Note\n\nIn the first test case, the following happens at starting positions $1$, $2$, and $3$:\n\n![](https://espresso.codeforces.com/63db34c82cbed1e62971514d85a4a6bf71302a79.png)\n\nAnd the following in the second test case at starting position $2$:\n\n![](https://espresso.codeforces.com/70971ec2952940a09246b1e55290386a0dec24a1.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<ll> p(n);\n        for (int i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n        vector<int> d(n);\n        for (int i = 0; i < n; i++) {\n            cin >> d[i];\n        }\n        int q;\n        cin >> q;\n        vector<ll> a(q);\n        for (int i = 0; i < q; i++) {\n            cin >> a[i];\n        }\n\n        // We build a functional graph on states (i, r, dir),\n        // where i in [1..n] is the index of the traffic light,\n        // r in [0..k-1] is the current time mod k upon arrival,\n        // dir in {0=left,1=right} is the facing direction when arriving.\n        // From each state there is exactly one outgoing edge\n        // either to another light\u2010state or to an exit (denoted by -1).\n\n        const int UNVISITED = 0, VISITING = 1, YES = 2, NO = 3;\n        int M = n * k * 2;\n        vector<int> f(M);\n        vector<int> dp(M, UNVISITED);\n\n        // Build the transition array f[]\n        for (int i = 1; i <= n; i++) {\n            int ci = i - 1;  // zero-based index for p[] and d[]\n            for (int r = 0; r < k; r++) {\n                for (int dir = 0; dir < 2; dir++) {\n                    int idx = ((ci * k) + r) * 2 + dir;\n                    // If the light is red at this moment, we flip direction\n                    int new_dir = (r == d[ci] ? (dir ^ 1) : dir);\n\n                    if (new_dir == 1) {\n                        // moving right\n                        if (i == n) {\n                            // no more lights on the right => exit\n                            f[idx] = -1;\n                        } else {\n                            ll dist = p[ci + 1] - p[ci];\n                            int dm = int(dist % k);\n                            int r2 = (r + dm) % k;\n                            int nxt = (((ci + 1) * k) + r2) * 2 + new_dir;\n                            f[idx] = nxt;\n                        }\n                    } else {\n                        // moving left\n                        if (i == 1) {\n                            // no more lights on the left => exit\n                            f[idx] = -1;\n                        } else {\n                            ll dist = p[ci] - p[ci - 1];\n                            int dm = int(dist % k);\n                            int r2 = (r + dm) % k;\n                            int nxt = (((ci - 1) * k) + r2) * 2 + new_dir;\n                            f[idx] = nxt;\n                        }\n                    }\n                }\n            }\n        }\n\n        // We do a simple DFS\u2010like evaluation on the functional graph\n        // to mark each state as either eventually exiting (YES)\n        // or getting stuck in a cycle (NO).\n        vector<int> stack_;\n        stack_.reserve(M);\n        for (int u = 0; u < M; u++) {\n            if (dp[u] != UNVISITED) continue;\n            stack_.clear();\n            int cur = u;\n            int result = NO;\n            while (true) {\n                if (dp[cur] == UNVISITED) {\n                    dp[cur] = VISITING;\n                    stack_.push_back(cur);\n                    int nx = f[cur];\n                    if (nx < 0) {\n                        // exits\n                        result = YES;\n                        break;\n                    }\n                    if (dp[nx] == UNVISITED) {\n                        cur = nx;\n                        continue;\n                    }\n                    if (dp[nx] == VISITING) {\n                        // found a cycle\n                        result = NO;\n                        break;\n                    }\n                    // dp[nx] is already YES or NO\n                    result = (dp[nx] == YES ? YES : NO);\n                    break;\n                } else {\n                    // shouldn't really happen\n                    result = (dp[cur] == YES ? YES : NO);\n                    break;\n                }\n            }\n            // propagate the result to the entire chain we visited\n            for (int v : stack_) {\n                dp[v] = result;\n            }\n        }\n\n        // Answer each query\n        for (int i = 0; i < q; i++) {\n            ll x = a[i];\n            // if starting beyond the last light, we just exit immediately\n            if (x > p[n - 1]) {\n                cout << \"YES\\n\";\n            } else {\n                // otherwise we find the first light >= x\n                int idxp = int(lower_bound(p.begin(), p.end(), x) - p.begin());\n                ll dist = p[idxp] - x;\n                int r = int(dist % k);\n                if (r < 0) r += k;\n                int dir = 1;  // always start facing right\n                int state = ((idxp * k) + r) * 2 + dir;\n                cout << (dp[state] == YES ? \"YES\\n\" : \"NO\\n\");\n            }\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2118c",
      "PROBLEM_ID": "2118C",
      "PROBLEM_STATEMENT": "You are given an array $a$ of $n$ integers. We define the $\\text{beauty}$ of a number $x$ to be the number of $1$ bits in its binary representation. We define the beauty of an array to be the sum of beauties of the numbers it contains.\n\nIn one operation, you can select an index $i$\u00a0$(1 \\le i \\le n)$ and increase $a_i$ by $1$.\n\nFind the maximum beauty of the array after doing at most $k$ operations.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 5000$, $0 \\le k \\le 10^{18}$)\u00a0\u2014 the length of the array and the maximal number of operations.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots a_n$ ($0 \\le a_i \\le 10^9$)\u00a0\u2014denoting the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, output a single integer, the maximum beauty after at most $k$ operations.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n5 2\n\n0 1 7 2 4\n\n5 3\n\n0 1 7 2 4\n\n1 1\n\n3\n\n3 0\n\n2 0 3\n\n1 100000000000\n\n0\n\n```\n\n#### Output #1\n\n```\n8\n9\n2\n3\n36\n```\n\n### Note\n\nIn the first test case, $a = [0, 1, 7, 2, 4]$.\n\n- apply the first operation at $i = 1$, the new array is $a = [1, 1, 7, 2, 4]$\n- apply the second operation at $i = 4$, the new array is $a = [1, 1, 7, 3, 4]$\n\nThe beauty of this array is $1 + 1 + 3 + 2 + 1 = 8$. One of the other valid solutions with the same beauty is $[0, 1, 7, 3, 5]$.\n\nIn the third test case, $a = [3]$. Since you are not required to use exactly $k$ operations, it is optimal to do none.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \n// Helper function: number of bits in x (for x==0, we treat bit-length as 1)\nint bitLength(unsigned long long x) {\n    if(x == 0) return 1;\n    return 64 - __builtin_clzll(x);\n}\n \n// Helper: popcount of x\nint popCount(unsigned long long x) {\n    return __builtin_popcountll(x);\n}\n \n// This function computes the next number y > x such that popcount(y) > popcount(x). \n// (It is the \u201cminimal\u201d such y.) \n// The idea is: try every bit position (0-indexed, with 0 = least significant)\n// where x has a 0; then force that bit to 1 and \u201cfill\u201d the lower bits with the smallest number \n// (i.e. put as few ones as possible in the lower bits) so that the total ones become (popcount(x)+1).\n// If no candidate is found in the same bit\u2013length then x is of the form 2^L \u2013 1 and we return (1<<(L+1)) \u2013 1.\n \nunsigned long long nextIncrease(unsigned long long x) {\n    int currPop = popCount(x);\n    int L = bitLength(x);\n    unsigned long long best = ULLONG_MAX;\n    // iterate over bit positions 0 ... L-1 (0 = LSB)\n    for (int i = 0; i < L; i++){\n        if( !(x & (1ULL << i)) ){ // if bit i is 0\n            // For positions > i (i.e. bits at indices >= i+1) we keep the same as in x.\n            unsigned long long high = (x >> (i+1)) << (i+1); \n            int onesHigh = popCount(x >> (i+1));  // count ones in the higher part\n            // By flipping bit i we add one one.\n            // We want a total of at least (currPop + 1) ones.\n            // So in the lower i bits we want to add exactly: required = max(0, (currPop+1) - (onesHigh+1))\n            int required = max(0, (currPop + 1) - (onesHigh + 1));\n            if(required > i) continue; // impossible to set that many ones in i bits\n            // The smallest number in i bits with exactly \"required\" ones is: (1<<required)-1 \n            // (i.e. ones in the lowest positions).\n            unsigned long long lowerCandidate = (required == 0 ? 0ULL : ((1ULL << required) - 1));\n            unsigned long long candidate = high + (1ULL << i) + lowerCandidate;\n            if(candidate > x && candidate < best) {\n                best = candidate;\n            }\n        }\n    }\n    if(best != ULLONG_MAX) return best;\n    // Otherwise, x is of the form (2^L - 1). Then popCount(x)==L, so we want next with L+1 ones:\n    return ((1ULL << (L+1)) - 1);\n}\n \n// We'll simulate individual upgrade \"moves\" on each array element.\n// For an element in state x, its next move upgrades it to y = nextIncrease(x).\n// That move \u201ccost\u201d is (y - x) and \u201cbenefit\u201d is (popCount(y) - popCount(x)) (\u2265 1).\n \nstruct Move {\n    unsigned long long cost;\n    int benefit;\n    int idx;\n};\n \n// Compare moves by cost (min\u2013heap)\nstruct MoveComparator {\n    bool operator()(const Move &m1, const Move &m2) {\n        return m1.cost > m2.cost;\n    }\n};\n \n// Main\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        unsigned long long k;\n        cin >> n >> k;\n        vector<unsigned long long> arr(n);\n        for (int i = 0; i < n; i++){\n            cin >> arr[i];\n        }\n \n        // Base beauty = sum of popcounts of original elements.\n        long long baseBeauty = 0;\n        for (int i = 0; i < n; i++){\n            baseBeauty += popCount(arr[i]);\n        }\n \n        // For each element, we maintain its current state.\n        vector<unsigned long long> currentState = arr;\n \n        // We'll put the \u201cnext upgrade move\u201d for each element in a min-heap (priority_queue).\n        priority_queue<Move, vector<Move>, MoveComparator> pq;\n \n        for (int i = 0; i < n; i++){\n            unsigned long long cur = currentState[i];\n            int curPop = popCount(cur);\n            unsigned long long nextVal = nextIncrease(cur);\n            unsigned long long cost = nextVal - cur;\n            int benefit = popCount(nextVal) - curPop;\n            Move m;\n            m.cost = cost;\n            m.benefit = benefit;\n            m.idx = i;\n            pq.push(m);\n        }\n \n        long long extraBeauty = 0;\n        // Greedily \u201cbuy\u201d moves in order of increasing cost as long as budget (k) allows.\n        while(!pq.empty()){\n            Move m = pq.top();\n            if(m.cost > k) break;\n            pq.pop();\n            k -= m.cost;\n            extraBeauty += m.benefit;\n            int idx = m.idx;\n            currentState[idx] += m.cost; // now the element becomes its upgrade candidate\n            unsigned long long cur = currentState[idx];\n            int curPop = popCount(cur);\n            // We choose not to upgrade past a certain high beauty \u2013 \n            // note that even though k can be huge, it never pays to raise beauty arbitrarily;\n            // we cap further upgrades when popcount >= 60.\n            if(curPop >= 60) continue;\n            unsigned long long nextVal = nextIncrease(cur);\n            unsigned long long cost = nextVal - cur;\n            int benefit = popCount(nextVal) - curPop;\n            Move nextMove;\n            nextMove.cost = cost;\n            nextMove.benefit = benefit;\n            nextMove.idx = idx;\n            pq.push(nextMove);\n        }\n \n        long long answer = baseBeauty + extraBeauty;\n        cout << answer << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2118b",
      "PROBLEM_ID": "2118B",
      "PROBLEM_STATEMENT": "There is a matrix $A$ of size $n\\times n$ where $A_{i,j}=j$ for all $1 \\le i,j \\le n$.\n\nIn one operation, you can select a row and reverse any subarray$^{\\text{\u2217}}$ in it.\n\nFind a sequence of at most $2n$ operations such that every column will contain a permutation$^{\\text{\u2020}}$ of length $n$.\n\nIt can be proven that the construction is always possible. If there are multiple solutions, output any of them.\n\n$^{\\text{\u2217}}$An array $a$ is a subarray of an array $b$ if $a$ can be obtained from $b$ by deleting zero or more elements from the beginning and zero or more elements from the end.\n\n$^{\\text{\u2020}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($3 \\le n \\le 5000$)\u00a0\u2014 denoting the number of rows and columns in the matrix.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, on the first line, print an integer $k$\u00a0$(0 \\le k \\le 2n)$, the number of operations you wish to perform. On the next lines, you should print the operations.\n\nTo print an operation, use the format \"$i\\;l\\;r$\" ($1 \\leq l \\leq r \\leq n$ and $1 \\leq i \\leq n$) which reverses the subarray $A_{i, l}$, $A_{i, l+1}$, $\\ldots$, $A_{i, r}$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n3\n\n4\n\n```\n\n#### Output #1\n\n```\n4\n2 1 3\n2 2 3\n3 1 2\n3 2 3\n5\n2 1 4\n3 1 3\n3 2 4\n4 3 4\n4 1 2```\n\n### Note\n\nIn the first test case, the following operations are a valid solution:\n\n![](https://espresso.codeforces.com/3b9509868f6d3b65d8a4a7a94688db76911f59b7.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    // The total number of operations is 2 * (n - 1).\n    std::cout << 2 * (n - 1) << std::endl;\n\n    // For each i from 1 to n-1, we define a pair of operations\n    // on adjacent rows i and i+1.\n    for (int i = 1; i < n; ++i) {\n        // Operation on row i\n        std::cout << i << \" \" << i << \" \" << n << std::endl;\n        // Operation on row i+1\n        std::cout << i + 1 << \" \" << 1 << \" \" << i << std::endl;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2118a",
      "PROBLEM_ID": "2118A",
      "PROBLEM_STATEMENT": "We call a bitstring$^{\\text{\u2217}}$ perfect if it has the same number of $\\mathtt{101}$ and $\\mathtt{010}$ subsequences$^{\\text{\u2020}}$. Construct a perfect bitstring of length $n$ where the number of $\\mathtt{1}$ characters it contains is exactly $k$.\n\nIt can be proven that the construction is always possible. If there are multiple solutions, output any of them.\n\n$^{\\text{\u2217}}$A bitstring is a string consisting only of the characters $\\mathtt{0}$ and $\\mathtt{1}$.\n\n$^{\\text{\u2020}}$A sequence $a$ is a subsequence of a string $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly zero or all) characters.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 100$, $0 \\le k \\le n$)\u00a0\u2014 the size of the bitstring and the number of $\\mathtt{1}$ characters in the bitstring.\n\n### Output\n\nFor each test case, output the constructed bitstring. If there are multiple solutions, output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4 2\n\n5 3\n\n5 5\n\n6 2\n\n1 1\n\n```\n\n#### Output #1\n\n```\n1010\n10110\n11111\n100010\n1```\n\n### Note\n\nIn the first test case, the number of $\\mathtt{101}$ and $\\mathtt{010}$ subsequences is the same, both being $1$, and the sequence contains exactly two $\\mathtt{1}$ characters.\n\nIn the second test case, the number of $\\mathtt{101}$ and $\\mathtt{010}$ subsequences is the same, both being $2$, and the sequence contains exactly three $\\mathtt{1}$ characters.\n\nIn the third test case, the number of $\\mathtt{101}$ and $\\mathtt{010}$ subsequences is the same, both being $0$, and the sequence contains exactly five $\\mathtt{1}$ characters.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        \n        string result(n, '0');  // Initialize string of length n with all zeros\n        \n        // Set the first k positions to ones\n        for (int i = 0; i < k; i++) {\n            result[i] = '1';\n        }\n        \n        cout << result << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2117h",
      "PROBLEM_ID": "2117H",
      "PROBLEM_STATEMENT": "Note the unusual memory limit.\n\nSilver Wolf gives you an array $a$ of length $n$ and $q$ queries. In each query, she replaces an element in $a$. After each query, she asks you to output the maximum integer $k$ such that there exists an integer $x$ such that it is the $k$-majority of a subarray$^{\\text{\u2217}}$ of $a$.\n\nAn integer $y$ is the $k$-majority of array $b$ if $y$ appears at least $\\lfloor \\frac{|b|+1}{2} \\rfloor +k$ times in $b$, where $|b|$ represents the length of $b$. Note that $b$ may not necessarily have a $k$-majority.\n\n$^{\\text{\u2217}}$An array $b$ is a subarray of an array $a$ if $b$ can be obtained from $a$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\leq n, q \\leq 3 \\cdot 10^5$) \u00a0\u2014 the length of $a$ and the number of queries.\n\nThe following line contains $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq n$).\n\nThe following $q$ lines contain two integers $i$ and $x$, denoting the query that replaces $a_i$ with $x$ ($1 \\leq i, x \\leq n$).\n\nIt is guaranteed that the sum of $n$ and the sum of $q$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the answer to all queries on a single new line, separated by a space.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5 5\n\n1 2 3 4 5\n\n3 4\n\n1 4\n\n2 4\n\n4 3\n\n2 3\n\n7 8\n\n3 2 3 3 2 2 3\n\n2 3\n\n5 3\n\n6 3\n\n3 4\n\n4 4\n\n7 4\n\n6 4\n\n2 4\n\n```\n\n#### Output #1\n\n```\n1 1 2 1 0\n2 2 3 2 1 1 1 2\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <map>\n#include <time.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nconst int INF = 2e9;\n\nstruct Node {\n    int val;\n    int min_val, max_val;\n    int max_diff;\n    Node *l = nullptr, *r = nullptr;\n    int priority;\n    int size = 1;\n    int lazy = 0;\n\n    Node(int v) : val(v), min_val(v), max_val(v), max_diff(0) {\n        priority = rand();\n    }\n};\n\nint size(Node* t) {\n    return t ? t->size : 0;\n}\n\nvoid push(Node* t) {\n    if (!t || !t->lazy) return;\n    t->val += t->lazy;\n    t->min_val += t->lazy;\n    t->max_val += t->lazy;\n    if (t->l) t->l->lazy += t->lazy;\n    if (t->r) t->r->lazy += t->lazy;\n    t->lazy = 0;\n}\n\nvoid update_node(Node* t) {\n    if (!t) return;\n    push(t->l);\n    push(t->r);\n    t->size = 1 + size(t->l) + size(t->r);\n    \n    t->min_val = t->val;\n    t->max_val = t->val;\n    \n    if(t->l) t->min_val = min(t->min_val, t->l->min_val);\n    if(t->r) t->min_val = min(t->min_val, t->r->min_val);\n    \n    if(t->l) t->max_val = max(t->max_val, t->l->max_val);\n    if(t->r) t->max_val = max(t->max_val, t->r->max_val);\n\n    t->max_diff = 0;\n    if(t->l) t->max_diff = max(t->max_diff, t->l->max_diff);\n    if(t->r) t->max_diff = max(t->max_diff, t->r->max_diff);\n    if(t->l && t->r) t->max_diff = max(t->max_diff, t->r->max_val - t->l->min_val);\n    if(t->l) t->max_diff = max(t->max_diff, t->val - t->l->min_val);\n    if(t->r) t->max_diff = max(t->max_diff, t->r->max_val - t->val);\n}\n\nvoid split(Node* t, Node*& l, Node*& r, int pos, int add = 0) {\n    if (!t) {\n        l = r = nullptr;\n        return;\n    }\n    push(t);\n    int cur_pos = add + size(t->l);\n    if (pos <= cur_pos) {\n        split(t->l, l, t->l, pos, add);\n        r = t;\n    } else {\n        split(t->r, t->r, r, pos, cur_pos + 1);\n        l = t;\n    }\n    update_node(t);\n}\n\nNode* merge(Node* l, Node* r) {\n    push(l); push(r);\n    if (!l || !r) return l ? l : r;\n    if (l->priority > r->priority) {\n        l->r = merge(l->r, r);\n        update_node(l);\n        return l;\n    } else {\n        r->l = merge(l, r->l);\n        update_node(r);\n        return r;\n    }\n}\n\nvoid delete_treap(Node* t) {\n    if(!t) return;\n    delete_treap(t->l);\n    delete_treap(t->r);\n    delete t;\n}\n\nint calculate_f_light(const vector<int>& p) {\n    if (p.empty()) return 0;\n    int m = p.size();\n    if (m == 0) return 0;\n    long long max_so_far = 0;\n    long long min_b = 2LL * 1 - p[0];\n    for (int i = 1; i < m; ++i) {\n        long long b_i = 2LL * (i + 1) - p[i];\n        max_so_far = max(max_so_far, b_i - min_b);\n        min_b = min(min_b, b_i);\n    }\n    return (1 + max_so_far) / 2;\n}\n\nint get_f_from_treap(Node* t) {\n    if (!t) return 0;\n    push(t);\n    return (1 + max(0, t->max_diff)) / 2;\n}\n\nint N_val, Q_val;\nint B;\nvector<int> a;\nvector<vector<int>> light_pos;\nvector<ordered_set<int>> heavy_pos;\nvector<Node*> heavy_treaps;\nvector<bool> is_heavy;\nvector<int> f_vals;\nmultiset<int> f_set;\nvector<int> counts;\nint max_coord_val;\n\nvoid remove_val(int val, int p) {\n    f_set.erase(f_set.find(f_vals[val]));\n    counts[val]--;\n\n    if (is_heavy[val]) {\n        int rank = heavy_pos[val].order_of_key(p);\n        heavy_pos[val].erase(p);\n\n        Node *l, *m, *r;\n        split(heavy_treaps[val], l, r, rank + 1);\n        split(l, l, m, rank);\n        \n        delete m;\n        if (r) r->lazy -= 2;\n        heavy_treaps[val] = merge(l, r);\n\n        if (counts[val] == B) { // Becomes light\n            is_heavy[val] = false;\n            light_pos[val].clear();\n            for (int pos : heavy_pos[val]) {\n                light_pos[val].push_back(pos);\n            }\n            heavy_pos[val].clear();\n            delete_treap(heavy_treaps[val]);\n            heavy_treaps[val] = nullptr; \n            f_vals[val] = calculate_f_light(light_pos[val]);\n        } else {\n            f_vals[val] = get_f_from_treap(heavy_treaps[val]);\n        }\n    } else {\n        auto it = lower_bound(light_pos[val].begin(), light_pos[val].end(), p);\n        light_pos[val].erase(it);\n        f_vals[val] = calculate_f_light(light_pos[val]);\n    }\n    f_set.insert(f_vals[val]);\n}\n\nvoid add_val(int val, int p) {\n    if (counts[val]>0) {\n        f_set.erase(f_set.find(f_vals[val]));\n    }\n    counts[val]++;\n\n    if (is_heavy[val]) {\n        int rank = heavy_pos[val].order_of_key(p);\n        heavy_pos[val].insert(p);\n\n        Node* new_node = new Node(2 * (rank + 1) - p);\n        Node *l, *r;\n        split(heavy_treaps[val], l, r, rank);\n        if (r) r->lazy += 2;\n        heavy_treaps[val] = merge(merge(l, new_node), r);\n        f_vals[val] = get_f_from_treap(heavy_treaps[val]);\n    } else {\n        if (counts[val] == B + 1) { // Becomes heavy\n            is_heavy[val] = true;\n            \n            auto it = lower_bound(light_pos[val].begin(), light_pos[val].end(), p);\n            light_pos[val].insert(it, p);\n            \n            for (int pos : light_pos[val]) {\n                heavy_pos[val].insert(pos);\n            }\n            light_pos[val].clear();\n\n            Node* root = nullptr;\n            int i = 1;\n            for(int pos_val : heavy_pos[val]) {\n                root = merge(root, new Node(2LL*i - pos_val));\n                i++;\n            }\n            heavy_treaps[val] = root;\n            f_vals[val] = get_f_from_treap(heavy_treaps[val]);\n        } else {\n            auto it = lower_bound(light_pos[val].begin(), light_pos[val].end(), p);\n            light_pos[val].insert(it, p);\n            f_vals[val] = calculate_f_light(light_pos[val]);\n        }\n    }\n    f_set.insert(f_vals[val]);\n}\n\nvoid solve() {\n    cin >> N_val >> Q_val;\n    B = sqrt(N_val);\n    if (B == 0) B = 1;\n\n    a.assign(N_val + 1, 0);\n    vector<pair<int, int>> queries(Q_val);\n    vector<int> distinct_vals;\n    map<int, int> val_map;\n\n    for (int i = 1; i <= N_val; ++i) {\n        cin >> a[i];\n        distinct_vals.push_back(a[i]);\n    }\n    for (int i = 0; i < Q_val; ++i) {\n        cin >> queries[i].first >> queries[i].second;\n        distinct_vals.push_back(queries[i].second);\n    }\n    \n    sort(distinct_vals.begin(), distinct_vals.end());\n    distinct_vals.erase(unique(distinct_vals.begin(), distinct_vals.end()), distinct_vals.end());\n    \n    int cur_id = 0;\n    for (int val : distinct_vals) {\n        val_map[val] = cur_id++;\n    }\n    \n    max_coord_val = cur_id;\n    for (int i = 1; i <= N_val; ++i) a[i] = val_map[a[i]];\n    for (int i = 0; i < Q_val; ++i) queries[i].second = val_map[queries[i].second];\n    \n    is_heavy.assign(max_coord_val, false);\n    counts.assign(max_coord_val, 0);\n    light_pos.assign(max_coord_val, vector<int>());\n    heavy_pos.assign(max_coord_val, ordered_set<int>());\n    heavy_treaps.assign(max_coord_val, nullptr);\n    f_vals.assign(max_coord_val, 0);\n    f_set.clear();\n\n    for (int i = 1; i <= N_val; ++i) {\n        counts[a[i]]++;\n    }\n\n    for (int i = 0; i < max_coord_val; ++i) {\n        if (counts[i] > B) {\n            is_heavy[i] = true;\n        }\n    }\n\n    vector<vector<int>> temp_pos(max_coord_val);\n    for (int i = 1; i <= N_val; ++i) {\n        temp_pos[a[i]].push_back(i);\n    }\n\n    for (int i = 0; i < max_coord_val; ++i) {\n        if (counts[i] > 0) {\n            if (is_heavy[i]) {\n                for(int p : temp_pos[i]) heavy_pos[i].insert(p);\n                Node* root = nullptr;\n                int j = 1;\n                for (int p : heavy_pos[i]) {\n                    root = merge(root, new Node(2LL * j - p));\n                    j++;\n                }\n                heavy_treaps[i] = root;\n                f_vals[i] = get_f_from_treap(heavy_treaps[i]);\n            } else {\n                light_pos[i] = temp_pos[i];\n                f_vals[i] = calculate_f_light(light_pos[i]);\n            }\n            f_set.insert(f_vals[i]);\n        }\n    }\n    if (f_set.empty()) f_set.insert(0);\n    \n    for (int i = 0; i < Q_val; ++i) {\n        int p = queries[i].first;\n        int new_val = queries[i].second;\n        int old_val = a[p];\n\n        if (old_val != new_val) {\n            remove_val(old_val, p);\n            add_val(new_val, p);\n            a[p] = new_val;\n        }\n        \n        cout << *f_set.rbegin() << (i == Q_val - 1 ? \"\" : \" \");\n    }\n    cout << \"\\n\";\n\n    for(int i=0; i<max_coord_val; ++i) {\n        if(heavy_treaps[i]) {\n            delete_treap(heavy_treaps[i]);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    srand(time(0));\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2117g",
      "PROBLEM_ID": "2117G",
      "PROBLEM_STATEMENT": "You are given an undirected connected weighted graph. Define the cost of a path of length $k$ to be as follows:\n\n- Let the weights of all the edges on the path be $w_1,...,w_k$.\n- The cost of the path is $(\\min_{i = 1}^{k}{w_i}) + (\\max_{i=1}^{k}{w_i})$, or in other words, the maximum edge weight + the minimum edge weight.\n\nAcross all paths from vertex $1$ to $n$, report the cost of the path with minimum cost. Note that the path is not necessarily simple.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($2 \\le n \\le 2 \\cdot 10^5, n - 1 \\le m \\le \\min(2 \\cdot 10^5, \\frac{n(n - 1)}{2})$).\n\nThe next $m$ lines each contain integers $u, v$ and $w$ ($1 \\le u, v \\le n, 1 \\le w \\le 10^9$) representing an edge from vertex $u$ to $v$ with weight $w$. It is guaranteed that the graph does not contain self-loops or multiple edges and the resulting graph is connected.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$ and that the sum of $m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer, the minimum cost path from vertex $1$ to $n$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 2\n\n1 2 1\n\n2 3 1\n\n3 2\n\n1 3 13\n\n1 2 5\n\n8 9\n\n1 2 6\n\n2 3 5\n\n3 8 6\n\n1 4 7\n\n4 5 4\n\n5 8 7\n\n1 6 5\n\n6 7 5\n\n7 8 5\n\n3 3\n\n1 3 9\n\n1 2 8\n\n2 3 3\n\n```\n\n#### Output #1\n\n```\n2\n18\n10\n11\n```\n\n### Note\n\nFor the second test case, the optimal path is $1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 3$, the edge weights are $5, 5, 13$ so the cost is $\\min(5, 5, 13) + \\max(5, 5, 13) = 5 + 13 = 18$. It can be proven that there is no path with lower cost.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int INF = INT_MAX;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        vector<vector<pii>> adj(n);\n        for (int i = 0; i < m; i++) {\n            int u, v, w;\n            cin >> u >> v >> w;\n            u--; v--;\n            adj[u].push_back({v, w});\n            adj[v].push_back({u, w});\n        }\n\n        vector<int> d1(n, INF);\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n        d1[0] = 0;\n        pq.push({0, 0});\n        while (!pq.empty()) {\n            int max_edge = pq.top().first;\n            int u = pq.top().second;\n            pq.pop();\n            if (max_edge != d1[u]) continue;\n            for (auto [v, w] : adj[u]) {\n                int next_max = max(max_edge, w);\n                if (next_max < d1[v]) {\n                    d1[v] = next_max;\n                    pq.push({next_max, v});\n                }\n            }\n        }\n\n        vector<int> d2(n, INF);\n        d2[n-1] = 0;\n        pq.push({0, n-1});\n        while (!pq.empty()) {\n            int max_edge = pq.top().first;\n            int u = pq.top().second;\n            pq.pop();\n            if (max_edge != d2[u]) continue;\n            for (auto [v, w] : adj[u]) {\n                int next_max = max(max_edge, w);\n                if (next_max < d2[v]) {\n                    d2[v] = next_max;\n                    pq.push({next_max, v});\n                }\n            }\n        }\n\n        long long ans = LLONG_MAX;\n        for (int u = 0; u < n; u++) {\n            for (auto [v, w] : adj[u]) {\n                if (u < v) {\n                    int candidate1 = max({w, d1[u], d2[v]});\n                    int candidate2 = max({w, d1[v], d2[u]});\n                    ans = min(ans, (long long)min(candidate1, candidate2) + w);\n                }\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2117f",
      "PROBLEM_ID": "2117F",
      "PROBLEM_STATEMENT": "Yousef has a rooted tree$^{\\text{\u2217}}$ consisting of exactly $n$ vertices, which is rooted at vertex $1$. You would like to give Yousef an array $a$ of length $n$, where each $a_i$ $(1 \\le i \\le n)$ can either be $1$ or $2$.\n\nLet $s_u$ denote the sum of $a_v$ where vertex $v$ is in the subtree$^{\\text{\u2020}}$ of vertex $u$. Yousef considers the tree special if all the values in $s$ are pairwise distinct (i.e., all subtree sums are unique).\n\nYour task is to help Yousef count the number of different arrays $a$ that result in the tree being special. Two arrays $b$ and $c$ are different if there exists an index $i$ such that $b_i \\neq c_i$.\n\nAs the result can be very large, you should print it modulo $10^9 + 7$.\n\n$^{\\text{\u2217}}$A tree is a connected undirected graph with $n - 1$ edges.\n\n$^{\\text{\u2020}}$The subtree of a vertex $v$ is the set of all vertices that pass through $v$ on a simple path to the root. Note that vertex $v$ is also included in the set.\n\n### Input\n\nThe first line contains an integer $t$ $(1 \\le t \\le 10^4)$ \u2014 the number of test cases.\n\nEach test case consists of several lines. The first line of the test case contains an integer $n$ $(2 \\le n \\le 2 \\cdot 10^5)$ \u2014 the number of vertices in the tree.\n\nThen $n\u22121$ lines follow, each of them contains two integers $u$ and $v$ $(1 \\le u,v \\le n, u \\ne v)$ which describe a pair of vertices connected by an edge. It is guaranteed that the given graph is a tree and has no loops or multiple edges.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print one integer $x$ \u2014 the number of different arrays $a$ that result in the tree being special, modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n2\n\n1 2\n\n8\n\n1 2\n\n2 3\n\n3 8\n\n2 4\n\n4 5\n\n5 6\n\n6 7\n\n10\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n5 6\n\n4 7\n\n7 8\n\n4 9\n\n9 10\n\n7\n\n1 4\n\n4 2\n\n3 2\n\n3 5\n\n2 6\n\n6 7\n\n7\n\n1 2\n\n2 3\n\n3 4\n\n3 5\n\n4 6\n\n6 7\n\n7\n\n5 7\n\n4 6\n\n1 6\n\n1 3\n\n2 6\n\n6 7\n\n5\n\n3 4\n\n1 2\n\n1 3\n\n2 5\n\n```\n\n#### Output #1\n\n```\n4\n24\n0\n16\n48\n0\n4\n```\n\n### Note\n\nThe tree given in the fifth test case:\n\n![](https://espresso.codeforces.com/bd9f04ef8898b0b29a6e5e86a17295ed03a19d03.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int N = 2e5 + 10, MOD = 1e9 + 7;\n#define int long long\n \nvector<int> adj[N], lens;\nint pw[N];\nint lca;\n \nvoid dfs(int u, int par, int len) {\n    if(adj[u].size() > 2) lca = len;\n    \n    bool leaf = true;\n    for(int v : adj[u]) {\n        if(v != par) {\n            dfs(v, u, len + 1);\n            leaf = false;\n        }\n    }\n \n    if(leaf) lens.push_back(len);\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    for(int i = 1; i <= n; i++) adj[i].clear();\n    lens.clear();\n    lca = -1;\n\n    for(int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    adj[1].push_back(0); // dummy node\n    dfs(1, 0, 1);\n    if(lens.size() > 2) cout << 0 << endl;\n    else if(lens.size() == 1) cout << pw[n] << endl;\n    else {\n        int diff = abs(lens[0] - lens[1]);\n        int x = diff + lca;\n        if(diff) cout << (pw[x] + pw[x - 1]) % MOD << endl;\n        else cout << (2 * pw[x]) % MOD << endl;\n    }\n}\n\nsigned main() {\n    pw[0] = 1;\n    for(int i = 1; i < N; i++) pw[i] = (pw[i - 1] * 2) % MOD;\n\n    int t;\n    cin >> t;\n    while(t--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2117e",
      "PROBLEM_ID": "2117E",
      "PROBLEM_STATEMENT": "You are given two integer arrays $a$ and $b$, each of length $n$.\n\nYou may perform the following operation any number of times:\n\n- Choose an index $i$ $(1 \\le i \\le n - 1)$, and set $a_i := b_{i + 1}$, or set $b_i := a_{i + 1}$.\n\nBefore performing any operations, you are allowed to choose an index $i$ $(1 \\le i \\le n)$ and remove both $a_i$ and $b_i$ from the arrays. This removal can be done at most once.\n\nLet the number of matches between two arrays $c$ and $d$ of length $m$ be the number of positions $j$ $(1 \\le j \\le m)$ such that $c_j = d_j$.\n\nYour task is to compute the maximum number of matches you can achieve.\n\n### Input\n\nThe first line of the input contains an integer $t$ $(1 \\le t \\le 10^4)$ \u2014 the number of test cases. The description of each test case follows.\n\nThe first line contains an integer $n$ $(2 \\le n \\le 2 \\cdot 10^5)$ \u2014 the length of $a$ and $b$.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ $(1 \\le a_i \\le n)$ \u2014 the elements of $a$.\n\nThe third line contains $n$ integers $b_1, b_2, \\dots, b_n$ $(1 \\le b_i \\le n)$ \u2014 the elements of $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer \u2014 the answer for the test case.\n\n### Example\n\n#### Input #1\n\n```\n\n10\n\n4\n\n1 3 1 4\n\n4 3 2 2\n\n6\n\n2 1 5 3 6 4\n\n3 2 4 5 1 6\n\n2\n\n1 2\n\n2 1\n\n6\n\n2 5 1 3 6 4\n\n3 5 2 3 4 6\n\n4\n\n1 3 2 2\n\n2 1 3 4\n\n8\n\n3 1 4 6 2 2 5 7\n\n4 2 3 7 1 1 6 5\n\n10\n\n5 1 2 7 3 9 4 10 6 8\n\n6 2 3 6 4 10 5 1 7 9\n\n5\n\n3 2 4 1 5\n\n2 4 5 1 3\n\n7\n\n2 2 6 4 1 3 5\n\n3 1 6 5 1 4 2\n\n5\n\n4 1 3 2 5\n\n3 2 1 5 4\n\n```\n\n#### Output #1\n\n```\n3\n3\n0\n4\n3\n5\n6\n4\n5\n2\n```\n\n### Note\n\nIn the first test case, we can do the following:\n\n- We will choose not to remove any index.\n- Choose index $3$, and set $a_3 := b_4$. The arrays become: $a = [1, 3, 2, 4]$, $b = [4, 3, 2, 2]$.\n- Choose index $1$, and set $a_1 := b_2$. The arrays become: $a = [3, 3, 2, 4]$, $b = [4, 3, 2, 2]$.\n- Choose index $1$, and set $b_1 := a_2$. The arrays become: $a = [3, 3, 2, 4]$, $b = [3, 3, 2, 2]$. Notice that you can perform $a_i := b_{i + 1}$ and $b_i := a_{i + 1}$ on the same index $i$.\n\nThe number of matches is $3$. It can be shown that this is the maximum answer we can achieve.\n\nIn the second test case, we can do the following to achieve a maximum of $3$:\n\n- Let's choose to remove index $5$. The arrays become: $a = [2, 1, 5, 3, 4]$, $b = [3, 2, 4, 5, 6]$.\n- Choose index $4$, and set $b_4 := a_5$. The arrays become: $a = [2, 1, 5, 3, 4]$, $b = [3, 2, 4, 4, 6]$.\n- Choose index $3$, and set $a_3 := b_4$. The arrays become: $a = [2, 1, 4, 3, 4]$, $b = [3, 2, 4, 4, 6]$.\n- Choose index $2$, and set $a_2 := b_3$. The arrays become: $a = [2, 4, 4, 3, 4]$, $b = [3, 2, 4, 4, 6]$.\n- Choose index $1$, and set $b_1 := a_2$. The arrays become: $a = [2, 4, 4, 3, 4]$, $b = [4, 2, 4, 4, 6]$.\n- Choose index $2$, and set $b_2 := a_3$. The arrays become: $a = [2, 4, 4, 3, 4]$, $b = [4, 4, 4, 4, 6]$.\n- Choose index $1$, and set $a_1 := b_2$. The arrays become: $a = [4, 4, 4, 3, 4]$, $b = [4, 4, 4, 4, 6]$.\n\nIn the third test case, it can be shown that we can not get any matches. Therefore, the answer is $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n\n    for(auto &it : a) cin >> it;\n    for(auto &it : b) cin >> it;\n\n    vector<bool> seen(n + 1);\n    if(a.back() == b.back()) {\n        cout << n << endl;\n        return;\n    }\n\n    int ans = -1;\n    for(int i = n - 2; i >= 0; i--) {\n        if(a[i] == b[i] || a[i] == a[i + 1] || b[i] == b[i + 1] || seen[a[i]] || seen[b[i]]) {\n            ans = i;\n            break;\n        }\n\n        seen[a[i + 1]] = seen[b[i + 1]] = true;\n    }\n\n    cout << ans + 1 << endl;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while(t--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2117c",
      "PROBLEM_ID": "2117C",
      "PROBLEM_STATEMENT": "Yousef has an array $a$ of size $n$. He wants to partition the array into one or more contiguous segments such that each element $a_i$ belongs to exactly one segment.\n\nA partition is called cool if, for every segment $b_j$, all elements in $b_j$ also appear in $b_{j + 1}$ (if it exists). That is, every element in a segment must also be present in the segment following it.\n\nFor example, if $a = [1, 2, 2, 3, 1, 5]$, a cool partition Yousef can make is $b_1 = [1, 2]$, $b_2 = [2, 3, 1, 5]$. This is a cool partition because every element in $b_1$ (which are $1$ and $2$) also appears in $b_2$. In contrast, $b_1 = [1, 2, 2]$, $b_2 = [3, 1, 5]$ is not a cool partition, since $2$ appears in $b_1$ but not in $b_2$.\n\nNote that after partitioning the array, you do not change the order of the segments. Also, note that if an element appears several times in some segment $b_j$, it only needs to appear at least once in $b_{j + 1}$.\n\nYour task is to help Yousef by finding the maximum number of segments that make a cool partition.\n\n### Input\n\nThe first line of the input contains integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the size of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$) \u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print one integer \u2014 the maximum number of segments that make a cool partition.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n6\n\n1 2 2 3 1 5\n\n8\n\n1 2 1 3 2 1 3 2\n\n5\n\n5 4 3 2 1\n\n10\n\n5 8 7 5 8 5 7 8 10 9\n\n3\n\n1 2 2\n\n9\n\n3 3 1 4 3 2 4 1 2\n\n6\n\n4 5 4 5 6 4\n\n8\n\n1 2 1 2 1 2 1 2\n\n```\n\n#### Output #1\n\n```\n2\n3\n1\n3\n1\n3\n3\n4\n```\n\n### Note\n\nThe first test case is explained in the statement. We can partition it into $b_1 = [1, 2]$, $b_2 = [2, 3, 1, 5]$. It can be shown there is no other partition with more segments.\n\nIn the second test case, we can partition the array into $b_1 = [1, 2]$, $b_2 = [1, 3, 2]$, $b_3 = [1, 3, 2]$. The maximum number of segments is $3$.\n\nIn the third test case, the only partition we can make is $b_1 = [5, 4, 3, 2, 1]$. Any other partition will not satisfy the condition. Therefore, the answer is $1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t; \n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for(int i=0; i<n; i++){\n            cin >> a[i];\n        }\n \n        // Precompute last occurrence for each number.\n        // (Elements are between 1 and n.)\n        vector<int> last(n+1, -1);\n        for (int i = 0; i < n; i++){\n            last[a[i]] = i;\n        }\n \n        // We'll form segments greedily.\n        int segments = 0;\n        int start = 0;\n \n        // \"required\" indicates the set of numbers that the next segment must include.\n        vector<bool> required(n+1, false);\n        int reqCount = 0; // number of distinct numbers required.\n        \n        // To quickly check \u201cfirst occurrence\u201d in the current segment\n        // we use segMark. For each number, segMark[x] will hold the segment id in which it was first encountered.\n        vector<int> segMark(n+1, 0);\n        // For required elements: reqMark[x] will help us mark that the element x from the required set has been seen in the current segment.\n        vector<int> reqMark(n+1, 0);\n \n        int curSegId = 1; // will change with each segment (this avoids full resets of segMark / reqMark arrays).\n \n        while(start < n){\n            // For the current segment, we will build the distinct set, \n            // and update currentMin = min(last[x] for x in current segment).\n            int currentMin = INT_MAX;\n            int satisfied = 0; // count of required numbers from previous segment that have been encountered in current segment.\n \n            // We store the distinct numbers encountered in current segment (we will use these to update our \"required\" for the next segment).\n            vector<int> curDistinct;\n \n            // For a new segment, use a new segment id.\n            curSegId++;\n \n            bool madeCut = false;  // true if a cut (i.e. a non-final segment) is made within this pass.\n            int i;\n            for(i = start; i < n; i++){\n                int x = a[i];\n                // If x is appearing for the first time in the current segment:\n                if(segMark[x] != curSegId){\n                    segMark[x] = curSegId;\n                    curDistinct.push_back(x);\n                    currentMin = min(currentMin, last[x]);\n                    // If x is one of the required elements (from the previous segment) and it wasn\u2019t yet counted, count it.\n                    if(required[x]){\n                        reqMark[x] = curSegId;\n                        satisfied++;\n                    }\n                }\n                // Otherwise, x is already in the current segment \u2013 nothing else to update.\n \n                // Now, for a non-final segment we want to \u201ccut\u201d as soon as possible.\n                // We can cut here if:\n                //    (a) our current segment covers all required numbers,\n                //    (b) AND every number in the segment appears later \n                //        (i.e. i < min(last[x]) for all x in current segment)\n                if(satisfied == reqCount && i < currentMin){\n                    segments++;  // We form a non-final segment.\n                    // The next segment will be forced to include the current distinct set.\n                    vector<bool> newReq(n+1, false);\n                    for(auto &elem : curDistinct){\n                        newReq[elem] = true;\n                    }\n                    required = move(newReq);\n                    reqCount = curDistinct.size();\n \n                    start = i+1;\n                    madeCut = true;\n                    break;\n                }\n            }\n            if(!madeCut){\n                // We reached the end \u2013 this is the final segment.\n                segments++;\n                break;\n            }\n        }\n \n        cout << segments << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2117b",
      "PROBLEM_ID": "2117B",
      "PROBLEM_STATEMENT": "A shrink operation on an array $a$ of size $m$ is defined as follows:\n\n- Choose an index $i$ ($2 \\le i \\le m - 1$) such that $a_i \\gt a_{i - 1}$ and $a_i \\gt a_{i + 1}$.\n- Remove $a_i$ from the array.\n\nDefine the score of a permutation$^{\\text{\u2217}}$ $p$ as the maximum number of times that you can perform the shrink operation on $p$.\n\nYousef has given you a single integer $n$. Construct a permutation $p$ of length $n$ with the maximum possible score. If there are multiple answers, you can output any of them.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nThe first line of the input contains an integer $t$ ($1 \\le t \\le 10^3$) \u2014 the number of test cases.\n\nEach test case contains an integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$) \u2014 the size of the permutation.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output any permutation $p_1, p_2, \\dots, p_n$ that maximizes the number of shrink operations.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n3\n\n6\n\n```\n\n#### Output #1\n\n```\n1 3 2\n2 3 6 4 5 1\n```\n\n### Note\n\nIn the first test case:\n\n- We choose $p = [1, 3, 2]$.\n- Choose index $2$, and remove $p_2$ from the array. The array becomes $p = [1, 2]$.\n\nIt can be shown that the maximum number of operations we can perform is $1$. Another valid answer is $p = [2, 3, 1]$.\n\nIn the second test case:\n\n- We choose $p = [2, 3, 6, 4, 5, 1]$.\n- Choose index $5$, and remove $p_5$ from the array. The array becomes $p = [2, 3, 6, 4, 1]$.\n- Choose index $3$, and remove $p_3$ from the array. The array becomes $p = [2, 3, 4, 1]$.\n- Choose index $3$, and remove $p_3$ from the array. The array becomes $p = [2, 3, 1]$.\n- Choose index $2$, and remove $p_2$ from the array. The array becomes $p = [2, 1]$.\n\nThe maximum number of operations we can perform is $4$. Any permutation with a score of $4$ is valid.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<int> permutation(n);\n        \n        // First two elements are 2 and 3\n        permutation[0] = 2;\n        permutation[1] = 3;\n        \n        // Last element is always 1\n        permutation[n-1] = 1;\n        \n        if (n > 3) {\n            // Third element is n\n            permutation[2] = n;\n            \n            // Fill the rest with 4, 5, ..., n-1\n            int val = 4;\n            for (int i = 3; i < n-1; i++) {\n                permutation[i] = val++;\n            }\n        }\n        \n        // Print the permutation\n        for (int i = 0; i < n; i++) {\n            cout << permutation[i] << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2117a",
      "PROBLEM_ID": "2117A",
      "PROBLEM_STATEMENT": "Yousef is at the entrance of a long hallway with $n$ doors in a row, numbered from $1$ to $n$. He needs to pass through all the doors from $1$ to $n$ in order of numbering and reach the exit (past door $n$).\n\nEach door can be open or closed. If a door is open, Yousef passes through it in $1$ second. If the door is closed, Yousef can't pass through it.\n\nHowever, Yousef has a special button which he can use at most once at any moment. This button makes all closed doors become open for $x$ seconds.\n\nYour task is to determine if Yousef can pass through all the doors if he can use the button at most once.\n\n### Input\n\nThe first line of the input contains an integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n, x$ ($1 \\le n, x \\le 10$) \u2014 the number of doors and the number of seconds of the button, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, ..., a_n$ ($a_i \\in \\{0, 1\\}$) \u2014 the state of each door. Open doors are represented by '0', while closed doors are represented by '1'.\n\nIt is guaranteed that each test case contains at least one closed door.\n\n### Output\n\nFor each test case, output \"YES\" if Yousef can reach the exit, and \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n4 2\n\n0 1 1 0\n\n6 3\n\n1 0 1 1 0 0\n\n8 8\n\n1 1 1 0 0 1 1 1\n\n1 2\n\n1\n\n5 1\n\n1 0 1 0 1\n\n7 4\n\n0 0 0 1 1 0 1\n\n10 3\n\n0 1 0 0 1 0 0 1 0 0\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nYES\nNO\nYES\nNO\n```\n\n### Note\n\nIn the first test case, the optimal way is as follows:\n\n- At time $0$, the door is open, so Yousef passes.\n- At time $1$, the door is closed, Yousef can use the button now and pass through the door.\n- At time $2$, the button's effect is still on, so Yousef can still pass.\n- At time $3$, the button's effect has finished, but the door is open. Yousef passes and reaches the exit.\n\nIn the second test case, Yousef has a 3-second button, but he would need at least a 4-second button to reach the exit. Therefore, the answer is NO.\n\nIn the third test case, Yousef can turn on the button before starting to move. All the doors will stay open until he reaches the exit.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool canYousefReachExit(int n, int x, vector<int>& doors) {\n    // Find the first closed door\n    int first_closed = -1;\n    for (int i = 0; i < n; i++) {\n        if (doors[i] == 1) {\n            first_closed = i;\n            break;\n        }\n    }\n    \n    // If no closed doors, Yousef can reach the exit\n    if (first_closed == -1) {\n        return true;\n    }\n    \n    // Find the last closed door\n    int last_closed = -1;\n    for (int i = n - 1; i >= 0; i--) {\n        if (doors[i] == 1) {\n            last_closed = i;\n            break;\n        }\n    }\n    \n    // If the button is used at time first_closed, Yousef can pass through closed doors\n    // until time first_closed + x - 1. If last_closed is after this time, Yousef can't reach the exit.\n    return last_closed <= first_closed + x - 1;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, x;\n        cin >> n >> x;\n        \n        vector<int> doors(n);\n        for (int i = 0; i < n; i++) {\n            cin >> doors[i];\n        }\n        \n        if (canYousefReachExit(n, x, doors)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2116b",
      "PROBLEM_ID": "2116B",
      "PROBLEM_STATEMENT": "Flower gives Gellyfish two permutations$^{\\text{\u2217}}$ of $[0, 1, \\ldots, n-1]$: $p_0, p_1, \\ldots, p_{n-1}$ and $q_0, q_1, \\ldots, q_{n-1}$.\n\nNow Gellyfish wants to calculate an array $r_0,r_1,\\ldots,r_{n-1}$ through the following method:\n\n- For all $i$ ($0 \\leq i \\leq n-1$), $r_i = \\max\\limits_{j=0}^{i} \\left(2^{p_j} + 2^{q_{i-j}} \\right)$\n\nBut since Gellyfish is very lazy, you have to help her figure out the elements of $r$.\n\nSince the elements of $r$ are very large, you are only required to output the elements of $r$ modulo $998\\,244\\,353$.\n\n$^{\\text{\u2217}}$An array $b$ is a permutation of an array $a$ if $b$ consists of the elements of $a$ in arbitrary order. For example, $[4,2,3,4]$ is a permutation of $[3,2,4,4]$ while $[1,2,2]$ is not a permutation of $[1,2,3]$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 10^5$).\n\nThe second line of each test case contains $n$ integers $p_0, p_1, \\ldots,p_{n-1}$ ($0 \\leq p_i < n$).\n\nThe third line of each test case contains $n$ integers $q_0, q_1, \\ldots,q_{n-1}$ ($0 \\leq q_i < n$).\n\nIt is guaranteed that both $p$ and $q$ are permutations of $[0, 1, \\ldots, n-1]$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output $n$ integers $r_0, r_1, \\ldots, r_{n-1}$ in a single line, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n0 2 1\n\n1 2 0\n\n5\n\n0 1 2 3 4\n\n4 3 2 1 0\n\n10\n\n5 8 9 3 4 0 2 7 1 6\n\n9 5 1 4 0 3 2 8 7 6\n\n```\n\n#### Output #1\n\n```\n3 6 8\n17 18 20 24 32\n544 768 1024 544 528 528 516 640 516 768\n```\n\n### Note\n\nIn the first test case:\n\n- $r_0 = 2^{p_0} + 2^{q_0} = 1+2=3$\n- $r_1 = \\max(2^{p_0} + 2^{q_1}, 2^{p_1} + 2^{q_0}) = \\max(1+4, 4+2) = 6$\n- $r_2 = \\max(2^{p_0} + 2^{q_2}, 2^{p_1}+2^{q_1}, 2^{p_2}+2^{q_0}) = (1+1, 4+4, 2+2) = 8$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 998244353;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    // Precompute powers of 2 mod MOD up to 100000 (maximum n)\n    int maxPre = 100000;\n    vector<long long> pow2(maxPre+1,0);\n    pow2[0] = 1;\n    for (int i = 1; i <= maxPre; i++){\n        pow2[i] = (pow2[i-1] * 2) % MOD;\n    }\n    \n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> p(n), q(n);\n        for (int i = 0; i < n; i++){\n            cin >> p[i];\n        }\n        for (int i = 0; i < n; i++){\n            cin >> q[i];\n        }\n \n        // We will iterate i from 0 to n-1.\n        // For each i, we want to maximize over j in [0, i] the value\n        // candidate(j) = ( max(p[j], q[i-j]), min(p[j], q[i-j]) )\n        // Observing that the optimum always comes from one of two cases:\n        //  candidate1: where j = argmax_{0<=j<=i} p[j]\n        //  candidate2: where k = argmax_{0<=k<=i} q[k] (and then j = i - k)\n \n        int bestPIndex = 0; // index with maximum p in prefix [0,i]\n        int bestQIndex = 0; // index with maximum q in prefix [0,i]\n \n        vector<long long> res(n,0);\n        for (int i = 0; i < n; i++){\n            if(i > 0){\n                if(p[i] > p[bestPIndex])\n                    bestPIndex = i;\n                if(q[i] > q[bestQIndex])\n                    bestQIndex = i;\n            }\n \n            // Candidate 1 from p side.\n            int j1 = bestPIndex;         // we use j1 as best index in [0,i] for p.\n            int exp1 = p[j1];\n            int idx_q = i - j1;           // corresponding index in q.\n            int exp2 = q[idx_q];\n            // Candidate is sorted as (first, second) = (max(exp1,exp2), min(exp1, exp2))\n            int cand1_first = max(exp1, exp2);\n            int cand1_second = min(exp1, exp2);\n \n            // Candidate 2 from the q side.\n            int k1 = bestQIndex;         // best index in [0,i] for q.\n            int exp3 = q[k1];\n            int j2 = i - k1;             // corresponding index in p.\n            int exp4 = p[j2];\n            int cand2_first = max(exp3, exp4);\n            int cand2_second = min(exp3, exp4);\n \n            int best_first, best_second;\n            // Lex compare: first component priority, then second.\n            if(cand1_first > cand2_first){\n                best_first = cand1_first; best_second = cand1_second;\n            } else if(cand1_first < cand2_first){\n                best_first = cand2_first; best_second = cand2_second;\n            } else {\n                if(cand1_second >= cand2_second){\n                    best_first = cand1_first; best_second = cand1_second;\n                } else {\n                    best_first = cand2_first; best_second = cand2_second;\n                }\n            }\n \n            // Our answer is 2^(best_first) + 2^(best_second) modulo MOD.\n            long long term = (pow2[best_first] + pow2[best_second]) % MOD;\n            res[i] = term;\n        }\n \n        // output the computed r values\n        for (int i = 0; i < n; i++){\n            cout << res[i] << (i == n-1 ? \"\\n\" : \" \");\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2116a",
      "PROBLEM_ID": "2116A",
      "PROBLEM_STATEMENT": "Gellyfish and Flower are playing a game called \"Duel\".\n\nGellyfish has $a$ HP, while Flower has $b$ HP.\n\nEach of them has a knight. Gellyfish's knight has $c$ HP, while Flower's knight has $d$ HP.\n\nThey will play a game in rounds until one of the players wins. For $k = 1, 2, \\ldots$ in this order, they will perform the following actions:\n\n- If $k$ is odd and Gellyfish's knight is alive:\n  - Gellyfish's knight can attack Flower and reduce $b$ by $1$. If $b \\leq 0$, Gellyfish wins. Or,\n  - Gellyfish's knight can attack Flower's knight and reduce $d$ by $1$. If $d \\leq 0$, Flower's knight dies.\n- If $k$ is even and Flower's knight is alive:\n  - Flower's knight can attack Gellyfish and reduce $a$ by $1$. If $a \\leq 0$, Flower wins. Or,\n  - Flower's knight can attack Gellyfish's knight and reduce $c$ by $1$. If $c \\leq 0$, Gellyfish's knight dies.\n\nAs one of the smartest people in the world, you want to tell them who will win before the game. Assume both players play optimally.\n\nIt can be proven that the game will never end in a draw. That is, one player has a strategy to end the game in a finite number of moves.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first and only line of each test case contains four integers $a$, $b$, $c$, $d$ ($1 \\leq a, b, c, d \\leq 10^9$)\u00a0\u2014 the HP of Gellyfish, the HP of Flower, the HP of Gellyfish's knight, and the HP of Flower's knight, respectively.\n\n### Output\n\nFor each test case, if Flower will win, output \"Flower\", otherwise output \"Gellyfish\".\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1 2 3 4\n\n100 999 1 1\n\n10 20 10 30\n\n12 14 13 11\n\n998 244 353 107\n\n```\n\n#### Output #1\n\n```\nFlower\nGellyfish\nFlower\nGellyfish\nGellyfish\n```\n\n### Note\n\nIn the first test case, Gellyfish has only $1$ HP. Therefore, no matter what Gellyfish does in the first round, Flower's knight will attack Gellyfish in the second round, allowing Flower to win.\n\nIn the second test case, Flower's knight has only $1$ HP. Gellyfish will attack Flower's knight in the first round. Then Flower's knight will no longer be able to attack, allowing Gellyfish to win.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        ll a, b, c, d;\n        cin >> a >> b >> c >> d;\n        // Gellyfish (player 1) wins iff min(a, c) >= min(b, d)\n        if (min(a, c) >= min(b, d)) {\n            cout << \"Gellyfish\\n\";\n        } else {\n            cout << \"Flower\\n\";\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2115f2",
      "PROBLEM_ID": "2115F2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, the time limit and the constraints on $n$ and $q$ are higher. You can hack only if you solved all versions of this problem.\n\nGellyfish has an array consisting of $n$ sets. Initially, all the sets are empty.\n\nNow Gellyfish will do $q$ operations. Each operation contains one modification operation and one query operation, for the $i$-th ($1 \\leq i \\leq q$) operation:\n\nFirst, there will be a modification operation, which is one of the following:\n\n1. Insert operation: You are given an integer $r$. For the $1$-th to $r$-th sets, insert element $i$. Note that the element inserted here is $i$, the index of the operation, not the index of the set.\n2. Reverse operation: You are given an integer $r$. Reverse the $1$-th to $r$-th sets.\n3. Delete operation: You are given an integer $x$. Delete element $x$ from all sets that contain $x$.\n\nFollowed by a query operation:\n\n- Query operation: You are given an integer $p$. Output the smallest element in the $p$-th set (If the $p$-th set is empty, the answer is considered to be $0$).\n\nNow, Flower needs to provide the answer for each query operation. Please help her!\n\nAdditional constraint on the problem: Gellyfish will only give the next operation after Flower has answered the previous query operation. That is, you need to solve this problem online. Please refer to the input format for more details.\n\n### Input\n\nThe first line contains two integers $n$ and $q$ ($1 \\leq n, q \\leq 3 \\cdot 10^5$)\u00a0\u2014 the number of the sets and the number of operations.\n\nAs you need to respond to the operations online, the operations will be encoded.\n\nThe $i$-th line of the following $q$ lines contains three integers $a$, $b$, and $c$ ($1 \\leq a \\leq 3$, $1 \\leq c \\leq n$)\u00a0\u2014 describing the $i$-th operation in an encoded form.\n\nHere, $a$ represents the type of modification operation. Among them, $a=1$ represents Insert operation, $a=2$ represents Reverse operation, $a=3$ represents Delete operation.\n\n- If $a = 1$, then the modification operation is the Insert operation. It will be guaranteed that $1 \\leq b \\leq n$. $r$ will be calculated as $r=(b+\\text{ans}_{i-1}-1) \\bmod n + 1$.\n- If $a=2$, then the modification operation is the Reverse operation. It will be guaranteed that $1 \\leq b \\leq n$. $r$ will be calculated as $r=(b+\\text{ans}_{i-1}-1) \\bmod n + 1$.\n- If $a=3$, then the modification operation is the Delete operation. It will be guaranteed that $1 \\leq b \\leq q$. $x$ will be calculated as $x=(b+\\text{ans}_{i-1}-1) \\bmod q + 1$.\n\nFor the query operation, $p$ will be calculated as $p = (c+\\text{ans}_{i-1}-1) \\bmod n + 1$.\n\nHere $ \\text{ans}_{i} (1 \\leq i \\leq q)$ represents the answer to the query operation in the $i$-th operation. Additionally, we define $ \\text{ans}_{0} = 0$.\n\n### Output\n\nFor each query operation, output the answer to the query.\n\n### Example\n\n#### Input #1\n\n```\n\n5 10\n\n1 2 2\n\n2 3 1\n\n1 5 3\n\n2 2 5\n\n1 5 2\n\n2 4 4\n\n3 2 2\n\n3 1 2\n\n3 10 5\n\n3 2 4\n\n```\n\n#### Output #1\n\n```\n1\n0\n1\n1\n3\n1\n0\n5\n0\n0\n```\n\n### Note\n\nAll the sets are empty in the beginning, so the array is $[\\{\\}, \\{\\}, \\{\\}, \\{\\}, \\{\\}]$.\n\nWith the decoding method given before, we can see what happens in each operation:\n\n01. For the first operation: $a = 1, r = 2, p = 2$. The modification operation is an Insert operation; element $1$ is inserted into the first two sets; so the array becomes $[\\{1\\}, \\{1\\}, \\{\\}, \\{\\}, \\{\\}]$, and the smallest element in the second set is $1$.\n02. For the second operation: $a = 2, r = 4, p = 2$. The modification operation is a Reverse operation; the first four sets are reversed; so the array becomes $[\\{\\}, \\{\\}, \\{1\\}, \\{1\\}, \\{\\}]$, and the second set is empty, which means the answer is $0$.\n03. For the third operation: $a = 1, r = 5, p = 3$. The modification operation is an Insert operation; element $3$ is inserted into all the sets; so the array becomes $[\\{3\\}, \\{3\\}, \\{1, 3\\}, \\{1, 3\\}, \\{3\\}]$, and the smallest element in the third set is $1$.\n04. For the fourth operation: $a = 2, r = 3, p = 1$. The modification operation is a Reverse operation; the first three sets are reversed; so the array becomes $[\\{1, 3\\}, \\{3\\}, \\{3\\}, \\{1, 3\\}, \\{3\\}]$, and the smallest element in the first set is $1$.\n05. For the fifth operation: $a = 1, r = 1, p = 3$. The modification operation is an Insert operation; element $5$ is inserted into the first set; so the array becomes $[\\{1, 3, 5\\}, \\{3\\}, \\{3\\}, \\{1, 3\\}, \\{3\\}]$, and the smallest element in the third set is $3$.\n06. For the sixth operation: $a = 2, r = 2, p = 2$. The modification operation is a Reverse operation; the first two sets are reversed; so the array becomes $[\\{3\\}, \\{1, 3, 5\\}, \\{3\\}, \\{1, 3\\}, \\{3\\}]$, and the smallest element in the second set is $1$.\n07. For the seventh operation: $a = 3, x = 3, p = 3$. The modification operation is a Delete operation; element $3$ is deleted from all the sets; so the array becomes $[\\{\\}, \\{1, 5\\}, \\{\\}, \\{1\\}, \\{\\}]$, and the third set is empty, which means the answer is $0$.\n08. For the eighth operation: $a = 3, x = 1, p = 2$. The modification operation is a Delete operation; element $1$ is deleted from all the sets; so the array becomes $[\\{\\}, \\{5\\}, \\{\\}, \\{\\}, \\{\\}]$, and the smallest element in the second set is $5$.\n09. For the ninth operation: $a = 3, x = 5, p = 5$. The modification operation is a Delete operation; element $5$ is deleted from all the sets; so the array becomes $[\\{\\}, \\{\\}, \\{\\}, \\{\\}, \\{\\}]$, and the fifth set is empty, which means the answer is $0$.\n10. For the tenth operation: $a = 3, x = 2, p = 4$. The modification operation is a Delete operation; element $2$ is deleted from all the sets; so the array becomes $[\\{\\}, \\{\\}, \\{\\}, \\{\\}, \\{\\}]$, and the fourth set is empty, which means the answer is $0$.\n\nPlease note that although we have not inserted element $2$ into the sets, we still delete element $2$ from all the sets in the tenth operation, which means that the Delete operation doesn't necessarily require the existence of a set to contain the deleted element. It also shows that it is possible to have two Delete operations that delete the same element.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nconstexpr int N = 3e5 + 10, S = 1.1e7, SS = 2 * S;\nint n, q;\nint next[SS], val[SS], cnt;\nstruct queue {\n\tint head, tail;\n\tvoid push(int x) {\n\t\tif(head) {\n\t\t\tnext[tail] = ++ cnt, val[cnt] = x; tail = cnt;\n\t\t} else {\n\t\t\thead = tail = ++ cnt, val[cnt] = x;\n\t\t}\n\t\tassert(cnt < SS - 100);\n\t}\n\tvoid pop() {head = next[head];}\n\tint front() {return val[head];}\n\tbool check() {return head == tail;}\n\tbool empty() {return head == 0;}\n\tvoid clear() {head = tail = 0;}\n};\nstruct node {\n\tint ls, rs;\n\tqueue fa;\n\tint val, exit;\n\tint size, rev;\n}a[S];\nint tot;\nint id[N];\nvoid pushup(int u) {\n\ta[u].size = a[a[u].ls].size + a[a[u].rs].size;\n}\nvoid setR(int u) {\n\ta[u].rev ^= 1;\n\tstd::swap(a[u].ls, a[u].rs);\n}\nvoid setT(int u, int v) {\n\ta[u].fa.push(v);\n}\nvoid pushdown(int u) {\n\tif(a[u].rev) {\n\t\tsetR(a[u].ls);\n\t\tsetR(a[u].rs);\n\t\ta[u].rev = 0;\n\t}\n}\nint newnode() {\n\tint u = ++ tot;\n\ta[u].exit = 2;\n\treturn u;\n}\nint newleaf() {\n\tint u = newnode();\n\ta[u].size = 1;\n\treturn u;\n}\nint join(int x, int y) {\n\tint u = newnode();\n\ta[u].ls = x, a[u].rs = y;\n\ta[x].fa.push(u);\n\ta[y].fa.push(u);\n\tpushup(u);\n\treturn u;\n}\nauto cut(int x) {\n\tpushdown(x);\n\ta[x].exit = 1;\n\treturn std::make_pair(a[x].ls, a[x].rs);\n}\nint get_val(int u) {\n\tif(a[u].exit == 0) return 0;\n\tif(a[u].val != 0) return a[u].val;\n\tif(a[u].fa.empty()) return 0;\n\tint ans = 0;\n\twhile(1) {\n\t\tans = get_val(a[u].fa.front());\n\t\tif(ans) return ans;\n\t\tif(a[u].fa.check()) break;\n\t\ta[u].fa.pop();\n\t}\n\tif(a[u].exit == 1) {\n\t\ta[u].exit = 0;\n\t\ta[u].fa.pop();\n\t\ta[u].fa.clear();\n\t}\n\treturn 0;\n}\nint newtag(int x) {\n\tint u = ++ tot;\n\ta[u].val = x;\n\ta[u].exit = 1;\n\treturn u;\n}\nconstexpr double ALPHA = 0.292;\nbool too_heavy(int sx, int sy) {\n\treturn sy < ALPHA * (sx + sy);\n}\nint merge(int x, int y) {\n\tif(!x || !y) return x + y;\n\tif(too_heavy(a[x].size, a[y].size)) {\n\t\tauto [u, v] = cut(x);\n    \tif(too_heavy(a[v].size + a[y].size, a[u].size)) {\n    \t\tauto [z, w] = cut(v);\n    \t\treturn merge(merge(u, z), merge(w, y));\n   \t\t} else {\n    \t\treturn merge(u, merge(v, y));\n    \t}\n  \t} else if(too_heavy(a[y].size, a[x].size)) {\n\t\tauto [u, v] = cut(y);\n\t\tif(too_heavy(a[u].size + a[x].size, a[v].size)) {\n\t\t\tauto [z, w] = cut(u);\n\t\t\treturn merge(merge(x, z), merge(w, v));\n\t\t} else {\n\t\t\treturn merge(merge(x, u), v);\n\t\t}\n\t} else {\n\t\treturn join(x, y);\n\t}\n}\nstd::pair<int, int> split(int x, int k) {\n\tif(!x) return {0, 0};\n\tif(!k) return {0, x};\n\tif(k == a[x].size) return {x, 0};\n\tauto [u, v] = cut(x);\n\tif(k <= a[u].size) {\n\t\tauto [w, z] = split(u, k);\n\t\treturn {w, merge(z, v)};\n\t} else {\n\t\tauto [w, z] = split(v, k - a[u].size);\n\t\treturn {merge(u, w), z};\n\t}\n}\nint find(int u, int k) {\n\tif(a[u].size == 1) return u;\n\tpushdown(u);\n\tif(k <= a[a[u].ls].size) return find(a[u].ls, k);\n\telse return find(a[u].rs, k - a[a[u].ls].size);\n}\nint build(int n) {\n\tif(n == 1) return newleaf();\n\tint x = build(n / 2);\n\tint y = build(n - n / 2);\n\treturn join(x, y);\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> q;\n\tint rt = build(n);\n\tint lastans = 0;\n\tfor(int i = 1; i <= q; i ++) {\n\t\tint o;\n\t\tstd::cin >> o;\n\t\tif(o == 1) {\n\t\t\tint p;\n\t\t\tstd::cin >> p;\n\t\t\tp = (p + lastans - 1) % n + 1;\n\t\t\tauto [A, B] = split(rt, p);\n\t\t\tsetT(A, id[i] = newtag(i));\n\t\t\trt = merge(A, B);\n\t\t} else if(o == 2) {\n\t\t\tint p;\n\t\t\tstd::cin >> p;\n\t\t\tp = (p + lastans - 1) % n + 1;\n\t\t\tauto [A, B] = split(rt, p);\n\t\t\tsetR(A);\n\t\t\trt = merge(A, B);\n\t\t} else if(o == 3) {\n\t\t\tint x;\n\t\t\tstd::cin >> x;\n\t\t\tx = (x + lastans - 1) % q + 1;\n\t\t\ta[id[x]].exit = 0;\n\t\t} \n\t\tint p;\n\t\tstd::cin >> p;\n\t\tp = (p + lastans - 1) % n + 1;\n\t\tint u = find(rt, p);\n\t\tstd::cout << (lastans = get_val(u)) << '\\n';\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2115f1",
      "PROBLEM_ID": "2115F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, the time limit and the constraints on $n$ and $q$ are lower. You can hack only if you solved all versions of this problem.\n\nGellyfish has an array consisting of $n$ sets. Initially, all the sets are empty.\n\nNow Gellyfish will do $q$ operations. Each operation contains one modification operation and one query operation, for the $i$-th ($1 \\leq i \\leq q$) operation:\n\nFirst, there will be a modification operation, which is one of the following:\n\n1. Insert operation: You are given an integer $r$. For the $1$-th to $r$-th sets, insert element $i$. Note that the element inserted here is $i$, the index of the operation, not the index of the set.\n2. Reverse operation: You are given an integer $r$. Reverse the $1$-th to $r$-th sets.\n3. Delete operation: You are given an integer $x$. Delete element $x$ from all sets that contain $x$.\n\nFollowed by a query operation:\n\n- Query operation: You are given an integer $p$. Output the smallest element in the $p$-th set (If the $p$-th set is empty, the answer is considered to be $0$).\n\nNow, Flower needs to provide the answer for each query operation. Please help her!\n\nAdditional constraint on the problem: Gellyfish will only give the next operation after Flower has answered the previous query operation. That is, you need to solve this problem online. Please refer to the input format for more details.\n\n### Input\n\nThe first line contains two integers $n$ and $q$ ($1 \\leq n, q \\leq 10^5$)\u00a0\u2014 the number of the sets and the number of operations.\n\nAs you need to respond to the operations online, the operations will be encoded.\n\nThe $i$-th line of the following $q$ lines contains three integers $a$, $b$, and $c$ ($1 \\leq a \\leq 3$, $1 \\leq c \\leq n$)\u00a0\u2014 describing the $i$-th operation in an encoded form.\n\nHere, $a$ represents the type of modification operation. Among them, $a=1$ represents Insert operation, $a=2$ represents Reverse operation, $a=3$ represents Delete operation.\n\n- If $a = 1$, then the modification operation is the Insert operation. It will be guaranteed that $1 \\leq b \\leq n$. $r$ will be calculated as $r=(b+\\text{ans}_{i-1}-1) \\bmod n + 1$.\n- If $a=2$, then the modification operation is the Reverse operation. It will be guaranteed that $1 \\leq b \\leq n$. $r$ will be calculated as $r=(b+\\text{ans}_{i-1}-1) \\bmod n + 1$.\n- If $a=3$, then the modification operation is the Delete operation. It will be guaranteed that $1 \\leq b \\leq q$. $x$ will be calculated as $x=(b+\\text{ans}_{i-1}-1) \\bmod q + 1$.\n\nFor the query operation, $p$ will be calculated as $p = (c+\\text{ans}_{i-1}-1) \\bmod n + 1$.\n\nHere $ \\text{ans}_{i} (1 \\leq i \\leq q)$ represents the answer to the query operation in the $i$-th operation. Additionally, we define $ \\text{ans}_{0} = 0$.\n\n### Output\n\nFor each query operation, output the answer to the query.\n\n### Example\n\n#### Input #1\n\n```\n\n5 10\n\n1 2 2\n\n2 3 1\n\n1 5 3\n\n2 2 5\n\n1 5 2\n\n2 4 4\n\n3 2 2\n\n3 1 2\n\n3 10 5\n\n3 2 4\n\n```\n\n#### Output #1\n\n```\n1\n0\n1\n1\n3\n1\n0\n5\n0\n0\n```\n\n### Note\n\nAll the sets are empty in the beginning, so the array is $[\\{\\}, \\{\\}, \\{\\}, \\{\\}, \\{\\}]$.\n\nWith the decoding method given before, we can see what happens in each operation:\n\n01. For the first operation: $a = 1, r = 2, p = 2$. The modification operation is an Insert operation; element $1$ is inserted into the first two sets; so the array becomes $[\\{1\\}, \\{1\\}, \\{\\}, \\{\\}, \\{\\}]$, and the smallest element in the second set is $1$.\n02. For the second operation: $a = 2, r = 4, p = 2$. The modification operation is a Reverse operation; the first four sets are reversed; so the array becomes $[\\{\\}, \\{\\}, \\{1\\}, \\{1\\}, \\{\\}]$, and the second set is empty, which means the answer is $0$.\n03. For the third operation: $a = 1, r = 5, p = 3$. The modification operation is an Insert operation; element $3$ is inserted into all the sets; so the array becomes $[\\{3\\}, \\{3\\}, \\{1, 3\\}, \\{1, 3\\}, \\{3\\}]$, and the smallest element in the third set is $1$.\n04. For the fourth operation: $a = 2, r = 3, p = 1$. The modification operation is a Reverse operation; the first three sets are reversed; so the array becomes $[\\{1, 3\\}, \\{3\\}, \\{3\\}, \\{1, 3\\}, \\{3\\}]$, and the smallest element in the first set is $1$.\n05. For the fifth operation: $a = 1, r = 1, p = 3$. The modification operation is an Insert operation; element $5$ is inserted into the first set; so the array becomes $[\\{1, 3, 5\\}, \\{3\\}, \\{3\\}, \\{1, 3\\}, \\{3\\}]$, and the smallest element in the third set is $3$.\n06. For the sixth operation: $a = 2, r = 2, p = 2$. The modification operation is a Reverse operation; the first two sets are reversed; so the array becomes $[\\{3\\}, \\{1, 3, 5\\}, \\{3\\}, \\{1, 3\\}, \\{3\\}]$, and the smallest element in the second set is $1$.\n07. For the seventh operation: $a = 3, x = 3, p = 3$. The modification operation is a Delete operation; element $3$ is deleted from all the sets; so the array becomes $[\\{\\}, \\{1, 5\\}, \\{\\}, \\{1\\}, \\{\\}]$, and the third set is empty, which means the answer is $0$.\n08. For the eighth operation: $a = 3, x = 1, p = 2$. The modification operation is a Delete operation; element $1$ is deleted from all the sets; so the array becomes $[\\{\\}, \\{5\\}, \\{\\}, \\{\\}, \\{\\}]$, and the smallest element in the second set is $5$.\n09. For the ninth operation: $a = 3, x = 5, p = 5$. The modification operation is a Delete operation; element $5$ is deleted from all the sets; so the array becomes $[\\{\\}, \\{\\}, \\{\\}, \\{\\}, \\{\\}]$, and the fifth set is empty, which means the answer is $0$.\n10. For the tenth operation: $a = 3, x = 2, p = 4$. The modification operation is a Delete operation; element $2$ is deleted from all the sets; so the array becomes $[\\{\\}, \\{\\}, \\{\\}, \\{\\}, \\{\\}]$, and the fourth set is empty, which means the answer is $0$.\n\nPlease note that although we have not inserted element $2$ into the sets, we still delete element $2$ from all the sets in the tenth operation, which means that the Delete operation doesn't necessarily require the existence of a set to contain the deleted element. It also shows that it is possible to have two Delete operations that delete the same element.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#pragma GCC optimize(2)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n#pragma GCC diagnostic error \"-fwhole-program\"\n#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n// MagicDark\n#include <bits/stdc++.h>\n#define debug cerr << \"\\33[32m[\" << __LINE__ << \"]\\33[m \"\n#define SZ(x) ((int) x.size() - 1)\n#define all(x) x.begin(), x.end()\n#define ms(x, y) memset(x, y, sizeof x)\n#define F(i, x, y) for (int i = (x); i <= (y); i++)\n#define DF(i, x, y) for (int i = (x); i >= (y); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> T& chkmax(T& x, T y) {return x = max(x, y);}\ntemplate <typename T> T& chkmin(T& x, T y) {return x = min(x, y);}\n// template <typename T> T& read(T &x) {\n// \tx = 0; int f = 1; char c = getchar();\n// \tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n// \tfor (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n// \treturn x *= f;\n// }\n// bool be;\nconst int N = 1e5 + 1010, B = 500, B1 = N / B + 5, B2 = B + 5;\nint n, q, ans, p[N], wp[N], tot, t[N], tl[N], tr[N];\nbool rev[N];\nbool ed[N];\n// bool vv[N];\n// struct Q1 {\n// \tint tl = 1, tr;\n// \tint a[B2];\n// \tbool chk() {\n// \t\treturn tl <= tr;\n// \t}\n// \tint front() {\n// \t\treturn a[tl];\n// \t}\n// \tvoid pop() {\n// \t\ttl++;\n// \t}\n// \tvoid push(int x) {\n// \t\ta[++tr] = x;\n// \t}\n// } tq[N];\n// struct Q2 {\n// \tint tl = 1, tr;\n// \tint a[B1];\n// \tbool chk() {\n// \t\treturn tl <= tr;\n// \t}\n// \tint front() {\n// \t\treturn a[tl];\n// \t}\n// \tvoid pop() {\n// \t\ttl++;\n// \t}\n// \tvoid push(int x) {\n// \t\ta[++tr] = x;\n// \t}\n// } vq[N];\nqueue <int> tq[N], vq[N];\nvector <int> cur;\nint qq(int x) {\n\twhile (tq[x].size()) {\n\t\tif (!ed[tq[x].front()]) return tq[x].front();\n\t\ttq[x].pop();\n\t}\n\treturn 0;\n}\nint query(int x) {\n\tint s = 0;\n\tfor (int i: cur) {\n\t\ts += tr[i] - tl[i] + 1;\n\t\tif (s >= x) {\n\t\t\tint g = s - x + 1;\n\t\t\tint y;\n\t\t\tif (rev[i]) {\n\t\t\t\ty = p[tl[i] + g - 1];\n\t\t\t} else {\n\t\t\t\ty = p[tr[i] - g + 1];\n\t\t\t}\n\t\t\twhile (vq[y].size()) {\n\t\t\t\tint tmp = qq(vq[y].front());\n\t\t\t\tif (tmp) return tmp;\n\t\t\t\tvq[y].pop();\n\t\t\t}\n\t\t\t// int tmp = qq(i);\n\t\t\t// if (~tmp) return tmp;\n\t\t\treturn qq(i);\n\t\t}\n\t}\n\tassert(false);\n\t// return -1;\n}\n// bool ee;\n// int cnt = 0;\nsigned main() {\n\tios::sync_with_stdio(0); // don't use puts\n\tcin.tie(0), cout.tie(0);\n\t// debug << abs(&ee - &be) / 1024 / 1024 << endl;\n\tcin >> n >> q;\n\tF(i, 1, n) p[i] = i;\n\tcur.push_back(++tot);\n\ttl[1] = 1, tr[1] = n;\n\tF(i, 1, q) {\n\t\tint f, x, y; cin >> f >> x >> y;\n\t\tif (f == 3) {\n\t\t\tx = (x + ans - 1) % q + 1;\n\t\t} else {\n\t\t\tx = (x + ans - 1) % n + 1;\n\t\t}\n\t\ty = (y + ans - 1) % n + 1;\n\t\t// auto split = [&] (int x) {\n\t\t// \tif (x > n || vv[x]) return;\n\t\t// \t// vv[x] = true;\n\t\t// \tfor (auto [])\n\t\t// };\n\t\tif (f == 1) {\n\t\t\tint s = 0;\n\t\t\tfor (int j: cur) {\n\t\t\t\tint w = tr[j] - tl[j] + 1;\n\t\t\t\ts += w;\n\t\t\t\tif (s >= x) {\n\t\t\t\t\tif (s > x) {\n\t\t\t\t\t\ttot++;\n\t\t\t\t\t\ttq[tot] = tq[j];\n\t\t\t\t\t\tint g = s - x;\n\t\t\t\t\t\tif (rev[tot] = rev[j]) {\n\t\t\t\t\t\t\ttl[tot] = tl[j];\n\t\t\t\t\t\t\ttr[tot] = (tl[j] += g) - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttr[tot] = tr[j];\n\t\t\t\t\t\t\ttl[tot] = (tr[j] -= g) + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.insert(next(find(all(cur), j)), tot);\n\t\t\t\t\t}\n\t\t\t\t\ttq[j].push(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttq[j].push(i);\n\t\t\t}\n\t\t}\n\t\tif (f == 2) {\n\t\t\tint s = 0, sz = 0;\n\t\t\tfor (int j: cur) {\n\t\t\t\tsz++;\n\t\t\t\tint w = tr[j] - tl[j] + 1;\n\t\t\t\ts += w;\n\t\t\t\tif (s >= x) {\n\t\t\t\t\tif (s > x) {\n\t\t\t\t\t\ttot++;\n\t\t\t\t\t\ttq[tot] = tq[j];\n\t\t\t\t\t\tint g = s - x;\n\t\t\t\t\t\tif (rev[tot] = rev[j]) {\n\t\t\t\t\t\t\ttl[tot] = tl[j];\n\t\t\t\t\t\t\ttr[tot] = (tl[j] += g) - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttr[tot] = tr[j];\n\t\t\t\t\t\t\ttl[tot] = (tr[j] -= g) + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.insert(next(find(all(cur), j)), tot);\n\t\t\t\t\t}\n\t\t\t\t\treverse(cur.begin(), cur.begin() + sz);\n\t\t\t\t\tF(j, 0, sz - 1) rev[cur[j]] ^= true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f == 3) {\n\t\t\tif (x < i) ed[x] = true;\n\t\t}\n\t\tcout << (ans = query(y)) << '\\n';\n\t\tif (cur.size() >= B) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int j: cur) {\n\t\t\t\tif (rev[j]) {\n\t\t\t\t\tDF(k, tr[j], tl[j]) {\n\t\t\t\t\t\tvq[wp[++cnt] = p[k]].push(j);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tF(k, tl[j], tr[j]) {\n\t\t\t\t\t\tvq[wp[++cnt] = p[k]].push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tF(j, 1, n) {\n\t\t\t\tp[j] = wp[j];\n\t\t\t}\n\t\t\tcur.clear();\n\t\t\tcur.push_back(++tot);\n\t\t\ttl[tot] = 1, tr[tot] = n;\n\t\t}\n\t\t// for (int j: cur) {\n\t\t// \tdebug << tl[j] << \" \" << tr[j] << \" \" << rev[j] << endl;\n\t\t// }\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2115e",
      "PROBLEM_ID": "2115E",
      "PROBLEM_STATEMENT": "[Mayflower by Plum](https://www.youtube.com/watch?v=wD6_6R7dhnE/)\n\nMay, Gellyfish's friend, loves playing a game called \"Inscryption\" which is played on a directed acyclic graph with $n$ vertices and $m$ edges. All edges $ a \\rightarrow b$ satisfy $a<b$.\n\nYou start in vertex $1$ with some coins. You need to move from vertex $1$ to the vertex where the boss is located along the directed edges, and then fight with the final boss.\n\nEach of the $n$ vertices of the graph contains a Trader who will sell you a card with power $w_i$ for $c_i$ coins. You can buy as many cards as you want from each Trader. However, you can only trade with the trader on the $i$-th vertex if you are currently on the $i$-th vertex.\n\nIn order to defeat the boss, you want the sum of the power of your cards to be as large as possible.\n\nYou will have to answer the following $q$ queries:\n\n- Given integers $p$ and $r$. If the final boss is located at vertex $p$, and you have $r$ coins in the beginning, what is the maximum sum of the power of your cards when you fight the final boss? Note that you are allowed to trade cards on vertex $p$.\n\n### Input\n\nThe first line of input contains two integers $n$ and $m$ ($1 \\leq n \\leq 200$, $n - 1 \\leq m \\leq \\min(\\frac {n(n-1)} 2, 2000)$)\u00a0\u2014 the number of vertices and the number of edges.\n\nThe $i$-th of the following $n$ lines of input each contains two integers $c_i$ and $w_i$ ($1 \\leq c_i \\leq 200$, $1 \\leq w_i \\leq 10^9$)\u00a0\u2014 describing the cards of the Trader on the $i$-th vertex.\n\nIn the following $m$ lines of input, each line contains two integers $u$ and $v$ ($1 \\leq u < v \\leq n$), indicating a directed edge from vertex $u$ to vertex $v$. It is guaranteed that every edge $(u,v)$ appears at most once.\n\nThe next line of input contains one single integer $q$ ($1 \\leq q \\leq 2 \\cdot 10^5$)\u00a0\u2014 the number of queries.\n\nIn the following $q$ lines of input, each line contains two integers $p$ and $r$ ($1 \\leq p \\leq n$, $1 \\leq r \\leq 10^9$).\n\nIt is guaranteed that for all $i$, there exists a path from vertex $1$ to vertex $i$.\n\n### Output\n\nFor each query, output the answer to the query.\n\n### Examples\n\n#### Input #1\n\n```\n\n3 2\n\n3 9\n\n2 5\n\n1 2\n\n1 2\n\n2 3\n\n6\n\n1 4\n\n2 4\n\n3 4\n\n1 5\n\n2 5\n\n3 5\n\n```\n\n#### Output #1\n\n```\n9\n10\n11\n9\n14\n14\n```\n\n#### Input #2\n\n```\n\n4 4\n\n10 1000\n\n2 5\n\n1 2\n\n3 9\n\n1 2\n\n1 3\n\n2 4\n\n3 4\n\n9\n\n2 3\n\n3 3\n\n4 1\n\n4 2\n\n4 4\n\n4 5\n\n4 101\n\n4 102\n\n4 103\n\n```\n\n#### Output #2\n\n```\n5\n6\n2\n5\n11\n14\n10002\n10005\n10009\n```\n\n#### Input #3\n\n```\n\n6 8\n\n9 5\n\n4 1\n\n8 9\n\n10 4\n\n9 4\n\n8 2\n\n3 5\n\n4 6\n\n3 4\n\n2 3\n\n1 2\n\n2 5\n\n4 5\n\n1 3\n\n10\n\n3 12\n\n1 9\n\n6 47\n\n2 19\n\n1 129\n\n5 140\n\n2 148\n\n1 63\n\n2 43\n\n3 102\n\n```\n\n#### Output #3\n\n```\n10\n5\n46\n10\n70\n154\n81\n35\n21\n109\n```\n\n### Note\n\nFor the third query in the first example, we will play the game in the following order:\n\n- buy $1$ card with $9$ power from the trader on vertex $1$, and you'll still have $1$ coin after the trade.\n- move from vertex $1$ to vertex $2$.\n- move from vertex $2$ to vertex $3$.\n- buy $1$ card with $2$ power from the trader on vertex $3$, and you'll have no coins after the trade.\n\nIn the end, we will have $1$ card with $9$ power and $1$ card with $2$, so the sum of the power of the cards is $9+2=11$.\n\nFor the fifth query in the second example, we will play the game in the following order:\n\n- move from vertex $1$ to vertex $3$.\n- buy $1$ card with $2$ power from the trader on vertex $3$, and you'll still have $3$ coins after the trade.\n- move from vertex $3$ to vertex $4$.\n- buy $1$ card with $9$ power from the trader on vertex $4$, and you'll have no coins after the trade.\n\nIn the end, we will have $1$ card with $2$ power and $1$ card with $9$, so the sum of the power of the cards is $2+9=11$.\n\nFor the sixth query in the second example, we will play the game in the following order:\n\n- move from vertex $1$ to vertex $2$.\n- buy $1$ card with $5$ power from the trader on vertex $2$, and you'll still have $3$ coins after the trade.\n- move from vertex $2$ to vertex $4$.\n- buy $1$ card with $9$ power from the trader on vertex $4$, and you'll have no coins after the trade.\n\nIn the end, we will have $1$ card with $5$ power and $1$ card with $9$, so the sum of the power of the cards is $5+9=14$.\n\nFor the seventh query in the second example, we will play the game in the following order:\n\n- buy $10$ cards with $1000$ power from the trader on vertex $1$, and you'll still have $1$ coin after the trade.\n- move from vertex $1$ to vertex $3$.\n- buy $1$ card with $2$ power from the trader on vertex $3$, and you'll have no coins after the trade.\n- move from vertex $3$ to vertex $4$.\n\nIn the end, we will have $10$ cards with $1000$ power and $1$ card with $2$ power, so the sum of the power of the cards is $10 \\cdot 1000+2=10\\,002$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int N_MAX = 201;\nconst int C_MAX = 200;\nconst int B_MAX = 40000;\nconst int DP_TABLE_SIZE = B_MAX + C_MAX;\n\nstruct Trader {\n    int c;\n    long long w;\n};\n\nstruct PathInfo {\n    int best_trader_id;\n    vector<long long> dp_table;\n};\n\nTrader traders[N_MAX];\nvector<int> rev_adj[N_MAX];\nvector<PathInfo> F[N_MAX];\n\nbool compare_traders(int id1, int id2) {\n    if (id1 == 0) return false;\n    if (id2 == 0) return true;\n    return (long long)traders[id1].w * traders[id2].c > (long long)traders[id2].w * traders[id1].c;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> traders[i].c >> traders[i].w;\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        rev_adj[v].push_back(u);\n    }\n\n    // Base case: vertex 1\n    {\n        PathInfo pi;\n        pi.best_trader_id = 1;\n        pi.dp_table.assign(DP_TABLE_SIZE, 0);\n        \n        for (int b = traders[1].c; b < DP_TABLE_SIZE; ++b) {\n            pi.dp_table[b] = max(pi.dp_table[b], pi.dp_table[b - traders[1].c] + traders[1].w);\n        }\n        for (int b = 1; b < DP_TABLE_SIZE; ++b) {\n            pi.dp_table[b] = max(pi.dp_table[b], pi.dp_table[b-1]);\n        }\n        F[1].push_back(pi);\n    }\n    \n    for (int v = 2; v <= n; ++v) {\n        map<int, vector<long long>> candidates;\n        \n        for (int u : rev_adj[v]) {\n            for (const auto& path_info : F[u]) {\n                int current_best_id = path_info.best_trader_id;\n                int new_best_id = current_best_id;\n                if (compare_traders(v, current_best_id)) {\n                    new_best_id = v;\n                }\n\n                vector<long long> new_dp_table = path_info.dp_table;\n                \n                for (int b = traders[v].c; b < DP_TABLE_SIZE; ++b) {\n                    new_dp_table[b] = max(new_dp_table[b], new_dp_table[b - traders[v].c] + traders[v].w);\n                }\n                for (int b = 1; b < DP_TABLE_SIZE; ++b) {\n                    new_dp_table[b] = max(new_dp_table[b], new_dp_table[b-1]);\n                }\n\n                if (candidates.find(new_best_id) == candidates.end()) {\n                    candidates[new_best_id] = new_dp_table;\n                } else {\n                    for (int b = 0; b < DP_TABLE_SIZE; ++b) {\n                        candidates[new_best_id][b] = max(candidates[new_best_id][b], new_dp_table[b]);\n                    }\n                }\n            }\n        }\n        \n        vector<pair<int, vector<long long>>> sorted_cands;\n        for (auto const& [id, table] : candidates) {\n            sorted_cands.push_back({id, table});\n        }\n        sort(sorted_cands.begin(), sorted_cands.end(), [](const auto& a, const auto& b) {\n            return compare_traders(a.first, b.first);\n        });\n\n        vector<long long> max_t(DP_TABLE_SIZE, 0);\n        for (const auto& cand : sorted_cands) {\n            bool dominated = true;\n            for (int b = 0; b < DP_TABLE_SIZE; ++b) {\n                if (cand.second[b] > max_t[b]) {\n                    dominated = false;\n                    break;\n                }\n            }\n            if (!dominated) {\n                F[v].push_back({cand.first, cand.second});\n                for (int b = 0; b < DP_TABLE_SIZE; ++b) {\n                    max_t[b] = max(max_t[b], cand.second[b]);\n                }\n            }\n        }\n    }\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int p;\n        long long r;\n        cin >> p >> r;\n\n        long long max_power = 0;\n        \n        for (const auto& path_info : F[p]) {\n            long long current_power = 0;\n            if (r < DP_TABLE_SIZE) {\n                current_power = path_info.dp_table[r];\n            } else {\n                int best_id = path_info.best_trader_id;\n                long long c_best = traders[best_id].c;\n                long long w_best = traders[best_id].w;\n                \n                long long b_dp = B_MAX + (r - B_MAX) % c_best;\n                long long num_best = (r - b_dp) / c_best;\n                current_power = num_best * w_best + path_info.dp_table[b_dp];\n            }\n            if (current_power > max_power) {\n                max_power = current_power;\n            }\n        }\n        \n        cout << max_power << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2115d",
      "PROBLEM_ID": "2115D",
      "PROBLEM_STATEMENT": "Gellyfish and Flower are playing a game.\n\nThe game consists of two arrays of $n$ integers $a_1,a_2,\\ldots,a_n$ and $b_1,b_2,\\ldots,b_n$, along with a binary string $c_1c_2\\ldots c_n$ of length $n$.\n\nThere is also an integer $x$ which is initialized to $0$.\n\nThe game consists of $n$ rounds. For $i = 1,2,\\ldots,n$, the round proceeds as follows:\n\n1. If $c_i = \\mathtt{0}$, Gellyfish will be the active player. Otherwise, if $c_i = \\mathtt{1}$, Flower will be the active player.\n2. The active player will perform exactly one of the following operations:\n   - Set $x:=x \\oplus a_i$.\n   - Set $x:=x \\oplus b_i$.\n\nHere, $\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nGellyfish wants to minimize the final value of $ x $ after $ n $ rounds, while Flower wants to maximize it.\n\nFind the final value of $ x $ after all $ n $ rounds if both players play optimally.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 10^5$)\u00a0\u2014 the number of rounds of the game.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i < 2^{60}$).\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($0 \\leq b_i < 2^{60}$).\n\nThe fourth line of each test case contains a binary string $c$ of length $n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the final value of $ x $ after all $ n $ rounds.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n0\n\n2\n\n0\n\n2\n\n12 2\n\n13 3\n\n11\n\n3\n\n6 1 2\n\n6 2 3\n\n010\n\n4\n\n1 12 7 2\n\n4 14 4 2\n\n0111\n\n9\n\n0 5 10 6 6 2 6 2 11\n\n7 3 15 3 6 7 6 7 8\n\n110010010\n\n```\n\n#### Output #1\n\n```\n0\n15\n6\n11\n5\n```\n\n### Note\n\nIn the first test case, there's only one round and Gellyfish is the active player of that round. Therefore, she will choose $a_1$, and the final value of $x$ is $0$.\n\nIn the second test case, Flower will be the active player in both rounds. She will choose $a_1$ and $b_2$, and the final value of $x$ is $a_1 \\oplus b_2 = 15$. Flower may also choose $b_1$ and $a_2$ instead for the same result of $x=a_2 \\oplus b_1 = 15$.\n\nIn the third test case, $a_1 = b_1$ so it doesn't matter what decision Gellyfish makes in the first round. In the second round:\n\n- If Flower chooses $a_2$, then $x$ will become $7$. Gellyfish will choose $b_3$ in the third round, so the final value of $x$ will be $4$.\n- Otherwise, Flower chooses $b_2$, then $x$ will become $4$. Gellyfish will choose $a_3$ in the third round, so the final value of $x$ will be $6$.\n\nFlower wants to maximize the final value of $x$, so Flower will choose $b_2$ in the second round. Therefore, the final value of $x$ will be $6$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing i64 = long long;\nconstexpr int L = 60;\nint main() {\n\tstd::ios::sync_with_stdio(false), std::cin.tie(0);\n\tint T;\n\tfor(std::cin >> T; T; T --) {\n\t\tint n; \n\t\tstd::cin >> n;\n\t\tstd::vector<i64> a(n), b(n);\n\t\tstd::string str;\n\t\ti64 all = 0;\n\t\tfor(auto &x : a) std::cin >> x, all ^= x;\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\tstd::cin >> b[i];\n\t\t\tb[i] ^= a[i];\n\t\t}\n\t\tstd::cin >> str;\n\t\tstd::vector<i64> bas(L);\n\t\tstd::vector<int> bel(L, -1);\n\t\ti64 ans = 0;\n\t\tfor(int i = n - 1; i >= 0; i --) {\n\t\t\ti64 x = b[i], col = str[i] - '0';\n\t\t\tfor(int i = L - 1; i >= 0; i --) if(x >> i & 1) {\n\t\t\t\tif(bas[i]) {\n\t\t\t\t\tx ^= bas[i];\n\t\t\t\t} else {\n\t\t\t\t\tfor(int j = i - 1; j >= 0; j --) if(x >> j & 1) {\n\t\t\t\t\t\tx ^= bas[j];\n\t\t\t\t\t}\n\t\t\t\t\tbas[i] = x;\n\t\t\t\t\tfor(int j = L - 1; j > i; j --) if(bas[j] >> i & 1){\n\t\t\t\t\t\tbas[j] ^= bas[i];\n\t\t\t\t\t} \n\t\t\t\t\tbel[i] = col;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\n\t\tfor(int i = L - 1; i >= 0; i --) if(all >> i & 1) {\n\t\t\tall ^= bas[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i ++) if(bel[i] == 1) ans ^= bas[i];\n\t\tstd::cout << (all ^ ans) << '\\n';\n\t}\n\t\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2115c",
      "PROBLEM_ID": "2115C",
      "PROBLEM_STATEMENT": "There are $n$ monsters, numbered from $1$ to $n$, in front of Gellyfish. The HP of the $i$-th monster is $h_i$.\n\nGellyfish doesn't want to kill them, but she wants to keep these monsters from being a threat to her. So she wants to reduce the HP of all the monsters to exactly $1$.\n\nNow, Gellyfish, with The Sword Sharpened with Tears, is going to attack the monsters for $m$ rounds. For each round:\n\n1. The Sword Sharpened with Tears shines with a probability of $p$.\n2. Gellyfish can choose whether to attack:\n   - If Gellyfish doesn't attack, nothing happens.\n   - If Gellyfish chooses to attack and The Sword Sharpened with Tears shines, the HP of all the monsters will be reduced by $1$.\n   - If Gellyfish chooses to attack and The Sword Sharpened with Tears does not shine, Gellyfish can choose one of the monsters and reduce its HP by $1$.\n\nPlease note that before Gellyfish decides whether or not to attack, she will know whether the sword shines or not. Also, when the sword shines, Gellyfish can only make attacks on all the monsters and cannot make an attack on only one monster.\n\nNow, Gellyfish wants to know what the probability is that she will reach her goal if she makes choices optimally during the battle.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $p'$ ($1 \\leq n \\leq 20$, $1 \\leq m \\leq 4000$, $0 \\leq p' \\leq 100$)\u00a0\u2014 the number of monsters, the number of rounds of attacks, and an integer representing the probability $p = \\frac {p'} {100}$ that the Sword Sharpened with Tears shines.\n\nThe second line of each test case contains $n$ integers $h_1,h_2,\\ldots,h_n$ ($1 \\leq h_i \\leq 400$)\u00a0\u2014 the HP of the monsters.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $100$.\n\n### Output\n\nFor each test case, output a single real number representing the probability that Gellyfish will reach her goal.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.\n\nFormally, let your answer be $a$, and the jury's answer be $b$. Your answer is accepted if and only if $\\frac{|a - b|}{\\max{(1, |b|)}} \\le 10^{-6}$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 2 10\n\n2 2\n\n5 5 20\n\n2 2 2 2 2\n\n6 20 50\n\n1 1 4 5 1 4\n\n9 50 33\n\n9 9 8 2 4 4 3 5 3\n\n```\n\n#### Output #1\n\n```\n0.910000\n0.672320\n0.588099\n0.931474\n```\n\n### Note\n\nIn the first test case, Gellyfish will always attack whether the sword shines or not in the first round.\n\nIf the sword shines in the first round, then Gellyfish can reach her goal after the attack in the first round.\n\nOtherwise, if the sword does not shine in the first round, she will attack monster $1$ in the first round. For the second round:\n\n- If the sword shines, since monster $1$ was attacked in the first round, Gellyfish can't reach her goal.\n- Otherwise, Gellyfish can attack monster $2$, allowing her to reach her goal.\n\nTherefore, the probability that Gellyfish can reach her goal is $10\\% + (90\\% \\cdot 90\\%) = 91\\%$.\n\nIn the second test case, Gellyfish will only attack in the first round where the sword shines. It can be observed that the only way Gellyfish can't reach her goal is if the sword never shines in all $5$ rounds. The probability that Gellyfish can reach her goal is $100\\% - (80\\%)^5 = 67.232\\%$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 22, K = 4000 + 5, M = 400 + 5, Inf = 0x3f3f3f3f;\n\ninline void checkmin(double &x, double y){\n\tif(y < x) x = y;\n}\n\nint n = 0, m = 0, s = 0, k = 0, p0 = 0, h[N] = {};\ndouble p = 0, f[K][K] = {}, g[K][N][M] = {}, ans = 0;\n\ninline void init(){\n\tfor(int i = 0 ; i <= k ; i ++){\n\t\tfor(int c = 0 ; c < n ; c ++) for(int x = 0 ; x <= m ; x ++) g[i][c][x] = 0;\n\t\tfor(int x = 0 ; x <= s ; x ++) f[i][x] = 0;\n\t}\n\tm = Inf, s = 0, ans = 0;\n}\n\ninline void solve(){\n\tscanf(\"%d %d %d\", &n, &k, &p0);\n\tp = 1.0 * p0 / 100;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%d\", &h[i]); h[i] --;\n\t\tm = min(m, h[i]);\n\t}\n\tfor(int i = 1 ; i <= n ; i ++) s += h[i] - m;\n\tif(s > k){\n\t    printf(\"0.000000\\n\");\n\t    return;\n\t}\n\tg[0][0][0] = 1;\n\tfor(int i = 1 ; i <= k ; i ++){\n\t\tg[i][0][0] = 1;\n\t\tfor(int x = 1 ; x <= m ; x ++) g[i][0][x] = g[i - 1][0][x - 1] * p + max(g[i - 1][0][x], g[i - 1][n - 1][x - 1]) * (1 - p);\n\t\tfor(int c = 1 ; c < n ; c ++){\n\t\t\tg[i][c][0] = g[i - 1][c][0] * p + g[i - 1][c - 1][0] * (1 - p);\n\t\t\tfor(int x = 1 ; x <= m ; x ++) g[i][c][x] = g[i - 1][c][x - 1] * p + g[i - 1][c - 1][x] * (1 - p);\n\t\t}\n\t}\n\tf[0][0] = 1;\n\tfor(int i = 0 ; i < k ; i ++) for(int x = 0 ; x < s ; x ++){\n\t\tf[i + 1][x] += f[i][x] * p;\n\t\tf[i + 1][x + 1] += f[i][x] * (1 - p);\n\t}\n\tfor(int i = s ; i <= k ; i ++){\n\t\tdouble r = 0;\n\t\tfor(int x = 0 ; x <= min(i - s, m) ; x ++) r = max(r, g[k - i][0][m - x]);\n\t\tans += r * f[i][s];\n\t}\n\tprintf(\"%.6lf\\n\", ans);\n}\n\nint T = 0;\n\nint main(){\n\tscanf(\"%d\", &T);\n\twhile(T --) init(), solve();\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2115b",
      "PROBLEM_ID": "2115B",
      "PROBLEM_STATEMENT": "Gellyfish has an array of $n$ integers $c_1, c_2, \\ldots, c_n$. In the beginning, $c = [a_1, a_2, \\ldots, a_n]$.\n\nGellyfish will make $q$ modifications to $c$.\n\nFor $i = 1,2,\\ldots,q$, Gellyfish is given three integers $x_i$, $y_i$, and $z_i$ between $1$ and $n$. Then Gellyfish will set $c_{z_i} := \\min(c_{x_i}, c_{y_i})$.\n\nAfter the $q$ modifications, $c = [b_1, b_2, \\ldots, b_n]$.\n\nNow Flower knows the value of $b$ and the value of the integers $x_i$, $y_i$, and $z_i$ for all $1 \\leq i \\leq q$, but she doesn't know the value of $a$.\n\nFlower wants to find any possible value of the array $a$ or report that no such $a$ exists.\n\nIf there are multiple possible values of the array $a$, you may output any of them.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\leq n, q \\leq 3 \\cdot 10^5$)\u00a0\u2014 the size of the array and the number of modifications.\n\nThe second line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq 10^9$)\u00a0\u2014 the value of the array $c$ after the $q$ modifications.\n\nThe following $q$ lines each contain three integers $x_i$, $y_i$, and $z_i$ ($1 \\leq x_i, y_i, z_i \\leq n$)\u00a0\u2014 describing the $i$-th modification.\n\nIt is guaranteed that the sum of $n$ and the sum of $q$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, if $a$ exists, output $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 10^9$) in a single line. Otherwise, output \"-1\" in a single line.\n\nIf there are multiple solutions, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 1\n\n1 2\n\n2 1 2\n\n3 2\n\n1 2 3\n\n2 3 2\n\n1 2 1\n\n6 4\n\n1 2 2 3 4 5\n\n5 6 6\n\n4 5 5\n\n3 4 4\n\n2 3 3\n\n```\n\n#### Output #1\n\n```\n-1\n1 2 3\n1 2 3 4 5 5\n```\n\n### Note\n\nIn the first test case, based on the given sequence of modifications, we know that $b_1 = a_1$ and $b_2 = \\min(a_1, a_2)$. Therefore, it is necessary that $b_2 \\leq b_1$. However, for the given $b$, we have $b_1<b_2$. Therefore, there is no solution.\n\nIn the second test case, we can see that the given $c$ becomes $b$ from $a$ after the given modifications, and $c$ is not changed at each modification.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\nusing ll = long long;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    if(!(cin >> t)) return 0;\n    while(t--){\n        int n, q;\n        cin >> n >> q;\n        vector<int> b(n+1);\n        for(int i = 1; i <= n; i++){\n            cin >> b[i];\n        }\n        vector<int> x(q+1), y(q+1), z(q+1);\n        for(int i = 1; i <= q; i++){\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        // Build list of ops per destination z\n        vector<vector<int>> pos(n+1);\n        pos.assign(n+1, vector<int>());\n        for(int i = 1; i <= q; i++){\n            pos[z[i]].push_back(i);\n        }\n        // Build adjacency: for each op i, edges to prev state of x[i] and y[i]\n        vector<vector<int>> adj(q+1);\n        adj.assign(q+1, vector<int>());\n        for(int i = 1; i <= q; i++){\n            // prev op on x[i] before time i\n            int xi = x[i];\n            auto &vx = pos[xi];\n            int prev_x;\n            if(vx.empty()){\n                // no op on xi at all\n                prev_x = q + xi;\n            } else {\n                // find first element >= i\n                auto it = std::lower_bound(vx.begin(), vx.end(), i);\n                if(it == vx.begin()){\n                    // no earlier op\n                    prev_x = q + xi;\n                } else {\n                    --it;\n                    prev_x = *it;\n                }\n            }\n            // prev op on y[i] before time i\n            int yi = y[i];\n            auto &vy = pos[yi];\n            int prev_y;\n            if(vy.empty()){\n                prev_y = q + yi;\n            } else {\n                auto it = std::lower_bound(vy.begin(), vy.end(), i);\n                if(it == vy.begin()){\n                    prev_y = q + yi;\n                } else {\n                    --it;\n                    prev_y = *it;\n                }\n            }\n            // Add edges from op i to those prev states\n            adj[i].push_back(prev_x);\n            adj[i].push_back(prev_y);\n        }\n        // Determine last op time L_j for each j\n        vector<int> L(n+1, 0);\n        for(int j = 1; j <= n; j++){\n            if(!pos[j].empty()){\n                L[j] = pos[j].back();\n            } else {\n                L[j] = 0;\n            }\n        }\n        // dp array size q + n + 1, indices 0..q+n\n        int totalNodes = q + n;\n        vector<int> dp(totalNodes+1, 0);\n        // Seed dp values\n        for(int j = 1; j <= n; j++){\n            if(L[j] > 0){\n                dp[L[j]] = max(dp[L[j]], b[j]);\n            } else {\n                dp[q + j] = max(dp[q + j], b[j]);\n            }\n        }\n        // Propagate dp in topological order: ops from q downto 1\n        for(int i = q; i >= 1; i--){\n            int vdp = dp[i];\n            if(vdp == 0) continue;\n            for(int u : adj[i]){\n                if(dp[u] < vdp) dp[u] = vdp;\n            }\n        }\n        // Build initial array a\n        vector<int> a(n+1);\n        for(int j = 1; j <= n; j++){\n            a[j] = dp[q + j];\n        }\n        // Simulate the operations to get final c\n        vector<int> c(n+1);\n        for(int j = 1; j <= n; j++){\n            c[j] = a[j];\n        }\n        for(int i = 1; i <= q; i++){\n            int zi = z[i];\n            int xi = x[i], yi = y[i];\n            int val = c[xi] < c[yi] ? c[xi] : c[yi];\n            c[zi] = val;\n        }\n        // Check if c equals b\n        bool ok = true;\n        for(int j = 1; j <= n; j++){\n            if(c[j] != b[j]){\n                ok = false;\n                break;\n            }\n        }\n        if(!ok){\n            cout << \"-1\\n\";\n        } else {\n            // Output a[1..n]\n            for(int j = 1; j <= n; j++){\n                cout << a[j] << (j==n?'\\n':' ');\n            }\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2115a",
      "PROBLEM_ID": "2115A",
      "PROBLEM_STATEMENT": "Gellyfish hates math problems, but she has to finish her math homework:\n\nGellyfish is given an array of $n$ positive integers $a_1, a_2, \\ldots, a_n$.\n\nShe needs to do the following two-step operation until all elements of $a$ are equal:\n\n1. Select two indexes $i$, $j$ satisfying $1 \\leq i, j \\leq n$ and $i \\neq j$.\n2. Replace $a_i$ with $\\gcd(a_i, a_j)$.\n\nNow, Gellyfish asks you for the minimum number of operations to achieve her goal.\n\nIt can be proven that Gellyfish can always achieve her goal.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 5000$)\u00a0\u2014 the length of the array.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\leq a_i \\leq 5000$)\u00a0\u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations to achieve her goal.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n12 20 30\n\n6\n\n1 9 1 9 8 1\n\n3\n\n6 14 15\n\n```\n\n#### Output #1\n\n```\n4\n3\n3\n```\n\n### Note\n\nIn the first test case, the following is a way that minimizes the number of operations:\n\n1. Choose $i = 3$ and $j=2$ and replace $a_3$ with $\\gcd(a_3,a_2) = \\gcd(30, 20) = 10$, then $a$ becomes $[12, 20, 10]$.\n2. Choose $i=1$ and $j=3$ and replace $a_1$ with $\\gcd(a_1,a_3) = \\gcd(12, 10) = 2$, then $a$ becomes $[2, 20, 10]$.\n3. Choose $i=2$ and $j=1$ and replace $a_2$ with $\\gcd(a_2,a_1) = \\gcd(20, 2) = 2$, then $a$ becomes $[2, 2, 10]$.\n4. Choose $i=3$ and $j=1$ and replace $a_3$ with $\\gcd(a_3,a_1) = \\gcd(10, 2) = 2$, then $a$ becomes $[2, 2, 2]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(vector<int>& a) {\n    int n = a.size();\n    \n    // Compute the GCD of the array\n    int g = a[0];\n    for (int i = 1; i < n; i++) {\n        g = __gcd(g, a[i]);\n    }\n    \n    // If all elements are already equal to the GCD, no operations needed\n    int count_equal_to_gcd = 0;\n    for (int val : a) {\n        if (val == g) {\n            count_equal_to_gcd++;\n        }\n    }\n    \n    if (count_equal_to_gcd == n) return 0;\n    \n    // If at least one element is equal to the GCD, we can reduce all others in one operation each\n    if (count_equal_to_gcd > 0) {\n        return n - count_equal_to_gcd;\n    }\n    \n    // If no element is equal to the GCD, we need to create one first\n    vector<int> min_ops(5001, -1);\n    queue<int> q;\n    \n    // Initialize with all distinct values in the array\n    for (int val : a) {\n        if (min_ops[val] == -1) {\n            min_ops[val] = 0;\n            q.push(val);\n        }\n    }\n    \n    // BFS to find minimum operations to get the GCD\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n        \n        for (int aj : a) {\n            int new_val = __gcd(current, aj);\n            if (new_val < current && min_ops[new_val] == -1) {\n                min_ops[new_val] = min_ops[current] + 1;\n                q.push(new_val);\n                \n                if (new_val == g) {\n                    // Once we have the GCD, we can exit\n                    goto found;\n                }\n            }\n        }\n    }\n    \nfound:\n    // Once we have one element equal to the GCD, we need (n-1) more operations\n    // to convert all remaining elements\n    return min_ops[g] + (n - 1);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        \n        cout << solve(a) << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2114g",
      "PROBLEM_ID": "2114G",
      "PROBLEM_STATEMENT": "Yesterday, Dima found an empty array and decided to add some integers to it. He can perform the following operation an unlimited number of times:\n\n- add any integer to the left or right end of the array.\n- then, as long as there is a pair of identical adjacent elements in the array, they will be replaced by their sum.\n\nIt can be shown that there can be at most one such pair in the array at the same time.\n\nFor example, if the array is $[3, 6, 4]$ and we add the number $3$ to the left, the array will first become $[3, 3, 6, 4]$, then the first two elements will be replaced by $6$, and the array will become $[6, 6, 4]$, and then \u2014 $[12, 4]$.\n\nAfter performing the operation exactly $k$ times, he thinks he has obtained an array $a$ of length $n$, but he does not remember which operations he applied. Determine if there exists a sequence of $k$ operations that could result in the given array $a$ from an empty array, or determine that it is impossible.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The descriptions of the test cases follow.\n\nThe first line of each test case description contains two integers $n$ and $k$ ($1 \\le n \\le 10^5$, $n \\le k \\le 10^6$) \u2014 the length of the resulting array and the number of operations.\n\nThe second line contains $n$ integers $a_i$ ($1 \\le a_i \\le 10^9, a_{i - 1} \\ne a_i$) \u2014 the elements of the resulting array.\n\nIt is guaranteed that the sum of the values of $n$ across all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, if there is no suitable sequence of operations of length $k$, output \"NO\". Otherwise, output \"YES\".\n\nYou may output \"YES\" and \"NO\" in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n3 3\n\n2 1 4\n\n3 7\n\n2 1 4\n\n2 15\n\n2 16\n\n3 10\n\n256 32 1\n\n3 289\n\n768 96 1\n\n3 290\n\n768 96 1\n\n5 7\n\n5 1 6 3 10\n\n4 6\n\n6 8 5 10\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\n#define int long long\n#define pb emplace_back\n#define mp make_pair\n#define x first\n#define y second\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n\ntypedef long double ld;\ntypedef long long ll;\n\nusing namespace std;\n\nmt19937 rnd(time(nullptr));\n\nconst int inf = 1e9;\nconst int M = 1e9 + 7;\nconst ld pi = atan2(0, -1);\nconst ld eps = 1e-6;\n\nint max_op(int a, int b) {\n    int min_part = a;\n    while (min_part % 2 == 0 && min_part / 2 != b) {\n        min_part /= 2;\n    }\n    if (min_part % 2 == 1) {\n        return a / min_part;\n    }\n    int true_min = min_part;\n    while (true_min % 2 == 0) {\n        true_min /= 2;\n    }\n    return 1 + (a - min_part) / true_min;\n}\n\nvoid solve(int tc){\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int &e: a) cin >> e;\n    vector<int> pre(n, 0);\n    for (int j = 1; j < n; ++j) {\n        pre[j] = pre[j - 1] + max_op(a[j - 1], a[j]);\n    }\n    vector<int> suf(n, 0);\n    for (int j = n - 2; j >= 0; --j) {\n        suf[j] = suf[j + 1] + max_op(a[j + 1], a[j]);\n    }\n    for (int i = 0; i < n; i++) {\n        int res = max_op(a[i], 0) + pre[i] + suf[i];\n        if (res >= k) {\n            cout << \"YES\";\n            return;\n        }\n    }\n    cout << \"NO\";\n}\n\nbool multi = true;\n\nsigned main() {\n\n    int t = 1;\n    if (multi) cin >> t;\n    for (int i = 1; i <= t; ++i) {\n        solve(i);\n        cout << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2114f",
      "PROBLEM_ID": "2114F",
      "PROBLEM_STATEMENT": "Given an integer $x$ and an integer $k$. In one operation, you can perform one of two actions:\n\n- choose an integer $1 \\le a \\le k$ and assign $x = x \\cdot a$;\n- choose an integer $1 \\le a \\le k$ and assign $x = \\frac{x}{a}$, where the value of $\\frac{x}{a}$ must be an integer.\n\nFind the minimum number of operations required to make the number $x$ equal to $y$, or determine that it is impossible.\n\n### Input\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains three integers $x$, $y$ and $k$ ($1 \\le x, y, k \\le 10^6$).\n\nIt is guaranteed that the sum of $x$ and the sum of $y$ across all test cases does not exceed $10^8$.\n\n### Output\n\nFor each test case, output $-1$ if it is impossible to achieve $x=y$ using the given operations, and the minimum number of required operations otherwise.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n4 6 3\n\n4 5 3\n\n4 6 2\n\n10 45 3\n\n780 23 42\n\n11 270 23\n\n1 982800 13\n\n1 6 2\n\n```\n\n#### Output #1\n\n```\n2\n-1\n-1\n3\n3\n3\n6\n-1\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \n// Global maximum: x, y, k up to 1e6.\nconst int MAXN = 1000000;\n \n// spf[i] will hold the smallest prime factor for i.\nvector<int> spf(MAXN+1, 0);\n \n// Sieve to compute smallest prime factor for each number up to MAXN.\nvoid sieve(){\n    for (int i = 1; i <= MAXN; i++){\n        spf[i] = i;\n    }\n    for (int i = 2; i * i <= MAXN; i++){\n        if(spf[i] == i){\n            for (int j = i * i; j <= MAXN; j += i){\n                if(spf[j] == j)\n                    spf[j] = i;\n            }\n        }\n    }\n}\n \n// Factorize n using spf, returns vector of (prime, exponent)\nvector<pair<int,int>> factorize(int n) {\n    vector<pair<int,int>> res;\n    while(n > 1) {\n        int p = spf[n];\n        int cnt = 0;\n        while(n % p == 0){\n            cnt++;\n            n /= p;\n        }\n        res.push_back({p, cnt});\n    }\n    return res;\n}\n \n// Recursively generate all divisors of n from its prime factorization.\nvoid genDivisors(int idx, long long cur, const vector<pair<int,int>> &factors, vector<int>& divs) {\n    if(idx == (int)factors.size()){\n        divs.push_back((int)cur);\n        return;\n    }\n    int prime = factors[idx].first, exp = factors[idx].second;\n    long long mult = 1;\n    for (int i = 0; i <= exp; i++){\n        genDivisors(idx+1, cur * mult, factors, divs);\n        mult *= prime;\n    }\n}\n \n// Recursively generate all coins (allowed multipliers) for representing n.\n// We generate numbers of form a = \u220f p^e, where p runs over the distinct primes of n,\n// and e ranges from 0 until a exceeds coinLimit. (We require a >= 2.)\nvoid genCoins(int idx, long long cur, const vector<int>& primes, int coinLimit, vector<int>& coins) {\n    if(idx == (int)primes.size()){\n        if(cur >= 2) coins.push_back((int)cur);\n        return;\n    }\n    long long mult = 1;\n    // Increase exponent for primes[idx] while staying within coinLimit.\n    while(cur * mult <= coinLimit){\n        genCoins(idx+1, cur * mult, primes, coinLimit, coins);\n        mult *= primes[idx];\n        if(mult > coinLimit) break;\n    }\n}\n \n// Given an integer n (n>=1) and parameter k, let f(n) be the minimum number of allowed coins \n// (each coin is an integer a with 2 <= a <= min(n,k) and having only primes dividing n)\n// needed so that starting from 1 we can obtain n by multiplication.\n// We run a BFS on the state space whose nodes are divisors of n.\nint minCoinsForTarget(int n, int k) {\n    if(n == 1) return 0;\n \n    // Factorize n and get distinct primes.\n    vector<pair<int,int>> factors = factorize(n);\n    vector<int> distinctPrimes;\n    for(auto &p : factors)\n        distinctPrimes.push_back(p.first);\n \n    // The allowed coin values are in the range [2, min(n, k)].\n    int coinLimit = min(n, k);\n    vector<int> coins;\n    genCoins(0, 1LL, distinctPrimes, coinLimit, coins);\n    sort(coins.begin(), coins.end());\n    coins.erase(unique(coins.begin(), coins.end()), coins.end());\n \n    // Generate all divisors of n.\n    vector<int> divs;\n    genDivisors(0, 1LL, factors, divs);\n    sort(divs.begin(), divs.end());\n    // Create a mapping from the divisor value to an index.\n    unordered_map<int,int> divIndex;\n    for (int i = 0; i < (int)divs.size(); i++){\n        divIndex[divs[i]] = i;\n    }\n \n    int D = divs.size();\n    vector<int> dist(D, INT_MAX);\n    // BFS starting at 1.\n    queue<int>q;\n    dist[divIndex[1]] = 0;\n    q.push(1);\n    while(!q.empty()){\n        int cur = q.front();\n        q.pop();\n        int curDist = dist[divIndex[cur]];\n        if(cur == n)\n            return curDist;\n        int remain = n / cur;\n        for (int coin : coins){\n            // The coin is applicable if it divides the remaining factor (n/cur)\n            if(remain % coin == 0){\n                int nxt = cur * coin;\n                if(dist[divIndex[nxt]] > curDist + 1){\n                    dist[divIndex[nxt]] = curDist + 1;\n                    q.push(nxt);\n                }\n            }\n        }\n    }\n    return INT_MAX;\n}\n \n// Main\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    sieve();\n    int t;\n    cin >> t;\n    while(t--){\n        int x, y, k;\n        cin >> x >> y >> k;\n        // We need to achieve: x * (M)/(D) = y\n        // i.e. (M/D) = y/x. Write y/x in lowest terms as A/B.\n        int g = gcd(x, y);\n        int A = y / g;  // numerator part (from multiplications)\n        int B = x / g;  // denominator part (from divisions)\n \n        // For the sequence to be possible using coins a (which have a <= k),\n        // every prime factor in A (and in B) must be <= k.\n        bool poss = true;\n        {\n            vector<pair<int,int>> facA = factorize(A);\n            for(auto &p : facA){\n                if(p.first > k) { poss = false; break; }\n            }\n        }\n        {\n            vector<pair<int,int>> facB = factorize(B);\n            for(auto &p : facB){\n                if(p.first > k) { poss = false; break; }\n            }\n        }\n \n        if(!poss){\n            cout << -1 << \"\\n\";\n            continue;\n        }\n \n        int opsA = minCoinsForTarget(A, k);\n        int opsB = minCoinsForTarget(B, k);\n \n        if(opsA == INT_MAX || opsB == INT_MAX)\n            cout << -1 << \"\\n\";\n        else\n            cout << opsA + opsB << \"\\n\";\n    }\n \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2114e",
      "PROBLEM_ID": "2114E",
      "PROBLEM_STATEMENT": "Once, Kirei stealthily infiltrated the trap-filled estate of the Ainzbern family but was discovered by Kiritugu's familiar. Assessing his strength, Kirei decided to retreat. The estate is represented as a tree with $n$ vertices, with the root at vertex $1$. Each vertex of the tree has a number $a_i$ recorded, which represents the danger of vertex $i$. Recall that a tree is a connected undirected graph without cycles.\n\nFor a successful retreat, Kirei must compute the threat value for each vertex. The threat of a vertex is equal to the maximumalternating sum along the vertical path starting from that vertex. The alternating sum along the vertical path starting from vertex $i$ is defined as $a_i - a_{p_i} + a_{p_{p_i}} - \\ldots$, where $p_i$ is the parent of vertex $i$ on the path to the root (to vertex $1$).\n\nFor example, in the tree below, vertex $4$ has the following vertical paths:\n\n- $[4]$ with an alternating sum of $a_4 = 6$;\n- $[4, 3]$ with an alternating sum of $a_4 - a_3 = 6 - 2 = 4$;\n- $[4, 3, 2]$ with an alternating sum of $a_4 - a_3 + a_2 = 6 - 2 + 5 = 9$;\n- $[4, 3, 2, 1]$ with an alternating sum of $a_4 - a_3 + a_2 - a_1 = 6 - 2 + 5 - 4 = 5$.\n\n![](https://espresso.codeforces.com/1d786fdded1f234d101767c2c7b55e98960c8af0.png)The dangers of the vertices are indicated in red.\n\nHelp Kirei compute the threat values for all vertices and escape the estate.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe following describes the test cases.\n\nThe first line contains an integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of vertices in the tree.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the dangers of the vertices.\n\nThe next $n - 1$ lines contain the numbers $v, u$ ($1 \\le v, u \\le n$, $v \\neq u$)\u00a0\u2014 the description of the edges of the tree.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$. It is also guaranteed that the given set of edges forms a tree.\n\n### Output\n\nFor each test case, output $n$ integers\u00a0\u2014 the threat of each vertex.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5\n\n4 5 2 6 7\n\n1 2\n\n3 2\n\n4 3\n\n5 1\n\n6\n\n1000000000 500500500 900900900 9 404 800800800\n\n3 4\n\n5 1\n\n2 5\n\n1 6\n\n6 4\n\n```\n\n#### Output #1\n\n```\n4 5 2 9 7\n1000000000 1500500096 1701701691 199199209 404 800800800\n```\n\n### Note\n\nThe tree from the first test case is depicted in the statement, and the maximum variable-sign sums are achieved as follows:\n\n1. $a_1 = 4$;\n2. $a_2 = 5$;\n3. $a_3 = 2$;\n4. $a_4 - a_3 + a_2 = 6 - 2 + 5 = 9$;\n5. $a_5 = 7$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<long long> a(n+1);\n        for (int i = 1; i <= n; i++){\n            cin >> a[i];\n        }\n \n        // Build tree as an undirected adjacency list.\n        vector<vector<int>> adj(n+1);\n        for (int i = 1; i < n; i++){\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n \n        // F[i] : maximum alternating sum from i (starting with +a[i])\n        // R[i] : maximum alternating sum from i (starting with -a[i])\n        vector<long long> F(n+1, 0), R(n+1, 0);\n        vector<int> parent(n+1, 0);\n \n        // Start from the root vertex 1\n        F[1] = a[1];\n        R[1] = -a[1];\n        parent[1] = 0;\n \n        // Use BFS traversal (can use DFS as well) to compute F and R for all vertices.\n        queue<int> q;\n        q.push(1);\n \n        while(!q.empty()){\n            int cur = q.front();\n            q.pop();\n            for (int nxt : adj[cur]){\n                if(nxt == parent[cur])\n                    continue;\n                parent[nxt] = cur;\n                F[nxt] = max(a[nxt], a[nxt] + R[cur]);\n                R[nxt] = max(-a[nxt], -a[nxt] + F[cur]);\n                q.push(nxt);\n            }\n        }\n \n        // Output the threat values F[i] for each vertex\n        for (int i = 1; i <= n; i++){\n            cout << F[i] << (i == n? \"\\n\" : \" \");\n        }\n    }\n \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2114c",
      "PROBLEM_ID": "2114C",
      "PROBLEM_STATEMENT": "Given an array $a$ and $n$ integers. It is sorted in non-decreasing order, that is, $a_i \\le a_{i + 1}$ for all $1 \\le i < n$.\n\nYou can remove any number of elements from the array (including the option of not removing any at all) without changing the order of the remaining elements. After the removals, the following will occur:\n\n- $a_1$ is written to a new array;\n- if $a_1 + 1 < a_2$, then $a_2$ is written to a new array; otherwise, $a_2$ is written to the same array as $a_1$;\n- if $a_2 + 1 < a_3$, then $a_3$ is written to a new array; otherwise, $a_3$ is written to the same array as $a_2$;\n- $\\cdots$\n\nFor example, if $a=[1, 2, 4, 6]$, then:\n\n- $a_1 = 1$ is written to the new array, resulting in arrays: $[1]$;\n- $a_1 + 1 = 2$, so $a_2 = 2$ is added to the existing array, resulting in arrays: $[1, 2]$;\n- $a_2 + 1 = 3$, so $a_3 = 4$ is written to a new array, resulting in arrays: $[1, 2]$ and $[4]$;\n- $a_3 + 1 = 5$, so $a_4 = 6$ is written to a new array, resulting in arrays: $[1, 2]$, $[4]$, and $[6]$.\n\nYour task is to remove elements in such a way that the described algorithm creates as many arrays as possible. If you remove all elements from the array, no new arrays will be created.\n\n### Input\n\nThe first line of input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^6$, $a_i \\le a_{i + 1}$) \u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output one integer \u2014 the maximum number of arrays that can be obtained by removing any (possibly zero) number of elements.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n6\n\n1 2 3 4 5 6\n\n3\n\n1 2 3\n\n4\n\n1 2 2 4\n\n1\n\n2\n\n3\n\n1 4 8\n\n2\n\n1 1\n\n```\n\n#### Output #1\n\n```\n3\n2\n2\n1\n3\n1\n```\n\n### Note\n\nIn the first example, you can remove $a_3$ and $a_5$, then $a=[1, 2, 4, 6]$, the process of forming arrays for it is shown in the statement.\n\nIn the second example, you need to remove $a_2$, after which $a = [1, 3]$, and the arrays $[1]$ and $[3]$ will be written.\n\nIn the third example, no removals are needed; for $a = [1, 2, 2, 4]$, the arrays $[1, 2, 2]$ and $[4]$ will be written.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint solve(vector<int>& a) {\n    int n = a.size();\n    if (n == 0) return 0;\n    \n    int last = -1; // Ensures first element is selected because a_i >= 1\n    int arrays = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        if (a[i] > last + 1) {\n            // Current element creates a new array\n            last = a[i];\n            arrays++;\n        }\n        // If a[i] <= last + 1, we skip this element (remove it)\n    }\n    \n    return arrays;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        \n        cout << solve(a) << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2114b",
      "PROBLEM_ID": "2114B",
      "PROBLEM_STATEMENT": "Vlad found a binary string$^{\\text{\u2217}}$ $s$ of even length $n$. He considers a pair of indices ($i, n - i + 1$), where $1 \\le i < n - i + 1$, to be good if $s_i = s_{n - i + 1}$ holds true.\n\nFor example, in the string '010001' there is only $1$ good pair, since $s_1 \\ne s_6$, $s_2 \\ne s_5$, and $s_3=s_4$. In the string '0101' there are no good pairs.\n\nVlad loves palindromes, but not too much, so he wants to rearrange some characters of the string so that there are exactly $k$ good pairs of indices.\n\nDetermine whether it is possible to rearrange the characters in the given string so that there are exactly $k$ good pairs of indices ($i, n - i + 1$).\n\n$^{\\text{\u2217}}$A string $s$ is called binary if it consists only of the characters '0' and '1'\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2 \\le n \\le 2 \\cdot 10^5$, $0 \\le k \\le \\frac{n}{2}$, $n$ is even)\u00a0\u2014 the length of the string and the required number of good pairs.\n\nThe second line of each test case contains a binary string $s$ of length $n$.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output \"YES\" if there is a way to rearrange the characters of the string so that there are exactly $k$ good pairs, otherwise output \"NO\".\n\nYou may output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n6 2\n\n000000\n\n2 1\n\n01\n\n4 1\n\n1011\n\n10 2\n\n1101011001\n\n10 1\n\n1101011001\n\n2 1\n\n11\n\n```\n\n#### Output #1\n\n```\nNO\nNO\nYES\nNO\nYES\nYES\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        \n        string s;\n        cin >> s;\n        \n        int cnt0 = 0, cnt1 = 0;\n        for (char c : s) {\n            if (c == '0') cnt0++;\n            else cnt1++;\n        }\n        \n        int pairs = n / 2;\n        int badPairs = pairs - k;\n        \n        bool condition1 = (cnt0 >= badPairs);\n        bool condition2 = (cnt1 >= badPairs);\n        bool condition3 = ((cnt0 - badPairs) % 2 == 0);\n        \n        if (condition1 && condition2 && condition3) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2114a",
      "PROBLEM_ID": "2114A",
      "PROBLEM_STATEMENT": "One can notice the following remarkable mathematical fact: the number $2025$ can be represented as $(20+25)^2$.\n\nYou are given a year represented by a string $s$, consisting of exactly $4$ characters. Thus, leading zeros are allowed in the year representation. For example, \"0001\", \"0185\", \"1375\" are valid year representations. You need to express it in the form $(a + b)^2$, where $a$ and $b$ are non-negative integers, or determine that it is impossible.\n\nFor example, if $s$ = \"0001\", you can choose $a = 0$, $b = 1$, and write the year as $(0 + 1)^2 = 1$.\n\n### Input\n\nThe first line of the input contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe following lines describe the test cases.\n\nThe only line of each test case contains a string $s$, consisting of exactly $4$ characters. Each character is a digit from $0$ to $9$.\n\n### Output\n\nOn a separate line for each test case, output:\n\n- Two numbers $a$ and $b$ ($a, b \\ge 0$) such that $(a + b)^2 = s$, if they exist. If there are multiple suitable pairs, you may output any of them.\n- The number $-1$ otherwise.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n0001\n\n1001\n\n1000\n\n4900\n\n2025\n\n```\n\n#### Output #1\n\n```\n0 1\n-1\n-1\n34 36\n20 25\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while(t--) {\n        string s;\n        cin >> s;\n        \n        int num = stoi(s);\n        \n        // Check if num is a perfect square\n        int sqrt_num = sqrt(num);\n        if (sqrt_num * sqrt_num != num) {\n            cout << \"-1\" << endl;\n            continue;\n        }\n        \n        bool found = false;\n        \n        // Try all possible ways to split the number into two parts\n        for (int i = 1; i < s.length(); i++) {\n            string first_part = s.substr(0, i);\n            string second_part = s.substr(i);\n            \n            // Skip if second part has leading zeros (except when it's just \"0\")\n            if (second_part.size() > 1 && second_part[0] == '0') \n                continue;\n            \n            int a = stoi(first_part);\n            int b = stoi(second_part);\n            \n            if (a + b == sqrt_num) {\n                cout << a << \" \" << b << endl;\n                found = true;\n                break;\n            }\n        }\n        \n        // If no valid split is found, output any valid pair\n        if (!found) {\n            cout << 0 << \" \" << sqrt_num << endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2113f",
      "PROBLEM_ID": "2113F",
      "PROBLEM_STATEMENT": "You are given two arrays $a$ and $b$ of length $n$. You can perform the following operation an unlimited number of times:\n\n- Choose an integer $i$ from $1$ to $n$ and swap $a_i$ and $b_i$.\n\nLet $f(c)$ be the number of distinct numbers in array $c$. Find the maximum value of $f(a) + f(b)$. Also, output the arrays $a$ and $b$ after performing all operations.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$)\u00a0\u2014 the length of the arrays.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 2n$)\u00a0\u2014 the elements of array $a$.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le 2n$)\u00a0\u2014 the elements of array $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, print a single integer in the first line\u00a0\u2014 the maximum value of $f(a) + f(b)$.\n\nIn the second line, print $n$ integers\u00a0\u2014 the elements of array $a$ after performing the operations.\n\nIn the third line, print $n$ integers\u00a0\u2014 the elements of array $b$ after performing the operations.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5\n\n1 2 4 4 4\n\n1 3 3 5 2\n\n7\n\n2 2 4 4 5 5 5\n\n1 3 3 2 1 6 6\n\n7\n\n12 3 3 4 5 6 4\n\n1 2 13 8 10 13 7\n\n```\n\n#### Output #1\n\n```\n9\n1 3 4 5 2\n1 2 3 4 4\n12\n2 3 4 2 1 5 6\n1 2 3 4 5 6 5\n14\n12 3 13 8 10 6 4\n1 2 3 4 5 13 7\n```\n\n### Note\n\nIn the first test case, after applying three operations with $i=2$, $i=4$, and $i=5$, we obtain $a = [1, 3, 4, 5, 2]$ and $b = [1, 2, 3, 4, 4]$. After that, $f(a) + f(b) = 5 + 4 = 9$. It can be shown that it is not possible to achieve a greater answer.\n\nIn the second test case, after applying the operations: \n\n$$f([2, 3, 4, 2, 1, 5, 6]) + f([1, 2, 3, 4, 5, 6, 5]) = 6 + 6 = 12$$\n\n",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include \"bits/stdc++.h\"\n \nusing namespace std;\n \nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    vector<int> b(n);\n    for (int i = 0; i < n; i++) {\n        cin >> b[i];\n    }\n    vector<int> want(n);\n    auto make = [&] (int i, int x, int y) {\n        if (!want[i]) {\n            if (a[i] != x) {\n                swap(a[i], b[i]);\n            }\n            want[i] = 1;\n        }\n    };\n    const int N = 2 * n + 22;\n    vector<vector<pair<int, int>>> g(N);\n    for (int i = 0; i < n; i++) {\n        g[a[i]].push_back({b[i], i});\n        g[b[i]].push_back({a[i], i});\n    }\n    vector<int> used(N);\n    auto dfs = [&] (auto&& dfs, int v, int h) -> void {\n        used[v] = h;\n        for (auto& [u, i] : g[v]) {\n            if (used[u] <= 0) {\n                make(i, v, u);\n                dfs(dfs, u, h + 1);\n            } else if (used[u] < used[v]) {\n                make(i, v, u);\n            }\n        }\n    };\n    for (int i = 0; i < N; i++) {\n        if (used[i] == 0 && int(g[i].size()) == 1) {\n            dfs(dfs, i, 1);\n        }\n    }\n    int rt;\n    auto find = [&] (auto&& find, int v, int pr) -> void {\n        used[v] = -1;\n        for (auto& [u, i] : g[v]) {\n            if (used[u] == 0) {\n                find(find, u, i);\n            } else if (i != pr) {\n                rt = u;\n            }\n        }\n    };\n    for (int i = 0; i < N; i++) {\n        if (used[i] == 0 && !g[i].empty()) {\n            rt = -1;\n            find(find, i, -1);\n            dfs(dfs, rt, 1);\n        }\n    }\n    cout << set<int>(a.begin(), a.end()).size() + set<int>(b.begin(), b.end()).size() << '\\n';\n    for (int i = 0; i < n; i++) {\n        cout << a[i] << \" \";\n    }\n    cout << '\\n';\n    for (int i = 0; i < n; i++) {\n        cout << b[i] << \" \";\n    }\n    cout << '\\n';\n}\n \nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2113e",
      "PROBLEM_ID": "2113E",
      "PROBLEM_STATEMENT": "Marat is a native of Kazan. Kazan can be represented as an undirected tree consisting of $n$ vertices. In his youth, Marat often got into street fights, and now he has $m$ enemies, numbered from $1$ to $m$, living in Kazan along with him.\n\nEvery day, all the people living in the city go to work. Marat knows that the $i$-th of his enemies lives at vertex $a_i$ and works at vertex $b_i$. He himself lives at vertex $x$ and works at vertex $y$. It is guaranteed that $a_i \\ne x$.\n\nAll enemies go to work via the shortest path and leave their homes at time $1$. That is, if we represent the shortest path between vertices $a_i$ and $b_i$ as $c_1, c_2, c_3, \\ldots, c_k$ (where $c_1 = a_i$ and $c_k = b_i$), then at the moment $p$ ($1 \\le p \\le k$), the enemy numbered $i$ will be at vertex $c_p$.\n\nMarat really does not want to meet any of his enemies at the same vertex at the same time, as this would create an awkward situation, but they can meet on an edge. Marat also leaves his home at time $1$, and at each subsequent moment in time, he can either move to an adjacent vertex or stay at his current one.\n\nNote that Marat can only meet the $i$-th enemy at the moments $2, 3, \\ldots, k$ (where $c_1, c_2, \\ldots, c_k$ is the shortest path between vertices $a_i$ and $b_i$). In other words, starting from the moment after the enemy reaches work, Marat can no longer meet him.\n\nHelp Marat find the earliest moment in time when he can reach work without encountering any enemies along the way, or determine that it is impossible.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains four integers $n$, $m$, $x$, and $y$ ($2 \\le n \\le 10^5$, $1 \\le m \\le 200$, $1 \\le x, y \\le n$, $x \\neq y$)\u00a0\u2014 the number of vertices in the tree, the number of enemies, and the vertex numbers from which Marat starts his journey and where he needs to arrive, respectively.\n\nThe $j$-th of the following $n - 1$ lines contains two integers $v_j$ and $u_j$ ($1 \\le v_j, u_j \\le n$, $v_j \\neq u_j$)\u00a0\u2014 the endpoints of the $j$-th edge of the tree.\n\nThe $i$-th of the following $m$ lines contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le n$, $a_i \\neq b_i$, $a_i \\ne x$)\u00a0\u2014 the description of the routes of Marat's enemies.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum moment in time when Marat can reach work, or $-1$ if it is impossible.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4 1 1 4\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n5 1 1 5\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n5 1\n\n9 2 1 9\n\n1 2\n\n2 3\n\n3 4\n\n3 5\n\n5 6\n\n6 7\n\n6 8\n\n8 9\n\n9 1\n\n7 1\n\n9 2 7 2\n\n1 4\n\n2 5\n\n3 6\n\n4 5\n\n5 6\n\n4 7\n\n5 8\n\n6 9\n\n2 8\n\n3 7\n\n3 2 1 3\n\n1 2\n\n2 3\n\n2 1\n\n3 1\n\n```\n\n#### Output #1\n\n```\n4\n6\n10\n5\n-1\n```\n\n### Note\n\nIn the first test case, it is possible to reach vertex number $4$ from vertex number $1$ via the shortest path. Note that Marat will meet a single enemy on an edge, not at a vertex.\n\nIn the second test case, the optimal strategy is to wait for one moment in time at the starting vertex and then go along the shortest path from vertex $1$ to vertex $5$. If he does not stop at the beginning, Marat will meet his enemy at a vertex, not on an edge.\n\nIn the third test case, it is beneficial to go from vertex $1$ to vertex $4$. After that, he should not move anywhere for one moment in time, and then go along the shortest path from vertex $4$ to vertex $9$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "//#pragma GCC optimize(\"Ofast\")\n\n#include \"bits/stdc++.h\"\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep1(i, n) for (int i = 1; i < (n); ++i)\n#define rep1n(i, n) for (int i = 1; i <= (n); ++i)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; --i)\n//#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define each(x, a) for (auto &x : a)\n#define ar array\n#define vec vector\n#define range(i, n) rep(i, n)\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = double;\nusing str = string;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\n\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vpi = vector<pair<int, int>>;\nusing vvi = vector<vi>;\n\nint Bit(int mask, int b) { return (mask >> b) & 1; }\n\ntemplate<class T>\nbool ckmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool ckmax(T &a, const T &b) {\n    if (b > a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// [l, r)\ntemplate<typename T, typename F>\nT FindFirstTrue(T l, T r, const F &predicat) {\n    --l;\n    while (r - l > 1) {\n        T mid = l + (r - l) / 2;\n        if (predicat(mid)) {\n            r = mid;\n        } else {\n            l = mid;\n        }\n    }\n    return r;\n}\n\ntemplate<typename T, typename F>\nT FindLastFalse(T l, T r, const F &predicat) {\n    return FindFirstTrue(l, r, predicat) - 1;\n}\n\nconst int INFi = 2e9;\nconst ll INF = 2e18;\n\nvoid solve() {\n    int n, m, x, y; cin >> n >> m >> x >> y;\n    x--;\n    y--;\n    vvi g(n);\n    rep(_, n - 1) {\n        int u, v; cin >> u >> v;\n        u--;\n        v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    vector<vi> block;\n\n    vi path;\n    auto dfs = [&] (auto &&self, int v, int p, int t) -> bool {\n        path.push_back(v);\n        if (v == t) return true;\n        for(auto &u : g[v]) {\n            if (u == p) continue;\n            if (self(self, u, v, t)) return true;\n        }\n        path.pop_back();\n        return false;\n    };\n\n    rep(i, m) {\n        int a, b; cin >> a >> b;\n        a--;\n        b--;\n\n        dfs(dfs, a, -1, b);\n        assert(!path.empty());\n\n        if (block.size() < path.size()) block.resize(path.size());\n\n        rep(j, path.size()) block[j].push_back(path[j]);\n        path.clear();\n    }\n\n    vector<bool> ok(n, false);\n    vi q;\n    q.push_back(x);\n\n    vector<bool> cur(n, false);\n    vi was(n, -1);\n    for(int t = 0;;++t) {\n\n        if (t < block.size()) for(auto &u : block[t]) cur[u] = true;\n        vi nxt;\n        for(auto &v : q) {\n            if (ok[v] || cur[v] || was[v] == t) continue;\n            was[v] = t;\n            bool nei = 0;\n            for(auto &u : g[v]) nei |= ok[u];\n            if (t && !nei) continue;\n            nxt.push_back(v);\n        }\n\n        q.clear();\n        if (t < block.size()) {\n            for(auto &u : block[t]) {\n                cur[u] = false;\n                if (ok[u]) {\n                    ok[u] = false;\n                }\n                q.push_back(u);\n            }\n        }\n\n        for(auto &v : nxt) {\n            assert(!ok[v]);\n            ok[v] = true;\n            for(auto &u : g[v]) {\n                if (!ok[u]) {\n                    q.push_back(u);\n                }\n            }\n        }\n\n        if (ok[y]) {\n            cout << t + 1 << '\\n';\n            return;\n        }\n\n        if (t > (int)block.size() && q.empty()) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(12) << fixed;\n    int t = 1;\n    cin >> t;\n    rep(_, t) {\n        solve();\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2113d",
      "PROBLEM_ID": "2113D",
      "PROBLEM_STATEMENT": "You are playing a new card game in a casino with the following rules:\n\n1. The game uses a deck of $2n$ cards with different values.\n2. The deck is evenly split between the player and the dealer: each receives $n$ cards.\n3. Over $n$ rounds, the player and the dealer simultaneously play one top card from their hand. The cards are compared, and the point goes to the one whose card has a higher value. The winning card is removed from the game, while the losing card is returned to the hand and placed on top of the other cards in the hand of the player who played it.\n\nNote that the game always lasts exactly $n$ rounds.\n\nYou have tracked the shuffling of the cards and know the order of the cards in the dealer's hand (from top to bottom). You want to maximize your score, so you can swap any two cards in your hand no more than once (to avoid raising suspicion).\n\nDetermine the maximum number of points you can achieve.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5 \\cdot 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^{5}$)\u00a0\u2014 the number of cards in the player's hand.\n\nThe second line of each test case contains $n$ integers $a_{1}, a_{2}, \\ldots, a_{n}$ ($1 \\leq a_{i} \\leq 2n$)\u00a0\u2014 the values of the cards in the player's hand from top to bottom.\n\nThe third line of each test case contains $n$ integers $b_{1}, b_{2}, \\ldots, b_{n}$ ($1 \\leq b_{i} \\leq 2n$)\u00a0\u2014 the values of the cards in the dealer's hand from top to bottom.\n\nIt is guaranteed that the values of all cards are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximum number of points you can achieve.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n7\n\n13 7 4 9 12 10 2\n\n6 1 14 3 8 5 11\n\n3\n\n1 6 5\n\n2 3 4\n\n5\n\n8 6 3 10 1\n\n7 9 5 2 4\n\n```\n\n#### Output #1\n\n```\n6\n2\n3\n```\n\n### Note\n\nIn the first test case, the cards can remain unchanged. The gameplay will be organized as follows:\n\n1. The cards with values $13$ and $6$ are compared. The player wins and receives a point.\n2. The cards with values $7$ and $6$ are compared. The player wins and receives a point.\n3. The cards with values $4$ and $6$ are compared. The dealer wins.\n4. The cards with values $4$ and $1$ are compared. The player wins and receives a point.\n5. The cards with values $9$ and $1$ are compared. The player wins and receives a point.\n6. The cards with values $12$ and $1$ are compared. The player wins and receives a point.\n7. The cards with values $10$ and $1$ are compared. The player wins and receives a point.\n\nThus, the player received $6$ points.\n\nIn the second test case, the cards with values $1$ and $5$ can be swapped, then the player's hand looks as follows $[5, 6, 1]$. The gameplay will be organized as follows:\n\n1. The cards with values $5$ and $2$ are compared. The player wins and receives a point.\n2. The cards with values $6$ and $2$ are compared. The player wins and receives a point.\n3. The cards with values $1$ and $2$ are compared. The dealer wins.\n\nThus, the player received $2$ points.\n\nIn the third test case, the cards with values $3$ and $10$ can be swapped, then the player's hand looks as follows $[8, 6, 10, 3, 1]$. The gameplay will be organized as follows:\n\n1. The cards with values $8$ and $7$ are compared. The player wins and receives a point.\n2. The cards with values $6$ and $7$ are compared. The dealer wins.\n3. The cards with values $6$ and $9$ are compared. The dealer wins.\n4. The cards with values $6$ and $5$ are compared. The player wins and receives a point.\n5. The cards with values $10$ and $5$ are compared. The player wins and receives a point.\n\nThus, the player received $3$ points.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) ((x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst char en = '\\n';\nconst int INF = 1e9 + 7;\nconst ll INFLL = 1e18;\n\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n\n#ifdef LOCAL\n#include \"debug.h\"\n#define numtest(x) cerr << \"Test #\" << (x) << \": \" << endl;\n#else\n#define debug(...) 42\n#define numtest(x) 42\n#endif\n\nint merge(const vector<int> &a, const vector<int> &b) {\n    int n = sz(a);\n    int res = 0;\n    for (int c = 0, i = 0, j = 0; c < n; ++c) {\n        if (a[i] > b[j]) {\n            ++res;\n            ++i;\n        } else if (a[i] < b[j]) {\n            ++j;\n        } else {\n            assert(0);\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n    }\n    vector<int> pref_min(n), suf_max(n);\n    pref_min[0] = 0;\n    for (int i = 1; i < n; ++i) {\n        pref_min[i] = pref_min[i - 1];\n        if (a[i] < a[pref_min[i - 1]]) {\n            pref_min[i] = i;\n        }\n    }\n    suf_max[n - 1] = n - 1;\n    for (int i = n - 2; i >= 0; --i) {\n        suf_max[i] = suf_max[i + 1];\n        if (a[i] > a[suf_max[i + 1]]) {\n            suf_max[i] = i;\n        }\n    }\n    int cur = merge(a, b);\n    int l = cur, r = n;\n    while (r - l > 1) {\n        int m = l + (r - l) / 2;\n        swap(a[pref_min[m - 1]], a[suf_max[m]]);\n        if (merge(a, b) >= m) {\n            l = m;\n        } else {\n            r = m;\n        }\n        swap(a[pref_min[m - 1]], a[suf_max[m]]);\n    }\n    cout << l << en;\n}\n\nint32_t main() {\n    int tests = 1;\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    tests = 1;\n#else\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#endif\n    cin >> tests;\n    for (int testcase = 1; testcase <= tests; ++testcase) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2113c",
      "PROBLEM_ID": "2113C",
      "PROBLEM_STATEMENT": "The boy Smilo is playing Minecraft! To prepare for the battle with the dragon, he needs a lot of golden apples, and for that, he requires a lot of gold. Therefore, Smilo goes to the mine.\n\nThe mine is a rectangular grid of size $n \\times m$, where each cell can be either gold ore, stone, or an empty cell. Smilo can blow up dynamite in any empty cell. When dynamite explodes in an empty cell with coordinates $(x, y)$, all cells within a square of side $2k + 1$ centered at cell $(x, y)$ become empty. If gold ore was located strictly inside this square (not on the boundary), it disappears. However, if the gold ore was on the boundary of this square, Smilo collects that gold.\n\nDynamite can only be detonated inside the mine, but the explosion square can extend beyond the mine's boundaries.\n\nDetermine the maximum amount of gold that Smilo can collect.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$ ($1 \\leq n, m, k \\leq 500$)\u00a0\u2014 the number of rows, columns, and the explosion parameter $k$, respectively.\n\nEach of the following $n$ lines contains $m$ characters, each of which is equal to '.', '#', or 'g', where '.'\u00a0\u2014 is an empty cell, '#'\u00a0\u2014 is stone, 'g'\u00a0\u2014 is gold. It is guaranteed that at least one of the cells is empty.\n\nIt is guaranteed that the sum $n \\cdot m$ across all test cases does not exceed $2.5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximum amount of gold that can be obtained.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 3 1\n\n#.#\n\ng.g\n\n2 3 2\n\n#.#\n\ng.g\n\n3 4 2\n\n.gg.\n\ng..#\n\ng##.\n\n```\n\n#### Output #1\n\n```\n2\n0\n4\n```\n\n### Note\n\nIn the first test case, Smilo can detonate the dynamite in any empty cell and obtain $2$ gold:\n\n![](https://espresso.codeforces.com/8d84438b7b95b71aaa30d080d90a75329fdadcac.png)\n\nIn the second test case, no matter what Smilo does, he will not be able to obtain any gold:\n\n![](https://espresso.codeforces.com/98712070a6a4b0c65db7542b15f57d61ae19e48e.png)\n\nIn the third test case, it is possible to detonate the dynamite in the bottom right corner to obtain $2$ gold, and then make another explosion one cell to the left to obtain the remaining $2$ gold:\n\n![](https://espresso.codeforces.com/b781559838668a5220fc0c077b93d684cd0ee5ec.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <queue>\n#include <unordered_set>\n#include <fstream>\n#include <random>\n\nusing namespace std;\n\nusing ll = long long;\n\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\nconst int MAXN = 500;\nint sum[MAXN + 1][MAXN + 1];\n\nint n, m, k;\nint check(int i, int mx) {\n\treturn min(max(i, 0), mx);\n}\n\nint pref(int i, int j) {\n\treturn sum[check(i, n)][check(j, m)];\n}\n\nvoid solve() {\n\tcin >> n >> m >> k; k--;\n\tvector<string> mine(n);\n\tint all_gold = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> mine[i];\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tall_gold += (mine[i][j] == 'g');\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + (mine[i][j] == 'g');\n\t\t}\n\t}\n\tint ans = all_gold;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (mine[i][j] == '.') {\n\t\t\t\tint a = i - k, b = i + k + 1, c = j - k, d = j + k + 1;\n\t\t\t\tans = min(ans, pref(b, d) - pref(a, d) - pref(b, c) + pref(a, c));\n\t\t\t}\n\t\t}\n\t}\n\tcout << all_gold - ans << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tint t = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\tsolve();\n\t}\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2113b",
      "PROBLEM_ID": "2113B",
      "PROBLEM_STATEMENT": "The roof is a rectangle of size $w \\times h$ with the bottom left corner at the point $(0, 0)$ on the plane. Your team needs to completely cover this roof with identical roofing sheets of size $a \\times b$, with the following conditions:\n\n- The sheets cannot be rotated (not even by $90^\\circ$).\n- The sheets must not overlap (but they can touch at the edges).\n- The sheets can extend beyond the boundaries of the rectangular roof.\n\nA novice from your team has already placed two such sheets on the roof in such a way that the sheets do not overlap and each of them partially covers the roof.\n\nYour task is to determine whether it is possible to completely tile the roof without removing either of the two already placed sheets.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains four integers $w$, $h$, $a$, and $b$ ($1 \\le w, h, a, b \\le 10^9$)\u00a0\u2014 the dimensions of the roof and the dimensions of the roofing sheets, respectively.\n\nThe second line of each test case contains four integers $x_1$, $y_1$, $x_2$, and $y_2$ ($-a + 1 \\le x_1, x_2 \\le w - 1, -b + 1 \\le y_1, y_2 \\le h - 1$)\u00a0\u2014 the coordinates of the bottom left corners of the already placed roofing sheets. It is guaranteed that these sheets do not overlap.\n\n### Output\n\nFor each test case, output \"Yes\" (without quotes) if it is possible to completely tile the roof without removing either of the two already placed tiles, and \"No\" (without quotes) otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n6 5 2 3\n\n-1 -2 5 4\n\n4 4 2 2\n\n0 0 3 1\n\n10 9 3 2\n\n0 0 4 3\n\n10 9 3 2\n\n0 0 6 3\n\n5 5 2 2\n\n-1 -1 4 -1\n\n5 5 2 2\n\n-1 -1 2 3\n\n7 8 2 4\n\n0 0 0 5\n\n```\n\n#### Output #1\n\n```\nYes\nNo\nNo\nYes\nNo\nYes\nNo\n```\n\n### Note\n\nIn the first test case, it is possible to add $8$ roofing sheets as follows:\n\n![](https://espresso.codeforces.com/76a7cc7bc4e86f820c778a0bb385668955eaab01.png)\n\nIn the second test case, it is impossible to completely tile the roof:\n\n![](https://espresso.codeforces.com/7a137282544846beb0e98facae5ddf58e8248fee.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \n// helper: determine if two intervals [L1,R1] and [L2,R2] (closed on left, open on right)\n// have a non\u2010empty overlap.\nbool intersect(long long L1, long long R1, long long L2, long long R2){\n    return max(L1, L2) < min(R1, R2);\n}\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t; \n    cin >> t;\n    while(t--){\n        long long w, h, a, b;\n        cin >> w >> h >> a >> b;\n        long long x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n \n        // The fixed tile i covers [xi, xi+a] in x and [yi, yi+b] in y.\n        // But since only the part that lies on the roof [0,w]\u00d7[0,h] matters,\n        // compute the intersection intervals.\n        long long I1xL = max(0LL, x1);\n        long long I1xR = min(w, x1 + a);\n        long long I2xL = max(0LL, x2);\n        long long I2xR = min(w, x2 + a);\n \n        long long I1yL = max(0LL, y1);\n        long long I1yR = min(h, y1 + b);\n        long long I2yL = max(0LL, y2);\n        long long I2yR = min(h, y2 + b);\n \n        bool sameCol = intersect(I1xL, I1xR, I2xL, I2xR);\n        bool sameRow = intersect(I1yL, I1yR, I2yL, I2yR);\n \n        auto modVal = [&](long long X, long long M) -> long long {\n            long long r = X % M;\n            if(r < 0) r += M;\n            return r;\n        };\n \n        long long r1x = modVal(x1, a);\n        long long r2x = modVal(x2, a);\n        long long r1y = modVal(y1, b);\n        long long r2y = modVal(y2, b);\n \n        bool possible = false;\n        // Case 1. Fixed tiles both lie in the same column and the same row.\n        if(sameCol && sameRow){\n            if(r1x == r2x && r1y == r2y)\n                possible = true;\n        }\n        // Case 2. They lie in the same row only.\n        else if(sameRow && (!sameCol)){\n            // In a fixed row the horizontal grid is forced:\n            if(r1x == r2x)\n                possible = true;\n        }\n        // Case 3. They lie in the same column only.\n        else if(sameCol && (!sameRow)){\n            // In a fixed column the vertical grid must be common:\n            if(r1y == r2y)\n                possible = true;\n        }\n        // Case 4. They lie in different rows AND different columns.\n        else{\n            // In this case one may choose the grid in each stripe independently,\n            // and the tiling can be completed provided one of the offsets agrees.\n            if(r1x == r2x || r1y == r2y)\n                possible = true;\n        }\n \n        cout << (possible ? \"Yes\" : \"No\") << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2113a",
      "PROBLEM_ID": "2113A",
      "PROBLEM_STATEMENT": "You are the owner of a popular shashlik restaurant, and your grill is the heart of your kitchen. However, the grill has a peculiarity: after cooking each shashlik, its temperature drops.\n\nYou need to cook as many portions of shashlik as possible, and you have an unlimited number of portions of two types available for cooking:\n\n- The first type requires a temperature of at least $a$ degrees at the start of cooking, and after cooking, the grill's temperature decreases by $x$ degrees.\n- The second type requires a temperature of at least $b$ degrees at the start of cooking, and after cooking, the grill's temperature decreases by $y$ degrees.\n\nInitially, the grill's temperature is $k$ degrees. Determine the maximum total number of portions of shashlik that can be cooked.\n\nNote that the grill's temperature can be negative.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains five integers $k$, $a$, $b$, $x$, and $y$ ($1 \\le k, a, b, x, y \\le 10^9$)\u00a0\u2014 the initial temperature of the grill, the required temperature for cooking the first and second types of shashlik, respectively, as well as the temperature drop after cooking the first and second types of shashlik, respectively.\n\n### Output\n\nFor each test case, output a single integer \u2014 the maximum number of portions of shashlik that you can cook.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n10 3 4 2 1\n\n1 10 10 1 1\n\n100 17 5 2 3\n\n28 14 5 2 4\n\n277 5 14 1 3\n\n```\n\n#### Output #1\n\n```\n8\n0\n46\n10\n273\n```\n\n### Note\n\nIn the first test case, it is advantageous to cook $7$ portions of the second type of shashlik; after that, the grill's temperature will be $3$ degrees, and we can cook one more portion of the first type of shashlik.\n\nIn the second test case, we cannot cook either type of shashlik because the grill is too cold.\n\nIn the fourth test case, it is advantageous to cook $8$ portions of the first type of shashlik; after that, it will be possible to cook another $2$ portions of the second type of shashlik.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long max_portions(long long temp, long long req_temp, long long temp_drop) {\n    if (temp < req_temp) return 0;\n    return (temp - req_temp) / temp_drop + 1;\n}\n\nlong long solve(long long k, long long a, long long b, long long x, long long y) {\n    // Strategy 1: Cook type 1 first, then type 2\n    long long type1_count = max_portions(k, a, x);\n    long long remaining_temp = k - type1_count * x;\n    long long type2_count = max_portions(remaining_temp, b, y);\n    long long strategy1_total = type1_count + type2_count;\n    \n    // Strategy 2: Cook type 2 first, then type 1\n    type2_count = max_portions(k, b, y);\n    remaining_temp = k - type2_count * y;\n    type1_count = max_portions(remaining_temp, a, x);\n    long long strategy2_total = type2_count + type1_count;\n    \n    return max(strategy1_total, strategy2_total);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long k, a, b, x, y;\n        cin >> k >> a >> b >> x >> y;\n        \n        cout << solve(k, a, b, x, y) << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2112f",
      "PROBLEM_ID": "2112F",
      "PROBLEM_STATEMENT": "There are $n$ variables; let's denote the value of the $i$-th variable as $a_i$.\n\nThere are also $m$ operations which will be applied to these variables; the $i$-th operation is described by three integers $x_i, y_i, z_i$. When the $i$-th operation is applied, the variable $x_i$ gets assigned the following value: $\\min(a_{x_i}, a_{y_i} + z_i)$.\n\nEvery operation will be applied exactly once, but their order is not fixed; they can be applied in any order.\n\nLet's call a sequence of initial variable values $a_1, a_2, \\dots, a_n$ stable, if no matter in which order we apply operations, the resulting values will be the same. If the resulting value of the $i$-th variable depends on the order of operations, then the sequence of initial variable values is called $i$-unstable.\n\nYou have to process $q$ queries. In each query, you will be given initial values $a_1, a_2, \\dots, a_n$ and an integer $k$; before applying the operations, you can at most $k$ times choose a variable and decrease it by $1$. For every variable $i$, you have to independently determine if it is possible to transform the given values into an $i$-unstable sequence.\n\n### Input\n\nThe first line contains two integers $n$ and $m$ ($2 \\le n \\le 500$; $1 \\le m \\le 4 \\cdot 10^5$) \u2014 the number of variables and operations, respectively.\n\nThen, $m$ lines follow. The $i$-th of them contains three integers $x_i, y_i, z_i$ ($1 \\le x_i, y_i \\le n$; $x_i \\ne y_i$; $0 \\le z_i \\le 10^5$) \u2014 the description of the $i$-th operation.\n\nThe next line contains one integer $q$ ($1 \\le q \\le 1000$) \u2014 the number of queries.\n\nEach query consists of two lines:\n\n- the first line contains one integer $k$ ($0 \\le k \\le 10^9$) \u2014 the maximum number of times you can choose a variable and decrease it by $1$;\n- the second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the initial values of the variables.\n\n### Output\n\nFor each query, print a string of $n$ zeroes and/or ones. The $i$-th character should be 1 if it is possible to obtain an $i$-unstable sequence, or 0 otherwise.\n\n### Examples\n\n#### Input #1\n\n```\n\n4 5\n\n2 1 10\n\n3 2 5\n\n1 4 8\n\n1 2 6\n\n3 1 17\n\n3\n\n0\n\n20 0 15 5\n\n10\n\n20 0 15 5\n\n30\n\n20 0 15 5\n\n```\n\n#### Output #1\n\n```\n0000\n0000\n0110\n```\n\n#### Input #2\n\n```\n\n3 5\n\n1 2 100\n\n1 2 10\n\n1 3 5\n\n1 2 100\n\n3 2 5\n\n1\n\n1000000000\n\n0 0 0\n\n```\n\n#### Output #2\n\n```\n000\n```\n\n#### Input #3\n\n```\n\n3 4\n\n2 3 5\n\n1 2 0\n\n3 1 4\n\n1 3 4\n\n10\n\n5\n\n7 5 3\n\n2\n\n5 7 0\n\n1\n\n1 1 1\n\n5\n\n3 0 1\n\n0\n\n5 3 5\n\n5\n\n6 0 4\n\n5\n\n1 5 6\n\n1\n\n7 7 2\n\n1\n\n1 6 6\n\n4\n\n7 7 2\n\n```\n\n#### Output #3\n\n```\n000\n000\n000\n001\n000\n001\n001\n000\n000\n000\n```\n\n### Note\n\nConsider the first example. If the initial variable values are $[20, 0, 15, 5]$, the resulting values will be $[6, 0, 5, 5]$ with any order of operations. Decreasing the variables $10$ times is not enough. However, if we can apply no more than $30$ changes, we can decrease the $1$-st variable by $2$, and the $4$-th variable by $25$, we get initial values equal to $[18, 0, 15, -20]$, and this sequence is $2$-unstable and $3$-unstable:\n\n- if you apply the operations in the order they are given, you will get $[-12, 0, 5, -20]$;\n- however, if you apply the operations in order $[3, 2, 4, 1, 5]$, you will get $[-12, -2, 5, -20]$;\n- and if you apply the operations in order $[3, 4, 5, 1, 2]$, you will get $[-12, -2, 3, -20]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAXN = 500;\nconst int INF = 1000000000;\nconst ll INFLL = (ll)4e18;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    if(!(cin >> n >> m)) return 0;\n    static int W0[MAXN][MAXN];\n    static int D[MAXN][MAXN];\n    // Initialize direct weights and D\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            W0[i][j] = INF;\n            D[i][j] = INF;\n        }\n    }\n    for(int i = 0; i < n; ++i){\n        W0[i][i] = 0;\n        D[i][i] = 0;\n    }\n    // Read operations: edge y->x with weight z\n    for(int ei = 0; ei < m; ++ei){\n        int x, y, z;\n        cin >> x >> y >> z;\n        --x; --y;\n        if(z < W0[y][x]){\n            W0[y][x] = z;\n            D[y][x] = z;\n        }\n    }\n    // Floyd-Warshall to compute all-pairs shortest paths\n    for(int k = 0; k < n; ++k){\n        for(int i = 0; i < n; ++i){\n            if(D[i][k] == INF) continue;\n            int dik = D[i][k];\n            // Unroll inner loop for cache? We'll keep simple\n            for(int j = 0; j < n; ++j){\n                if(D[k][j] == INF) continue;\n                int nd = dik + D[k][j];\n                if(nd < D[i][j]){\n                    D[i][j] = nd;\n                }\n            }\n        }\n    }\n\n    int q;\n    cin >> q;\n    vector<ll> a(n);\n    // Pre-allocate buffers\n    vector<ll> best1(n), d(n);\n    string ans;\n    ans.resize(n);\n\n    while(q--){\n        ll k;\n        cin >> k;\n        for(int i = 0; i < n; ++i){\n            cin >> a[i];\n        }\n        // Compute best1[i] = min over j of a[j] + W0[j][i]\n        for(int i = 0; i < n; ++i){\n            ll mn = INFLL;\n            // j from 0..n-1\n            // W0[j][i] < INF means direct or self\n            for(int j = 0; j < n; ++j){\n                int wji = W0[j][i];\n                if(wji < INF){\n                    ll val = a[j] + (ll)wji;\n                    if(val < mn) mn = val;\n                }\n            }\n            best1[i] = mn;\n        }\n        // Compute minimal d[i]\n        for(int i = 0; i < n; ++i){\n            ll di = INFLL;\n            ll thr = best1[i];\n            // For each candidate j with D[j][i] < W0[j][i]\n            for(int j = 0; j < n; ++j){\n                int dij = D[j][i];\n                int wji = W0[j][i]; // direct\n                if(dij < wji){\n                    // candidate\n                    // compute minimal decrease d so that a[j] - d + dij < thr\n                    // => d > a[j] + dij - thr\n                    ll delta = (ll)a[j] + (ll)dij - thr + 1;\n                    if(delta <= 0){\n                        di = 0;\n                        break;\n                    }\n                    if(delta < di) di = delta;\n                }\n            }\n            d[i] = di;\n        }\n        // Build answer\n        for(int i = 0; i < n; ++i){\n            if(d[i] <= k) ans[i] = '1';\n            else ans[i] = '0';\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2112e",
      "PROBLEM_ID": "2112E",
      "PROBLEM_STATEMENT": "Consider a rooted undirected tree. Each vertex can be colored blue, green, or yellow. A coloring is called beautiful if it meets these conditions:\n\n- the root of the tree is green;\n- if you consider all blue and green vertices, they are reachable from each other without passing through any yellow vertices;\n- if you consider all yellow and green vertices, they are reachable from each other without passing through any blue vertices;\n\nYou are given an integer $m$. Your task is to calculate the minimum number of vertices in a tree with exactly $m$ beautiful colorings.\n\n### Input\n\nThe first line contains a single integer ($1 \\le t \\le 10^5$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains a single integer $m$ ($1 \\le m \\le 5 \\cdot 10^5$).\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the minimum number of vertices in a tree with exactly $m$ beautiful colorings. If such a tree does not exist, print $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n3\n\n5\n\n7\n\n9\n\n```\n\n#### Output #1\n\n```\n1\n2\n3\n4\n3\n```\n\n### Note\n\nIn the following notes, let $g$ describe green color, $b$ be blue, and $y$ be yellow.\n\nIn the first example, consider a simple tree with just $1$ vertex. This tree has exactly $1$ beautiful coloring: the root is green.\n\nIn the second example, consider a simple tree with $2$ vertices with a root at the $1$-st vertex. There are exactly $3$ beautiful colorings: $[g, g]$, $[g, b]$ and $[g, y]$.\n\nIn the third example, consider a bamboo tree with $3$ vertices with a root at the $1$-st vertex. There are exactly $5$ beautiful colorings: $[g, g, g]$, $[g, g, b]$, $[g, g, y]$, $[g, b, b]$ and $[g, y, y]$.\n\nIn the fifth example, consider a tree with $3$ vertices with a root at the $1$-st vertex, and the other $2$ vertices connected to it. There are exactly $9$ beautiful colorings: $[g, g, g]$, $[g, g, b]$, $[g, g, y]$, $[g, b, g]$, $[g, b, b]$, $[g, b, y]$, $[g, y, g]$, $[g, y, b]$ and $[g, y, y]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\nconst int INF = 1000000000;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    vector<int> queries(t);\n    int max_m = 0;\n    for(int i = 0; i < t; i++){\n        cin >> queries[i];\n        max_m = max(max_m, queries[i]);\n    }\n    // We need dp and aux arrays up to at least max_m\n    int N = max(2, max_m);\n\n    // Compute smallest prime factor (spf) up to N\n    vector<int> spf(N+1, 0);\n    for(int i = 2; i <= N; i++){\n        if(spf[i] == 0){\n            for(int j = i; j <= N; j += i){\n                if(spf[j] == 0) spf[j] = i;\n            }\n        }\n    }\n\n    // dp[m] = minimal number of vertices in a tree with exactly m beautiful colorings\n    // f[m] = minimal sum of subtree-sizes (excluding the root) to achieve product = m\n    vector<int> dp(N+1, INF), f(N+1, INF);\n    dp[1] = 1;\n    f[1] = 0;\n\n    // temporary arrays for factorization and divisor generation\n    int primes[20], exps[20], pf_sz;\n    vector<int> divs;\n    divs.reserve(64);\n\n    for(int m = 2; m <= N; m++){\n        // factorize m using spf\n        pf_sz = 0;\n        int x = m;\n        while(x > 1){\n            int p = spf[x], cnt = 0;\n            while(x % p == 0){\n                x /= p;\n                cnt++;\n            }\n            primes[pf_sz] = p;\n            exps[pf_sz] = cnt;\n            pf_sz++;\n        }\n        // generate all divisors of m\n        divs.clear();\n        divs.push_back(1);\n        for(int i = 0; i < pf_sz; i++){\n            int p = primes[i], e = exps[i];\n            int prev_sz = divs.size();\n            long long pp = 1;\n            for(int k = 1; k <= e; k++){\n                pp *= p;\n                // append new divisors = old_div * p^k\n                for(int j = 0; j < prev_sz; j++){\n                    divs.push_back(int(divs[j] * pp));\n                }\n            }\n        }\n        // DP over divisors >= 3\n        int best = INF;\n        for(int d : divs){\n            if(d < 3) continue;\n            int m2 = m / d;\n            // we split m = d * m2: one child-subtree factor d => f = d-2,\n            // plus other children summing to f[m2].\n            if(f[m2] < INF && dp[d - 2] < INF){\n                int cand = f[m2] + dp[d - 2];\n                if(cand < best) best = cand;\n            }\n        }\n        f[m] = best;\n        if(best < INF) dp[m] = best + 1;\n        else dp[m] = INF;\n    }\n\n    // answer queries\n    for(int m : queries){\n        int ans = dp[m];\n        if(ans >= INF) ans = -1;\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2112d",
      "PROBLEM_ID": "2112D",
      "PROBLEM_STATEMENT": "Let $u$ and $v$ be two distinct vertices in a directed graph. Let's call the ordered pair $(u, v)$ good if there exists a path from vertex $u$ to vertex $v$ along the edges of the graph.\n\nYou are given an undirected tree with $n$ vertices and $n - 1$ edges. Determine whether it is possible to assign a direction to each edge of this tree so that the number of good pairs in it is exactly $n$. If it is possible, print any way to direct the edges resulting in exactly $n$ good pairs.\n\n![](https://espresso.codeforces.com/0f17bdc8df6de9dcbcefe04d44049c8911e607a8.png)One possible directed version of the tree for the first test case.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of vertices in the tree.\n\nThe next $n - 1$ lines describe the edges. The $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$; $u_i \\neq v_i$)\u00a0\u2014 the vertices connected by the $i$-th edge.\n\nIt is guaranteed that the edges in each test case form an undirected tree and that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print \"NO\" (case-insensitive) if it is impossible to direct all edges of the tree and obtain exactly $n$ good pairs of vertices.\n\nOtherwise, print \"YES\" (case-insensitive) and then print $n - 1$ pairs of integers $u_i$ and $v_i$ separated by spaces\u00a0\u2014 the edges directed from $u_i$ to $v_i$.\n\nThe edges can be printed in any order. If there are multiple answers, output any.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n5\n\n1 2\n\n2 4\n\n1 3\n\n3 5\n\n5\n\n1 2\n\n1 3\n\n1 4\n\n4 5\n\n2\n\n2 1\n\n4\n\n3 1\n\n1 2\n\n2 4\n\n```\n\n#### Output #1\n\n```\nYES\n1 2\n3 1\n3 5\n4 2\nYES\n2 1\n3 1\n4 1\n5 4\nNO\nYES\n1 3\n2 1\n2 4\n```\n\n### Note\n\nThe tree from the first test case and its possible directed version are shown in the legend above. In this version, there are exactly $5$ good pairs of vertices: $(3, 5)$, $(3, 1)$, $(3, 2)$, $(1, 2)$, and $(4, 2)$.\n\nOne possible directed version of the tree from the second test case is shown below:\n\n![](https://espresso.codeforces.com/e52886ce22e1a452186a3dfa3c2cc602f6c4d2ec.png)\n\nIn the presented answer, there are exactly $5$ good pairs of vertices: $(2, 1)$, $(3, 1)$, $(4, 1)$, $(5, 4)$, and $(5, 1)$.\n\nIn the third test case, there are only two directed pairs of vertices, but for any direction of the edge, only one pair will be good.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;                                                // test cases\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n\n        vector<Edge> edges(n - 1);\n        vector<vector<pair<int,int>>> adj(n + 1);         // (neighbour, edge id)\n\n        for (int i = 0; i < n - 1; ++i) {\n            int u, v; cin >> u >> v;\n            edges[i] = {u, v};\n            adj[u].push_back({v, i});\n            adj[v].push_back({u, i});\n        }\n\n        /* ----------------------------------------------------------\n           find a vertex of degree 2 (centre of the unique long path)\n        ---------------------------------------------------------- */\n        int b = -1;                                       // centre\n        for (int i = 1; i <= n; ++i)\n            if ((int)adj[i].size() == 2) { b = i; break; }\n\n        if (b == -1) {                                    // impossible\n            cout << \"NO\\n\";\n            continue;\n        }\n\n        /* neighbours of b  -> a and c                       */\n        int a      = adj[b][0].first;\n        int id_ab  = adj[b][0].second;                    // (a , b)\n        int c      = adj[b][1].first;\n        int id_bc  = adj[b][1].second;                    // (b , c)\n\n        vector<int> tail(n - 1, -1);                      // tail (from) of every edge\n        tail[id_ab] = a;                                  // a -> b\n        tail[id_bc] = b;                                  // b -> c\n\n        /* ----------------------------------------------------------\n           colour the remaining vertices and orient the other edges\n        ---------------------------------------------------------- */\n        vector<int> type(n + 1, -1);                      // 0 = OUT, 1 = IN\n        queue<int> q;\n\n        type[a] = 0;  q.push(a);\n        type[c] = 1;  q.push(c);\n\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (auto [v, id] : adj[u]) {\n                if (v == b) continue;                     // edges with b already fixed\n\n                if (type[v] == -1) {                      // first visit of v\n                    type[v] = type[u] ^ 1;\n                    q.push(v);\n                }\n                if (tail[id] == -1) {                     // orient this edge\n                    if (type[u] == 0) tail[id] = u;       // OUT -> IN\n                    else               tail[id] = v;\n                }\n            }\n        }\n\n        /* ----------------------------------------------------------\n           output\n        ---------------------------------------------------------- */\n        cout << \"YES\\n\";\n        for (int i = 0; i < n - 1; ++i) {\n            int from = tail[i];\n            int to   = (edges[i].u == from ? edges[i].v : edges[i].u);\n            cout << from << ' ' << to << '\\n';\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2112c",
      "PROBLEM_ID": "2112C",
      "PROBLEM_STATEMENT": "Alice and Bob are playing a game using an integer array $a$ of size $n$.\n\nInitially, all elements of the array are colorless. First, Alice chooses $3$ elements and colors them red. Then Bob chooses any element and colors it blue (if it was red\u00a0\u2014 recolor it). Alice wins if the sum of the red elements is strictly greater than the value of the blue element.\n\nYour task is to calculate the number of ways that Alice can choose $3$ elements in order to win regardless of Bob's actions.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 5000$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_1 \\le a_2 \\le \\cdots \\le a_n \\le 10^5$).\n\nAdditional constraint on the input: the sum of $n$ over all test cases doesn't exceed $5000$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the number of ways that Alice can choose $3$ elements in order to win regardless of Bob's actions.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n3\n\n1 2 3\n\n4\n\n1 1 2 4\n\n5\n\n7 7 7 7 7\n\n5\n\n1 1 2 2 4\n\n6\n\n2 3 3 4 5 5\n\n5\n\n1 1 1 1 3\n\n```\n\n#### Output #1\n\n```\n0\n0\n10\n2\n16\n0\n```\n\n### Note\n\nIn the first two test cases, no matter which three elements Alice chooses, Bob will be able to paint one element blue so that Alice does not win.\n\nIn the third test case, Alice can choose any three elements. If Bob colors one of the red elements, the sum of red elements will be $14$, and the sum of blue elements will be $7$. If Bob chooses an uncolored element, the sum of red elements will be $21$, and the sum of blue elements will be $7$.\n\nIn the fourth test case, Alice can choose either the $1$-st, $3$-rd and $4$-th element, or the $2$-nd, $3$-rd and $4$-th element.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        // The input is guaranteed sorted: a[0] <= a[1] <= ... <= a[n-1]\n\n        long long ans = 0;\n        // We treat k as the index of the largest element in the chosen triple.\n        // For each k from 2 to n-1 (0-based), count pairs (i<j<k)\n        // such that a[i] + a[j] > max(a[k], a[n-1] - a[k]).\n        for (int k = 2; k < n; k++) {\n            int T1 = a[k];\n            int T2 = a[n-1] - a[k];\n            int T = max(T1, T2);\n            int l = 0, r = k - 1;\n            while (l < r) {\n                // if a[l] + a[r] > T, then for this r, all pairs (l..r-1, r) are valid\n                if (a[l] + a[r] > T) {\n                    ans += (r - l);\n                    r--;\n                } else {\n                    l++;\n                }\n            }\n        }\n\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2112a",
      "PROBLEM_ID": "2112A",
      "PROBLEM_STATEMENT": "Alice and Bob participate in a game TV show. When the game starts, the prize will be dropped to a certain point, and whoever gets to it first will get the prize.\n\nAlice decided that she would start running from point $a$. Bob, however, has not yet chosen his starting position.\n\nBob knows that the prize could drop either at point $x$ or at point $y$. He also knows that he can reach the prize faster than Alice if the distance from his starting position to the prize is strictly less than the distance from Alice's starting position to the prize. The distance between any two points $c$ and $d$ is calculated as $|c-d|$.\n\nYour task is to determine whether Bob can choose an integer point that is guarantee to get to the prize faster, regardless of where it appears (at point $x$ or $y$). Bob can choose any integer point, except for $a$ (in particular, he can choose to start in point $x$, point $y$, or any other point, but not $a$).\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains three integers $a$, $x$, $y$ ($1 \\le a, x, y \\le 100$). Points $a$, $x$, and $y$ are pairwise distinct.\n\n### Output\n\nFor each test case, print \"YES\" (case insensitive) if Bob can choose an integer point that is guarantee to get to the prize faster, regardless of where it appears. Otherwise, print \"NO\" (case insensitive).\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n1 3 4\n\n5 3 1\n\n3 1 5\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\n```\n\n### Note\n\nIn the first example, Bob can choose point $4$. If the prize will be at point $x$, then Bob's distance is $|4-3|=1$ and Alice's distance is $|1-3|=2$. If the prize will be at point $y$, then Bob's distance is $|4-4|=0$ and Alice's distance is $|1-4|=3$.\n\nIn the second example, Bob can choose point $2$. If the prize will be at point $x$, then Bob's distance is $|2-3|=1$ and Alice's distance is $|5-3|=2$. If the prize will be at point $y$, then Bob's distance is $|2-1|=1$ and Alice's distance is $|5-1|=4$.\n\nIn the third example, Bob cannot choose a point to guarantee his victory.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nbool canBobWin(int a, int x, int y) {\n    int leftX, rightX, leftY, rightY;\n    \n    // Calculate interval for condition |b-x| < |a-x|\n    if (a < x) {\n        leftX = a;\n        rightX = 2 * x - a;\n    } else {\n        leftX = 2 * x - a;\n        rightX = a;\n    }\n    \n    // Calculate interval for condition |b-y| < |a-y|\n    if (a < y) {\n        leftY = a;\n        rightY = 2 * y - a;\n    } else {\n        leftY = 2 * y - a;\n        rightY = a;\n    }\n    \n    // Find the intersection of both intervals\n    int leftBound = max(leftX, leftY);\n    int rightBound = min(rightX, rightY);\n    \n    // Check if there's at least one integer in the open interval (leftBound, rightBound)\n    // Since the interval is open and one endpoint is always 'a', \n    // we need at least 2 units of space to have an integer that isn't 'a'\n    return rightBound - leftBound >= 2;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int a, x, y;\n        cin >> a >> x >> y;\n        \n        if (canBobWin(a, x, y)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2111g",
      "PROBLEM_ID": "2111G",
      "PROBLEM_STATEMENT": "Technically, this is an interactive problem.\n\nAn array $a$ of $m$ numbers is called divisible if at least one of the following conditions holds:\n\n- There exists an index $i$ ($1 \\le i < m$) and an integer $x$ such that for all indices $j$ ($j \\le i$), it holds that $a_{j} \\le x$ and for all indices $k$ ($k > i$), it holds that $a_{k} > x$.\n- There exists an index $i$ ($1 \\le i < m$) and an integer $x$ such that for all indices $j$ ($j \\le i$), it holds that $a_{j} > x$ and for all indices $k$ ($k > i$), it holds that $a_{k} \\le x$.\n\nYou are given a permutation $p$ of integers $1, 2, \\dots, n$. Your task is to answer queries of the following form fast: if we take only the segment \\[$l$, $r$\\] from the permutation, that is, the numbers $p_{l}, p_{l + 1}, \\dots, p_{r}$, is this subarray of numbers divisible?\n\nQueries will be submitted in interactive mode in groups of $10$, meaning you will not receive the next group of queries until you output all answers for the current group.\n\n### Input\n\nThe first line contains one integer $n$ ($2 \\le n \\le 2 \\cdot 10^{5}$)\u00a0\u2014 the size of the permutation.\n\nThe second line contains $n$ integers $p_{i}$ ($1 \\le p_{i} \\le n$)\u00a0\u2014 the permutation of natural numbers itself.\n\nThe third line contains one integer $q$ ($10 \\le q \\le 10^{6}, q \\bmod 10 = 0$)\u00a0\u2014 the number of queries.\n\nThe following $q$ lines contain two integers $l$ and $r$ ($1 \\le l < r \\le n$)\u00a0\u2014 the parameters of the query.\n\n### Output\n\nFor each query, output the string \"YES\" if the subarray from this query is divisible and \"NO\" otherwise.\n\nAfter printing the answers to a group of queries, do not forget to output the end of line and flush the output buffer. Otherwise, you may get the Idleness Limit Exceeded verdict. To flush the buffer, use:\n\n- fflush(stdout) or cout.flush() in C++;\n- System.out.flush() in Java;\n- flush(output) in Pascal;\n- stdout.flush() in Python;\n- refer to the documentation for other languages.\n\nYou have to flush the output buffer after the $10$-th, $20$-th, $30$-th query (and so on), i.\u2009e. after each query with index divisible by $10$. After that, you can read the next group of queries.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n4 2 3 6 1 5 7\n\n20\n\n1 2\n\n1 3\n\n1 4\n\n1 5\n\n1 6\n\n2 3\n\n2 4\n\n2 5\n\n2 6\n\n3 4\n\n3 5\n\n3 6\n\n4 5\n\n4 6\n\n5 6\n\n1 7\n\n2 7\n\n3 7\n\n4 7\n\n5 7\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int INF = 1e9;\nconst int LOGN = 18;\n\nstruct solver{\n    int n;\n    vector<int> p;\n\n    solver(const vector<int> &p) : p(p){\n        n = p.size();\n        build();\n    }\n\n    vector<int> nxtmn, nxtmx;\n\n    vector<vector<int>> up;\n    vector<vector<int>> mx;\n\n    void build(){\n        nxtmx.resize(n);\n        vector<int> stmn, stmx;\n        for (int i = n - 1; i >= 0; --i){\n            while (!stmx.empty() && p[stmx.back()] < p[i])\n                stmx.pop_back();\n            nxtmx[i] = (stmx.empty() ? n : stmx.back());\n            stmx.push_back(i);\n        }\n        vector<vector<int>> qr(n + 1);\n        forn(i, n) qr[nxtmx[i]].push_back(i);\n        nxtmn.assign(n, n);\n        for (int i = n - 1; i >= 0; --i){\n            while (!stmn.empty() && p[stmn.back()] > p[i])\n                stmn.pop_back();\n            stmn.push_back(i);\n            for (int j : qr[i]){\n                int l = 0, r = int(stmn.size()) - 1;\n                while (l <= r){\n                    int m = (l + r) / 2;\n                    if (p[stmn[m]] < p[j]){\n                        nxtmn[j] = stmn[m];\n                        l = m + 1;\n                    }\n                    else{\n                        r = m - 1;\n                    }\n                }\n            }\n        }\n        up.assign(n + 1, vector<int>(LOGN));\n        mx.assign(n + 1, vector<int>(LOGN));\n        forn(i, n){\n            up[i][0] = nxtmx[i];\n            mx[i][0] = nxtmn[i];\n        }\n        up[n][0] = n;\n        mx[n][0] = 0;\n        for (int j = 1; j < LOGN; ++j) forn(i, n + 1){\n            up[i][j] = up[up[i][j - 1]][j - 1];\n            mx[i][j] = max(mx[i][j - 1], mx[up[i][j - 1]][j - 1]);\n        }\n    }\n\n    bool query(int l, int r){\n        int v = l;\n        for (int i = LOGN - 1; i >= 0; --i){\n            if (up[v][i] >= r) continue;\n            if (mx[v][i] >= r) return true;\n            v = up[v][i];\n        }\n        return false;\n    }\n};\n\nint main(){\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<vector<int>> p(2, vector<int>(n));\n    forn(i, n){\n        cin >> p[0][i];\n        --p[0][i];\n    }\n    p[1] = p[0];\n    reverse(p[1].begin(), p[1].end());\n    solver p0(p[0]);\n    solver p1(p[1]);\n    int m;\n    cin >> m;\n    forn(i, m){\n\t\tif (i % 10 == 0){\n\t\t\tcout.flush();\n\t\t}\n        int l, r;\n        cin >> l >> r;\n        --l; -- r;\n        bool ans = p0.query(l, r + 1) || p1.query(n - r - 1, n - l);\n        cout << (ans ? \"YES\\n\" : \"NO\\n\");\n    }\n    cout.flush();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2111f",
      "PROBLEM_ID": "2111F",
      "PROBLEM_STATEMENT": "You have been gifted a puzzle, where each piece of this puzzle is a square with a side length of one. You can glue any picture onto this puzzle, cut it, and obtain an almost ordinary jigsaw puzzle.\n\nYour friend is an avid mathematician, so he suggested you consider the following problem. Is it possible to arrange the puzzle pieces in such a way that the following conditions are met:\n\n- the pieces are aligned parallel to the coordinate axes;\n- the pieces do not overlap each other;\n- all pieces form a single connected component (i.e., there exists a path from each piece to every other piece along the pieces, where each two consecutive pieces share a side);\n- the ratio of the perimeter of this component to the area of this component equals $\\frac{p}{s}$;\n- the number of pieces used does not exceed $50\\,000$.\n\nCan you handle it?\n\n![](https://espresso.codeforces.com/21225771b06e268653d52533d80b6910fcaf58fb.png)For this figure, the ratio of the perimeter to the area is $\\frac{11}{9}$\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains two integers $p$ and $s$ ($1 \\le p, s \\le 50$).\n\n### Output\n\nFor each test case:\n\n- if it is impossible to arrange the pieces as described above, output a single integer $-1$;\n- otherwise, in the first line output a single integer $k$ ($1 \\le k \\le 50\\,000$), and then in $k$ lines output the coordinates of the pieces: each line should contain two integers $x_{i}$ and $y_{i}$ ($-10^{9} \\le x_{i}, y_{i} \\le 10^{9}$). If there are multiple suitable arrangements of the pieces, output any of them.\n\n### Examples\n\n#### Input #1\n\n```\n\n2\n\n1 1\n\n31 4\n\n```\n\n#### Output #1\n\n```\n20\n3 7\n3 8\n6 4\n6 5\n3 5\n4 4\n4 5\n4 3\n3 4\n5 3\n5 4\n5 7\n3 6\n4 6\n5 5\n5 6\n4 7\n4 8\n6 6\n6 7\n-1\n```\n\n#### Input #2\n\n```\n\n2\n\n4 2\n\n12 5\n\n```\n\n#### Output #2\n\n```\n24\n-7 2\n-3 -3\n-7 -5\n-7 1\n-3 2\n-7 -2\n-3 -5\n-7 -6\n-5 -6\n-3 -4\n-3 -6\n-7 0\n-6 -6\n-7 -3\n-5 2\n-7 -1\n-3 1\n-4 -6\n-3 0\n-7 -4\n-6 2\n-4 2\n-3 -1\n-3 -2\n5\n0 0\n0 1\n1 0\n-1 0\n0 -1\n```\n\n### Note\n\nIn the first test case of the first test, the figure may look like this:\n\n![](https://espresso.codeforces.com/c78a4676f61c6a56a17a58a94d80b977997a016f.png)\n\nIn the second test, the figures look like this:\n\n![](https://espresso.codeforces.com/2d4ef6ccde7efc7b4b537794e8dec6817d5235f2.png)![](https://espresso.codeforces.com/54d05bdd77431e3f82d36d7b022980f2a2ecafa8.png)\n\nNote that the internal perimeter is also taken into account!",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAX_K = 50000;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    if (!(cin >> T)) return 0;\n    while (T--) {\n        ll p, s;\n        cin >> p >> s;\n\n        /* ---------- impossible because ratio would exceed 4 ---------- */\n        if (p > 4 * s) {\n            cout << -1 << '\\n';\n            continue;\n        }\n\n        /* ---------- ratio  > 2  ------------------------------------ */\n        if (p > 2 * s) {\n            ll denom = p - 2 * s;              // > 0\n            if ((2 * s) % denom) {             // not integer\n                cout << -1 << '\\n';\n                continue;\n            }\n            ll k = (2 * s) / denom;            // strip length\n            if (k > MAX_K) {\n                cout << -1 << '\\n';\n                continue;\n            }\n            cout << k << '\\n';\n            for (ll i = 0; i < k; ++i)\n                cout << i << ' ' << 0 << '\\n';\n            continue;\n        }\n\n        /* ---------- ratio  = 2  ------------------------------------ */\n        if (p == 2 * s) {                      // 2\u00d72 block\n            cout << 4 << '\\n';\n            cout << 0 << ' ' << 0 << '\\n';\n            cout << 1 << ' ' << 0 << '\\n';\n            cout << 0 << ' ' << 1 << '\\n';\n            cout << 1 << ' ' << 1 << '\\n';\n            continue;\n        }\n\n        /* ---------- 0 < ratio < 2  ---------------------------------- */\n        ll d = 2 * s - p;                      // positive\n        bool done = false;\n        int bestW = -1, bestH = -1;\n        ll bestT  = -1;\n\n        for (int w = 1; w <= MAX_K && !done; ++w) {\n            int maxH = MAX_K / w;\n            for (int h = 1; h <= maxH; ++h) {\n                ll A0 = 1LL * w * h;\n                ll P0 = 2LL * (w + h);\n                ll n  = 1LL * p * A0 - 1LL * s * P0;\n                if (n < 0) continue;\n                if (n % d) continue;\n                ll t = n / d;\n                if (A0 + t > MAX_K) continue;\n                bestW = w; bestH = h; bestT = t;\n                done = true;\n                break;\n            }\n        }\n\n        if (!done) {                           // should not happen\n            cout << -1 << '\\n';\n            continue;\n        }\n\n        ll k = 1LL * bestW * bestH + bestT;\n        cout << k << '\\n';\n\n        /* rectangle */\n        for (int x = 0; x < bestW; ++x)\n            for (int y = 0; y < bestH; ++y)\n                cout << x << ' ' << y << '\\n';\n\n        /* glued squares \u2013 vertical chain above the rectangle */\n        for (ll i = 0; i < bestT; ++i)\n            cout << 0 << ' ' << bestH + i << '\\n';\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2111e",
      "PROBLEM_ID": "2111E",
      "PROBLEM_STATEMENT": "Given a string $s$ that consists only of the first three letters of the Latin alphabet, meaning each character of the string is either a, b, or c.\n\nAlso given are $q$ operations that need to be performed on the string. In each operation, two letters $x$ and $y$ from the set of the first three letters of the Latin alphabet are provided, and for each operation, one of the following two actions must be taken:\n\n- change any (one) occurrence of the letter $x$ in the string $s$ to the letter $y$ (if at least one occurrence of the letter $x$ exists);\n- do nothing.\n\nThe goal is to perform all operations in the given order in such a way that the string $s$ becomes lexicographically minimal.\n\nRecall that a string $a$ is lexicographically less than a string $b$ if and only if one of the following conditions holds:\n\n- $a$ is a prefix of $b$, but $a \\neq b$;\n- at the first position where $a$ and $b$ differ, the string $a$ has a letter that comes earlier in the alphabet than the corresponding letter in $b$.\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^{3}$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nIn the first line of each test case, there are two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^{5}$)\u00a0\u2014 the length of the string $s$ and the number of operations.\n\nIn the second line of each test case, the string $s$ is given\u00a0\u2014 a string of exactly $n$ characters, each of which is a, b, or c.\n\nThe next $q$ lines of each test case contain the description of the operations. Each line contains two characters $x$ and $y$, each of which is a, b, or c.\n\nAdditional constraints on the input:\n\n- the sum of $n$ across all test cases does not exceed $2 \\cdot 10^{5}$;\n- the sum of $q$ across all test cases does not exceed $2 \\cdot 10^{5}$.\n\n### Output\n\nFor each test case, output the lexicographically minimal string that can be obtained from $s$ using the given operations.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2\n\ncb\n\nc b\n\nb a\n\n10 10\n\nbbbbbbbbbb\n\nb a\n\nb c\n\nc b\n\nb a\n\nc a\n\nb c\n\nb c\n\nb a\n\na b\n\nc a\n\n30 20\n\nabcaababcbbcabcbbcabcbabbbbabc\n\nb c\n\nb c\n\nc a\n\nb c\n\nb c\n\nb a\n\nb c\n\nb c\n\nb a\n\nb a\n\nb a\n\nb a\n\nc a\n\nb c\n\nc a\n\nb c\n\nc a\n\nc a\n\nb c\n\nc b\n\n```\n\n#### Output #1\n\n```\nab\naaaaabbbbb\naaaaaaaaaaaaaaabbbabcbabbbbabc\n```\n\n### Note\n\nIn the first test case, both operations need to be applied to the first letter:\n\n1. after the first operation, $s = $ \"bb\"\n2. after the second operation, $s = $ \"ab\"\n\nIn the second test case, the string could change as follows:\n\n01. \"bbbbabbbbb\" (changed the $5$-th letter)\n02. \"cbbbabbbbb\" (changed the $1$-st letter)\n03. \"cbbbabbbbb\" (did nothing)\n04. \"cbbaabbbbb\" (changed the $4$-th letter)\n05. \"abbaabbbbb\" (changed the $1$-st letter)\n06. \"abcaabbbbb\" (changed the $3$-rd letter)\n07. \"abcaabbbbb\" (did nothing)\n08. \"aacaabbbbb\" (changed the $2$-nd letter)\n09. \"aacaabbbbb\" (did nothing)\n10. \"aaaaabbbbb\" (changed the $3$-rd letter)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t; \n    cin >> t;\n    while(t--){\n        int n, q;\n        cin >> n >> q;\n        string s;\n        cin >> s;\n        \n        // We store indices (1-indexed) for each op type in a multiset.\n        multiset<int> BA, CA, BC, CB;\n        \n        for (int i = 1; i <= q; i++){\n            char x, y;\n            cin >> x >> y;\n            // Only store useful operations\n            if(x=='b' && y=='a'){\n                BA.insert(i);\n            } else if(x=='c' && y=='a'){\n                CA.insert(i);\n            } else if(x=='b' && y=='c'){\n                BC.insert(i);\n            } else if(x=='c' && y=='b'){\n                CB.insert(i);\n            }\n            // All other ops (like a->b or a->c) are not beneficial.\n        }\n        \n        string res;\n        res.resize(n);\n        \n        // Process positions from left (most significant) to right.\n        for (int i = 0; i < n; i++){\n            char cur = s[i];\n            if(cur == 'a'){\n                res[i] = 'a';\n            } else if(cur == 'b'){\n                bool transformed = false;\n                // Option 1: Try direct conversion b -> a using a (b,a) op\n                if(!BA.empty()){\n                    BA.erase(BA.begin());\n                    res[i] = 'a';\n                    transformed = true;\n                } else {\n                    // Option 2: Try indirect conversion: need op from BC then an op from CA (with CA index > chosen BC).\n                    if(!BC.empty()){\n                        int op_bc = *BC.begin();\n                        auto it = CA.lower_bound(op_bc + 1);\n                        if(it != CA.end()){\n                            // We found a valid pair; use them.\n                            BC.erase(BC.begin());\n                            CA.erase(it);\n                            res[i] = 'a';\n                            transformed = true;\n                        }\n                    }\n                    if(!transformed)\n                        res[i] = 'b';\n                }\n            } else if(cur == 'c'){\n                bool transformed = false;\n                // Option for c: try to get final letter 'a'\n                // Option 1: Direct conversion c -> a using (c,a) op.\n                if(!CA.empty()){\n                    CA.erase(CA.begin());\n                    res[i] = 'a';\n                    transformed = true;\n                } else {\n                    // Option 2: indirect: use (c,b) then (b,a)\n                    if(!CB.empty()){\n                        int op_cb = *CB.begin();\n                        auto it = BA.lower_bound(op_cb + 1);\n                        if(it != BA.end()){\n                            CB.erase(CB.begin());\n                            BA.erase(it);\n                            res[i] = 'a';\n                            transformed = true;\n                        }\n                    }\n                }\n                if(!transformed){\n                    // Could not get 'a' from c, try to get c -> b using (c,b) op.\n                    if(!CB.empty()){\n                        CB.erase(CB.begin());\n                        res[i] = 'b';\n                    } else {\n                        // Otherwise, leave it as 'c'\n                        res[i] = 'c';\n                    }\n                }\n            }\n        }\n        \n        cout << res << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2111d",
      "PROBLEM_ID": "2111D",
      "PROBLEM_STATEMENT": "A new semester is about to begin, and it is necessary to create a schedule for the first day. There are a total of $n$ groups and $m$ classrooms in the faculty. It is also known that each group has exactly $6$ classes on the first day, and the $k$-th class of each group takes place at the same time. Each class must be held in a classroom, and at the same time, there cannot be classes for more than one group in the same classroom.\n\nEach classroom has its own index (at least three digits), and all digits of this index, except for the last two, indicate the floor on which the classroom is located. For example, classroom $479$ is located on the $4$-th floor, while classroom $31415$ is on the $314$-th floor. Between floors, one can move by stairs; for any floor $x > 1$, one can either go down to floor $x - 1$ or go up to floor $x + 1$; from the first floor, one can only go up to the second; from the floor $10^7$ (which is the last one), it is possible to go only to the floor $9999999$.\n\nThe faculty's dean's office has decided to create the schedule in such a way that students move as much as possible between floors, meaning that the total number of movements between floors across all groups should be maximized. When the students move from one floor to another floor, they take the shortest path.\n\nFor example, if there are $n = 2$ groups and $m = 4$ classrooms $[479, 290, 478, 293]$, the schedule can be arranged as follows:\n\nClass No.Group 1Group 2$1\n\n$$290$$\n\n293\n\n$$2$$\n\n478\n\n$$479$$\n\n3\n\n$$293$$\n\n290\n\n$$4$$\n\n479\n\n$$478$$\n\n5\n\n$$293$$\n\n290\n\n$$6$$\n\n479$$478$\n\nIn such a schedule, the groups will move between the $2$nd and $4$th floors each time, resulting in a total of $20$ movements between floors.\n\nHelp the dean's office create any suitable schedule!\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^{3}$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le m \\le 10^{5}$)\u00a0\u2014 the number of groups and the number of available classrooms.\n\nThe second line of each test case contains $m$ integers $a_{i}$ ($100 \\le a_{i} < 10^{9}$)\u00a0\u2014 the indices of the available classrooms.\n\nAdditional constraints on the input:\n\n- the numbers of all classrooms are pairwise distinct;\n- the sum of $m$ across all test cases does not exceed $10^{5}$.\n\n### Output\n\nFor each test case, output $n$ lines, where the $i$-th line should contain $6$ integers\u00a0\u2014 the indices of the classrooms where the classes for the $i$-th group will be held.\n\nEach classroom must be occupied by at most one group during the $k$-th class.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 4\n\n479 290 478 293\n\n1 1\n\n31415\n\n6 10\n\n479 385 290 293 384 383 297 478 291 382\n\n```\n\n#### Output #1\n\n```\n290 478 293 479 293 479\n293 479 290 478 290 478\n31415 31415 31415 31415 31415 31415\n479 290 479 290 479 290\n290 479 290 479 290 479\n293 478 293 478 293 478\n297 385 297 385 297 385\n478 293 478 293 478 293\n291 384 291 384 291 384\n```\n\n### Note\n\nIn the third test case, the maximum number of moves between classrooms is $50$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        vector<pair<ll,int>> v(m);\n        for (int i = 0; i < m; i++) {\n            ll a;\n            cin >> a;\n            // floor number is all digits except last two\n            ll fl = a / 100;\n            v[i] = {fl, (int)a};\n        }\n        // sort by floor ascending\n        sort(v.begin(), v.end(),\n             [](auto &x, auto &y) {\n               return x.first < y.first;\n             });\n        // prefix sums of floors\n        vector<ll> pref(m+1, 0);\n        for (int i = 1; i <= m; i++) {\n            pref[i] = pref[i-1] + v[i-1].first;\n        }\n        ll total = pref[m];\n\n        // find p in [0..n] maximizing S(p) = A(p) + B(p)\n        // A(p) = sum_{k=0..p-1} (f[m-1-k] - f[k])\n        //      = (total - pref[m-p]) - pref[p]\n        // B(p) = sum_{j=0..n-p-1} (f[m-(n-p)+j] - f[j])\n        //      = (total - pref[m-(n-p)]) - pref[n-p]\n        ll bestS = LLONG_MIN;\n        int bestP = 0;\n        for (int p = 0; p <= n; p++) {\n            // A(p)\n            ll A = (total - pref[m-p]) - pref[p];\n            int L = n - p;\n            // B(p)\n            ll B = (total - pref[m-L]) - pref[L];\n            ll S = A + B;\n            if (S > bestS) {\n                bestS = S;\n                bestP = p;\n            }\n        }\n        int p = bestP;\n        int L = n - p;\n\n        // Build X_ids (rooms used at odd timeslots)\n        // X_ids = v[0..p-1] and v[m-(n-p) .. m-1]\n        vector<int> X_ids;\n        X_ids.reserve(n);\n        for (int i = 0; i < p; i++) {\n            X_ids.push_back(v[i].second);\n        }\n        for (int i = m - (n - p); i < m; i++) {\n            X_ids.push_back(v[i].second);\n        }\n\n        // Build Y_ids (rooms used at even timeslots)\n        // Y_ids = v[0..n-p-1] and v[m-p .. m-1]\n        vector<int> Y_ids;\n        Y_ids.reserve(n);\n        for (int i = 0; i < n - p; i++) {\n            Y_ids.push_back(v[i].second);\n        }\n        for (int i = m - p; i < m; i++) {\n            Y_ids.push_back(v[i].second);\n        }\n\n        // Now X_ids and Y_ids are each of size n, and sorted by floor ascending\n        // We match X_ids[i] with Y_ids[n-1-i] for i=0..n-1\n        // and print sequence X, Y, X, Y, X, Y\n\n        for (int i = 0; i < n; i++) {\n            int x = X_ids[i];\n            int y = Y_ids[n - 1 - i];\n            // print 6 classes: x y x y x y\n            cout << x;\n            for (int k = 1; k < 6; k++) {\n                if (k & 1) cout << ' ' << y;\n                else      cout << ' ' << x;\n            }\n            cout << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2111c",
      "PROBLEM_ID": "2111C",
      "PROBLEM_STATEMENT": "You are given an array $a_1, a_2, \\dots, a_n$, consisting of $n$ integers.\n\nIn one operation, you are allowed to perform one of the following actions:\n\n- Choose a position $i$ ($1 < i \\le n$) and make all elements to the left of $i$ equal to $a_i$. That is, assign the value $a_i$ to all $a_j$ ($1 \\le j < i$). The cost of such an operation is $(i - 1) \\cdot a_i$.\n- Choose a position $i$ ($1 \\le i < n$) and make all elements to the right of $i$ equal to $a_i$. That is, assign the value $a_i$ to all $a_j$ ($i < j \\le n$). The cost of such an operation is $(n - i) \\cdot a_i$.\n\nNote that the elements affected by an operation may already be equal to $a_i$, but that doesn't change the cost.\n\nYou are allowed to perform any number of operations (including zero). What is the minimum total cost to make all elements of the array equal?\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 5 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$).\n\nThe sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the minimum total cost of operations to make all elements of the array equal.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4\n\n2 4 1 3\n\n3\n\n1 1 1\n\n10\n\n7 5 5 5 10 9 9 4 6 10\n\n```\n\n#### Output #1\n\n```\n3\n0\n35\n```\n\n### Note\n\nIn the first test case, you can perform the operation twice:\n\n- choose $i = 3$ and make all elements to the left of it equal to it, the cost will be $2 \\cdot 1 = 2$;\n- choose $i = 3$ and make all elements to the right of it equal to it, the cost will be $1 \\cdot 1 = 1$.\n\nThe total cost is $2 + 1 = 3$.\n\nIn the second test case, all elements are already equal, so no operations need to be performed.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nstatic const int MAXN = 500000 + 5;\nstatic vector<int> pos[MAXN];\nstatic int prevSArr[MAXN];\nstatic int wLArr[MAXN];\nstatic int wRArr[MAXN];\nstatic int prewRArr[MAXN];\nstatic int minwLArr[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    if (!(cin >> t)) return 0;\n    vector<int> to_clear;\n    to_clear.reserve(1024);\n\n    while (t--) {\n        int n;\n        cin >> n;\n        to_clear.clear();\n        // read array and fill positions\n        for (int i = 1; i <= n; i++) {\n            int a;\n            cin >> a;\n            if (pos[a].empty()) {\n                to_clear.push_back(a);\n            }\n            pos[a].push_back(i);\n        }\n\n        ll answer = LLONG_MAX;\n        // process each distinct value x\n        for (int x : to_clear) {\n            auto &P = pos[x];\n            int m = (int)P.size();\n            if (m == n) {\n                // all equal already\n                answer = 0;\n                // clear for this x\n                P.clear();\n                continue;\n            }\n            // build list of segment indices k where gap >= 2\n            // segments indexed by k=0..m where p_k and p_{k+1}\n            vector<int> segments;\n            segments.reserve(m+1);\n            // consider k = 0 .. m\n            for (int k = 0; k <= m; k++) {\n                int pk = (k == 0 ? 0 : P[k-1]);\n                int pkn = (k == m ? n+1 : P[k]);\n                if (pkn - pk >= 2) {\n                    segments.push_back(k);\n                }\n            }\n            if (segments.empty()) {\n                // no operations needed\n                answer = 0;\n                P.clear();\n                continue;\n            }\n            int k_min = segments.front();\n            int k_max = segments.back();\n\n            // compute wL and wR for i=1..m\n            for (int i = 1; i <= m; i++) {\n                int pi = P[i-1];\n                wLArr[i] = pi - 1;\n                wRArr[i] = n - pi;\n            }\n            // prefix min of wR\n            const int INF = 1000000007;\n            prewRArr[0] = INF;\n            for (int i = 1; i <= m; i++) {\n                prewRArr[i] = min(prewRArr[i-1], wRArr[i]);\n            }\n            // suffix min of wL\n            minwLArr[m+1] = INF;\n            for (int i = m; i >= 1; i--) {\n                minwLArr[i] = min(wLArr[i], minwLArr[i+1]);\n            }\n            // build prevSArr: for each i, largest segment index < i\n            int tptr = 0;\n            int seg_sz = (int)segments.size();\n            int lastSeg = -1;\n            for (int i = 1; i <= m; i++) {\n                while (tptr < seg_sz && segments[tptr] < i) {\n                    lastSeg = segments[tptr];\n                    tptr++;\n                }\n                prevSArr[i] = lastSeg;\n            }\n\n            // compute minimal scaled cost C_scaled\n            ll C_scaled = LLONG_MAX;\n            // only R operation\n            if (k_min > 0) {\n                // can use R at some i <= k_min\n                C_scaled = min<ll>(C_scaled, prewRArr[k_min]);\n            }\n            // only L operation\n            if (k_max + 1 <= m) {\n                C_scaled = min<ll>(C_scaled, minwLArr[k_max + 1]);\n            }\n            // combination of one R and one L\n            for (int i = 1; i <= m; i++) {\n                int prev_k = prevSArr[i];\n                int j_min = prev_k + 1;\n                if (j_min < 1) j_min = 1;\n                if (j_min <= m) {\n                    ll cost = (ll)wRArr[i] + (ll)minwLArr[j_min];\n                    if (cost < C_scaled) C_scaled = cost;\n                }\n            }\n            // final cost for this x\n            ll cost_x = C_scaled * (ll)x;\n            if (cost_x < answer) answer = cost_x;\n\n            // clear positions for x\n            P.clear();\n        }\n\n        // output answer for this test\n        cout << answer << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2111b",
      "PROBLEM_ID": "2111B",
      "PROBLEM_STATEMENT": "There are $n$ Fibonacci cubes, where the side of the $i$-th cube is equal to $f_{i}$, where $f_{i}$ is the $i$-th Fibonacci number.\n\nIn this problem, the Fibonacci numbers are defined as follows:\n\n- $f_{1} = 1$\n- $f_{2} = 2$\n- $f_{i} = f_{i - 1} + f_{i - 2}$ for $i > 2$\n\nThere are also $m$ empty boxes, where the $i$-th box has a width of $w_{i}$, a length of $l_{i}$, and a height of $h_{i}$.\n\nFor each of the $m$ boxes, you need to determine whether all the cubes can fit inside that box. The cubes must be placed in the box following these rules:\n\n- The cubes can only be stacked in the box such that the sides of the cubes are parallel to the sides of the box;\n- Every cube must be placed either on the bottom of the box or on top of other cubes in such a way that all space below the cube is occupied;\n- A larger cube cannot be placed on top of a smaller cube.\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^{3}$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nIn the first line of each test case, there are two integers $n$ and $m$ ($2 \\le n \\le 10, 1 \\le m \\le 2 \\cdot 10^{5}$)\u00a0\u2014 the number of cubes and the number of empty boxes.\n\nThe next $m$ lines of each test case contain $3$ integers $w_{i}$, $l_{i}$, and $h_{i}$ ($1 \\le w_{i}, l_{i}, h_{i} \\le 150$)\u00a0\u2014 the dimensions of the $i$-th box.\n\nAdditional constraints on the input:\n\n- The sum of $m$ across all test cases does not exceed $2 \\cdot 10^{5}$.\n\n### Output\n\nFor each test case, output a string of length $m$, where the $i$-th character is equal to \"1\" if all $n$ cubes can fit into the $i$-th box; otherwise, the $i$-th character is equal to \"0\".\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5 4\n\n3 1 2\n\n10 10 10\n\n9 8 13\n\n14 7 20\n\n2 6\n\n3 3 3\n\n1 2 1\n\n2 1 2\n\n3 2 2\n\n2 3 1\n\n3 2 4\n\n```\n\n#### Output #1\n\n```\n0010\n100101\n```\n\n### Note\n\nIn the first test case, only one box is suitable. The cubes can be placed in it as follows:\n\n![](https://espresso.codeforces.com/54966256bccdbc30210ab7bdc8f99c3da1e1312f.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Space {\n    int x, y, z, z0;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    // Precompute Fibonacci sizes\n    // f[1]=1, f[2]=2, f[i]=f[i-1]+f[i-2]\n    vector<int> fib(11);\n    fib[1] = 1;\n    fib[2] = 2;\n    for(int i = 3; i <= 10; ++i) {\n        fib[i] = fib[i-1] + fib[i-2];\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        string ans;\n        ans.reserve(m);\n\n        // We'll reuse this vector of free spaces for each box\n        vector<Space> spaces;\n        spaces.reserve(25);\n\n        for (int bi = 0; bi < m; ++bi) {\n            int w, l, h;\n            cin >> w >> l >> h;\n\n            // Start with one free space: the whole box\n            spaces.clear();\n            spaces.push_back({w, l, h, 0});\n\n            bool ok = true;\n            // Place cubes in descending order of size\n            for (int i = n; i >= 1; --i) {\n                int s = fib[i];\n                int bestIdx = -1;\n                int bestZ0 = INT_MAX;\n                // Find the lowest\u2010level free space that can fit this cube\n                for (int j = 0; j < (int)spaces.size(); ++j) {\n                    const auto &sp = spaces[j];\n                    if (sp.x >= s && sp.y >= s && sp.z >= s) {\n                        if (sp.z0 < bestZ0) {\n                            bestZ0 = sp.z0;\n                            bestIdx = j;\n                        }\n                    }\n                }\n                if (bestIdx < 0) {\n                    ok = false;\n                    break;\n                }\n                // Remove that space and split it into up to 3 new spaces\n                Space sp = spaces[bestIdx];\n                spaces[bestIdx] = spaces.back();\n                spaces.pop_back();\n\n                int a = sp.x, b = sp.y, c = sp.z, z0 = sp.z0;\n                // Region 1: to the \"right\" of the placed cube\n                if (a - s > 0) {\n                    spaces.push_back({a - s, b, c, z0});\n                }\n                // Region 2: in front of the placed cube\n                if (b - s > 0) {\n                    spaces.push_back({s, b - s, c, z0});\n                }\n                // Region 3: above the placed cube\n                if (c - s > 0) {\n                    spaces.push_back({s, s, c - s, z0 + s});\n                }\n            }\n\n            ans.push_back(ok ? '1' : '0');\n        }\n\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2111a",
      "PROBLEM_ID": "2111A",
      "PROBLEM_STATEMENT": "There are three energy crystals numbered $1$, $2$, and $3$; let's denote the energy level of the $i$-th crystal as $a_i$. Initially, all of them are discharged, meaning their energy levels are equal to $0$. Each crystal needs to be charged to level $x$ (exactly $x$, not greater).\n\nIn one action, you can increase the energy level of any one crystal by any positive amount; however, the energy crystals are synchronized with each other, so an action can only be performed if the following condition is met afterward:\n\n- for each pair of crystals $i$, $j$, it must hold that $a_{i} \\ge \\lfloor\\frac{a_{j}}{2}\\rfloor$.\n\nWhat is the minimum number of actions required to charge all the crystals?\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^{4}$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains a single integer $x$ ($1 \\le x \\le 10^{9}$).\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of actions required to charge all energy crystals to level $x$.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n1\n\n5\n\n14\n\n2025\n\n31415\n\n536870910\n\n1000000000\n\n```\n\n#### Output #1\n\n```\n3\n7\n9\n23\n31\n59\n61\n```\n\n### Note\n\nIn the first test case, one possible sequence of actions is:\n\n\n\n$$[0, 0, 0] \\to [\\color{red}{1}, 0, 0] \\to [1, 0, \\color{red}{1}] \\to [1, \\color{red}{1}, 1]$$\n\nOne of the possible sequences of actions in the second test case is:\n\n\n\n$$[0, 0, 0] \\to [\\color{red}{1}, 0, 0] \\to [1, \\color{red}{1}, 0] \\to [1, 1, \\color{red}{2}] \\to [\\color{red}{3}, 1, 2] \\to [3, \\color{red}{5}, 2] \\to [\\color{red}{5}, 5, 2] \\to [5, 5, \\color{red}{5}]$$\n\n",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long x;\n        cin >> x;\n        \n        // Calculate the number of bits in x\n        int binary_length = 0;\n        long long temp = x;\n        while (temp > 0) {\n            binary_length++;\n            temp >>= 1;\n        }\n        \n        // Apply the formula: 3 + 2 * (binary_length - 1)\n        int min_actions = 3 + 2 * (binary_length - 1);\n        \n        cout << min_actions << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2110f",
      "PROBLEM_ID": "2110F",
      "PROBLEM_STATEMENT": "In 2077, after the world was enslaved by robots, the robots decided to implement an educational reform, and now the operation of taking the modulus is only taught in the faculty of \"Ancient World History\". Here is one of the entrance tasks for this faculty:\n\nWe define the beauty of an array of positive integers $b$ as the maximum $f(b_i, b_j)$ over all pairs $1 \\leq i, j \\leq n$, where $f(x, y) = (x \\bmod y) + (y \\bmod x)$.\n\nGiven an array of positive integers $a$ of length $n$, output $n$ numbers, where the $i$-th number ($1 \\leq i \\leq n$) is the beauty of the array $a_1, a_2, \\ldots, a_i$.\n\n$x \\bmod y$ is the remainder of the division of $x$ by $y$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 10^6$)\u00a0\u2014 the size of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output $n$ integers\u00a0\u2014 the beauties of all prefixes of the array $a$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5\n\n3 1 4 1 5\n\n7\n\n5 11 11 4 2 1 10\n\n```\n\n#### Output #1\n\n```\n0 1 4 4 5\n0 6 6 7 7 7 11\n```\n\n### Note\n\nThe beauty of the array $3$ is $0$.\n\nThe beauty of the array $3, 1$ is $f(3, 1) = 1$.\n\nThe beauty of the array $3, 1, 4$ is $f(3, 4) = 4$.\n\nThe beauty of the array $3, 1, 4, 1$ is $f(4, 3) = 4$.\n\nThe beauty of the array $3, 1, 4, 1, 5$ is $f(4, 5) = 5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint f(int x, int y) {\n    return (x % y) + (y % x);\n}\n\nvoid Solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    int ans = 0;\n    int mx = a[0];\n    for (int i = 0; i < n; ++i) {\n        ans = max(ans, f(mx, a[i]));\n        if (a[i] > mx) {\n            if (a[i] >= mx * 2) {\n                mx = a[i];\n                for (int j = 0; j < i; ++j) {\n                    ans = max(ans, f(a[i], a[j]));\n                }\n            } else {\n                mx = a[i];\n                ans = mx;\n            }\n        }\n        cout << ans << ' ';\n    }\n    cout << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        Solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2110d",
      "PROBLEM_ID": "2110D",
      "PROBLEM_STATEMENT": "In 2077, when robots took over the world, they decided to compete in the following game.\n\nThere are $n$ checkpoints, and the $i$-th checkpoint contains $b_i$ batteries. Initially, the Robot starts at the $1$-st checkpoint with no batteries and must reach the $n$-th checkpoint.\n\nThere are a total of $m$ one-way passages between the checkpoints. The $i$-th passage allows movement from point $s_i$ to point $t_i$ ($s_i < t_i$), but not the other way. Additionally, the $i$-th passage can only be used if the robot has at least $w_i$ charged batteries; otherwise, it will run out of power on the way.\n\nWhen the robot arrives at point $v$, it can additionally take any number of batteries from $0$ to $b_v$, inclusive. Moreover, it always carries all previously collected batteries, and at each checkpoint, it recharges all previously collected batteries.\n\nFind the minimum number of batteries that the robot can have at the end of the journey, or report that it is impossible to reach from the first checkpoint to the last.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n, m$ ($2 \\leq n \\leq 2 \\cdot 10^5, 0 \\leq m \\leq 3 \\cdot 10^5$)\u00a0\u2014 the number of checkpoints and the number of passages, respectively.\n\nThe second line contains $n$ numbers $b_i$ ($0 \\leq b_i \\leq 10^9$)\u00a0\u2014 the number of batteries at the $i$-th checkpoint.\n\nThe next $m$ lines contain three integers $s_i, t_i, w_i$ ($1 \\leq s_i < t_i \\leq n, 1 \\leq w_i \\leq 10^9$)\u00a0\u2014 the endpoints of the passage and the minimum number of batteries required to pass through it.\n\nIt is guaranteed that the sum of $n$ does not exceed $2 \\cdot 10^5$.\n\nIt is guaranteed that the sum of $m$ does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the minimum number of batteries that you can have at the end of the journey, or $-1$ if it is impossible to reach point $n$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 3\n\n2 0 0\n\n1 2 1\n\n2 3 1\n\n1 3 2\n\n5 6\n\n2 2 5 0 1\n\n1 2 2\n\n1 3 1\n\n1 4 3\n\n3 5 5\n\n2 4 4\n\n4 5 3\n\n2 0\n\n1 1\n\n4 4\n\n3 10 0 0\n\n1 2 1\n\n1 3 3\n\n2 3 10\n\n3 4 5\n\n```\n\n#### Output #1\n\n```\n1\n4\n-1\n10\n```\n\n### Note\n\nIn the first test case, you need to take $1$ battery at the starting point, then move to point $2$, and then to point $3$.\n\nIn the second test case, you need to take $2$ batteries at the starting point, then move to point $2$, take another $2$ batteries, move to point $4$, and then to point $5$.\n\nIn the third test case, there is no path from point $1$ to point $n$.\n\nIn the fourth test case, you need to take $1$ battery at the starting point, then move to point $2$, take another $9$ batteries, move to point $3$, and then to point $4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\n \n// Structure for graph edges.\nstruct Edge {\n    int to;\n    ll req;\n};\n \n// We represent an achievable interval for \u201cleaving state\u201d as [L,R]\nstruct Interval {\n    ll L, R;\n};\n \n// Main\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t; \n    cin >> t;\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n        vector<ll> b(n+1);\n        for (int i = 1; i <= n; i++){\n            cin >> b[i];\n        }\n \n        // Build graph; note: passages go from lower to higher index.\n        vector<vector<Edge>> graph(n+1);\n        for (int i = 0; i < m; i++){\n            int s, t;\n            ll w;\n            cin >> s >> t >> w;\n            graph[s].push_back({t, w});\n        }\n \n        // dp[i] will store (a union of) intervals of achievable \u201cleaving states\u201d at checkpoint i.\n        vector<vector<Interval>> dp(n+1);\n        // At checkpoint 1, the robot arrives with 0 and may take up to b[1] batteries.\n        dp[1].push_back({0, b[1]});\n \n        // Process nodes in increasing order. (The graph is a DAG.)\n        for (int i = 1; i <= n; i++){\n            if(dp[i].empty()) continue; // no reachable state here\n \n            // Merge intervals at i.\n            vector<Interval> merged;\n            {\n                sort(dp[i].begin(), dp[i].end(), [](const Interval &a, const Interval &b){\n                    if(a.L == b.L) return a.R < b.R;\n                    return a.L < b.L;\n                });\n                Interval cur = dp[i][0];\n                for (size_t j = 1; j < dp[i].size(); j++){\n                    if(dp[i][j].L <= cur.R){\n                        cur.R = max(cur.R, dp[i][j].R);\n                    } else {\n                        merged.push_back(cur);\n                        cur = dp[i][j];\n                    }\n                }\n                merged.push_back(cur);\n            }\n            dp[i] = move(merged);\n \n            // Propagate from checkpoint i along each outgoing edge.\n            for(auto &edge : graph[i]){\n                int j = edge.to;\n                ll req = edge.req;\n                // For each interval in dp[i], only the part \u2265 req can be used\n                for(auto &intv : dp[i]){\n                    if(intv.R < req) continue; // no value in this interval meets the requirement\n                    ll newL = max(intv.L, req);\n                    // When arriving at j you can add up to b[j] batteries,\n                    // so you can leave j with any battery count in [x, x + b[j]].\n                    // As x varies in [max(L,req), intv.R], taking union gives:\n                    ll newR = intv.R + b[j];\n                    dp[j].push_back({newL, newR});\n                }\n            }\n        }\n \n        // Answer: if dp[n] is empty, there is no feasible path.\n        // Otherwise, the answer is the smallest achievable battery count at checkpoint n,\n        // i.e. the minimum L among the intervals in dp[n] (after merging).\n        if(dp[n].empty()){\n            cout << -1 << \"\\n\";\n        } else {\n            vector<Interval> merged;\n            sort(dp[n].begin(), dp[n].end(), [](const Interval &a, const Interval &b){\n                if(a.L == b.L) return a.R < b.R;\n                return a.L < b.L;\n            });\n            Interval cur = dp[n][0];\n            for (size_t j = 1; j < dp[n].size(); j++){\n                if(dp[n][j].L <= cur.R)\n                    cur.R = max(cur.R, dp[n][j].R);\n                else{\n                    merged.push_back(cur);\n                    cur = dp[n][j];\n                }\n            }\n            merged.push_back(cur);\n            ll ans = merged[0].L;\n            cout << ans << \"\\n\";\n        }\n    }\n \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2110c",
      "PROBLEM_ID": "2110C",
      "PROBLEM_STATEMENT": "In 2077, a sport called hobby-droning is gaining popularity among robots.\n\nYou already have a drone, and you want to win. For this, your drone needs to fly through a course with $n$ obstacles.\n\nThe $i$-th obstacle is defined by two numbers $l_i, r_i$. Let the height of your drone at the $i$-th obstacle be $h_i$. Then the drone passes through this obstacle if $l_i \\le h_i \\le r_i$. Initially, the drone is on the ground, meaning $h_0 = 0$.\n\nThe flight program for the drone is represented by an array $d_1, d_2, \\ldots, d_n$, where $h_{i} - h_{i-1} = d_i$, and $0 \\leq d_i \\leq 1$. This means that your drone either does not change height between obstacles or rises by $1$. You already have a flight program, but some $d_i$ in it are unknown and marked as $-1$. Replace the unknown $d_i$ with numbers $0$ and $1$ to create a flight program that passes through the entire obstacle course, or report that it is impossible.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nIn the first line of each test case, an integer $n$ ($1 \\le n \\le 2 \\cdot 10^5)$ is given\u00a0\u2014 the size of the array $d$.\n\nIn the second line of each test case, there are $n$ integers $d_1, d_2, \\ldots, d_n$ ($-1 \\leq d_i \\leq 1$)\u00a0\u2014 the elements of the array $d$. $d_i = -1$ means that this $d_i$ is unknown to you.\n\nNext, there are $n$ lines containing $2$ integers $l_i,r_i$ ($0\\leq l_i\\leq r_i\\leq n$)\u00a0\u2014 descriptions of the obstacles.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n$ integers $d_1,d_2,\\ldots,d_n$, if it is possible to correctly restore the array $d$, or $-1$ if it is not possible.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4\n\n0 -1 -1 1\n\n0 4\n\n1 2\n\n2 4\n\n1 4\n\n3\n\n0 -1 -1\n\n0 1\n\n2 2\n\n0 3\n\n2\n\n-1 -1\n\n0 0\n\n2 2\n\n8\n\n-1 -1 1 -1 -1 0 0 -1\n\n0 0\n\n0 1\n\n0 2\n\n0 2\n\n1 3\n\n0 4\n\n2 5\n\n4 5\n\n1\n\n0\n\n1 1\n\n```\n\n#### Output #1\n\n```\n0 1 1 1\n-1\n-1\n0 1 1 0 1 0 0 1\n-1\n```\n\n### Note\n\nIn the first test case, one possible answer is $d=[0,1,1,1]$. The array $h$ will be $[0,0+1,0+1+1,0+1+1+1]=[0,1,2,3]$. This array meets the conditions of the problem.\n\nIn the second test case, it can be proven that there is no suitable array $d$, so the answer is $-1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAXN = 200000 + 5;\nint d_arr[MAXN], l_arr[MAXN], r_arr[MAXN];\nint L[MAXN], R[MAXN], ans[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        for (int i = 1; i <= n; ++i) {\n            cin >> d_arr[i];\n        }\n        for (int i = 1; i <= n; ++i) {\n            cin >> l_arr[i] >> r_arr[i];\n        }\n\n        // DP forward: compute feasible interval [L[i], R[i]] for h[i]\n        bool possible = true;\n        L[0] = R[0] = 0;\n        for (int i = 1; i <= n; ++i) {\n            int li = l_arr[i], ri = r_arr[i];\n            if (d_arr[i] == -1) {\n                // unknown: can stay or go up\n                L[i] = max(li, L[i-1]);\n                R[i] = min(ri, R[i-1] + 1);\n            } else if (d_arr[i] == 0) {\n                // must stay\n                L[i] = max(li, L[i-1]);\n                R[i] = min(ri, R[i-1]);\n            } else {\n                // must go up\n                L[i] = max(li, L[i-1] + 1);\n                R[i] = min(ri, R[i-1] + 1);\n            }\n            if (L[i] > R[i]) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (!possible) {\n            cout << \"-1\\n\";\n            continue;\n        }\n\n        // Backtrack to build one valid sequence\n        int curr_h = R[n];  // pick any h[n] in [L[n], R[n]], choose R[n]\n        for (int i = n; i >= 1; --i) {\n            if (d_arr[i] == 0) {\n                // horizontal\n                ans[i] = 0;\n                // h_{i-1} = curr_h\n            } else if (d_arr[i] == 1) {\n                // up\n                ans[i] = 1;\n                curr_h = curr_h - 1;\n            } else {\n                // unknown: pick horizontal if possible, else up\n                if (curr_h >= L[i-1] && curr_h <= R[i-1]) {\n                    ans[i] = 0;\n                    // h_{i-1} stays curr_h\n                } else {\n                    ans[i] = 1;\n                    curr_h = curr_h - 1;\n                }\n            }\n        }\n        // curr_h should be 0 here (h[0]=0)\n\n        // Output the filled sequence\n        for (int i = 1; i <= n; ++i) {\n            cout << ans[i] << (i == n ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2110b",
      "PROBLEM_ID": "2110B",
      "PROBLEM_STATEMENT": "In 2077, robots decided to get rid of balanced bracket sequences once and for all!\n\nA bracket sequence is called balanced if it can be constructed by the following formal grammar.\n\n1. The empty sequence $\\varnothing$ is balanced.\n2. If the bracket sequence $A$ is balanced, then $\\mathtt{(}A\\mathtt{)}$ is also balanced.\n3. If the bracket sequences $A$ and $B$ are balanced, then the concatenated sequence $A B$ is also balanced.\n\nYou are the head of the department for combating balanced bracket sequences, and your main task is to determine which brackets you can destroy and which you cannot.\n\nYou are given a balanced bracket sequence represented by a string $s$, consisting of the characters ( and ). Since the robots' capabilities are not limitless, they can remove exactly one opening bracket and exactly one closing bracket from the string.\n\nYour task is to determine whether the robots can delete such two brackets so that the string $s$ is no longer a balanced bracket sequence.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nEach test case consists of a single string $s$ ($2 \\leq |s| \\leq 2 \\cdot 10^5$)\u00a0\u2014 a sequence of the characters ( and ).\n\nIt is guaranteed that $s$ is a balanced bracket sequence.\n\nIt is also guaranteed that the sum of $|s|$ across all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output \"YES\" if the robots can make the string stop being a balanced bracket sequence, and \"NO\" otherwise.\n\nYou may output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n(())\n\n(())()()\n\n()\n\n(())(())\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nNO\nYES\n```\n\n### Note\n\nIn the first test case, it can be shown that the robots will not be able to break the correct bracket sequence.\n\nIn the second test case, one of the options for removing brackets is as follows:\n\n$\\texttt{(())}\\color{red}{\\texttt{(}}\\texttt{)(}\\color{red}{\\texttt{)}} \\rightarrow \\texttt{(()))(}$, which is not a correct bracket sequence.\n\nIn the fourth test case, one of the options for removal is as follows:\n\n$\\texttt{(}\\color{red}{\\texttt{(}}\\texttt{))((}\\color{red}{\\texttt{)}}\\texttt{)}\\rightarrow \\texttt{())(()}$, which is not a correct bracket sequence.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(const string& s) {\n    int n = s.size();\n    \n    // Compute the balance at each position\n    int balance = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(') balance++;\n        else balance--;\n        \n        // If the balance is 0 at a position other than the end,\n        // it means we have multiple balanced subsequences\n        if (balance == 0 && i < n - 1) {\n            return \"YES\";\n        }\n    }\n    \n    return \"NO\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        string s;\n        cin >> s;\n        cout << solve(s) << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2110a",
      "PROBLEM_ID": "2110A",
      "PROBLEM_STATEMENT": "In 2077, everything became fashionable among robots, even arrays...\n\nWe will call an array of integers $a$ fashionable if $\\min(a) + \\max(a)$ is divisible by $2$ without a remainder, where $\\min(a)$\u00a0\u2014 the value of the minimum element of the array $a$, and $\\max(a)$\u00a0\u2014 the value of the maximum element of the array $a$.\n\nYou are given an array of integers $a_1, a_2, \\ldots, a_n$. In one operation, you can remove any element from this array. Your task is to determine the minimum number of operations required to make the array $a$ fashionable.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($1 \\leq n \\leq 50$)\u00a0\u2014 the size of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 50$)\u00a0\u2014 the elements of the array $a$.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the minimum number of operations required to make the array $a$ fashionable.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n2\n\n5 2\n\n7\n\n3 1 4 1 5 9 2\n\n7\n\n2 7 4 6 9 11 5\n\n3\n\n1 2 1\n\n2\n\n2 1\n\n8\n\n8 6 3 6 4 1 1 6\n\n```\n\n#### Output #1\n\n```\n1\n0\n2\n1\n1\n3\n```\n\n### Note\n\nIn the first test case, at least one element needs to be removed since $\\min(a)+\\max(a)=2+5=7$, and $7$ is not divisible by $2$. If any of the elements are removed, only one element will remain. Then $\\max(a) + \\min(a)$ will be divisible by $2$.\n\nIn the second test case, nothing needs to be removed since $\\min(a)+\\max(a)=1+9=10$, and $10$ is divisible by $2$.\n\nIn the third test case, you can remove the elements with values $2$ and $4$, then $\\min(a)+\\max(a)=5+11=16$, and $16$ is divisible by $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint minOperations(vector<int>& a) {\n    int n = a.size();\n    sort(a.begin(), a.end());\n    \n    // Check if the array is already fashionable\n    if ((a[0] + a[n-1]) % 2 == 0) {\n        return 0;\n    }\n    \n    // Get unique elements and their frequencies\n    vector<int> unique;\n    vector<int> freq;\n    \n    for (int i = 0; i < n; i++) {\n        if (unique.empty() || unique.back() != a[i]) {\n            unique.push_back(a[i]);\n            freq.push_back(1);\n        } else {\n            freq.back()++;\n        }\n    }\n    \n    int m = unique.size();\n    \n    // Precompute the number of elements less than each unique element\n    vector<int> less_than(m, 0);\n    for (int i = 1; i < m; i++) {\n        less_than[i] = less_than[i-1] + freq[i-1];\n    }\n    \n    // Precompute the number of elements greater than each unique element\n    vector<int> greater_than(m, 0);\n    for (int i = m-2; i >= 0; i--) {\n        greater_than[i] = greater_than[i+1] + freq[i+1];\n    }\n    \n    int min_ops = INT_MAX;\n    \n    // For each potential minimum and maximum\n    for (int i = 0; i < m; i++) {\n        for (int j = i; j < m; j++) {\n            int potential_min = unique[i];\n            int potential_max = unique[j];\n            \n            if ((potential_min + potential_max) % 2 == 0) {\n                // Count elements to remove (those less than min or greater than max)\n                int ops = less_than[i] + greater_than[j];\n                min_ops = min(min_ops, ops);\n            }\n        }\n    }\n    \n    return min_ops;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        \n        cout << minOperations(a) << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2109f",
      "PROBLEM_ID": "2109F",
      "PROBLEM_STATEMENT": "Mouf, the clever master of Darkness, and Fouad, the brave champion of Light, have entered the Grid Realm once more. This time, they have found the exit, but it is guarded by fierce monsters! They must fight with their bare hands instead of summoning monsters!\n\nMouf and Fouad are standing on an $n \\times n$ grid. Each cell $(i, j)$ has a value $a_{i,j}$ and a color. The color of a cell is white if $c_{i,j} = 0$ and black if $c_{i,j} = 1$.\n\nMouf starts at the top-left corner $(1, 1)$, and Fouad starts at the bottom-left corner $(n, 1)$. Both are trying to reach the exit cell at $(r, n)$.\n\nA path is defined as a sequence of adjacent cells (sharing a horizontal or vertical edge). The cost of a path is the maximum value of $a_{i, j}$ among all cells included in the path (including the first and last cells).\n\nLet:\n\n- $\\mathrm{dis}_M$ denote the minimum possible cost of a valid path from Mouf's starting position $(1, 1)$ to the exit $(r, n)$;\n- $\\mathrm{dis}_F$ denote the minimum possible cost of a valid path from Fouad's starting position $(n, 1)$ to the exit $(r, n)$.\n\nBefore moving, Mouf can perform up to $k$ operations. In each operation, he may select any black cell and increment its value by $1$ (possibly choosing the same cell multiple times).\n\nMouf wants to maximize $\\mathrm{dis}_F$ while ensuring that his own cost $\\mathrm{dis}_M$ remains unchanged (as if he performed no operations). If Mouf acts optimally, what are the values of $\\mathrm{dis}_M$ and $\\mathrm{dis}_F$?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $r$, and $k$ ($2 \\le n \\le 300$, $1 \\le r \\le n$, $0 \\le k \\le 10^6$)\u00a0\u2014 the length of the grid, the row number of the exit cell, and the number of allowed operations.\n\nThe $i$-th of the next $n$ lines contains $n$ integers $a_{i,1}, a_{i,2}, \\ldots, a_{i,n}$ ($1 \\le a_{ij} \\le 10^6$)\u00a0\u2014 the values of the cells in the $i$-th row.\n\nThe $i$-th of the next $n$ lines contains a binary string $c_i$ of length $n$\u00a0\u2014 denoting the color of the cells in the $i$-th row (cell $(i,j)$ is white if $c_{i,j}=\\mathtt{0}$ and black if $c_{i,j} = \\mathtt{1}$).\n\nIt is guaranteed that the sum of $n^2$ over all test cases does not exceed $9 \\cdot 10^4$.\n\n### Output\n\nFor each test case, output two integers\u00a0\u2014 $\\mathrm{dis}_M$ and $\\mathrm{dis}_F$ if Mouf performs the operations optimally.\n\n### Examples\n\n#### Input #1\n\n```\n\n4\n\n2 1 30\n\n2 2\n\n1 1\n\n11\n\n01\n\n3 3 5\n\n9 2 2\n\n2 3 2\n\n2 2 2\n\n111\n\n111\n\n010\n\n7 3 12\n\n3 3 3 3 5 1 1\n\n9 4 8 3 3 5 5\n\n9 4 8 7 3 3 3\n\n4 4 4 4 9 4 9\n\n4 4 4 4 9 4 9\n\n1 4 4 4 4 4 9\n\n1 1 4 4 9 9 9\n\n1111111\n\n1011111\n\n1011111\n\n1111111\n\n1111101\n\n1110001\n\n0111111\n\n5 3 1419\n\n1219 678 1672 1858 1210\n\n535 732 1316 345 296\n\n1106 3060 507 216 1943\n\n194 2124 47 87 4818\n\n1007 329 1425 284 660\n\n00010\n\n10111\n\n00101\n\n10001\n\n10100\n\n```\n\n#### Output #1\n\n```\n2 2\n9 5\n3 8\n1943 2426\n```\n\n#### Input #2\n\n```\n\n1\n\n8 2 2216\n\n429 589 675 2022 259 452 733 967\n\n1097 2880 256 1894 259 1052 345 692\n\n911 831 513 1243 200 14 854 217\n\n611 882 681 279 54 719 1469 1885\n\n504 2524 1332 17 3113 34 1281 717\n\n498 1896 1800 2231 731 364 69 1247\n\n1397 399 68 448 1337 1076 166 3786\n\n16 857 91 475 106 102 1517 1949\n\n01010100\n\n00101100\n\n00001000\n\n10100110\n\n00001000\n\n00100000\n\n01100011\n\n00001000\n\n```\n\n#### Output #2\n\n```\n733 1671\n```\n\n### Note\n\nIn the first test case:\n\n- Although Mouf can perform up to $30$ operations, he can not increase $\\mathrm{dis}_F$ beyond $2$; he is restricted to applying operations only on $(2,2)$, because performing operations on $(1,1)$ or $(1,2)$ would change $\\mathrm{dis}_M$.\n- Mouf may apply all $30$ operations on cell $(2,2)$; however, Fouad can still follow the path $(2,1) \\rightarrow (1,1) \\rightarrow (1,2)$ with a cost of $2$.\n\nIn the second test case, Mouf can apply two operations on $(2,2)$ and three operations on $(3,2)$. It can be shown that Mouf can not increase $\\mathrm{dis}_F$ beyond $5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconstexpr int inf = 1e9;\narray<int, 8> dx{0, 0, 1, -1, 1, 1, -1, -1};\narray<int, 8> dy{1, -1, 0, 0, -1, 1, -1, 1};\n\nvoid solve() {\n    int n, r, k;\n    cin >> n >> r >> k;\n    --r;\n    \n    vector a(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> a[i][j];\n        }\n    }\n    \n    vector b(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < n; ++j) {\n            b[i][j] = s[j] - '0';\n        }\n    }\n    \n    auto in = [&](int i, int j) {\n        return (0 <= i && i < n && 0 <= j && j < n);\n    };\n    \n    priority_queue<array<int, 3>, vector<array<int, 3>>, greater<>> pq;\n    pq.push({a[0][0], 0, 0});\n    vector dis(n, vector<int>(n, inf));\n    dis[0][0] = a[0][0];\n    while (pq.size()) {\n        auto [mx, i, j] = pq.top();\n        pq.pop();\n        if (dis[i][j] != mx) {\n            continue;\n        }\n        for (int dir = 0; dir < 4; ++dir) {\n            int ni = i + dx[dir];\n            int nj = j + dy[dir];\n            if (in(ni, nj) && dis[ni][nj] > max(mx, a[ni][nj])) {\n                int nmx = max(mx, a[ni][nj]);\n                dis[ni][nj] = nmx;\n                pq.push({nmx, ni, nj});\n            }\n        }\n    }\n    int mouf = dis[r][n - 1];\n    \n    vector dont(n, vector<int>(n));\n    auto run = [&](auto &&run, int i, int j) -> void {\n        for (int dir = 0; dir < 8; ++dir) {\n            int ni = i + dx[dir];\n            int nj = j + dy[dir];\n            if (in(ni, nj) && dont[ni][nj] == 0) {\n                dont[ni][nj] = 1;\n                if (a[ni][nj] > mouf) {\n                    run(run, ni, nj);\n                }\n            }\n        }\n    };\n    \n    for (int j = 0; j < n; ++j) {\n        dont[0][j] = 1;\n        if (a[0][j] > mouf) {\n            run(run, 0, j);\n        }\n    }\n    for (int i = 0; i <= r; ++i) {\n        dont[i][n - 1] = 1;\n        if (a[i][n - 1] > mouf) {\n            run(run, i, n - 1);\n        }\n    }\n    \n    int L = 1, R = 2e6;\n    while (L <= R) {\n        int mid = (L + R) / 2;\n        for (int j = 0; j < n; ++j) {\n            if ((mid > mouf && dont[n - 1][j]) || (mid > a[n - 1][j] && b[n - 1][j] == 0)) {\n                continue;\n            }\n            pq.push({max(0, mid - a[n - 1][j]), n - 1, j});\n        }\n        for (int i = r; i < n; ++i) {\n            if ((mid > mouf && dont[i][n - 1]) || (mid > a[i][n - 1] && b[i][n - 1] == 0)) {\n                continue;\n            }\n            pq.push({max(0, mid - a[i][n - 1]), i, n - 1});\n        }\n        fill(dis.begin(), dis.end(), vector<int>(n, inf));\n        while (pq.size()) {\n            auto [cost, i, j] = pq.top();\n            pq.pop();\n            dis[i][j] = min(dis[i][j], cost);\n            if (dis[i][j] != cost) {\n                continue;\n            }\n            for (int dir = 0; dir < 8; ++dir) {\n                int ni = i + dx[dir];\n                int nj = j + dy[dir];\n                if (in(ni, nj)) {\n                    if ((mid > mouf && dont[ni][nj]) || (mid > a[ni][nj] && b[ni][nj] == 0)) {\n                        continue;\n                    }\n                    if (dis[ni][nj] > cost + max(0, mid - a[ni][nj])) {\n                        int ncost = cost + max(0, mid - a[ni][nj]);\n                        dis[ni][nj] = ncost;\n                        pq.push({ncost, ni, nj});\n                    }\n                }\n            }\n        }\n        int minCost = inf;\n        if (mid <= mouf) {\n            for (int j = 0; j < n; ++j) {\n                minCost = min(minCost, dis[0][j]);\n            }\n            for (int i = 0; i <= r; ++i) {\n                minCost = min(minCost, dis[i][n - 1]);\n            }\n        }\n        for (int i = 1; i < n; ++i) {\n            minCost = min(minCost, dis[i][0]);\n        }\n        if (minCost <= k) {\n            L = mid + 1;\n        } else {\n            R = mid - 1;\n        }\n    }\n            \n    cout << mouf << \" \" << R << \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2109e",
      "PROBLEM_ID": "2109E",
      "PROBLEM_STATEMENT": "Mouf is bored with themes, so he decided not to use any themes for this problem.\n\nYou are given a binary$^{\\text{\u2217}}$ string $s$ of length $n$. You are to perform the following operation exactly $k$ times:\n\n- select an index $i$ ($1 \\le i \\le n$) such that $s_i = \\mathtt{0}$;\n- then flip$^{\\text{\u2020}}$ each $s_j$ for all indices $j$ ($1 \\le j \\le i$).\n\nYou need to count the number of possible ways to perform all $k$ operations.\n\nSince the answer could be ginormous, print it modulo $998\\,244\\,353$.\n\nTwo sequences of operations are considered different if they differ in the index selected at any step.\n\n$^{\\text{\u2217}}$A binary string is a string that consists only of the characters $\\mathtt{0}$ and $\\mathtt{1}$.\n\n$^{\\text{\u2020}}$Flipping a binary character is changing it from $\\mathtt{0}$ to $\\mathtt{1}$ or vice versa.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 500$)\u00a0\u2014 the length of the binary string $s$ and the number of times the operation must be performed, respectively.\n\nThe second line of each test case contains a binary string $s$ of length $n$ consisting of only characters $\\mathtt{0}$ and $\\mathtt{1}$.\n\nIt is guaranteed that the sum of $n$ does not exceed $500$ over all test cases.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the number of ways you can perform exactly $k$ operations, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3 1\n\n010\n\n3 2\n\n000\n\n5 4\n\n01001\n\n8 8\n\n11001100\n\n20 20\n\n10010110101101010110\n\n```\n\n#### Output #1\n\n```\n2\n3\n10\n27286\n915530405\n```\n\n### Note\n\nIn the first test case, here are all the possible sequences of operations:\n\n- $\\mathtt{\\color{red}{0}10} \\xrightarrow{i = 1} \\mathtt{110}$\n- $\\mathtt{\\color{red}{010}} \\xrightarrow{i = 3} \\mathtt{101}$\n\nIn the second test case, here are all the possible sequences of operations:\n\n- $\\mathtt{\\color{red}{0}00} \\xrightarrow{i = 1} \\mathtt{\\color{red}{1}00} \\xrightarrow{i = 2} \\mathtt{010}$\n- $\\mathtt{\\color{red}{0}00} \\xrightarrow{i = 1} \\mathtt{\\color{red}{1}00} \\xrightarrow{i = 3} \\mathtt{011}$\n- $\\mathtt{\\color{red}{00}0} \\xrightarrow{i = 2} \\mathtt{\\color{red}{11}0} \\xrightarrow{i = 3} \\mathtt{001}$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \n// mod constant from the problem statement.\nconst int MOD = 998244353;\n \n// Main \u2013 we precompute binomials up to MAXC (set to 260 which is enough, because in our DP \n// allowed(m, s[i]) is at most about m/2 where m <= 500, so about 250) \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t;\n    cin >> t;\n    const int MAXC = 260;\n    vector<vector<int>> binom(MAXC+1, vector<int>(MAXC+1, 0));\n    for (int i = 0; i <= MAXC; i++){\n        binom[i][0] = 1;\n        for (int j = 1; j <= i; j++){\n            binom[i][j] = ( binom[i-1][j-1] + binom[i-1][j] ) % MOD;\n        }\n    }\n \n    while(t--){\n        int n, k;\n        cin >> n >> k;\n        string s;\n        cin >> s;\n        // dp[i][m] : number of valid ways using indices i..n when the total number of operations \n        // among indices i..n is m.\n        // We use 1-indexing for the string positions (s[0] corresponds to position 1).\n        vector<vector<int>> dp(n+2, vector<int>(k+1, 0));\n \n        // Base: for i = n+1, dp[n+1][0] = 1 and others are zero.\n        dp[n+1][0] = 1;\n        for (int m = 1; m <= k; m++){\n            dp[n+1][m] = 0;\n        }\n \n        // Process i = n down to 1.\n        for (int i = n; i >= 1; i--){\n            for (int m = 0; m <= k; m++){\n                int allowed = 0; // allowed positions in a merged sequence of m moves for index i.\n                if(m % 2 == 0){\n                    allowed = m/2;  \n                } else {\n                    if(s[i-1]=='0'){\n                        allowed = (m+1)/2;\n                    } else {\n                        allowed = (m-1)/2;\n                    }\n                }\n                long long ways = 0;\n                // We decide how many operations, x, among the m moves come from index i.\n                // The remaining m-x will be those coming from indices i+1..n.\n                // Note: if x > allowed then binom[allowed][x] is 0\n                int max_x = min(m, allowed);\n                for (int x = 0; x <= max_x; x++){\n                    int y = m - x; // these many moves are from indices > i.\n                    ways = ( ways + (long long) dp[i+1][y] * binom[allowed][x] ) % MOD;\n                }\n                dp[i][m] = (int) ways;\n            }\n        }\n        cout << dp[1][k] % MOD << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2109d",
      "PROBLEM_ID": "2109D",
      "PROBLEM_STATEMENT": "Of course, a problem with the letter D is sponsored by Declan Akaba.\n\nYou are given a simple, connected, undirected graph with $n$ vertices and $m$ edges. The graph contains no self-loops or multiple edges. You are also given a multiset $A$ consisting of $\\\\ell$ elements: \n\n$$ A = \\{A_1, A_2, \\ldots, A_\\ell\\} $$\n\nStarting from vertex $1$, you may perform the following move any number of times, as long as the multiset $A$ is not empty:\n\n- Select an element $k \\in A$ and remove it from the multiset . You must remove exactly one occurrence of $k$ from $A$.\n- Traverse any walk$^{\\text{\u2217}}$ of exactly $k$ edges to reach some vertex (possibly the same one you started from).\n\nFor each $i$ ($1 \\le i \\le n$), determine whether there exists a sequence of such moves that starts at vertex $1$ and ends at vertex $i$, using the original multiset $A$.\n\nNote that the check for each vertex $i$ is independent\u00a0\u2014 you restart from vertex $1$ and use the original multiset $A$ for each case.\n\n$^{\\text{\u2217}}$A walk of length $k$ is a sequence of vertices $v_0, v_1, \\ldots, v_{k - 1}, v_k$ such that each consecutive pair of vertices $(v_i, v_{i + 1})$ is connected by an edge in the graph. The sequence may include repeated vertices.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $\\ell$ ($2 \\leq n \\leq 2 \\cdot 10^5$, $n-1 \\leq m \\leq 4 \\cdot 10^5$, $1 \\leq \\ell \\leq 2 \\cdot 10^5$)\u00a0\u2014 the number of vertices, the number of edges, and the size of the multiset, respectively.\n\nThe second line of each test case contains $\\ell$ integers $A_1, A_2, \\ldots, A_{\\ell}$ ($1 \\leq A_i \\leq 10^4$)\u00a0\u2014 the elements of the multiset.\n\nEach of the following $m$ lines contains two integers $u$ and $v$ ($1 \\le u < v \\le n$)\u00a0\u2014 the endpoints of an edge in the graph.\n\nIt is guaranteed that the edges form a simple, connected graph without self-loops or multiple edges.\n\nIt is guaranteed that the sum of $n$, the sum of $m$, and the sum of $\\ell$ over all test cases does not exceed $2 \\cdot 10^5$, $4 \\cdot 10^5$, and $2 \\cdot 10^5$, respectively.\n\n### Output\n\nFor each test case, output a binary string of length $n$, where the $i$-th character is $\\mathtt{1}$ if there exists a sequence of moves ending at vertex $i$, and $\\mathtt{0}$ otherwise.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n6 5 2\n\n2 3\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n5 6\n\n5 5 1\n\n5\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n3 5\n\n5 4 3\n\n100 200 300\n\n1 2\n\n1 3\n\n1 4\n\n2 5\n\n```\n\n#### Output #1\n\n```\n111101\n11111\n10001\n```\n\n### Note\n\nIn the first test case:\n\n- Vertex $1$ is reachable without making any moves.\n- Vertex $2$ is reachable by selecting element $3 \\in A$; one possible walk is \\[$1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 2$\\].\n- Vertex $3$ can be reached by selecting element $2 \\in A$ and taking the walk \\[$1 \\rightarrow 2 \\rightarrow 3$\\].\n- Vertex $4$ is reachable by selecting element $3 \\in A$ and following the walk \\[$1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4$\\].\n- Vertex $5$ is not reachable by any valid sequence of moves.\n- Vertex $6$ is reachable by first selecting element $2 \\in A$ and taking the walk \\[$1 \\rightarrow 2 \\rightarrow 3$\\], followed by selecting element $3 \\in A$ and taking the walk \\[$3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$\\].",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m, L;\n        cin >> n >> m >> L;\n        \n        /* ------------ analyse multiset A ------------- */\n        long long total = 0;\n        int minOdd = INF;\n        for (int i = 0; i < L; ++i) {\n            int x; cin >> x;\n            total += x;\n            if (x & 1) minOdd = min(minOdd, x);\n        }\n        \n        /* maximum reachable sum of each parity */\n        long long maxEven = 0, maxOdd = -1;      // -1  means \u201cparity impossible\u201d\n        if ((total & 1) == 0) {                  // total even\n            maxEven = total;\n            if (minOdd != INF) maxOdd = total - minOdd;\n        } else {                                 // total odd\n            maxOdd  = total;\n            if (minOdd != INF) maxEven = total - minOdd;   // always true here\n        }\n        /* empty subset is always possible, keep the larger one */\n        maxEven = max<long long>(maxEven, 0);\n        \n        /* ------------- read graph -------------------- */\n        vector<vector<int>> g(n + 1);\n        for (int i = 0; i < m; ++i) {\n            int u, v; cin >> u >> v;\n            g[u].push_back(v);\n            g[v].push_back(u);\n        }\n        \n        /* ------------- BFS for (vertex , parity) ----- */\n        vector<array<int,2>> dist(n + 1, {INF, INF});\n        queue<pair<int,int>> q;\n        dist[1][0] = 0;\n        q.push({1,0});\n        while (!q.empty()) {\n            auto [v, p] = q.front(); q.pop();\n            int nd = dist[v][p] + 1;\n            int np = p ^ 1;\n            for (int to : g[v]) {\n                if (dist[to][np] == INF) {\n                    dist[to][np] = nd;\n                    q.push({to, np});\n                }\n            }\n        }\n        \n        /* ------------- produce answer ---------------- */\n        string ans;\n        ans.reserve(n);\n        for (int i = 1; i <= n; ++i) {\n            bool ok = false;\n            if (dist[i][0] != INF && dist[i][0] <= maxEven) ok = true;\n            if (maxOdd != -1  && dist[i][1] != INF && dist[i][1] <= maxOdd) ok = true;\n            ans.push_back(ok ? '1' : '0');\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2109c3",
      "PROBLEM_ID": "2109C3",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. In this version, the limit of commands you can send is described in the statement. You can make hacks only if all versions of the problem are solved.\n\nThis is an interactive problem.\n\nWelcome, Duelists! In this interactive challenge, there is an unknown integer $x$ ($1 \\le x \\le 10^9$). You must make it equal to a given integer in the input $n$. By harnessing the power of \"Mathmech\" monsters, you can send a command to do one of the following:\n\nCommandConstraintResultCaseUpdateJury's response\"add $y$\"$-10^{18} \\le y \\le 10^{18}\n\n$$\\mathrm{res} = x + y$$\n\ntext{if } 1 \\le \\mathrm{res} \\le 10^{18}\n\n$$x \\leftarrow \\mathrm{res}$\"1\"$\\mathrm{else}$$\n\nx \\leftarrow x$\"0\"\"mul $y$\"$1 \\le y \\le 10^{18}\n\n$$\\mathrm{res} = x \\cdot y$$\n\ntext{if } 1 \\le \\mathrm{res} \\le 10^{18}\n\n$$x \\leftarrow \\mathrm{res}$\"1\"$\\mathrm{else}$$\n\nx \\leftarrow x$\"0\"\"div $y$\"$1 \\le y \\le 10^{18}\n\n$$\\mathrm{res} = x/y$$\n\ntext{if } y$ divides $x\n\n$$x \\leftarrow \\mathrm{res}$\"1\"$\\mathrm{else}$$\n\nx \\leftarrow x$\"0\"\"digit\"\u2014$\\\\mathrm{res} = S(x)$$^{\\\\text{\u2217}}$\u2014$x \\leftarrow \\mathrm{res}$\"1\"\n\nLet $f(n)$ be the minimum integer such that there is a sequence of $f(n)$ commands that transforms $x$ into $n$ for all $x(1 \\le x \\le 10^9)$. You do not know the value of $x$ in advance. Find $f(n)$ such that, no matter what $x$ is, you can always transform it into $n$ using at most $f(n)$ commands.\n\nYour task is to change $x$ into $n$ using at most $f(n)$ commands.\n\n$^{\\\\text{\u2217}}$$S(n)$ is a function that returns the sum of all the individual digits of a non-negative integer $n$. For example, $S(123) = 1 + 2 + 3 = 6$\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5000$). The description of the test cases follows.\n\nThe first and only line of each test case contains one integer $n$ ($1 \\le n \\le 10^9$).\n\n### Interaction\n\nThe interaction for each test case begins by reading the integer $n$.\n\nTo send a command, output a line in the following format:\n\n- \"add $y$\" Add some integer $y$ ($-10^{18} \\le y \\le 10^{18}$) to $x$.\nThe jury will output \"1\" if $x + y$ is within $[1, 10^{18}]$ (successful), and \"0\" otherwise. If successful, update $x \\leftarrow x + y$.\n\n- \"mul $y$\" Multiply $x$ by a positive integer $y$ ($1 \\le y \\le 10^{18}$).\nThe jury will output \"1\" if $x \\cdot y$ is within $[1, 10^{18}]$ (successful), and \"0\" otherwise. If successful, update $x \\leftarrow x \\cdot y$.\n\n- \"div $y$\" Divide $x$ by a positive integer $y$ ($1 \\le y \\le 10^{18}$).\nThe jury will output \"1\" if $y$ is a divisor of $x$ (successful), and \"0\" otherwise. If successful, update $x \\leftarrow \\frac{x}{y}$.\n\n- \"digit\" Make $x$ equal to the sum of its digits.\nThe jury will always output \"1\" and update $x \\leftarrow S(x)$.\n\n\nNote that commands are case sensitive.\n\nWhen you have determined that $x$ is equal to $n$, output a line in the following format:\n\n- \"!\" \u2014 where the jury will output a \"1\" if $n$ is equal to $x$, and \"-1\" otherwise.\n\nNote that answering does not count toward your limit of commands.\n\nIf your program makes more than $f(n)$ commands ($f(n)$ is described above) for one test case, or makes an invalid command, then the response to the command will be \"-1\". After receiving such a response, your program should immediately terminate to receive the verdict Wrong Answer. Otherwise, it may receive any other verdict.\n\nAfter printing a command, do not forget to output the end of the line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\n\n- fflush(stdout) or cout.flush() in C++;\n- System.out.flush() in Java;\n- sys.stdout.flush() in Python;\n- std::io::stdout().flush() in Rust;\n- see the documentation for other languages.\n\nThe interactor is non-adaptive. The unknown integer $x$ does not change during the interaction.\n\nHacks\n\nTo hack, use the following format.\n\nThe first line should contain a single integer $t$ ($1 \\leq t \\leq 5000$) \u2014 the number of test cases.\n\nThe first line of each test case should contain two positive integers $n$ and $x$ ($1 \\leq n,x \\leq 10^9$) \u2014 denoting the unknown integer and the target value to which it should be made equal, respectively.\n\n### Example\n\n#### Input #1\n\n```\n2\n100\n\n0\n\n1\n\n1\n\n1\n\n5\n\n1\n\n1\n\n1\n```\n\n#### Output #1\n\n```\n\nadd -10\n\nadd 1\n\nmul 10\n\n!\n\ndigit\n\ndiv 2\n\n!\n```\n\n### Note\n\nSolutionJuryExplanation$\\texttt{2}$There are 2 test cases.$\\texttt{100}$In the first test case, the unknown integer $x = 9$ and we have to make it equal to $n = 100$.$\\texttt{add -10}\n\n$$\\texttt{0}$The answer to \"add -10\" is \"0\". This means that the addition command was not successful as $x + y = 9 + (-10) \\le 0$, and $x$ remains $9$ after the command$\\texttt{add 1}$$\n\ntexttt{1}$The answer to \"add 1\" is \"1\". This means that the addition command was successful as $x + y = 9 + 1 = 10$, and $x$ changes to $10$ after the command.$\\texttt{mul 10}\n\n$$\\texttt{1}$The answer to \"mul 10\" is \"1\". This means that the multiplication command was successful as $x \\cdot y = 10 \\cdot 10 = 100$, and $x$ changes to $100$ after the command.$\\texttt{!}$$\n\ntexttt{1}$The answer to \"!\" is \"1\". This means you have determined that $x$ equals $n$.$\\texttt{5}$In the second test case, the unknown integer $x = 1234$ and we have to make it equal to $n = 5$.$\\texttt{digit}\n\n$$\\texttt{1}$The answer to \"digit\" is \"1\". This means that $x$ turned into the sum of its digits $1 + 2 + 3 + 4 = 10$, and $x$ changes to $10$ after the command.$\\texttt{div 2}$$\n\ntexttt{1}$The answer to \"div 2\" is \"1\". This means that the division command was successful as $y = 2$ is a divisor of $x = 10$, and $x$ changes to $\\frac{x}{y} = \\frac{10}{2} = 5$ after the command.$\\texttt{!}$$\\texttt{1}$The answer to \"!\" is \"1\". This means you have determined that $x$ equals $n$.\n\nNote that the empty lines in the example input and output are for the sake of clarity, and do not occur in the real interaction.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    cout << \"mul 999999999\" << endl;\n    int x;\n    cin >> x;\n\n    cout << \"digit\" << endl;\n    cin >> x;\n\n    if (n != 81) {\n        cout << \"add \" << n - 81 << endl;\n        cin >> x;\n    }\n\n    cout << \"!\" << endl;\n    cin >> x;\n    assert(x == 1);\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2109a",
      "PROBLEM_ID": "2109A",
      "PROBLEM_STATEMENT": "Something you may not know about Mouf is that he is a big fan of the Yu-Gi-Oh! card game. He loves to duel with anyone he meets. To gather all fans who love to play as well, he decided to organize a big Yu-Gi-Oh! tournament and invited $n$ players.\n\nMouf arranged the $n$ players in a line, numbered from $1$ to $n$. They then held $n - 1$ consecutive duels: for each $i$ from $1$ to $n - 1$, player $i$ faced player $i + 1$, producing one winner and one loser per match. Afterward, each player reports a value $a_i(0 \\le a_i \\le 1)$:\n\n- $0$ indicating they won no duels;\n- $1$ indicating they won at least one duel.\n\nSince some may lie about their results (e.g., reporting a $1$ instead of a $0$, or vice versa) to influence prize outcomes, Mouf will cancel the tournament if he can prove any report to be false.\n\nGiven the array $a$, determine whether at least one player must be lying.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($2 \\le n \\le 100$)\u00a0\u2014 the number of players in the tournament.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 1$)\u00a0\u2014 denoting the report of the $i$-th player.\n\n### Output\n\nFor each test case, print \"YES\" (without quotes) if there is at least one liar among the players, and \"NO\" (without quotes) otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n3\n\n0 1 0\n\n2\n\n0 0\n\n2\n\n1 1\n\n4\n\n0 1 1 1\n\n4\n\n1 0 0 1\n\n7\n\n0 1 0 1 0 1 0\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nYES\nNO\nYES\nNO\n```\n\n### Note\n\nIn the first test case, it is consistent if player $2$ defeats both players $1$ and $3$, so nobody's report is necessarily false.\n\nIn the second test case, in the only match between players $1$ and $2$, one must win \u2014 but both claimed zero wins, so someone must be lying.\n\nIn the third test case, the tournament consists of exactly one duel between players $1$ and $2$ \u2014 but it's impossible for both to win, concluding that at least one report is false.\n\nIn the fourth test case, a possible scenario is that player $2$ won against player $1$, then $3$ won against $2$, and then $4$ won against $3$. All reports align, so there is no evidence that someone lied.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t; \n    cin >> t;\n    while(t--){\n        int n; \n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++){\n            cin >> a[i];\n        }\n \n        // dp[i][v] will be true if we can assign outcomes for matches 1...i (1-indexed)\n        // such that b[i] (i-th match outcome) equals 'v'.\n        // For convenience, players:\n        //   - Player1's report forces b[1] = a[0] (since a is given 0-indexed).\n        //   - For a middle player (i+1, i from 1 to n-2) with report a[i],\n        //     the constraint involves b[i] (from previous match) and b[i+1] (current match).\n        //   - Finally, player n's report forces b[n-1] = (a[n-1] ? 0 : 1).\n        vector<vector<bool>> dp(n+1, vector<bool>(2, false));\n \n        // Set match1 outcome based on player1's report.\n        dp[1][ a[0] ] = true;\n \n        // Process players 2 to n-1 (i.e. matches 2 to n-1 will be decided)\n        for (int i = 1; i <= n - 2; i++){\n            int rep = a[i]; // report of player i+1 (0-indexed a[i])\n            for (int prev = 0; prev < 2; prev++){\n                if(!dp[i][prev])\n                    continue;\n                if(rep == 0){\n                    // For player i+1 to have 0 wins:\n                    // They must not win as the second player in match i -> b[i] must be 1.\n                    // And they must not win match i+1 -> current outcome must be 0.\n                    if(prev == 1){\n                        dp[i+1][0] = true;\n                    }\n                } else { // rep == 1: player i+1 claims at least one win.\n                    // Losing both matches (b[i]==1 and cur==0) is forbidden.\n                    if(prev == 1){\n                        // b[i]==1 means they already lost match i, so to avoid losing both, cur must be 1.\n                        dp[i+1][1] = true;\n                    } else {\n                        // if prev==0 then player i+1 already won match i.\n                        // Then, cur can be arbitrary.\n                        dp[i+1][0] = true;\n                        dp[i+1][1] = true;\n                    }\n                }\n            }\n        }\n \n        // Final check: player n is in only match n-1.\n        // They win if b[n-1]==0.\n        // So if a[n-1] == 1 then we require b[n-1] == 0.\n        // If a[n-1] == 0 then we require b[n-1] == 1.\n        int required = (a[n-1] == 1 ? 0 : 1);\n \n        bool possible = dp[n-1][required];\n        // If possible, then there is a valid assignment. \n        // So we output \"NO\" (no proof of lying). Otherwise, output \"YES\".\n        cout << (possible ? \"NO\" : \"YES\") << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2108f",
      "PROBLEM_ID": "2108F",
      "PROBLEM_STATEMENT": "Pizano built an array $a$ of $n$ towers, each consisting of $a_i \\ge 0$ blocks.\n\nPizano can knock down a tower so that the next $a_i$ towers grow by $1$. In other words, he can take the element $a_i$, increase the next $a_i$ elements by one, and then set $a_i$ to $0$. The blocks that fall outside the array of towers disappear. If Pizano knocks down a tower with $0$ blocks, nothing happens.\n\nPizano wants to knock down all $n$ towers in any order, each exactly once. That is, for each $i$ from $1$ to $n$, he will knock down the tower at position $i$ exactly once.\n\nMoreover, the resulting array of tower heights must be non-decreasing. This means that after he knocks down all $n$ towers, for any $i < j$, the tower at position $i$ must not be taller than the tower at position $j$.\n\nYou are required to output the maximum $\\text{MEX}$ of the resulting array of tower heights.\n\nThe $\\text{MEX}$ of an array is the smallest non-negative integer that is not present in the array.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 10^5$)\u00a0\u2014 the number of towers.\n\nThe second line of each test case contains $n$ integers\u00a0\u2014 the initial heights of the towers $a_1, \\ldots, a_n$ ($0 \\leq a_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximum $\\text{MEX}$ of the final array.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n2\n\n1 2\n\n4\n\n2 1 0 0\n\n10\n\n5 9 3 7 1 5 1 5 4 3\n\n10\n\n1 1 1 1 1 1 1 1 1 1\n\n10\n\n3 2 1 0 3 2 1 0 3 2\n\n5\n\n5 2 0 5 5\n\n1\n\n1000000000\n\n7\n\n4 0 1 0 2 7 7\n\n```\n\n#### Output #1\n\n```\n2\n3\n7\n4\n5\n4\n1\n3\n```\n\n### Note\n\nExplanation for the first test case.\n\n![](https://espresso.codeforces.com/b27f3ad036c335f58fe3b07c11f325fd39450091.png)\n\nExplanation for the second test case. Note that all towers were knocked down exactly once, and the final array of heights is non-decreasing.\n\n![](https://espresso.codeforces.com/5d8740d0c655899ee758c6d450d7dca858b1f65d.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\n#define S 100005\n\ntypedef long long l;\n \nl a[S], d[S], n;\n\nbool check(l ans) {\n    memset(d, 0, sizeof(l) * n);\n    l acc = 0;\n    \n    for (l i = 0; i < n; ++i) {\n        acc -= d[i];\n        \n        l need = std::max(0LL, i - (n - ans));\n        if (acc < need) return false;\n        \n        l end = i + a[i] + (acc++) - need + 1;\n        if (end < n) ++d[end];\n    }\n    \n    return true;\n}\n\nvoid solve() {\n    scanf(\"%lld\", &n);\n    for (l i = 0; i < n; ++i) scanf(\"%lld\", &a[i]);\n    \n    l le = 1, ri = n + 1, mid;\n    while (ri - le > 1) {\n        mid = (le + ri) / 2;\n        if (check(mid)) le = mid;\n        else ri = mid;\n    }\n    \n    printf(\"%lld\\n\", le);\n}\n\nint main() {\n    l tc; scanf(\"%lld\", &tc);\n    while (tc--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2108e",
      "PROBLEM_ID": "2108E",
      "PROBLEM_STATEMENT": "It's already a hot April outside, and Polycarp decided that this is the perfect time to finally take down the spruce tree he set up several years ago. As he spent several hours walking around it, gathering his strength, he noticed something curious: the spruce is actually a tree$^{\\text{\u2217}}$\u00a0\u2014 and not just any tree, but one consisting of an odd number of vertices $n$. Moreover, on $n-1$ of the vertices hang Christmas ornaments, painted in exactly $\\frac{n-1}{2}$ distinct colors, with exactly two ornaments painted in each color. The remaining vertex, as tradition dictates, holds the tree's topper.\n\nAt last, after several days of mental preparation, Polycarp began dismantling the spruce. First, he removed the topper and had already started taking apart some branches when suddenly a natural question struck him: how can he remove one of the tree's edges and rearrange the ornaments in such a way that the sum of the lengths of the simple paths between ornaments of the same color is as large as possible?\n\nIn this problem, removing an edge from the tree is defined as follows: choose a pair of adjacent vertices $a$ and $b$ ($a < b$), then remove vertex $b$ from the tree and reattach all of $b$'s adjacent vertices (except for $a$) directly to $a$.\n\nPolycarp cannot continue dismantling his spruce until he gets an answer to this question. However, checking all possible options would take him several more years. Knowing your experience in competitive programming, he turned to you for help. But can you solve this dispute?\n\n$^{\\text{\u2217}}$A tree is a connected graph without cycles.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains an odd number $n$ ($3 \\le n < 2 \\cdot 10^5$)\u00a0\u2014 the number of vertices in the tree.\n\nThe following $n-1$ lines describe the tree, given by pairs of adjacent vertices $u$, $v$ ($1 \\le u, v \\le n, u \\neq v$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, you need to output two lines.\n\nIn the first line, output the pair of vertices $u$, $v$, the edge between which Polycarp is going to remove.\n\nIn the next line, output the array $c$ of $n$ numbers from $0$ to $\\frac{n-1}{2}$, where $c[i]$\u00a0\u2014 the positive color number assigned to vertex $i$. Note that $c[\\text{max}(u, v)]= 0$, since this vertex has been removed.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5\n\n1 2\n\n2 3\n\n2 4\n\n4 5\n\n5\n\n1 2\n\n1 3\n\n1 4\n\n1 5\n\n7\n\n1 5\n\n5 4\n\n4 3\n\n3 2\n\n2 6\n\n6 7\n\n```\n\n#### Output #1\n\n```\n1 2\n2 0 1 1 2\n1 5\n1 1 2 2 0\n4 3\n1 3 3 0 2 2 1\n```\n\n### Note\n\nConsider the first test case.\n\nRemove the edge connecting vertices $1$ and $2$. After this, vertex $2$ will be removed from the tree, and vertices $3$ and $4$ will be connected to vertex $1$.\n\nColor vertices $3$ and $4$ with the first color, and vertices $1$ and $5$ with the second. The sum of the lengths of simple paths between ornaments of the same color is equal to $2 + 2 = 4$. It can be shown that this value is the largest possible.\n\n![](https://espresso.codeforces.com/187d5439eac93442b727d84bea394613d3a21efe.png)\n\nIn the second and third examples, the maximum sum of path lengths will be $3$ and $9$, respectively.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <cstdio>\n#include <vector>\n\n#define S 200005\n\nusing namespace std;\ntypedef long long l;\n\nl coloring[S], centroid, best, best_dist, n, color;\nvector<vector<l>> g;\n\nl search_centroid(l u, l from) {\n  l sum = 0;\n  bool f = true;\n  for (l v : g[u]) if (v != from) {\n    l t = search_centroid(v, u);\n    if (t > n / 2) f = false;\n    sum += t;\n  }\n  \n  if (f && n - 1 - sum <= n / 2) centroid = u;\n  return sum + 1;\n}\n\nvoid make_coloring(l u, l from, l dist) {\n  coloring[u] = (color++) % (n / 2) + 1;\n  if (g[u].size() == 1 && dist < best_dist) {\n    best_dist = dist;\n    best = u;\n  }\n  for (l v : g[u]) if (v != from)\n    make_coloring(v, u, dist + 1);\n}\n\nvoid solve() {\n  centroid = -1, best_dist = S, color = 0;\n  scanf(\"%lld\", &n);\n  g.assign(n, vector<l>());\n  for (l i = 0; i < n - 1; ++i) {\n    l u, v; scanf(\"%lld %lld\", &u, &v); --u, --v;\n    g[u].push_back(v); g[v].push_back(u);\n  }\n  \n  search_centroid(1543 % n, -1);\n  make_coloring(centroid, -1, 0);\n  \n  l bbest = max(best, g[best][0]);\n  coloring[centroid] = coloring[bbest];\n  coloring[bbest] = 0;\n  \n  printf(\"%lld %lld\\n\", best + 1, g[best][0] + 1);\n  for (l i = 0; i < n; ++i) {\n    if (i) printf(\" \");\n    printf(\"%lld\", coloring[i]);\n  }\n  printf(\"\\n\");\n}\n\nint main() {\n  l tc; scanf(\"%lld\", &tc);\n  while (tc--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2108d",
      "PROBLEM_ID": "2108D",
      "PROBLEM_STATEMENT": "This is an interactive problem.\n\nYou found the numbers $k$ and $n$ in the attic, but lost two arrays $A$ and $B$.\n\nYou remember that:\n\n- $|A| + |B| = n$, the total length of the arrays is $n$.\n- $|A| \\geq k$ and $|B| \\geq k$, the length of each array is at least $k$.\n- The arrays consist only of numbers from $1$ to $k$.\n- If you take any $k$ consecutive elements from array $A$, they will all be different. Also, if you take any $k$ consecutive elements from array $B$, they will all be different.\n\nFortunately, a kind spirit that settled in the attic found these arrays and concatenated them into an array $C$ of length $n$. That is, the elements of array $A$ were first written into array $C$, followed by the elements of array $B$.\n\nYou can ask the kind spirit up to $250$ questions. Each question contains an index $i$ ($1 \\leq i \\leq n$). In response, you will receive the $i$-th element of the concatenated array $C$.\n\nYou need to find the lengths of arrays $A$ and $B$, or report that it is impossible to determine them uniquely.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 300$). The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$ and $k$ ($1 \\leq k \\leq 50$, $2 k \\leq n \\leq 10^{6}$).\n\nNote that the sum of $n$ across test cases is not limited.\n\n### Interaction\n\nThe interaction for each test case begins with reading the integer $n$.\n\nThen you can make up to $250$ queries.\n\nTo make a query, output a string in the format \"? x\" (without quotes) ($1 \\leq x \\leq n$). After each query, read an integer\u00a0\u2014 the answer to your query.\n\nIf you make too many queries, you will receive a verdict of Wrong answer.\n\nTo report your answer, output a string in the format \"! a b\" (without quotes), where $a$ and $b$ are the lengths of arrays $A$ and $B$ that you found, respectively. The answer is not counted when counting the number of queries.\n\nIf it is impossible to determine the lengths of the arrays uniquely, output \"! -1\" (without quotes). Note that if you answer $-1$ while there is a sequence of at most $250$ queries that uniquely determines the lengths of arrays, you will get a Wrong answer verdict.\n\nIt is guaranteed that there are arrays $A$ and $B$ that do not contradict the statement, for which the interactor output is correct.\n\nThe interactor is not adaptive, which means that the answer is known before the participant makes queries and does not depend on the queries made by the participant.\n\nIf your program makes more than $250$ queries, your program should immediately terminate to receive the verdict Wrong answer. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\n\nAfter outputting a query, do not forget to output a newline and flush the output buffer. Otherwise, you will receive a verdict of \"IL\" (Idleness limit exceeded). To flush the buffer, use:\n\n- fflush(stdout) or cout.flush() in C++;\n- System.out.flush() in Java;\n- flush(output) in Pascal;\n- stdout.flush() in Python;\n- see the documentation for other languages.\n\nHacks\n\nHacks are disabled for this problem.\n\n### Example\n\n#### Input #1\n\n```\n6\n5 2\n\n1\n\n2\n\n2\n\n18 4\n\n2\n\n4\n\n1\n\n1\n\n4\n\n3 1\n\n10 5\n\n9 3\n\n3\n\n3\n\n2\n\n12 4\n\n1\n\n3\n\n1\n\n3\n\n1\n\n3\n```\n\n#### Output #1\n\n```\n\n? 1\n\n? 2\n\n? 3\n\n! 2 3\n\n? 9\n\n? 13\n\n? 10\n\n? 14\n\n? 6\n\n! 9 9\n\n! -1\n\n! 5 5\n\n? 3\n\n? 6\n\n? 9\n\n! 6 3\n\n? 1\n\n? 2\n\n? 5\n\n? 6\n\n? 9\n\n? 10\n\n! -1\n```\n\n### Note\n\nConsider the first example. We queried the first $3$ elements out of $5$. Now we know that the array $C$ looks like $[1, 2, 2, ?, ?]$. We know for sure that the third element is not from array $A$\u00a0\u2014 because according to the condition, any $k$ consecutive elements (in our case $k = 2$) in array $A$ are different. Thus, the third element is definitely located in array $B$. This means that the length of array $A$ is $2$, and the length of array $B$ is $3$.\n\nThe picture shows arrays from all test cases. The elements whose values were requested are marked in yellow.\n\n![](https://espresso.codeforces.com/1981313348269cab100360e478a64874954e4b27.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <cstdio>\n#include <cstdlib>\n#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))\n#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))\ntypedef long long l;\n\nl a[55], b[55], ui[55];\n\nl ask(l v) {\n    printf(\"? %lld\\n\", v + 1);\n    fflush(stdout);\n    l t; scanf(\"%lld\", &t);\n    return t;\n}\n\nvoid noans() {\n    printf(\"! -1\\n\");\n    fflush(stdout);\n}\n\nvoid ans(l a, l b) {\n    printf(\"! %lld %lld\\n\", a, b);\n    fflush(stdout);\n}\n\nvoid solve() {\n    l n, k; scanf(\"%lld %lld\", &n, &k);\n\n    for (l i = 0; i < k; ++i) a[i] = ask(i);\n    for (l i = n - k; i < n; ++i) b[i % k] = ask(i);\n\t\n    l uc = 0;\n    for (l i = 0; i < k; ++i) if (a[i] != b[i]) ui[uc++] = i;\n    \n    if (!uc) {\n        if (n == k * 2) ans(k, k);\n        else noans();\n        return;\n    }\n    \n    l le = ui[0], ri = ui[0] + (n - 1) / k * k;\n    while (le + k != ri) {\n        l mid = le + (ri - le) / k / 2 * k;\n        if (ask(mid) == a[ui[0]]) le = mid;\n        else ri = mid;\n    }\n    \n    l lee = 0, rii = uc;\n    while (lee + 1 != rii) {\n        l mid = (lee + rii) / 2;\n        if (ask(le - ui[0] + ui[mid]) == a[ui[mid]]) lee = mid;\n        else rii = mid;\n    }\n    \n    l pos1 = MAX(le - ui[0] + ui[lee], k - 1);\n    l pos2 = MIN(le - ui[0] + ((rii == uc) ? (ui[0] + k) : ui[rii]), n - k);\n    \n    if (pos1 + 1 != pos2) { noans(); return; }\n    ans(pos2, n - pos2);\n}\n\nint main() {\n    l t; scanf(\"%lld\", &t);\n    while (t--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2108c",
      "PROBLEM_ID": "2108C",
      "PROBLEM_STATEMENT": "Neo wants to escape from the Matrix. In front of him are $n$ buttons arranged in a row. Each button has a weight given by an integer: $a_1, a_2, \\ldots, a_n$.\n\nNeo is immobilized, but he can create and move clones. This means he can perform an unlimited number of actions of the following two types in any order:\n\n1. Create a clone in front of a specific button.\n2. Move an existing clone one position to the left or right.\n\nAs soon as a clone is in front of another button that has not yet been pressed\u2014regardless of whether he was created or moved\u00a0\u2014 he immediately presses it. If the button has already been pressed, a clone does nothing\u00a0\u2014 buttons can only be pressed once.\n\nFor Neo to escape, he needs to press all the buttons in such an order that the sequence of their weights is non-increasing\u00a0\u2014 that is, if $b_1, b_2, \\ldots, b_n$ are the weights of the buttons in the order they are pressed, then it must hold that $b_1 \\geq b_2 \\geq \\cdots \\geq b_n$.\n\nYour task is to determine the minimum number of clones that Neo needs to create in order to press all the buttons in a valid order.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the number of buttons.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$)\u00a0\u2014 the weights of the buttons.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the minimum number of clones that need to be created to press all the buttons in a valid order.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n5\n\n4 3 2 1 5\n\n3\n\n1 1 1\n\n6\n\n7 8 1 5 9 2\n\n10\n\n1 7 9 7 1 10 2 10 10 7\n\n```\n\n#### Output #1\n\n```\n2\n1\n2\n3\n```\n\n### Note\n\nIn the first test case, Neo can act as follows:\n\n1. Create a clone in front of the fifth button (with weight $5$).\n2. Create a clone in front of the first button (with weight $4$).\n3. Move the second clone from the first button to the second (with weight $3$).\n4. Move the second clone from the second button to the third (with weight $2$).\n5. Move the first clone from the fifth button to the fourth (with weight $1$).\n\nThus, the sequence of button presses will be $5 \\rightarrow 4 \\rightarrow 3 \\rightarrow 2 \\rightarrow 1$, which meets the requirement. It can be shown that the number of clones created is the smallest possible.\n\nIn the second test case, Neo can act as follows:\n\n1. Create a clone in front of the second button (with weight $1$).\n2. Move the clone from the second button to the third (with weight $1$).\n3. Move the clone from the third button to the second (already pressed).\n4. Move the clone from the second button to the first (with weight $1$).\n\nThus, the sequence of button presses will be $1 \\rightarrow 1 \\rightarrow 1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \n// Sparse table for range maximum query (0-indexed)\nstruct SparseTable {\n    int n;\n    vector<vector<long long>> st; // st[k][i] = max in segment of length 2^k starting at i\n    vector<int> logVal;\n    SparseTable(const vector<long long>& arr) {\n        n = arr.size();\n        logVal.resize(n+1);\n        for (int i = 2; i <= n; i++){\n            logVal[i] = logVal[i/2] + 1;\n        }\n        int K = logVal[n] + 1;\n        st.assign(K, vector<long long>(n));\n        for (int i = 0; i < n; i++){\n            st[0][i] = arr[i];\n        }\n        for (int k = 1; k < K; k++){\n            for (int i = 0; i + (1 << k) - 1 < n; i++){\n                st[k][i] = max(st[k-1][i], st[k-1][i + (1 << (k-1))]);\n            }\n        }\n    }\n    // query max in [L, R] (0-indexed)\n    long long query(int L, int R) {\n        if(L > R) return -1e18;\n        int j = logVal[R - L + 1];\n        return max(st[j][L], st[j][R - (1 << j) + 1]);\n    }\n};\n \n// Main solution\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t;\n    cin >> t;\n    while(t--){\n        int n; \n        cin >> n;\n        vector<int> a(n+1);\n        for (int i=1; i<=n; i++){\n            cin >> a[i];\n        }\n \n        // 1. Precompute LND: longest non-decreasing segment ending at i.\n        vector<int> LND(n+1, 1);\n        LND[1] = 1;\n        for (int i = 2; i <= n; i++){\n            if(a[i-1] <= a[i])\n                LND[i] = LND[i-1] + 1;\n            else\n                LND[i] = 1;\n        }\n \n        // 2. Precompute ndEnd: for each i, maximum j such that a[i..j] is non-decreasing.\n        vector<int> ndEnd(n+1, 0);\n        int i = 1;\n        while(i <= n){\n            int j = i;\n            while(j < n && a[j] <= a[j+1]) j++;\n            for (int k = i; k <= j; k++){\n                ndEnd[k] = j;\n            }\n            i = j+1;\n        }\n \n        // 3. Precompute RNI: longest non-increasing segment starting at i.\n        vector<int> RNI(n+2, 1);\n        RNI[n] = 1;\n        for (int i = n-1; i >= 1; i--){\n            if(a[i] >= a[i+1])\n                RNI[i] = RNI[i+1] + 1;\n            else\n                RNI[i] = 1;\n        }\n \n        // 4. For k = 1..n, define B[k] = k + RNI[k] \u2013 1.\n        vector<long long> B(n+1, 0);\n        for (int k = 1; k <= n; k++){\n            B[k] = k + (long long) RNI[k] - 1;\n        }\n \n        // Build a sparse table on B (convert 1-index to 0-index for storage).\n        vector<long long> B0(n);\n        for (int i = 0; i < n; i++){\n            B0[i] = B[i+1];\n        }\n        SparseTable sp(B0);\n \n        // For a starting position L (1-indexed), far[L] = max_{k in [L, ndEnd[L]]} B[k],\n        // i.e. far[L] = maximum R that can be covered by a clone created at L.\n        auto getFar = [&](int L) -> int {\n            int L0 = L - 1;\n            int R0 = ndEnd[L] - 1;\n            long long best = sp.query(L0, R0);\n            return (int)best;\n        };\n        vector<int> farArr(n+1, 0);\n        for (int L = 1; L <= n; L++){\n            farArr[L] = getFar(L);\n            if(farArr[L] > n) farArr[L] = n;\n        }\n \n        // 5. Compute dp: dp[i] = min number of clones needed to cover positions 1..i.\n        // We need dp[i] = min_{L such that L \u2264 i \u2264 farArr[L]} ( dp[L-1] + 1 ).\n        const int INF = 1e9;\n        vector<int> dp(n+1, INF);\n        dp[0] = 0;\n \n        // We'll use a min-heap where for each possible starting position L we store an \"interval\"\n        // with range [L, farArr[L]] and candidate value dp[L-1] + 1.\n        struct HeapItem {\n            int end;      // farArr[L]\n            int candidate; // value = dp[L-1] + 1\n            int start;    // L (for debugging/tracking)\n        };\n        struct cmp {\n            bool operator()(const HeapItem &a, const HeapItem &b) {\n                return a.candidate > b.candidate; // min-heap (smallest candidate first)\n            }\n        };\n        priority_queue<HeapItem, vector<HeapItem>, cmp> heap;\n \n        // We sweep i from 1 to n.\n        for (int i = 1; i <= n; i++){\n            // When i becomes the starting position of an interval, add that interval.\n            heap.push({farArr[i], dp[i-1] + 1, i});\n \n            // Remove intervals that no longer cover i.\n            while(!heap.empty() && heap.top().end < i)\n                heap.pop();\n \n            if(!heap.empty()){\n                dp[i] = heap.top().candidate;\n            }\n        }\n \n        cout << dp[n] << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2108b",
      "PROBLEM_ID": "2108B",
      "PROBLEM_STATEMENT": "On a recent birthday, your best friend Maurice gave you a pair of numbers $n$ and $x$, and asked you to construct an array of positive numbers $a$ of length $n$ such that $a_1 \\oplus a_2 \\oplus \\cdots \\oplus a_n = x$ $^{\\text{\u2217}}$.\n\nThis task seemed too simple to you, and therefore you decided to give Maurice a return gift by constructing an array among all such arrays that has the smallest sum of its elements. You immediately thought of a suitable array; however, since writing it down turned out to be too time-consuming, Maurice will have to settle for just the sum of its elements.\n\n$^{\\\\text{\u2217}}$$\\\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nEach test case consists of a single line containing a pair of numbers $n$ and $x$ ($1 \\le n \\le 10^9, \\; 0 \\le x \\le 10^9$)\u00a0\u2014 the numbers given to you by Maurice.\n\n### Output\n\nFor each test case, output your gift to Maurice\u00a0\u2014 the sum of the elements of the array that satisfies all the described properties. If a suitable array does not exist, output $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n2 1\n\n3 6\n\n1 0\n\n2 0\n\n5 0\n\n2 27\n\n15 43\n\n12345678 9101112\n\n```\n\n#### Output #1\n\n```\n5\n8\n-1\n2\n8\n27\n55\n21446778\n```\n\n### Note\n\nIn the first test case, one of the suitable arrays is $[2, 3]$. It can be shown that it is impossible to achieve a smaller sum of array elements.\n\nIn the second case, one of the suitable arrays is $[1, 3, 4]$. It can also be shown that this is the optimal amount.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    if (!(cin >> t)) return 0;\n    while (t--) {\n        ll n, x;\n        cin >> n >> x;\n        // Compute popcount of x\n        int pc = __builtin_popcountll(x);\n        // If we already have enough ones to cover all elements, no extra cost\n        ll delta = n - pc;\n        if (delta <= 0) {\n            // We can assign bits so that each element is positive\n            // and total sum is exactly x\n            // Except the case n=1 and x=0, but that gives delta=1>0, so here x>0 or n>1\n            cout << x << \"\\n\";\n            continue;\n        }\n        // We need to add at least delta ones across bits, but we can only\n        // add in pairs (to preserve parity per bit). Let t_pairs be needed pairs.\n        ll t_pairs = (delta + 1) / 2;  // ceil(delta/2)\n        ll cost = 0;\n        ll t_rem = t_pairs;\n        // Greedily take pairs from lowest bit upwards\n        for (int i = 0; i < 32 && t_rem > 0; i++) {\n            // initial k_i is parity bit of x at i\n            int xi = (x >> i) & 1;\n            // maximal k_i we can reach with same parity xi and <= n\n            ll max_ki = ((n & 1LL) == xi ? n : n - 1);\n            // extra ones we can add at bit i\n            ll extra = max_ki - xi;\n            if (extra <= 0) continue;\n            // pairs we can take here\n            ll pairs = extra / 2;\n            ll take = min(pairs, t_rem);\n            // cost for each pair is 2 * (1<<i)\n            cost += take * (1LL << (i + 1));\n            t_rem -= take;\n        }\n        if (t_rem > 0) {\n            // Not possible\n            cout << -1 << \"\\n\";\n        } else {\n            // Total sum is x + cost of extra bits\n            cout << (x + cost) << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2108a",
      "PROBLEM_ID": "2108A",
      "PROBLEM_STATEMENT": "For a permutation $p$ of length $n$$^{\\\\text{\u2217}}$, we define the function:\n\n\n\n$$ f(p) = \\sum_{i=1}^{n} \\lvert p_i - i \\rvert $$\n\nYou are given a number $n$. You need to compute how many distinct values the function $f(p)$ can take when considering all possible permutations of the numbers from $1$ to $n$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 500$)\u00a0\u2014 the number of numbers in the permutations.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the number of distinct values of the function $f(p)$ for the given length of permutations.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n3\n\n8\n\n15\n\n43\n\n```\n\n#### Output #1\n\n```\n2\n3\n17\n57\n463\n```\n\n### Note\n\nConsider the first two examples of the input.\n\nFor $n = 2$, there are only $2$ permutations\u00a0\u2014 $[1, 2]$ and $[2, 1]$. $f([1, 2]) = \\lvert 1 - 1 \\rvert + \\lvert 2 - 2 \\rvert = 0$, $f([2, 1]) = \\lvert 2 - 1 \\rvert + \\lvert 1 - 2 \\rvert = 1 + 1 = 2$. Thus, the function takes $2$ distinct values.\n\nFor $n=3$, there are already $6$ permutations: $[1, 2, 3]$, $[1, 3, 2]$, $[2, 1, 3]$, $[2, 3, 1]$, $[3, 1, 2]$, $[3, 2, 1]$, the function values of which will be $0, 2, 2, 4, 4$, and $4$ respectively, meaning there are a total of $3$ values.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nusing namespace std;\n\nint count_distinct_f_values(int n) {\n    if (n % 2 == 0) {\n        return n * n / 4 + 1;\n    } else {\n        return (n * n + 3) / 4;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        cout << count_distinct_f_values(n) << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2107f2",
      "PROBLEM_ID": "2107F2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, $1\\le n\\le 10^6$ and you need to output the answer for each prefix. You can hack only if you solved all versions of this problem.\n\nLeo works as a programmer in the city center, and his lover teaches at a high school in the suburbs. Every weekend, Leo would ride his bike to the suburbs to spend a nice weekend with his lover.\n\nThere are $n$ cyclists riding in front of Leo on this road right now. They are numbered $1$, $2$, $\\ldots$, $n$ from front to back. Initially, Leo is behind the $n$-th cyclist. The $i$-th cyclist has an agility value $a_i$.\n\nLeo wants to get ahead of the $1$-st cyclist. Leo can take the following actions as many times as he wants:\n\n- Assuming that the first person in front of Leo is cyclist $i$, he can go in front of cyclist $i$ for a cost of $a_i$. This puts him behind cyclist $i - 1$.\n- Using his super powers, swap $a_i$ and $a_j$ ($1\\le i < j\\le n$) for a cost of $(j - i)$.\n\nLeo wants to know the minimum cost to get in front of the $1$-st cyclist.\n\nIn addition, he wants to know the answer for each $1\\le i \\le n$, $[a_1, a_2, \\ldots, a_i]$ as the original array. The problems of different $i$ are independent. To be more specific, in the $i$-th problem, Leo starts behind the $i$-th cyclist instead of the $n$-th cyclist, and cyclists numbered $i + 1, i + 2, \\ldots, n$ are not present.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a positive integer $n$ ($1 \\leq n \\leq 10^6$), representing the number of the cyclists.\n\nThe second line of each test case contains $n$ integers $a_1, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, print $n$ integers, the answers for the array $[a_1, a_2, \\ldots, a_i]$ for each $i = 1, 2, \\ldots n$ in this order.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\n1 2 4\n\n4\n\n1 1 1 1\n\n2\n\n1 2\n\n4\n\n4 1 3 2\n\n```\n\n#### Output #1\n\n```\n1 3 7\n1 2 3 4\n1 3\n4 3 6 8\n```\n\n### Note\n\nIn the first test case, one possible way to move from the position behind the $n$-th cyclist to the position in front of the $1$-st cyclist is:\n\n- Leo swaps $a_2$ $(i=2)$ and $a_3$ $(j=3)$, then the array becomes $[1,4,2]$; it costs $j-i=3-2=1$.\n- Leo is behind the $3$-rd cyclist and moves behind the $2$-nd cyclist; it costs $a_3=2$.\n- Leo swaps $a_1$ $(i=1)$ and $a_2$ $(j=2)$, then the array becomes $[4,1,2]$; it costs $j-i=2-1=1$.\n- Leo is behind the $2$-nd cyclist and moves behind the $1$-st cyclist; it costs $a_2=1$.\n- Leo swaps $a_1$ $(i=1)$ and $a_2$ $(j=2)$, then the array becomes $[1,4,2]$; it costs $j-i=2-1=1$.\n- Leo moves ahead of the $1$-st cyclist; it costs $a_1=1$.\n\nSo the total cost is $1+2+1+1+1+1=7$. It can be proved that $7$ is the minimum cost.\n\nIn the second test case, to move ahead of the $1$-st cyclist from the position behind the $n$-th cyclist, Leo should not swap anyone's agility value. The total cost is $1+1+1+1=4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define INF (int)1e18\n\n#define inf 1e18\n#define ld long double\n\nmt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());\n\n \nstruct chtDynamicMin {  \n\tstruct line {\n\t\tint m, b; ld x; \n\t\tint om, ob;\n\t\tint val; bool isQuery; \n\t\tline(int _m = 0, int _b = 0, int _om = 0, int _ob = 0) {\n\t\t\tm = _m;\n\t\t\tb = _b;\n\t\t\tom = _om;\n\t\t\tob = _ob;\n\t\t\tval = 0;\n\t\t\tx = -inf;\n\t\t\tisQuery = false;\n\t\t}\n\t\t\t\n\t\t\n\t\tint eval(int x) const { return m * x + b;\t}\n\t\tbool parallel(const line &l) const { return m == l.m; }\n\t\tld intersect(const line &l) const {\n\t\t\treturn parallel(l) ? inf : 1.0 * (l.b - b) / (m - l.m);\n\t\t}\n\t\tbool operator < (const line &l) const {\n\t\t\tif(l.isQuery) return x < l.val;\n\t\t\telse return m < l.m; \n\t\t}\n\t};\n \n\tset<line> hull; \n\ttypedef set<line> :: iterator iter; \n \n\tbool cPrev(iter it) { return it != hull.begin(); }\n\tbool cNext(iter it) { return it != hull.end() && next(it) != hull.end(); }\n \n\tbool bad(const line &l1, const line &l2, const line &l3) {\n\t\treturn l1.intersect(l3) <= l1.intersect(l2); \n\t}\n\tbool bad(iter it) {\n\t\treturn cPrev(it) && cNext(it) && bad(*prev(it), *it, *next(it));\n\t}\n \n\titer update(iter it) {\n\t\tif(!cPrev(it)) return it; \n\t\tld x = it -> intersect(*prev(it));\n\t\tline tmp(*it); tmp.x = x;\n\t\tit = hull.erase(it); \n\t\treturn hull.insert(it, tmp);\n\t}\n    \n\tvoid addLine(int m, int b) { \n\t\tint om = m, ob = b;\n\t\tm *= -1;\n\t\tb *= -1;\n\t\tline l(m, b, om, ob); \n\t\titer it = hull.lower_bound(l); \n\t\tif(it != hull.end() && l.parallel(*it)) {\n\t\t\tif(it -> b < b) it = hull.erase(it); \n\t\t\telse return;\n\t\t}\n \n\t\tit = hull.insert(it, l); \n\t\tif(bad(it)) return (void) hull.erase(it);\n \n\t\twhile(cPrev(it) && bad(prev(it))) hull.erase(prev(it));\n\t\twhile(cNext(it) && bad(next(it))) hull.erase(next(it));\n \n\t\tit = update(it);\n\t\tif(cPrev(it)) update(prev(it));\n\t\tif(cNext(it)) update(next(it));\n\t}\n \n\tint query(int x) const { \n\t\tif(hull.empty()) return inf;\n\t\tline q; q.val = x, q.isQuery = 1;\n\t\titer it = --hull.lower_bound(q);\n\t\treturn - it -> eval(x);\n\t}\n};\n\nvoid Solve() \n{\n    int n; cin >> n;\n    \n    // insert lines and calculate CHT \n    chtDynamicMin cht;\n    \n    vector <int> a(n + 1);\n    for (int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    \n    vector <int> pv(n + 1, 0);\n    // previous smaller \n    stack <pair<int, int>> st;\n    for (int i = n; i >= 1; i--){\n        while (!st.empty() && st.top().first >= a[i]){\n            pv[st.top().second] = i;\n            st.pop();\n        }\n        \n        st.push({a[i], i});\n    }\n    \n    vector <int> dp(n + 1, 0);\n    \n    for (int i = 1; i <= n; i++){\n        dp[i] = dp[pv[i]] + a[i] * (i - pv[i]) + (i - pv[i] - 1);\n        // slope is +2 + a[i] \n        // constant - slope * i  \n        int m = 2 + a[i];\n        int c = dp[i] - m * i;\n        cht.addLine(m, c);\n        \n        int ans = cht.query(i);\n        cout << ans << \" \\n\"[i == n];\n    }\n}\n\nint32_t main() \n{\n    auto begin = std::chrono::high_resolution_clock::now();\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int t = 1;\n    // freopen(\"in\",  \"r\", stdin);\n    // freopen(\"out\", \"w\", stdout);\n    \n    cin >> t;\n    for(int i = 1; i <= t; i++) \n    {\n        //cout << \"Case #\" << i << \": \";\n        Solve();\n    }\n    auto end = std::chrono::high_resolution_clock::now();\n    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);\n    cerr << \"Time measured: \" << elapsed.count() * 1e-9 << \" seconds.\\n\"; \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2107f1",
      "PROBLEM_ID": "2107F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, $1\\le n\\le 5\\cdot 10^3$ and you don't need to output the answer for each prefix. You can hack only if you solved all versions of this problem.\n\nLeo works as a programmer in the city center, and his lover teaches at a high school in the suburbs. Every weekend, Leo would ride his bike to the suburbs to spend a nice weekend with his lover.\n\nThere are $n$ cyclists riding in front of Leo on this road right now. They are numbered $1$, $2$, $\\ldots$, $n$ from front to back. Initially, Leo is behind the $n$-th cyclist. The $i$-th cyclist has an agility value $a_i$.\n\nLeo wants to get ahead of the $1$-st cyclist. Leo can take the following actions as many times as he wants:\n\n- Assuming that the first person in front of Leo is cyclist $i$, he can go in front of cyclist $i$ for a cost of $a_i$. This puts him behind cyclist $i - 1$.\n- Using his super powers, swap $a_i$ and $a_j$ ($1\\le i < j\\le n$) for a cost of $(j - i)$.\n\nLeo wants to know the minimum cost to get in front of the $1$-st cyclist. Here you only need to print the answer for the whole array, i.e. $[a_1, a_2, \\ldots, a_n]$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains a positive integer $n$ ($1 \\leq n \\leq 5\\cdot 10^3$), representing the number of the cyclists.\n\nThe second line of each test case contains $n$ integers $a_1, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5\\cdot 10^3$.\n\n### Output\n\nFor each test case, print one integer representing the minimum cost for Leo to go from behind the $n$-th cyclist to in front of the $1$-st cyclist.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\n1 2 4\n\n4\n\n1 1 1 1\n\n2\n\n1 2\n\n4\n\n4 1 3 2\n\n```\n\n#### Output #1\n\n```\n7\n4\n3\n8\n```\n\n### Note\n\nIn the first test case, one possible way to move from the position behind the $n$-th cyclist to the position in front of the $1$-st cyclist is:\n\n- Leo swaps $a_2$ $(i=2)$ and $a_3$ $(j=3)$, then the array becomes $[1,4,2]$; it costs $j-i=3-2=1$.\n- Leo is behind the $3$-rd cyclist and moves behind the $2$-nd cyclist; it costs $a_3=2$.\n- Leo swaps $a_1$ $(i=1)$ and $a_2$ $(j=2)$, then the array becomes $[4,1,2]$; it costs $j-i=2-1=1$.\n- Leo is behind the $2$-nd cyclist and moves behind the $1$-st cyclist; it costs $a_2=1$.\n- Leo swaps $a_1$ $(i=1)$ and $a_2$ $(j=2)$, then the array becomes $[1,4,2]$; it costs $j-i=2-1=1$.\n- Leo moves ahead of the $1$-st cyclist; it costs $a_1=1$.\n\nSo the total cost is $1+2+1+1+1+1=7$. It can be proved that $7$ is the minimum cost.\n\nIn the second test case, to move ahead of the $1$-st cyclist from the position behind the $n$-th cyclist, Leo should not swap anyone's agility value. The total cost is $1+1+1+1=4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int t; cin >> t;\n    while (t--){\n        int n; cin >> n;\n        \n        vector <int> a(n + 1);\n        for (int i = 1; i <= n; i++){\n            cin >> a[i];\n        }\n        \n        vector <long long> dp(n + 1, 1e18);\n        dp[n] = 0;\n        \n        for (int i = n - 1; i >= 0; i--){\n            int p = i + 1;\n            for (int j = i + 1; j <= n; j++) if (a[j] < a[p]){\n                p = j;\n            }\n            \n            for (int j = p; j <= n; j++){\n                dp[i] = min(dp[i], dp[j] + 2 * (j - p) + 1LL * (j - i) * a[p] + (p - i - 1));\n            }\n        }\n        \n        cout << dp[0] << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2107e",
      "PROBLEM_ID": "2107E",
      "PROBLEM_STATEMENT": "If I was also hit by an apple falling from an apple tree, could I become as good at physics as Newton?\n\nTo be better at physics, Ain wants to build an apple tree so that she can get hit by apples on it. Her apple tree has $n$ nodes and is rooted at $1$. She defines the weight of an apple tree as $\\sum \\limits_{i=1}^n \\sum \\limits_{j=i+1}^n \\text{dep}(\\operatorname{lca}(i,j))$.\n\nHere, $\\text{dep}(x)$ is defined as the number of edges on the unique shortest path from node $1$ to node $x$. $\\operatorname{lca}(i, j)$ is defined as the unique node $x$ with the largest value of $\\text{dep}(x)$ and which is present on both the paths $(1, i)$ and $(1, j)$.\n\nFrom some old books Ain reads, she knows that Newton's apple tree's weight is around $k$, but the exact value of it is lost.\n\nAs Ain's friend, you want to build an apple tree with $n$ nodes for her, and the absolute difference between your tree's weight and $k$ should be at most $1$, i.e. $|\\text{weight} - k| \\le 1$. Unfortunately, this is not always possible, in this case please report it.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two numbers $n,k$ ($2 \\le n \\le 10^5,0 \\le k \\le 10^{15}$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, first output $\\texttt{Yes}$ if a solution exists or $\\texttt{No}$ if no solution exists. You may print each character in either case, for example $\\texttt{YES}$ and $\\texttt{yEs}$ will also be accepted.\n\nIf there's at least one solution, print $n-1$ lines and each line contains two numbers $u,v$ $(1 \\le u,v \\le n)$ represents the apple tree.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2 1\n\n2 2\n\n4 0\n\n5 7\n\n5 5\n\n```\n\n#### Output #1\n\n```\nYes\n1 2\nNo\nYes\n1 2\n1 3\n1 4\nYes\n1 3\n3 5\n4 5\n3 2\nYes\n1 2\n2 3\n2 4\n2 5\n```\n\n### Note\n\nIn the first test case, we can check that the weight is $0$. This satisfies the condition because $k = 1$ and so the absolute difference is only $1$.\n\nIn the second test case, there exists no solution because there are no trees of $2$ nodes with weights of either $1, 2$ or $3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int t; cin >> t;\n    while (t--){\n        int n; cin >> n;\n        long long k; cin >> k;\n        \n        long long mx = 1LL * n * (n - 1) * (n - 2) / 6;\n        if (k > mx + 1){\n            cout << \"No\\n\";\n            continue;\n        }\n        cout << \"Yes\\n\";\n        k = mx - min(k, mx);\n        \n        int p = n - 1;\n        for (int i = n; i >= 2; i--){\n            while (1LL * p * (p - 1) / 2 > k){\n                p--;\n            }\n            k -= 1LL * p * (p - 1) / 2;\n            \n            cout << (i - p) << \" \" << i << \"\\n\";\n            if (p != 1) p--;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2107c",
      "PROBLEM_ID": "2107C",
      "PROBLEM_STATEMENT": "You are given an array $a_1,a_2,\\ldots,a_n$ of length $n$ and a positive integer $k$, but some parts of the array $a$ are missing. Your task is to fill the missing part so that the maximum subarray sum$^{\\text{\u2217}}$ of $a$ is exactly $k$, or report that no solution exists.\n\nFormally, you are given a binary string $s$ and a partially filled array $a$, where:\n\n- If you remember the value of $a_i$, $s_i = 1$ to indicate that, and you are given the real value of $a_i$.\n- If you don't remember the value of $a_i$, $s_i = 0$ to indicate that, and you are given $a_i = 0$.\n\nAll the values that you remember satisfy $|a_i| \\le 10^6$. However, you may use values up to $10^{18}$ to fill in the values that you do not remember. It can be proven that if a solution exists, a solution also exists satisfying $|a_i| \\le 10^{18}$.\n\n$^{\\text{\u2217}}$The maximum subarray sum of an array $a$ of length $n$, i.e. $a_1, a_2, \\ldots a_n$ is defined as $\\max_{1 \\le i \\le j \\le n} S(i, j)$ where $S(i, j) = a_i + a_{i + 1} + \\ldots + a_j$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two numbers $n,k$ ($1 \\le n \\le 2 \\cdot 10^5,1 \\le k \\le 10^{12}$).\n\nThe second line of each test case contains a binary ($\\texttt{01}$) string $s$ of length $n$.\n\nThe third line of each test case contains $n$ numbers $a_1,a_2,\\ldots,a_n$ ($|a_i| \\le 10^6$). If $s_i = \\texttt{0}$, then it's guaranteed that $a_i = 0$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, first output $\\texttt{Yes}$ if a solution exists or $\\texttt{No}$ if no solution exists. You may print each character in either case, for example $\\texttt{YES}$ and $\\texttt{yEs}$ will also be accepted.\n\nIf there's at least one solution, print $n$ numbers $a_1,a_2,\\ldots,a_n$ on the second line. $|a_i| \\le 10^{18}$ must hold.\n\n### Example\n\n#### Input #1\n\n```\n\n10\n\n3 5\n\n011\n\n0 0 1\n\n5 6\n\n11011\n\n4 -3 0 -2 1\n\n4 4\n\n0011\n\n0 0 -4 -5\n\n6 12\n\n110111\n\n1 2 0 5 -1 9\n\n5 19\n\n00000\n\n0 0 0 0 0\n\n5 19\n\n11001\n\n-8 6 0 0 -5\n\n5 10\n\n10101\n\n10 0 10 0 10\n\n1 1\n\n1\n\n0\n\n3 5\n\n111\n\n3 -1 3\n\n4 5\n\n1011\n\n-2 0 1 -5\n\n```\n\n#### Output #1\n\n```\nYes\n4 0 1\nYes\n4 -3 5 -2 1\nYes\n2 2 -4 -5\nNo\nYes\n5 1 9 2 2\nYes\n-8 6 6 7 -5\nYes\n10 -20 10 -20 10\nNo\nYes\n3 -1 3\nYes\n-2 4 1 -5\n```\n\n### Note\n\nIn test case $1$, only the first position is not filled. We can fill it with $4$ to get the array $[4, 0, 1]$ which has maximum subarray sum of $5$.\n\nIn test case $2$, only the third position is not filled. We can fill it with $5$ to get the array $[4, -3, 5, -2, 1]$. Here the maximum subarray sum comes from the subarray $[4, -3, 5]$ and it is $6$, as required.\n\nIn test case $3$, the first and second positions are unfilled. We can fill both with $2$ to get the array $[2, 2, -4, -5]$ which has a maximum subarray sum of $4$. Note that other outputs are also possible such as $[0, 4, -4, -5]$.\n\nIn test case $4$, it is impossible to get a valid array. For example, if we filled the third position with $0$, we get $[1, 2, 0, 5, -1, 9]$, but this has a maximum subarray sum of $16$, not $12$ as required.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    const ll NEG = 1000000000000000000LL; // a large negative filler\n\n    while(t--){\n        int n;\n        ll k;\n        cin >> n >> k;\n        string s;\n        cin >> s;\n        vector<ll> a(n);\n        for(int i = 0; i < n; i++){\n            cin >> a[i];\n        }\n\n        // Identify contiguous blocks of known elements (s[i] == '1')\n        struct Block {\n            int l, r;\n            ll prefix_max;\n            ll suffix_max;\n            ll block_max;\n        };\n        vector<Block> blocks;\n        vector<int> block_id(n, -1);\n\n        ll known_max = LLONG_MIN;\n        for(int i = 0; i < n; ){\n            if(s[i] == '1'){\n                int l = i;\n                while(i < n && s[i] == '1') i++;\n                int r = i - 1;\n                // compute prefix_max, suffix_max, block_max for [l..r]\n                ll sum = 0, pmx = LLONG_MIN;\n                for(int j = l; j <= r; j++){\n                    sum += a[j];\n                    pmx = max(pmx, sum);\n                    block_id[j] = (int)blocks.size();\n                }\n                ll sum2 = 0, smx = LLONG_MIN;\n                for(int j = r; j >= l; j--){\n                    sum2 += a[j];\n                    smx = max(smx, sum2);\n                }\n                // Kadane for block_max\n                ll cur = LLONG_MIN, bmx = LLONG_MIN;\n                for(int j = l; j <= r; j++){\n                    if(cur < 0) cur = a[j];\n                    else cur += a[j];\n                    bmx = max(bmx, cur);\n                }\n                Block B{l, r, pmx, smx, bmx};\n                blocks.push_back(B);\n                known_max = max(known_max, bmx);\n            } else {\n                i++;\n            }\n        }\n        // If no known blocks, treat known_max < k\n        if(blocks.empty()){\n            known_max = LLONG_MIN;\n        }\n\n        // If any known-block max-subarray exceeds k, impossible\n        if(known_max > k){\n            cout << \"No\\n\";\n            continue;\n        }\n\n        // Check if we have any unknown positions\n        bool has_unknown = false;\n        for(char c : s) if(c == '0'){ has_unknown = true; break; }\n\n        // Case 1: known_max == k: just fill all unknowns with large negative to prevent any >k\n        if(known_max == k){\n            cout << \"Yes\\n\";\n            for(int i = 0; i < n; i++){\n                if(s[i] == '0') cout << -NEG;\n                else             cout << a[i];\n                if(i + 1 < n) cout << ' ';\n            }\n            cout << '\\n';\n            continue;\n        }\n\n        // Case 2: known_max < k but no unknown to boost => impossible\n        if(!has_unknown){\n            cout << \"No\\n\";\n            continue;\n        }\n\n        // Case 3: known_max < k and we have unknowns => pick one unknown position p\n        int p = -1;\n        for(int i = 0; i < n; i++){\n            if(s[i] == '0'){\n                p = i;\n                break;\n            }\n        }\n        // Compute best suffix sum on left, and best prefix sum on right\n        ll P = 0, Q = 0;\n        if(p > 0 && s[p-1] == '1'){\n            int bid = block_id[p-1];\n            // we may choose to include left suffix only if positive\n            P = max(blocks[bid].suffix_max, 0LL);\n        }\n        if(p+1 < n && s[p+1] == '1'){\n            int bid = block_id[p+1];\n            Q = max(blocks[bid].prefix_max, 0LL);\n        }\n        // Set a[p] so that P + a[p] + Q == k\n        ll X = k - (P + Q);\n\n        // Output solution\n        cout << \"Yes\\n\";\n        for(int i = 0; i < n; i++){\n            if(s[i] == '1'){\n                // known entries stay\n                cout << a[i];\n            } else {\n                // unknown entries: only at p set X, others large negative\n                if(i == p) cout << X;\n                else        cout << -NEG;\n            }\n            if(i + 1 < n) cout << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2107b",
      "PROBLEM_ID": "2107B",
      "PROBLEM_STATEMENT": "Tom and Jerry found some apples in the basement. They decided to play a game to get some apples.\n\nThere are $n$ boxes, and the $i$-th box has $a_i$ apples inside. Tom and Jerry take turns picking up apples. Tom goes first. On their turn, they have to do the following:\n\n- Choose a box $i$ ($1 \\le i \\le n$) with a positive number of apples, i.e. $a_i > 0$, and pick $1$ apple from this box. Note that this reduces $a_i$ by $1$.\n- If no valid box exists, the current player loses.\n- If after the move, $\\max(a_1, a_2, \\ldots, a_n) - \\min(a_1, a_2, \\ldots, a_n) > k$ holds, then the current player (who made the last move) also loses.\n\nIf both players play optimally, predict the winner of the game.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n,k$ ($2 \\le n \\le 10^5,1\\le k \\le 10^9$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, print \"Tom\" (without quotes) if Tom will win, or \"Jerry\" (without quotes) otherwise.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3 1\n\n2 1 2\n\n3 1\n\n1 1 3\n\n2 1\n\n1 4\n\n```\n\n#### Output #1\n\n```\nTom\nTom\nJerry\n```\n\n### Note\n\nNote that neither player is necessarily playing an optimal strategy in the following games, just to give you an idea of how the game is going.\n\nIn the first test case of the example, one possible situation is shown as follows.\n\n- Tom takes an apple from the first box. The array $a$ becomes $[1, 1, 2]$. Tom does not lose because $\\max(1, 1, 2) - \\min(1, 1, 2) = 1 \\le k$.\n- Jerry takes an apple from the first box as well. The array $a$ becomes $[0, 1, 2]$. Jerry loses because $\\max(0, 1, 2) - \\min(0, 1, 2) = 2 > k$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t; \n    cin >> t;\n    while(t--){\n        int n;\n        long long k;\n        cin >> n >> k;\n        vector<long long> a(n);\n        long long sum = 0;\n        for (int i = 0; i < n; i++){\n            cin >> a[i];\n            sum += a[i];\n        }\n        sort(a.begin(), a.end());\n        long long mn = a[0], mx = a[n-1];\n \n        // Count how many boxes are at the minimum and maximum.\n        int countMin = 0, countMax = 0;\n        for (int i = 0; i < n; i++){\n            if(a[i] == mn)\n                countMin++;\n            else\n                break;\n        }\n        for (int i = n - 1; i >= 0; i--){\n            if(a[i] == mx)\n                countMax++;\n            else\n                break;\n        }\n        int countMid = n - countMin - countMax; // boxes strictly between mn and mx\n \n        bool safe = false;\n        // If all boxes are equal then (provided they are positive) a move is safe.\n        if(mn == mx){\n            if(mn > 0)\n                safe = true;\n            else\n                safe = false; // All boxes 0 means no moves.\n        } else {\n            // Option 1: try a move from a box with a value strictly between mn and mx.\n            if(countMid > 0){\n                // For such a move the move does not change the overall extreme values.\n                // So it is safe provided (mx - mn) <= k.\n                if(mx - mn <= k)\n                    safe = true;\n            }\n            // Option 2: try a move from a maximum box.\n            if(!safe){\n                if(countMax >= 2){\n                    // Non-unique maximum: removing one apple from a maximum stays in the mx bucket (since others are still mx).\n                    // So safe if (mx - mn) <= k.\n                    if(mx - mn <= k)\n                        safe = true;\n                } else { // unique maximum\n                    // Removing one apple makes that box become mx-1.\n                    // In the new state the maximum will be at most (mx-1) and the min is still mn.\n                    // This move is safe provided ( (mx-1) - mn ) <= k.\n                    if((mx - 1) - mn <= k)\n                        safe = true;\n                }\n            }\n            // Option 3: try a move from a minimum box.\n            if(!safe){\n                // Removing an apple from a minimum box (whether it is unique or not)\n                // causes that box to become (mn-1) and so the new min becomes (mn-1).\n                // The new difference becomes: mx - (mn-1) = (mx - mn + 1).\n                // This move is safe provided (mx - mn + 1) <= k, i.e. (mx - mn) <= k - 1.\n                if(mn > 0 && (mx - mn) <= k - 1)\n                    safe = true;\n            }\n        }\n \n        // If no safe move exists, the current (first) player loses.\n        if(!safe){\n            cout << \"Jerry\" << \"\\n\";\n        } \n        else {\n            // Otherwise every move is \u201csafe\u201d and exactly one apple is removed per move.\n            // Hence the game lasts exactly sum moves.\n            // (This idea is valid because when a safe move is available the players will never choose a move that immediately loses.)\n            // In a normal take-away game where one apple is taken per move,\n            // the first player wins if and only if sum is odd.\n            if(sum % 2 == 1)\n                cout << \"Tom\" << \"\\n\";\n            else\n                cout << \"Jerry\" << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2107a",
      "PROBLEM_ID": "2107A",
      "PROBLEM_STATEMENT": "You have an array $a$ of size $n$ \u2014 $a_1, a_2, \\ldots a_n$.\n\nYou need to divide the $n$ elements into $2$ sequences $B$ and $C$, satisfying the following conditions:\n\n- Each element belongs to exactly one sequence.\n- Both sequences $B$ and $C$ contain at least one element.\n- $\\gcd$ $(B_1, B_2, \\ldots, B_{|B|}) \\ne \\gcd(C_1, C_2, \\ldots, C_{|C|})$ $^{\\text{\u2217}}$\n\n$^{\\\\text{\u2217}}$$\\\\gcd(x, y)$ denotes the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers $x$ and $y$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($2 \\le n \\le 100$).\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le 10^4$).\n\n### Output\n\nFor each test case, first output $\\texttt{Yes}$ if a solution exists or $\\texttt{No}$ if no solution exists. You may print each character in either case, for example $\\texttt{YES}$ and $\\texttt{yEs}$ will also be accepted.\n\nOnly when there is a solution, output $n$ integers on the second line. The $i$-th number should be either $1$ or $2$. $1$ represents that the element belongs to sequence $B$ and $2$ represents that the element belongs to sequence $C$.\n\nYou should guarantee that $1$ and $2$ both appear at least once.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4\n\n1 20 51 9\n\n4\n\n5 5 5 5\n\n3\n\n1 2 2\n\n```\n\n#### Output #1\n\n```\nYes\n2 2 1 1\nNo\nYes\n1 2 2\n```\n\n### Note\n\nIn the first test case, $B = [51, 9]$ and $C = [1, 20]$. You can verify $\\gcd(B_1, B_2) = 3 \\ne 1 = \\gcd(C_1, C_2)$.\n\nIn the second test case, it is impossible to find a solution. For example, suppose you distributed the first $3$ elements to array $B$ and then the last element to array $C$. You have $B = [5, 5, 5]$ and $C = [5]$, but $\\gcd(B_1, B_2, B_3) = 5 = \\gcd(C_1)$. Hence it is invalid.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint calculate_gcd(const vector<int>& arr) {\n    if (arr.empty()) return 0;\n    int result = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        result = gcd(result, arr[i]);\n    }\n    return result;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        \n        // Check if all elements are the same\n        bool all_same = true;\n        for (int i = 1; i < n; i++) {\n            if (a[i] != a[0]) {\n                all_same = false;\n                break;\n            }\n        }\n        \n        if (all_same) {\n            cout << \"No\" << endl;\n            continue;\n        }\n        \n        // Try putting one element in B and the rest in C\n        bool found_partition = false;\n        for (int i = 0; i < n && !found_partition; i++) {\n            vector<int> C;\n            for (int j = 0; j < n; j++) {\n                if (j != i) {\n                    C.push_back(a[j]);\n                }\n            }\n            \n            int gcd_B = a[i];  // GCD of a single element is the element itself\n            int gcd_C = calculate_gcd(C);\n            \n            if (gcd_B != gcd_C) {\n                cout << \"Yes\" << endl;\n                for (int j = 0; j < n; j++) {\n                    if (j == i) {\n                        cout << \"1 \";\n                    } else {\n                        cout << \"2 \";\n                    }\n                }\n                cout << endl;\n                found_partition = true;\n            }\n        }\n        \n        // If no partition found with one element in B\n        if (!found_partition) {\n            // This case is unlikely to happen if array has different elements\n            // But let's try a different approach just in case\n            int first_different = -1;\n            for (int i = 1; i < n; i++) {\n                if (a[i] != a[0]) {\n                    first_different = i;\n                    break;\n                }\n            }\n            \n            cout << \"Yes\" << endl;\n            for (int i = 0; i < n; i++) {\n                if (i == 0 || i == first_different) {\n                    cout << \"1 \";\n                } else {\n                    cout << \"2 \";\n                }\n            }\n            cout << endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2106f",
      "PROBLEM_ID": "2106F",
      "PROBLEM_STATEMENT": "Dr. TC has a new patient called Goblin. He wants to test Goblin's intelligence, but he has gotten bored of his standard test. So, he decided to make it a bit harder.\n\nFirst, he creates a binary string$^{\\text{\u2217}}$ $s$ having $n$ characters. Then, he creates $n$ binary strings $a_1, a_2, \\ldots, a_n$. It is known that $a_i$ is created by first copying $s$, then flipping the $i$-th character ($\\texttt{1}$ becomes $\\texttt{0}$ and vice versa). After creating all $n$ strings, he arranges them into an $n \\times n$ grid $g$ where $g_{i, j} = a_{i_j}$.\n\nA set $S$ of size $k$ containing distinct integer pairs $\\{(x_1, y_1), (x_2, y_2), \\ldots, (x_k, y_k)\\}$ is considered good if:\n\n- $1 \\leq x_i, y_i \\leq n$ for all $1 \\leq i \\leq k$.\n- $g_{x_i, y_i} = \\texttt{0}$ for all $1 \\leq i \\leq k$.\n- For any two integers $i$ and $j$ ($1 \\leq i, j \\leq k$), coordinate $(x_i, y_i)$ is reachable from coordinate $(x_j, y_j)$ by traveling through a sequence of adjacent cells (which share a side) that all have a value of $\\texttt{0}$.\n\nGoblin's task is to find the maximum possible size of a good set $S$. Because Dr. TC is generous, this time he gave him two seconds to find the answer instead of one. Goblin is not known for his honesty, so he has asked you to help him cheat.\n\n$^{\\text{\u2217}}$A binary string is a string that only consists of characters $\\texttt{1}$ and $\\texttt{0}$.\n\n### Input\n\nThe first line of the input consists of a single integer $t$ $(1 \\le t \\le 10^3)$\u00a0\u2014 the number of test cases.\n\nThe first line of each test contains a single integer $n$ $(1 \\le n \\le 2 \\cdot 10^5)$\u00a0\u2014 the length of the binary string $s$.\n\nThe second line of each test contains a single binary string $s$ of length $n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single number, the maximum possible size of a good set of cells from the grid.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n3\n\n000\n\n4\n\n0010\n\n7\n\n1011001\n\n4\n\n0001\n\n2\n\n11\n\n1\n\n0\n\n```\n\n#### Output #1\n\n```\n3\n9\n10\n7\n1\n0\n```\n\n### Note\n\nIn the first example, the following grid has been written on the board:\n\n\n\n$$ 1 0 0 $$\n\n0 1 0 \n\n$$ $$\n\n0 0 1 $$\n\nThe set that consists of cells $(1, 2)$ and $(1, 3)$ is good. The set that consists of cells $(1, 1)$ and $(1, 2)$ is not good, since the value of cell $(1, 1)$ is not $0$. The set of cells $(1, 2)$, $(1, 3)$, $(2, 3)$ is good and has a maximum size of $3$. Note that the set of cells $(2, 1)$, $(3, 1)$, and $(3, 2)$ is also good with a maximum size of $3$.\n\nIn the second example, the following grid is written on the board:\n\n\n\n$$ 1 0 1 0 $$\n\n0 1 1 0 \n\n$$ $$\n\n0 0 0 0 \n\n$$ $$\n\n0 0 1 1 $$\n\nAnd the maximum possible size of a good set is $9$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct DSU {\n    int n;\n    vector<int> p, r;\n    DSU(int _n): n(_n), p(_n), r(_n,0) {\n        for(int i = 0; i < n; i++) p[i] = i;\n    }\n    int find(int x){\n        // iterative path compression\n        while(p[x] != x){\n            p[x] = p[p[x]];\n            x = p[x];\n        }\n        return x;\n    }\n    void unite(int a, int b){\n        a = find(a);\n        b = find(b);\n        if(a == b) return;\n        if(r[a] < r[b]) swap(a,b);\n        p[b] = a;\n        if(r[a] == r[b]) r[a]++;\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        // segments in each column\n        vector<vector<int>> segs(n);\n        // for each segment id: [L..R] interval of rows, and weight = number of zeros\n        vector<int> segL, segR;\n        vector<long long> w;\n        segL.reserve(2*n);\n        segR.reserve(2*n);\n        w.reserve(2*n);\n        int id = 0;\n        // build segments\n        for(int j0 = 0; j0 < n; j0++){\n            int j = j0 + 1; \n            if(s[j0] == '0'){\n                // upper segment [1..j-1]\n                if(j > 1){\n                    segL.push_back(1);\n                    segR.push_back(j-1);\n                    w.push_back((long long)(j-1));\n                    segs[j0].push_back(id++);\n                }\n                // lower segment [j+1..n]\n                if(j < n){\n                    segL.push_back(j+1);\n                    segR.push_back(n);\n                    w.push_back((long long)(n - j));\n                    segs[j0].push_back(id++);\n                }\n            } else {\n                // single zero at diagonal [j..j]\n                segL.push_back(j);\n                segR.push_back(j);\n                w.push_back(1LL);\n                segs[j0].push_back(id++);\n            }\n        }\n        if(id == 0){\n            // no zero cells\n            cout << 0 << \"\\n\";\n            continue;\n        }\n        // DSU on segments\n        DSU dsu(id);\n        // connect overlapping segments between adjacent columns\n        for(int j0 = 0; j0 + 1 < n; j0++){\n            for(int x : segs[j0]){\n                for(int y : segs[j0+1]){\n                    int L = max(segL[x], segL[y]);\n                    int R = min(segR[x], segR[y]);\n                    if(L <= R){\n                        dsu.unite(x, y);\n                    }\n                }\n            }\n        }\n        // accumulate component weights\n        vector<long long> compW(id, 0LL);\n        long long ans = 0;\n        for(int i = 0; i < id; i++){\n            int r = dsu.find(i);\n            compW[r] += w[i];\n            if(compW[r] > ans) ans = compW[r];\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2106e",
      "PROBLEM_ID": "2106E",
      "PROBLEM_STATEMENT": "Wolf has found $n$ sheep with tastiness values $p_1, p_2, ..., p_n$ where $p$ is a permutation$^{\\text{\u2217}}$. Wolf wants to perform binary search on $p$ to find the sheep with tastiness of $k$, but $p$ may not necessarily be sorted. The success of binary search on the range $[l, r]$ for $k$ is represented as $f(l, r, k)$, which is defined as follows:\n\nIf $l > r$, then $f(l, r, k)$ fails. Otherwise, let $m = \\lfloor\\frac{l + r}{2}\\rfloor$, and:\n\n- If $p_m = k$, then $f(l, r, k)$ is successful,\n- If $p_m < k$, then $f(l, r, k) = f(m+1, r, k)$,\n- If $p_m > k$, then $f(l, r, k) = f(l, m-1, k)$.\n\nCow the Nerd decides to help Wolf out. Cow the Nerd is given $q$ queries, each consisting of three integers $l$, $r$, and $k$. Before the search begins, Cow the Nerd may choose a non-negative integer $d$, and $d$ indices $1 \\le i_1 < i_2 < \\ldots < i_d \\le n$ where $p_{i_j} \\neq k$ over all $1 \\leq j \\leq d$. Then, he may re-order the elements $p_{i_1}, p_{i_2}, ..., p_{i_d}$ however he likes.\n\nFor each query, output the minimum integer $d$ that Cow the Nerd must choose so that $f(l, r, k)$ can be successful, or report that it is impossible. Note that the queries are independent and the reordering is not actually performed.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array that contains every integer from $1$ to $n$ exactly once.\n\n### Input\n\nThe first line of the input contains a single integer $t$ $(1 \\le t \\le 10^4)$\u00a0\u2014 the number of test cases.\n\nThe first line of each test contains two integers $n$ and $q$ $(1 \\le n, q \\le 2 \\cdot 10^5)$\u00a0\u2014 the length of $p$ and the number of queries respectively.\n\nThe second line contains $n$ integers $p_1, p_2, ..., p_n$\u00a0\u2014 the tastiness of the $i$-th sheep. It is guaranteed that every integer from $1$ to $n$ appears exactly once in $p$.\n\nThe following $q$ lines contain three integers $l$, $r$, and $k$ $(1 \\le l \\le r \\le n, 1 \\le k \\le n)$\u00a0\u2014 the range that the binary search will be performed on and the integer being searched for each query.\n\nIt is guaranteed that the sum of $n$ and the sum of $q$ over all cases do not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each query, output the minimum integer $d$ that Cow the Nerd must choose so that $f(l, r, k)$ is successful on a new line. If it is impossible, output $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n5 3\n\n1 2 3 4 5\n\n1 5 4\n\n1 3 4\n\n3 4 4\n\n7 4\n\n3 1 5 2 7 6 4\n\n3 4 2\n\n2 3 5\n\n1 5 6\n\n1 7 3\n\n2 1\n\n2 1\n\n1 2 1\n\n1 1\n\n1\n\n1 1 1\n\n7 1\n\n3 4 2 5 7 1 6\n\n1 7 1\n\n16 1\n\n16 10 12 6 13 9 14 3 8 11 15 2 7 1 5 4\n\n1 16 4\n\n16 1\n\n14 1 3 15 4 5 6 16 7 8 9 10 11 12 13 2\n\n1 16 14\n\n13 1\n\n12 13 10 9 8 4 11 5 7 6 2 1 3\n\n1 13 2\n\n```\n\n#### Output #1\n\n```\n0 -1 0\n2 0 -1 4\n-1\n0\n-1\n-1\n-1\n-1\n```\n\n### Note\n\nIn the first example, second query: Since $4$ does not exist in the first three elements, it is impossible to find it when searching for it in that range.\n\nIn the second example, on the first query, you may choose the indices $2$, $3$, and swap them so $p = [3, 5, 1, 2, 7, 6, 4]$. Then, $f(3, 4, 2)$ will work as follows:\n\n1. Let $m = \\lfloor \\frac{3 + 4}{2} \\rfloor = 3$. Because $p_3 = 1 < 2$, then $f(3, 4, 2) = f(4, 4, 2)$.\n2. Let $m = \\lfloor \\frac{4 + 4}{2} \\rfloor = 4$. Because $p_4 = 2 = k$, then $f(4, 4, 2)$ is successful. Therefore, $f(3, 4, 2)$ is also successful.\n\nThe total indices chosen were $2$, so the final cost is $2$, which can be shown that is minimum. Note that for this query we can't choose index $4$, since $p_4 = k = 2$.\n\nIn the last query of the second example, we can choose indices $2, 3, 4, 5$ and re-arrange them so $p = [3, 5, 2, 7, 1, 6, 4]$. Then, $f(1, 7, 3)$ is successful.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * @brief Solves a single test case for the Wolf and Sheep problem.\n * \n * Reads the input for one test case, including the permutation p, its length n,\n * and the number of queries q. For each query (l, r, k), it calculates the minimum\n * number of elements 'd' that need to be reordered (excluding the element k)\n * such that a binary search for k in the range [l, r] succeeds. If success is impossible,\n * it outputs -1.\n */\nvoid solve() { \n    int n; // length of permutation p\n    int q; // number of queries\n    cin >> n >> q; \n\n    // Read the permutation p. Using 1-based indexing for convenience.\n    vector<int> p(n + 1); \n    // pos[k] stores the index i such that p[i] = k. This allows O(1) lookup of k's position.\n    vector<int> pos(n + 1); \n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n        pos[p[i]] = i; // Store the position of the value p[i]\n    }\n\n    // Process each query independently\n    for (int qi = 0; qi < q; ++qi) {\n        int l, r, k; // query parameters: search range [l, r], target value k\n        cin >> l >> r >> k; \n\n        // Find the actual index where value k is located in the original permutation p.\n        int k_pos = pos[k]; \n\n        // The binary search can only succeed if the target value k is present within the initial search range [l, r].\n        // If k's position (k_pos) is outside this range, it's impossible to find it.\n        if (k_pos < l || k_pos > r) {\n            cout << -1 << \"\\n\"; // Output -1 indicating impossibility\n            continue; // Move to the next query\n        }\n\n        // Simulate the sequence of middle indices visited if the binary search always moved towards k_pos.\n        // This represents the \"ideal\" path the binary search should take.\n        int current_l = l;\n        int current_r = r;\n        // Stores the middle indices visited on the ideal path, excluding the final index k_pos.\n        vector<int> ideal_path_indices; \n\n        while (current_l <= current_r) {\n            // Calculate middle index using a method safe from potential integer overflow.\n            int mid_idx = current_l + (current_r - current_l) / 2; \n            \n            // If the middle index is k_pos, the ideal path has reached the target. Stop simulation.\n            if (mid_idx == k_pos) {\n                break;\n            }\n            \n            // Record this middle index as part of the ideal path.\n            ideal_path_indices.push_back(mid_idx);\n            \n            // Determine the next search sub-range for the ideal path simulation.\n            if (mid_idx < k_pos) {\n                // If mid_idx is to the left of k_pos, the ideal path moves right.\n                current_l = mid_idx + 1; \n            } else { // mid_idx > k_pos\n                // If mid_idx is to the right of k_pos, the ideal path moves left.\n                current_r = mid_idx - 1; \n            }\n        }\n\n        // Analyze the values p[mid_idx] at indices visited along the ideal path.\n        // Count indices where p[mid_idx] would cause the binary search to deviate (\"bad\" indices)\n        // vs. indices where p[mid_idx] correctly directs the search (\"good\" indices).\n        int M_bad_lt = 0; // Count of bad indices m < k_pos (where p[m] > k, but needs p[m] < k to proceed correctly)\n        int M_bad_gt = 0; // Count of bad indices m > k_pos (where p[m] < k, but needs p[m] > k to proceed correctly)\n        int M_good_lt = 0; // Count of good indices m < k_pos (where p[m] < k, as needed)\n        int M_good_gt = 0; // Count of good indices m > k_pos (where p[m] > k, as needed)\n\n        for (int mid_idx : ideal_path_indices) {\n            if (mid_idx < k_pos) { // Current mid index is to the left of the target position k_pos\n                // To proceed towards k_pos (move right), we need p[mid_idx] < k.\n                if (p[mid_idx] > k) {\n                    M_bad_lt++; // p[mid_idx] > k would incorrectly move left, hence this index is \"bad\".\n                } else { \n                    // p[mid_idx] < k correctly moves right. (p[mid_idx] cannot be k since mid_idx != k_pos)\n                    M_good_lt++; \n                }\n            } else { // Current mid index is to the right of the target position k_pos (mid_idx > k_pos)\n                // To proceed towards k_pos (move left), we need p[mid_idx] > k.\n                if (p[mid_idx] < k) {\n                    M_bad_gt++; // p[mid_idx] < k would incorrectly move right, hence this index is \"bad\".\n                } else {\n                     // p[mid_idx] > k correctly moves left. (p[mid_idx] cannot be k since mid_idx != k_pos)\n                    M_good_gt++;\n                }\n            }\n        }\n\n        // The minimum number of elements 'd' required for reordering is determined by the maximum\n        // number of bad indices needing correction on either side (< k_pos or > k_pos).\n        // The formula is 2 * max(|M_bad^<|, |M_bad^>|).\n        int cost = 2 * max(M_bad_lt, M_bad_gt);\n        bool possible = true; // Assume the reordering is possible unless proven otherwise.\n\n        // Check if enough auxiliary elements (not on the ideal path and not k itself) exist \n        // with the required values (< k or > k) to facilitate the necessary swaps/reordering.\n        if (M_bad_lt > M_bad_gt) { // Need more values < k than available from swapping within M_bad indices.\n            int delta = M_bad_lt - M_bad_gt; // Number of additional elements with value < k required.\n            \n            // Calculate the count of available indices j such that:\n            // 1. j is not on the ideal path (j not in ideal_path_indices)\n            // 2. j is not k_pos\n            // 3. p[j] < k\n            // Total indices i with p[i] < k is k-1. Subtract those already accounted for on the ideal path.\n            int available_lt = (k - 1) - (M_bad_gt + M_good_lt); \n            \n            if (available_lt < delta) {\n                // Not enough spare elements with value < k exist outside the ideal path.\n                possible = false; \n            }\n        } else if (M_bad_gt > M_bad_lt) { // Need more values > k than available from swapping within M_bad indices.\n            int delta = M_bad_gt - M_bad_lt; // Number of additional elements with value > k required.\n\n            // Calculate the count of available indices j such that:\n            // 1. j is not on the ideal path\n            // 2. j is not k_pos\n            // 3. p[j] > k\n            // Total indices i with p[i] > k is n-k. Subtract those already accounted for on the ideal path.\n             int available_gt = (n - k) - (M_bad_lt + M_good_gt);\n             \n            if (available_gt < delta) {\n                 // Not enough spare elements with value > k exist outside the ideal path.\n                 possible = false; \n            }\n        }\n\n        // Output the result for the current query.\n        if (possible) {\n            cout << cost << \"\\n\"; // Output the minimum cost 'd'.\n        } else {\n            cout << -1 << \"\\n\"; // Output -1 if it's impossible to make the search succeed.\n        }\n    }\n}\n\n// Main function: sets up fast I/O and handles multiple test cases.\nint main() {\n    // Optimize standard C++ I/O operations for faster execution.\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        solve(); // Call the solve function for each test case.\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2106d",
      "PROBLEM_ID": "2106D",
      "PROBLEM_STATEMENT": "Flower boy has a garden of $n$ flowers that can be represented as an integer sequence $a_1, a_2, \\dots, a_n$, where $a_i$ is the beauty of the $i$-th flower from the left.\n\nIgor wants to collect exactly $m$ flowers. To do so, he will walk the garden from left to right and choose whether to collect the flower at his current position. The $i$-th flower among ones he collects must have a beauty of at least $b_i$.\n\nIgor noticed that it might be impossible to collect $m$ flowers that satisfy his beauty requirements, so before he starts collecting flowers, he can pick any integer $k$ and use his magic wand to grow a new flower with beauty $k$ and place it anywhere in the garden (between two flowers, before the first flower, or after the last flower). Because his magic abilities are limited, he may do this at most once.\n\nOutput the minimum integer $k$ Igor must pick when he performs the aforementioned operation to ensure that he can collect $m$ flowers. If he can collect $m$ flowers without using the operation, output $0$. If it is impossible to collect $m$ flowers despite using the operation, output $-1$.\n\n### Input\n\nThe first line of the input contains a single integer $t$ $(1 \\le t \\le 10^4)$\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains exactly two integers $n$ and $m$ $(1 \\le m \\le n \\le 2 \\cdot 10^5)$\u00a0\u2014 the number of flowers in the garden and the number of flowers Igor wants to collect, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, ..., a_n$ $(1 \\le a_i \\le 10^9)$\u00a0\u2014 where $a_i$ is the beauty of the $i$-th flower from the left in the garden.\n\nThe third line of each test case contains $m$ integers $b_1, b_2, ..., b_m$ $(1 \\le b_i \\le 10^9)$\u00a0\u2014 where $b_i$ is the minimum beauty the $i$-th flower must have that Igor will collect.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, on a separate line, output the minimum integer $k$ Igor must pick when he performs the aforementioned operation to ensure that he can collect $m$ flowers. If he can collect $m$ flowers without using the operation, output $0$. If it is impossible to collect $m$ flowers despite using the operation, output $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n9 5\n\n3 5 2 3 3 5 8 1 2\n\n4 6 2 4 6\n\n6 3\n\n1 2 6 8 2 1\n\n5 4 3\n\n5 3\n\n4 3 5 4 3\n\n7 4 5\n\n6 3\n\n8 4 2 1 2 5\n\n6 1 4\n\n5 5\n\n1 2 3 4 5\n\n5 4 3 2 1\n\n6 3\n\n1 2 3 4 5 6\n\n9 8 7\n\n5 5\n\n7 7 6 7 7\n\n7 7 7 7 7\n\n```\n\n#### Output #1\n\n```\n6\n3\n7\n0\n-1\n-1\n7\n```\n\n### Note\n\nIn the first test case, suppose Igor grows a flower of beauty $6$ and places it between the third and the fourth flowers. Then, the garden will look like the following: $[3, 5, 2, 6, 3, 3, 5, 8, 1, 2]$. Then, he can select the second, fourth, sixth, seventh, and eighth flowers with beauties $[5, 6, 3, 5, 8]$.\n\nIn the third test case, he can grow a flower of beauty $7$ and place it before the first flower. The garden will look like the following: $[7, 4, 3, 5, 4, 3]$. Now, he can choose the first, second, and fourth flowers.\n\nIn the fourth test case, Igor does not need to use the operation, so the answer is $0$.\n\nIn the sixth test case, no matter how Igor performs the operation, he cannot collect $3$ flowers such that the $i$-th flower he collects has a beauty of at least $b_i$, therefore the answer is $-1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t; \n    cin >> t;\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n        vector<int> a(n);\n        for (int i=0; i<n; i++){\n            cin >> a[i];\n        }\n        vector<int> b(m);\n        for (int j=0; j<m; j++){\n            cin >> b[j];\n        }\n \n        // Step 1. Compute L[0..m]:\n        // L[i] = earliest index in a (0-indexed) that can match the first i required flowers.\n        // We set L[0] = -1 (before beginning any flower).\n        // If a match fails, we mark L[i] = n (which we use as INF, since valid indices are 0..n-1).\n        vector<int> L(m+1, -1);\n        L[0] = -1;\n        int pos = 0;\n        for (int i = 1; i <= m; i++){\n            while(pos < n && a[pos] < b[i-1])\n                pos++;\n            if(pos >= n){\n                L[i] = n; // not found (INF)\n                for (int j = i; j <= m; j++){\n                    L[j] = n;\n                }\n                break;\n            } else {\n                L[i] = pos;\n                pos++;\n            }\n        }\n \n        // If we can match all m required flowers using a alone then answer is 0.\n        if(L[m] < n){\n            cout << 0 << \"\\n\";\n            continue;\n        }\n \n        // Step 2. Compute R[1..m] using backward greedy.\n        // R[i] will be the index (0-indexed) that is used to match b[i-1] in a from a right-to-left scan.\n        // If it is not possible to match b[i...m] then we mark R[i] = -1.\n        vector<int> R(m+1, -1);\n        int j = n - 1;\n        for (int i = m; i >= 1; i--){\n            while(j >= 0 && a[j] < b[i-1])\n                j--;\n            if(j < 0){\n                R[i] = -1;\n                for (int k = i - 1; k >= 1; k--){\n                    R[k] = -1;\n                }\n                break;\n            }\n            R[i] = j;\n            j--;\n        }\n \n        // Step 3. Try every possible split t (1-indexed for b) where\n        // the inserted flower will cover the t-th requirement.\n        // For a valid t we must have:\n        //    t == 1: (prefix empty) and if m > 1 then R[2] must be defined.\n        //    1 < t < m: L[t-1] (prefix match) is valid, R[t+1] defined, and L[t-1] < R[t+1] (order condition).\n        //    t == m: (suffix empty) and L[m-1] is valid.\n        int candidate = INT_MAX;\n        // (t == 1) case:\n        if(m == 1){\n            // if there is just one requirement and it cannot be matched then inserting a new flower with beauty b[0] works.\n            candidate = min(candidate, b[0]);\n        } else {\n            if(R[2] != -1) { // note: R[2] exists when m>=2\n                candidate = min(candidate, b[0]);\n            }\n        }\n \n        // (1 < t < m) cases.\n        for (int t_i = 2; t_i <= m - 1; t_i++){\n            // Check:\n            // L[t_i - 1] < n ensures the prefix is matched.\n            // R[t_i + 1] != -1 ensures the suffix is matched.\n            // L[t_i - 1] < R[t_i + 1] ensures that the order (new flower inserted between) holds.\n            if(L[t_i - 1] < n && R[t_i + 1] != -1 && L[t_i - 1] < R[t_i + 1]){\n                candidate = min(candidate, b[t_i - 1]);\n            }\n        }\n \n        // (t == m) case:\n        if(m > 1 && L[m - 1] < n){\n            candidate = min(candidate, b[m - 1]);\n        }\n \n        if(candidate == INT_MAX){\n            cout << -1 << \"\\n\";\n        } else {\n            cout << candidate << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2106b",
      "PROBLEM_ID": "2106B",
      "PROBLEM_STATEMENT": "Given a permutation$^{\\\\text{\u2217}}$ $p$ of length $n$ that contains every integer from $0$ to $n-1$ and a strip of $n$ cells, St. Chroma will paint the $i$-th cell of the strip in the color $\\\\operatorname{MEX}(p\\_1, p\\_2, ..., p\\_i)$$^{\\\\text{\u2020}}$.\n\nFor example, suppose $p = [1, 0, 3, 2]$. Then, St. Chroma will paint the cells of the strip in the following way: $[0, 2, 2, 4]$.\n\nYou have been given two integers $n$ and $x$. Because St. Chroma loves color $x$, construct a permutation $p$ such that the number of cells in the strip that are painted color $x$ is maximized.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is a sequence of $n$ elements that contains every integer from $0$ to $n-1$ exactly once. For example, $[0, 3, 1, 2]$ is a permutation, but $[1, 2, 0, 1]$ isn't since $1$ appears twice, and $[1, 3, 2]$ isn't since $0$ does not appear at all.\n\n$^{\\text{\u2020}}$The $\\operatorname{MEX}$ of a sequence is defined as the first non-negative integer that does not appear in it. For example, $\\operatorname{MEX}(1, 3, 0, 2) = 4$, and $\\operatorname{MEX}(3, 1, 2) = 0$.\n\n### Input\n\nThe first line of the input contains a single integer $t$ ($1 \\le t \\le 4000$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le x \\le n$)\u00a0\u2014 the number of cells and the color you want to maximize.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nOutput a permutation $p$ of length $n$ such that the number of cells in the strip that are painted color $x$ is maximized. If there exist multiple such permutations, output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n4 2\n\n4 0\n\n5 0\n\n1 1\n\n3 3\n\n1 0\n\n4 3\n\n```\n\n#### Output #1\n\n```\n1 0 3 2\n2 3 1 0\n3 2 4 1 0\n0\n0 2 1\n0\n1 2 0 3```\n\n### Note\n\nThe first example is explained in the statement. It can be shown that $2$ is the maximum amount of cells that can be painted in color $2$. Note that another correct answer would be the permutation $[0, 1, 3, 2]$.\n\nIn the second example, the permutation gives the coloring $[0, 0, 0, 4]$, so $3$ cells are painted in color $0$, which can be shown to be maximum.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nint main() {\n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        int n, x;\n        std::cin >> n >> x;\n        \n        std::vector<int> permutation(n);\n        \n        if (x == 0) {\n            // Place 0 at the end, rest at the beginning\n            for (int i = 0; i < n - 1; i++) {\n                permutation[i] = i + 1;\n            }\n            permutation[n - 1] = 0;\n        } else if (x < n) {\n            // Place 0 to x-1 at the beginning\n            for (int i = 0; i < x; i++) {\n                permutation[i] = i;\n            }\n            \n            // Place x at the end\n            permutation[n - 1] = x;\n            \n            // Fill the middle with remaining numbers\n            int idx = x;\n            for (int j = x + 1; j < n; j++) {\n                permutation[idx++] = j;\n            }\n        } else {\n            // x >= n, just output any permutation\n            for (int i = 0; i < n; i++) {\n                permutation[i] = i;\n            }\n        }\n        \n        // Output the permutation\n        for (int i = 0; i < n; i++) {\n            std::cout << permutation[i];\n            if (i < n - 1) {\n                std::cout << \" \";\n            }\n        }\n        std::cout << std::endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2106a",
      "PROBLEM_ID": "2106A",
      "PROBLEM_STATEMENT": "In order to test his patients' intelligence, Dr. TC created the following test.\n\nFirst, he creates a binary string$^{\\text{\u2217}}$ $s$ having $n$ characters. Then, he creates $n$ binary strings $a_1, a_2, \\ldots, a_n$. It is known that $a_i$ is created by first copying $s$, then flipping the $i$'th character ($\\texttt{1}$ becomes $\\texttt{0}$ and vice versa). After creating all $n$ strings, he arranges them into a grid where the $i$'th row is $a_i$.\n\nFor example,\n\n- If $s = \\texttt{101}$, $a = [\\texttt{001}, \\texttt{111}, \\texttt{100}]$.\n- If $s = \\texttt{0000}$, $a = [\\texttt{1000}, \\texttt{0100}, \\texttt{0010}, \\texttt{0001}]$.\n\nThe patient needs to count the number of $1$s written on the board in less than a second. Can you pass the test?\n\n$^{\\text{\u2217}}$A binary string is a string that only consists of characters $\\texttt{1}$ and $\\texttt{0}$.\n\n### Input\n\nThe first line of the input consists of a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10$)\u00a0\u2014 the length of the binary string $s$.\n\nThe second line of each test case contains a single binary string $s$ of size $n$.\n\n### Output\n\nFor each test case, output a single integer, the number of $\\texttt{1}$s on the board.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3\n\n101\n\n1\n\n1\n\n5\n\n00000\n\n2\n\n11\n\n3\n\n010\n\n```\n\n#### Output #1\n\n```\n5\n0\n5\n2\n4\n```\n\n### Note\n\nThe first example is explained in the statement.\n\nFor the second example, the only string written on the board will be the string $\\texttt{0}$; therefore, the answer is $0$.\n\nIn the third example, the following strings will be written on the board: $[\\texttt{10000}, \\texttt{01000}, \\texttt{00100}, \\texttt{00010}, \\texttt{00001}]$; so there are five $\\texttt{1}$s written on the board.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        \n        int count_ones = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '1') {\n                count_ones += (n - 1); // This position will be '1' in (n-1) rows\n            } else {\n                count_ones += 1; // This position will be '1' in exactly 1 row\n            }\n        }\n        \n        cout << count_ones << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2104g",
      "PROBLEM_ID": "2104G",
      "PROBLEM_STATEMENT": "Surely, you have seen problems which require you to output the answer modulo $10^9+7$, $10^9+9$, or $998244353$. But have you ever seen a problem where you have to print the answer modulo $3$?\n\nYou are given a functional graph consisting of $n$ vertices, numbered from $1$ to $n$. It is a directed graph, in which each vertex has exactly one outgoing arc. The graph is given as the array $g_1, g_2, \\dots, g_n$, where $g_i$ means that there is an arc that goes from $i$ to $g_i$. For some vertices, the outgoing arcs might be self-loops.\n\nInitially, all vertices of the graph are colored in color $1$. You can perform the following operation: select a vertex and a color from $1$ to $k$, and then color this vertex and all vertices that are reachable from it. You can perform this operation any number of times (even zero).\n\nYou should process $q$ queries. The query is described by three integers $x$, $y$ and $k$. For each query, you should:\n\n- assign $g_x := y$;\n- then calculate the number of different graph colorings for the given value of $k$ (two colorings are different if there exists at least one vertex that is colored in different colors in these two colorings); since the answer can be very large, print it modulo $3$.\n\nNote that in every query, the initial coloring of the graph is reset (all vertices initially have color $1$ in each query).\n\n### Input\n\nThe first line contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $g_1, g_2, \\dots, g_n$ ($1 \\le g_i \\le n$).\n\nThe $q$ lines follow. The $i$-th line contains three integers $x_i$, $y_i$ and $k_i$ ($1 \\le x_i, y_i \\le n$; $1 \\le k_i \\le 10^9$).\n\n### Output\n\nFor each query, print a single integer\u00a0\u2014 the number of different graph colorings for the given value of $k$, taken modulo $3$.\n\n### Examples\n\n#### Input #1\n\n```\n\n4 5\n\n2 3 1 4\n\n4 3 1\n\n2 1 2\n\n3 4 3\n\n4 1 5\n\n2 4 4\n\n```\n\n#### Output #1\n\n```\n1\n2\n0\n2\n1\n```\n\n#### Input #2\n\n```\n\n8 10\n\n7 4 6 8 7 7 1 4\n\n1 7 5\n\n2 3 3\n\n8 6 1\n\n3 1 3\n\n7 2 5\n\n5 2 4\n\n2 7 4\n\n4 6 5\n\n5 2 3\n\n4 5 1\n\n```\n\n#### Output #2\n\n```\n1\n0\n1\n0\n2\n1\n1\n2\n0\n1\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\nstruct DSUEvent {\n    int ru;       // if ru==0 => cycle event, rv_or_flip stores flip bit\n    int rv_or_flip;\n    int sz;       // old size of root rv when union\n};\n \nint n, q;\nint Ntime; // = q+1\nvector<pii> seg[/*max*/ 4 * 200005];\nint g_init[200005];\nint qx[200005], qy[200005], qk_mod3[200005];\nint ans_arr[200005];\n \n// DSU with rollback and parity\nint par_dsu[200005];\nint sz_dsu[200005];\nint val_dsu[200005]; // parity to parent\nvector<DSUEvent> st;\nint T_parity; // parity of number of even-length cycles (mod2)\n \n// Find with parity accumulation\nint find_root(int x, int &parity) {\n    parity = 0;\n    while (par_dsu[x] != x) {\n        parity ^= val_dsu[x];\n        x = par_dsu[x];\n    }\n    return x;\n}\n \n// Unite edge u-v with parity constraint d (here always 1)\nvoid dsu_unite(int u, int v) {\n    int pu, pv;\n    int ru = find_root(u, pu);\n    int rv = find_root(v, pv);\n    if (ru == rv) {\n        // cycle event\n        // cycle length parity = (pu ^ pv ^ 1)\n        // even cycle if (pu ^ pv) == 1\n        if ((pu ^ pv) == 1) {\n            // flip T_parity\n            T_parity ^= 1;\n            // record event ru=0, rv_or_flip=1\n            st.push_back({0,1,0});\n        }\n        // if odd cycle, no T change, no record\n    } else {\n        // union by size\n        // constraint parity(u->v) = d = 1\n        int d = 1;\n        if (sz_dsu[ru] < sz_dsu[rv]) {\n            // attach ru -> rv\n            st.push_back({ru, rv, sz_dsu[rv]});\n            par_dsu[ru] = rv;\n            // set parity of ru->rv: pu ^ pv ^ d\n            val_dsu[ru] = pu ^ pv ^ d;\n            sz_dsu[rv] += sz_dsu[ru];\n        } else {\n            // attach rv -> ru\n            st.push_back({rv, ru, sz_dsu[ru]});\n            par_dsu[rv] = ru;\n            val_dsu[rv] = pu ^ pv ^ d;\n            sz_dsu[ru] += sz_dsu[rv];\n        }\n    }\n}\n \n// Rollback DSU to checkpoint 'ck'\nvoid dsu_rollback(int ck) {\n    while ((int)st.size() > ck) {\n        DSUEvent e = st.back();\n        st.pop_back();\n        if (e.ru == 0) {\n            // cycle event, flip bit\n            T_parity ^= 1;\n        } else {\n            // union event: e.ru was child, e.rv_or_flip is parent root, e.sz is old size of that root\n            int ru = e.ru;\n            int rv = e.rv_or_flip;\n            int old_sz_rv = e.sz;\n            // rollback\n            sz_dsu[rv] = old_sz_rv;\n            par_dsu[ru] = ru;\n            val_dsu[ru] = 0;\n        }\n    }\n}\n \n// Add edge event to segment tree for interval [ql, qr)\nvoid seg_add(int idx, int l, int r, int ql, int qr, const pii &edge) {\n    if (ql >= r || qr <= l) return;\n    if (ql <= l && r <= qr) {\n        seg[idx].push_back(edge);\n        return;\n    }\n    int mid = (l + r) >> 1;\n    seg_add(idx<<1, l, mid, ql, qr, edge);\n    seg_add(idx<<1|1, mid, r, ql, qr, edge);\n}\n \n// DFS on segment tree, maintain DSU state\nvoid dfs(int idx, int l, int r) {\n    int checkpoint = st.size();\n    // apply edges in this segment\n    for (auto &e : seg[idx]) {\n        dsu_unite(e.first, e.second);\n    }\n    if (r - l == 1) {\n        // leaf at time t = l\n        int t = l;\n        if (t <= q) {\n            int km3 = qk_mod3[t];\n            int res;\n            if (km3 == 0) {\n                res = 0;\n            } else if (km3 == 1) {\n                res = 1;\n            } else {\n                // km3 == 2\n                // exponent parity = (n mod2) XOR T_parity\n                int ep = ((n & 1) ^ T_parity);\n                res = (ep ? 2 : 1);\n            }\n            ans_arr[t] = res;\n        }\n    } else {\n        int mid = (l + r) >> 1;\n        dfs(idx<<1, l, mid);\n        dfs(idx<<1|1, mid, r);\n    }\n    // rollback\n    dsu_rollback(checkpoint);\n}\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n \n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) {\n        cin >> g_init[i];\n    }\n    // read queries\n    for (int i = 1; i <= q; i++) {\n        cin >> qx[i] >> qy[i] >> qk_mod3[i];\n        qk_mod3[i] %= 3;\n    }\n    // collect update times for each x\n    static vector<int> upd_times[200005];\n    for (int i = 1; i <= q; i++) {\n        upd_times[qx[i]].push_back(i);\n    }\n    // build segment tree events\n    Ntime = q + 1;\n    // for each x, process its edge intervals\n    for (int x = 1; x <= n; x++) {\n        int last = 1;\n        int prev_y = g_init[x];\n        for (int ti : upd_times[x]) {\n            int l = last;\n            int r = ti;\n            if (l < r) {\n                seg_add(1, 1, Ntime, l, r, {x, prev_y});\n            }\n            // apply update at time ti\n            prev_y = qy[ti];\n            last = ti;\n        }\n        // last interval until end\n        if (last < Ntime) {\n            seg_add(1, 1, Ntime, last, Ntime, {x, prev_y});\n        }\n    }\n    // initialize DSU\n    st.reserve( (n + q) * 20 );\n    for (int i = 1; i <= n; i++) {\n        par_dsu[i] = i;\n        sz_dsu[i] = 1;\n        val_dsu[i] = 0;\n    }\n    T_parity = 0;\n    // run dfs on segment tree\n    dfs(1, 1, Ntime);\n    // output answers\n    for (int i = 1; i <= q; i++) {\n        cout << ans_arr[i] << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2104f",
      "PROBLEM_ID": "2104F",
      "PROBLEM_STATEMENT": "For each integer $x$ from $1$ to $n$, we will form the string $S(x)$ according to the following rules:\n\n- compute $(x+1)$;\n- write $x$ and $x+1$ next to each other in the decimal system without separators and leading zeros;\n- in the resulting string, sort all digits in non-decreasing order.\n\nFor example, the string $S(139)$ is 011349 (before sorting the digits, it is 139140). The string $S(99)$ is 00199.\n\nYour task is to count the number of distinct strings among $S(1), S(2), \\dots, S(n)$.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of one line containing a single integer $n$ ($1 \\le n \\le 10^{9} - 2$).\n\n### Output\n\nFor each test case, output a single integer \u2014 the number of distinct strings among $S(1), S(2), \\dots, S(n)$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n42\n\n1337\n\n```\n\n#### Output #1\n\n```\n42\n948\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nconst long long A = (long long)(1e18);\n \nstring S(long long x)\n{\n    string s = to_string(x) + to_string(x + 1);\n    sort(s.begin(), s.end());\n    return s;\n}\n \nvector<long long> aux2;\nvector<pair<string, long long>> aux;\n \nlong long get_num(string cur)\n{\n    int first_non_zero = 0;\n    while(cur[first_non_zero] == '0') first_non_zero++;\n    swap(cur[first_non_zero], cur[0]);\n    return stoll(cur);\n}\n \nvoid rec(string cur, bool flag)\n{\n    if(*max_element(cur.begin(), cur.end()) > '0')\n    {\n        long long x = get_num(cur);\n        aux.push_back(make_pair(S(x), x));\n    }\n    if(cur.size() < 9)\n    {\n        if(flag)\n            rec(cur + \"9\", true);\n        else\n            for(char c = '0'; c <= '9'; c++)\n                rec(cur + string(1, c), c < cur.back());    \n    }\n}   \n \nvoid precalc()\n{\n    for(char c = '0'; c <= '9'; c++)\n        rec(string(1, c), false);\n    sort(aux.begin(), aux.end());\n    for(int i = 0; i < aux.size(); i++)\n        if(i == 0 || aux[i].first != aux[i - 1].first)\n            aux2.push_back(aux[i].second);\n    sort(aux2.begin(), aux2.end());\n}\n \nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    precalc();\n    for(int i = 0; i < t; i++)\n    {\n        long long n;\n        cin >> n;\n        cout << upper_bound(aux2.begin(), aux2.end(), n) - aux2.begin() << endl;              \n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2104e",
      "PROBLEM_ID": "2104E",
      "PROBLEM_STATEMENT": "Let's call a letter allowed if it is a lowercase letter and is one of the first $k$ letters of the Latin alphabet.\n\nYou are given a string $s$ of length $n$, consisting only of allowed letters.\n\nLet's call a string $t$ pleasant if $t$ is a subsequence of $s$.\n\nYou are given $q$ strings $t_1, t_2, \\dots, t_q$. All of them consist only of allowed letters. For each string $t_i$, calculate the minimum number of allowed letters you need to append to it on the right so that it stops being pleasant.\n\nA sequence $t$ is a subsequence of a sequence $s$ if $t$ can be obtained from $s$ by the deletion of several (possibly, zero or all) element from arbitrary positions.\n\n### Input\n\nThe first line contains two integers $n$ and $k$ ($1 \\le n \\le 10^6$; $1 \\le k \\le 26$)\u00a0\u2014 the length of the string $s$ and the number of allowed letters.\n\nThe second line contains the string $s$, consisting of $n$ lowercase Latin letters. Each character of the string is one of the first $k$ letters of the Latin alphabet.\n\nThe third line contains one integer $q$ ($1 \\le q \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of queries.\n\nThe next $q$ lines contain queries: one query per line. The $i$-th line contains the string $t_i$, consisting only of allowed letters.\n\nAdditional constraint on input: the total length of all $t_i$ does not exceed $10^6$.\n\n### Output\n\nFor each query, output one integer\u00a0\u2014 the minimum number of allowed letters that need to be appended to the string on the right so that it stops being pleasant.\n\n### Examples\n\n#### Input #1\n\n```\n\n7 3\n\nabacaba\n\n3\n\ncc\n\nbcb\n\nb\n\n```\n\n#### Output #1\n\n```\n0\n1\n2\n```\n\n#### Input #2\n\n```\n\n5 1\n\naaaaa\n\n6\n\na\n\naa\n\naaa\n\naaaa\n\naaaaa\n\naaaaaa\n\n```\n\n#### Output #2\n\n```\n5\n4\n3\n2\n1\n0\n```\n\n### Note\n\nIn the first example:\n\n1. The string cc is already unpleasant, so nothing needs to be appended to it;\n2. bcb is pleasant, so at least one letter needs to be appended to the right: bcba will not work, but bcbb and bcbc are unpleasant.\n3. To b, at least two letters need to be appended, since ba, bb, and bc are pleasant. For example, we can obtain an unpleasant string bbb.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    \n    // We use INF to mark an impossible index. \n    // Our indices for s are [0, n-1] and \"state\" n means we've finished s.\n    const int INF = n + 1;\n    \n    // Build the \"next occurrence\" table.\n    // nxt[c][i] will give the next position (from index i) where letter 'a'+c appears.\n    // For convenience, we set nxt[c][n] = INF (i.e. no occurrence).\n    vector<vector<int>> nxt(k, vector<int>(n+1, INF));\n    \n    for (int c = 0; c < k; c++){\n        nxt[c][n] = INF;\n    }\n    // Process s backwards.\n    for (int i = n-1; i >= 0; i--){\n        int charIndex = s[i] - 'a';\n        for (int c = 0; c < k; c++){\n            nxt[c][i] = nxt[c][i+1];\n        }\n        nxt[charIndex][i] = i;\n    }\n    \n    // Precompute dp: dp[p] = minimum extra letters to append from state p so that\n    // the resulting string (appended to a prefix that has been matched until p) is not a subsequence.\n    vector<int> dp(n+1, 0);\n    // Base: from state n there are no letters available in s, hence any appended letter will break.\n    dp[n] = 1;\n    \n    // Process states backwards.\n    for (int p = n-1; p >= 0; p--){\n        int best = INT_MAX;\n        for (int c = 0; c < k; c++){\n            int pos = nxt[c][p];\n            if(pos == INF) {\n                best = 1; // we found a letter that cannot be matched => append this letter to break.\n                break;\n            } else {\n                best = min(best, 1 + dp[pos+1]);\n            }\n        }\n        dp[p] = best;\n    }\n    \n    int q;\n    cin >> q;\n    while(q--){\n        string t;\n        cin >> t;\n        // Simulate the subsequence matching of t in s.\n        int pos = 0;\n        bool isSubsequence = true;\n        for (char ch: t){\n            int letter = ch - 'a';\n            int np = nxt[letter][pos];\n            if(np == INF){\n                isSubsequence = false;\n                break;\n            }\n            pos = np + 1;\n        }\n        if(!isSubsequence){\n            cout << 0 << \"\\n\";\n        } else {\n            // t is a pleasant string. Append dp[pos] letters to force failure.\n            cout << dp[pos] << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2104d",
      "PROBLEM_ID": "2104D",
      "PROBLEM_STATEMENT": "You are given an integer array $a$ of size $n$.\n\nYou can perform the following operations any number of times (possibly, zero):\n\n- pay one coin and increase any element of the array by $1$ (you must have at least $1$ coin to perform this operation);\n- gain one coin and decrease any element of the array by $1$.\n\nLet's say that an array is ideal if both of the following conditions hold:\n\n- each element of the array is at least $2$;\n- for each pair of indices $i$ and $j$ ($1 \\le i, j \\le n$; $i \\ne j$) the greatest common divisor (GCD) of $a_i$ and $a_j$ is equal to $1$. If the array has less than $2$ elements, this condition is automatically satisfied.\n\nLet's say that an array is beautiful if it can be transformed into an ideal array using the aforementioned operations, provided that you initially have no coins. If the array is already ideal, then it is also beautiful.\n\nThe given array is not necessarily beautiful or ideal. You can remove any elements from it (including removing the entire array or not removing anything at all). Your task is to calculate the minimum number of elements you have to remove (possibly, zero) from the array $a$ to make it beautiful.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 4 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($2 \\le a_i \\le 10^9$).\n\nAdditional constraint on the input: the sum of $n$ over all test cases doesn't exceed $4 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the minimum number of elements you have to remove (possibly, zero) from the array $a$ to make it beautiful.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3\n\n5 5 5\n\n4\n\n2 3 2 4\n\n1\n\n3\n\n3\n\n2 100 2\n\n5\n\n2 4 2 11 2\n\n```\n\n#### Output #1\n\n```\n0\n2\n0\n0\n1\n```\n\n### Note\n\nIn the first example, you don't need to delete any elements, because the array is already beautiful. It can be transformed into an ideal array as follows: $[5, 5, 5] \\rightarrow [4, 5, 5] \\rightarrow [4, 4, 5] \\rightarrow [4, 3, 5]$ (you end up with $3$ coins).\n\nIn the second example, you need to remove $2$ elements so that the array becomes beautiful. If you leave the elements $[2, 3]$ and delete the other elements, then the given array is already ideal (and therefore, beautiful).\n\nIn the third example, you don't need to delete any elements because the array is already ideal (and thus, beautiful).\n\nIn the fourth example, the array is beautiful. It can be transformed into an ideal array as follows: $[2, 100, 2] \\rightarrow [2, 99, 2] \\rightarrow [2, 99, 3] \\rightarrow [2, 98, 3] \\rightarrow [2, 97, 3]$ (you end up with $2$ coins).",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nconst int SIEVE_LIMIT = 6500000;\nstd::vector<int> primes;\nstd::vector<long long> prime_sum;\nstd::vector<bool> is_prime_sieve;\n\nvoid sieve_and_precompute() {\n    if (!primes.empty()) return; // Already precomputed\n    is_prime_sieve.assign(SIEVE_LIMIT + 1, true);\n    is_prime_sieve[0] = is_prime_sieve[1] = false;\n    for (int p = 2; p * p <= SIEVE_LIMIT; ++p) {\n        if (is_prime_sieve[p]) {\n            for (int i = p * p; i <= SIEVE_LIMIT; i += p)\n                is_prime_sieve[i] = false;\n        }\n    }\n    prime_sum.push_back(0); // S_p(0) = 0\n    for (int p = 2; p <= SIEVE_LIMIT; ++p) {\n        if (is_prime_sieve[p]) {\n            primes.push_back(p);\n            prime_sum.push_back(prime_sum.back() + p);\n        }\n    }\n}\n\nbool can_be_beautiful(size_t m, int n, const std::vector<long long>& a_prefix_sum) {\n    if (m == 0) return true;\n    if (m > (size_t)n) return false; // Cannot select more than n elements\n    if (m > primes.size()) return false; // Not enough primes precomputed for this large m\n\n    long long current_a_sum = a_prefix_sum[m];\n    long long required_prime_sum = prime_sum[m];\n\n    return current_a_sum >= required_prime_sum;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    sieve_and_precompute();\n\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        std::vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n        }\n\n        std::sort(a.rbegin(), a.rend()); // Sort in descending order\n\n        std::vector<long long> a_prefix_sum(n + 1, 0);\n        for (int i = 0; i < n; ++i) {\n            a_prefix_sum[i + 1] = a_prefix_sum[i] + a[i];\n        }\n\n        int low = 0, high = n, max_m = 0;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (can_be_beautiful(mid, n, a_prefix_sum)) {\n                max_m = mid;\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        std::cout << n - max_m << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2104c",
      "PROBLEM_ID": "2104C",
      "PROBLEM_STATEMENT": "Alice and Bob are playing a game. They have $n$ cards numbered from $1$ to $n$. At the beginning of the game, some of these cards are given to Alice, and the rest are given to Bob.\n\nCard with number $i$ beats card with number $j$ if and only if $i > j$, with one exception: card $1$ beats card $n$.\n\nThe game continues as long as each player has at least one card. During each turn, the following occurs:\n\n1. Alice chooses one of her cards and places it face up on the table;\n2. Bob, seeing Alice's card, chooses one of his cards and places it face up on the table;\n3. if Alice's card beats Bob's card, both cards are taken by Alice. Otherwise, both cards are taken by Bob.\n\nA player can use a card that they have taken during one of the previous turns.\n\nThe player who has no cards at the beginning of a turn loses. Determine who will win if both players play optimally.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 5000$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n- the first line contains a single integer $n$ ($2 \\le n \\le 50$) \u2014 the number of cards;\n- the second line contains $n$ characters, each either A or B. If the $i$-th character is A, then card number $i$ is initially given to Alice; otherwise, it is given to Bob.\n\nAdditional constraint on the input: in each test case, at least one card is initially given to Alice, and at least one card is initially given to Bob.\n\n### Output\n\nFor each test case, output Alice if Alice wins with optimal play, or Bob if Bob wins. It can be shown that if both players play optimally, the game will definitely end in a finite number of turns with one of the players winning.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n2\n\nAB\n\n2\n\nBA\n\n4\n\nABAB\n\n4\n\nBABA\n\n3\n\nBAA\n\n5\n\nAAAAB\n\n5\n\nBAAAB\n\n6\n\nBBBAAA\n\n```\n\n#### Output #1\n\n```\nAlice\nBob\nBob\nBob\nAlice\nAlice\nBob\nAlice\n```\n\n### Note\n\nIn the first test case, Alice has only one card, and Bob has only one card. Since Alice's card beats Bob's card, she wins after the first turn.\n\nIn the second test case, Alice has only one card, and Bob has only one card. Since Bob's card beats Alice's card, he wins after the first turn.\n\nIn the third test case, there are two possible game scenarios:\n\n- if Alice plays the card $1$ on the first turn, Bob can respond with the card $2$ and take both cards. Then, Alice has to play the card $3$ on the second turn, and Bob will respond by playing the card $4$. Then, he wins;\n- if Alice plays the card $3$ on the first turn, Bob can respond with the card $4$ and take both cards. Then, Alice has to play the card $1$, and Bob can respond either with the card $2$ or the card $3$. Then, he wins.\n\nIn the fourth test case, there are two possible game scenarios:\n\n- if Alice plays the card $2$ on the first turn, Bob can respond with the card $3$ and take both cards. Then, Alice has to play the card $4$ on the second turn, and Bob will respond by playing the card $1$. Then, he wins;\n- if Alice plays the card $4$ on the first turn, Bob can respond with the card $1$ and take both cards. Then, Alice has to play the card $2$, and Bob can respond either with the card $3$ or the card $4$. Then, he wins.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool doesAbeatB(int a, int b, int n) {\n    if (a == 1 && b == n) return true;\n    if (b == 1 && a == n) return false;\n    return a > b;\n}\n\nstring solve() {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<int> A, B;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == 'A') A.push_back(i + 1);\n        else B.push_back(i + 1);\n    }\n    \n    // Check if Alice has a card that can beat all of Bob's\n    for (int a : A) {\n        bool all = true;\n        for (int b : B) {\n            if (!doesAbeatB(a, b, n)) {\n                all = false;\n                break;\n            }\n        }\n        if (all) return \"Alice\";\n    }\n    \n    // Check if Bob has a card that can beat all of Alice's\n    for (int b : B) {\n        bool all = true;\n        for (int a : A) {\n            if (doesAbeatB(a, b, n)) {\n                all = false;\n                break;\n            }\n        }\n        if (all) return \"Bob\";\n    }\n    \n    // Check if Bob can counter all of Alice's cards\n    bool canBobCounter = true;\n    for (int a : A) {\n        bool found = false;\n        for (int b : B) {\n            if (!doesAbeatB(a, b, n)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            canBobCounter = false;\n            break;\n        }\n    }\n    if (canBobCounter) return \"Bob\";\n    \n    // Check if Alice can counter all of Bob's cards\n    bool canAliceCounter = true;\n    for (int b : B) {\n        bool found = false;\n        for (int a : A) {\n            if (doesAbeatB(a, b, n)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            canAliceCounter = false;\n            break;\n        }\n    }\n    if (canAliceCounter) return \"Alice\";\n    \n    // Compare highest strength\n    auto getStrength = [n](int i) { return (i == 1) ? n : (i - 1); };\n    int maxA = -1, maxB = -1;\n    for (int a : A) maxA = max(maxA, getStrength(a));\n    for (int b : B) maxB = max(maxB, getStrength(b));\n    return (maxA > maxB) ? \"Alice\" : \"Bob\";\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        cout << solve() << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2104b",
      "PROBLEM_ID": "2104B",
      "PROBLEM_STATEMENT": "You are given an array $a$ consisting of $n$ integers.\n\nFor every integer $k$ from $1$ to $n$, you have to do the following:\n\n1. choose an arbitrary element of $a$ and move it to the right end of the array (you can choose the last element, then the array won't change);\n2. print the sum of $k$ last elements of $a$;\n3. move the element you've chosen on the first step to its original position (restore the original array $a$).\n\nFor every $k$, you choose the element which you move so that the value you print is the maximum possible.\n\nCalculate the value you print for every $k$.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n- the first line contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$);\n- the second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nAdditional constraint on the input: the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print $n$ integers. The $i$-th of these integers should be equal to the maximum value you can print if $k=i$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n7\n\n13 5 10 14 8 15 13\n\n6\n\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n\n1\n\n42\n\n2\n\n7 5\n\n```\n\n#### Output #1\n\n```\n15 28 42 50 63 73 78\n1000000000 2000000000 3000000000 4000000000 5000000000 6000000000\n42\n7 12\n```\n\n### Note\n\nLet's consider the first test case from the statement:\n\n- when $k = 1$, you can move the $6$-th element to the end, the array becomes $[13, 5, 10, 14, 8, 13, 15]$, and the value you print is $15$;\n- when $k = 2$, you can move the $6$-th element to the end, the array becomes $[13, 5, 10, 14, 8, 13, 15]$, and the value you print is $13 + 15 = 28$;\n- when $k = 3$, you can move the $4$-th element to the end, the array becomes $[13, 5, 10, 8, 15, 13, 14]$, and the value you print is $15 + 13 + 14 = 42$;\n- when $k = 4$, you can move the $5$-th element to the end, the array becomes $[13, 5, 10, 14, 15, 13, 8]$, and the value you print is $14 + 15 + 13 + 8 = 50$;\n- when $k = 5$, you can move the $1$-st element to the end, the array becomes $[5, 10, 14, 8, 15, 13, 13]$, and the value you print is $14 + 8 + 15 + 13 + 13 = 63$;\n- when $k = 6$, you can move the $1$-st element to the end, the array becomes $[5, 10, 14, 8, 15, 13, 13]$, and the value you print is $10 + 14 + 8 + 15 + 13 + 13 = 73$;\n- when $k = 7$, you can move the $6$-th element to the end, the array becomes $[13, 5, 10, 14, 8, 13, 15]$, and the value you print is $13 + 5 + 10 + 14 + 8 + 13 + 15 = 78$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<long long> a(n+1);\n        for (int i = 1; i <= n; i++){\n            cin >> a[i];\n        }\n        \n        // Compute suffix sums: suf[i] = a[i] + a[i+1] + ... + a[n]\n        // We set suf[n+1] = 0 for convenience.\n        vector<long long> suf(n+2, 0);\n        for (int i = n; i >= 1; i--){\n            suf[i] = suf[i+1] + a[i];\n        }\n        \n        // Compute prefix maximum: prefMax[i] = max(a[1], a[2], ..., a[i])\n        vector<long long> prefMax(n+1, 0);\n        prefMax[1] = a[1];\n        for (int i = 2; i <= n; i++){\n            prefMax[i] = max(prefMax[i-1], a[i]);\n        }\n        \n        // For each k from 1 to n, compute the maximum sum achievable.\n        // Let boundary = n - k, i.e. the size of the part where we have the possibility to use the option r in [1, n-k].\n        for (int k = 1; k <= n; k++){\n            int boundary = n - k; \n            long long answer;\n            if(boundary == 0){\n                // When k == n, only option is the whole array sum.\n                answer = suf[1];\n            } else {\n                // Option1: remove an element from among indices n-k+1...n: the sum is suf[n-k+1]\n                long long option1 = suf[boundary + 1];\n                // Option2: remove an element from among indices 1...boundary:\n                // the sum is a[r] (choose best) plus suf[boundary+2] (which is sum from index n-k+2 to n).\n                long long option2 = prefMax[boundary] + suf[boundary + 2];\n                answer = max(option1, option2);\n            }\n            cout << answer << (k == n ? \"\\n\" : \" \");\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2104a",
      "PROBLEM_ID": "2104A",
      "PROBLEM_STATEMENT": "Monocarp placed three decks of cards in a row on the table. The first deck consists of $a$ cards, the second deck consists of $b$ cards, and the third deck consists of $c$ cards, with the condition $a < b < c$.\n\nMonocarp wants to take some number of cards (at least one, but no more than $c$) from the third deck and distribute them between the first two decks so that each of the taken cards ends up in either the first or the second deck. It is possible that all the cards taken from the third deck will go into the same deck.\n\nYour task is to determine whether Monocarp can make the number of cards in all three decks equal using the described operation.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains three integers $a, b$, and $c$ ($1 \\le a, b, c \\le 10^8$)\u00a0\u2014 the number of cards in the first, second, and third decks, respectively.\n\nAdditional constraint on the input: $a < b < c$.\n\n### Output\n\nFor each test case, output \"YES\" (without quotes) if Monocarp can make the number of cards in all three decks equal using the described operation. Otherwise, output \"NO\" (without quotes).\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 5 10\n\n12 20 30\n\n3 5 7\n\n1 5 6\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nNO\n```\n\n### Note\n\nIn the first test case, Monocarp has to take $4$ cards from the third deck, put $3$ cards in the first deck, and $1$ card in the second deck. Thus, there will be $6$ cards in all three decks.\n\nIn the second test case, it is impossible to make the number of cards in all three decks equal.\n\nIn the third test case, Monocarp has to take $2$ cards from the third deck and put both in the first deck. Thus, there will be $5$ cards in all three decks.\n\nIn the fourth test case, it is also impossible to make the number of cards in all three decks equal.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nbool can_make_equal(long long a, long long b, long long c) {\n    // Check if (2c - a - b) is divisible by 3\n    if ((2 * c - a - b) % 3 != 0) {\n        return false;\n    }\n    \n    long long m = (2 * c - a - b) / 3;\n    \n    // Check if m is at least 1\n    if (m < 1) {\n        return false;\n    }\n    \n    // Check if cards added to each deck are non-negative\n    long long cards_to_first = c - m - a;\n    long long cards_to_second = c - m - b;\n    \n    return cards_to_first >= 0 && cards_to_second >= 0;\n}\n\nint main() {\n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        long long a, b, c;\n        std::cin >> a >> b >> c;\n        \n        if (can_make_equal(a, b, c)) {\n            std::cout << \"YES\" << std::endl;\n        } else {\n            std::cout << \"NO\" << std::endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2103f",
      "PROBLEM_ID": "2103F",
      "PROBLEM_STATEMENT": "The bitwise nor$^{\\text{\u2217}}$ of an array of $k$-bit integers $b_1, b_2, \\ldots, b_m$ can be computed by calculating the bitwise nor cumulatively from left to right. More formally, $\\operatorname{nor}(b_1, b_2, \\ldots, b_m) = \\operatorname{nor}(\\operatorname{nor}(b_1, b_2, \\ldots, b_{m - 1}), b_m)$ for $m\\ge 2$, and $\\operatorname{nor}(b_1) = b_1$.\n\nYou are given an array of $k$-bit integers $a_1, a_2, \\ldots, a_n$. For each index $i$ ($1\\le i\\le n$), find the maximum bitwise nor among all subarrays$^{\\text{\u2020}}$ of $a$ containing index $i$. In other words, for each index $i$, find the maximum value of $\\operatorname{nor}(a_l, a_{l+1}, \\ldots, a_r)$ among all $1 \\le l \\le i \\le r \\le n$.\n\n$^{\\text{\u2217}}$ The [logical nor](https://en.m.wikipedia.org/wiki/Logical_NOR) of two boolean values is $1$ if both values are $0$, and $0$ otherwise. The bitwise nor of two $k$-bit integers is calculated by performing the logical nor operation on each pair of the corresponding bits.\n\nFor example, let us compute $\\operatorname{nor}(2, 6)$ when they are represented as $4$-bit numbers. In binary, $2$=$0010_2$ and $6=0110_2$. Therefore, $\\operatorname{nor}(2,6) = 1001_2 = 9$ as by performing the logical nor operations from left to right, we have:\n\n- $\\operatorname{nor}(0,0) = 1$\n- $\\operatorname{nor}(0,1) = 0$\n- $\\operatorname{nor}(1,0) = 0$\n- $\\operatorname{nor}(1,1) = 0$\n\nNote that if $2$ and $6$ were represented as $3$-bit integers instead, then $\\operatorname{nor}(2,6) = 1$.\n\n$^{\\text{\u2020}}$An array $x$ is a subarray of an array $y$ if $x$ can be obtained from $y$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 10^5$, $1 \\le k \\le 17$)\u00a0\u2014 the number of elements in the array and the number of bits of the array elements.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 2^k - 1$)\u00a0\u2014 the elements of array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output $n$ integers, the $i$-th of which is the maximum bitwise nor among all subarrays of $a$ containing index $i$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n2 2\n\n1 3\n\n5 3\n\n1 7 4 6 2\n\n```\n\n#### Output #1\n\n```\n1 3\n5 7 5 6 5\n```\n\n### Note\n\nIn the first test case, subarrays that have index $1$ are $[1]$ and $[1, 3]$. The values of their bitwise nor are $1$ and $0$ respectively. Hence, the answer for index $1$ is $1$. Subarrays that have index $2$ are $[3]$ and $[1, 3]$. The values of their bitwise nor are $3$ and $0$ respectively. Hence, the answer for index $2$ is $3$.\n\nIn the second test case:\n\n- For $i = 1$, the subarray with maximum bitwise nor is $[a_1, a_2, a_3, a_4, a_5] = [1, 7, 4, 6, 2]$, $\\operatorname{nor}(1, 7, 4, 6, 2) = 5$\n- For $i = 2$, the subarray with maximum bitwise nor is $[a_2] = [7]$, $\\operatorname{nor}(7) = 7$\n- For $i = 3$, the subarray with maximum bitwise nor is $[a_1, a_2, a_3, a_4, a_5] = [1, 7, 4, 6, 2]$, $\\operatorname{nor}(1, 7, 4, 6, 2) = 5$\n- For $i = 4$, the subarray with maximum bitwise nor is $[a_4] = [6]$, $\\operatorname{nor}(6) = 6$\n- For $i = 5$, the subarray with maximum bitwise nor is $[a_1, a_2, a_3, a_4, a_5] = [1, 7, 4, 6, 2]$, $\\operatorname{nor}(1, 7, 4, 6, 2) = 5$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n+1);\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        int mask = (1 << k) - 1;\n\n        // events[l] will hold pairs (r, val) meaning\n        // for subarray [l..r], f(l,r) = val\n        vector<vector<pii>> events(n+2);\n\n        // S_prev holds distinct states (val, l_min) for subarrays ending at r-1\n        vector<pii> S_prev;\n        S_prev.reserve(k+2);\n\n        // Build DP states and record intervals\n        for (int r = 1; r <= n; r++) {\n            vector<pii> S_curr;\n            S_curr.reserve(S_prev.size() + 1);\n\n            // Extend previous states by a[r]\n            for (auto &pr : S_prev) {\n                int old_val = pr.first;\n                int l_min   = pr.second;\n                // bitwise NOR fold: new_val = ~(old_val | a[r]) & mask\n                int new_val = (~(old_val | a[r])) & mask;\n                S_curr.emplace_back(new_val, l_min);\n            }\n            // Also the subarray that starts at r itself\n            S_curr.emplace_back(a[r], r);\n\n            // Deduplicate by val, keep minimal l_min for each val\n            sort(S_curr.begin(), S_curr.end(),\n                 [](const pii &x, const pii &y) {\n                     if (x.first != y.first) return x.first < y.first;\n                     return x.second < y.second;\n                 });\n            vector<pii> newS;\n            newS.reserve(S_curr.size());\n            for (auto &pr : S_curr) {\n                if (newS.empty() || newS.back().first != pr.first) {\n                    newS.push_back(pr);\n                }\n                // else duplicate val, ignore (we keep the first => minimal l)\n            }\n            S_prev.swap(newS);\n\n            // Record events for ans updating: for each state (val,l), interval [l..r]\n            for (auto &pr : S_prev) {\n                int val = pr.first;\n                int l   = pr.second;\n                if (val != 0) {\n                    events[l].emplace_back(r, val);\n                }\n            }\n        }\n\n        // Compute ans[i] = maximum val over all intervals [l..r] covering i\n        vector<int> ans(n+1, 0);\n        // max-heap of (val, r) for active intervals\n        priority_queue<pair<int,int>> pq;\n\n        // Sweep i from 1..n, add intervals that start at i, pop those ended\n        for (int i = 1; i <= n; i++) {\n            // add intervals starting at i\n            for (auto &ev : events[i]) {\n                int r = ev.first;\n                int v = ev.second;\n                pq.emplace(v, r);\n            }\n            // remove intervals that ended before i\n            while (!pq.empty() && pq.top().second < i) {\n                pq.pop();\n            }\n            if (!pq.empty()) {\n                ans[i] = pq.top().first;\n            } else {\n                ans[i] = 0;\n            }\n        }\n\n        // Output\n        for (int i = 1; i <= n; i++) {\n            if (i > 1) cout << ' ';\n            cout << ans[i];\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2103e",
      "PROBLEM_ID": "2103E",
      "PROBLEM_STATEMENT": "You are given an integer $k$ and an array $a$ of length $n$, where each element satisfies $0 \\le a_i \\le k$ for all $1 \\le i \\le n$. You can perform the following operation on the array:\n\n- Choose two distinct indices $i$ and $j$ ($1 \\le i,j \\le n$ and $i \\neq j$) such that $a_i + a_j = k$.\n- Select an integer $x$ satisfying $-a_j \\le x \\le a_i$.\n- Decrease $a_i$ by $x$ and increase $a_j$ by $x$. In other words, update $a_i := a_i - x$ and $a_j := a_j + x$.\n\nNote that the constraints on $x$ ensure that all elements of array $a$ remain between $0$ and $k$ throughout the operations.\n\nYour task is to determine whether it is possible to make the array $a$ non-decreasing$^{\\text{\u2217}}$ using the above operation. If it is possible, find a sequence of at most $3n$ operations that transforms the array into a non-decreasing one.\n\nIt can be proven that if it is possible to make the array non-decreasing using the above operation, there exists a solution that uses at most $3n$ operations.\n\n$^{\\text{\u2217}}$ An array $a_1, a_2, \\ldots, a_n$ is said to be non-decreasing if for all $1 \\le i \\le n - 1$, it holds that $a_i \\le a_{i+1}$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers, $n$ and $k$ ($4 \\le n \\le 2 \\cdot 10^5$, $1 \\le k \\le 10^9$)\u00a0\u2014 the length of the array $a$ and the required sum for the operation.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le k$)\u00a0\u2014 the elements of array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $-1$ if it is not possible to make the array non-decreasing using the operation.\n\nOtherwise, output the number of operations $m$ ($0 \\le m \\le 3n$). On each of the next $m$ lines, output three integers $i$, $j$, and $x$ representing an operation where $a_i$ is decreased by $x$ and $a_j$ is increased by $x$.\n\nNote that you are not required to minimize the number of operations. If there are multiple solutions requiring at most $3n$ operations, you may output any.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n5 100\n\n1 2 3 4 5\n\n5 6\n\n1 2 3 5 4\n\n5 7\n\n7 1 5 3 1\n\n10 10\n\n2 5 3 2 7 3 1 8 4 0\n\n```\n\n#### Output #1\n\n```\n0\n1\n4 1 1\n-1\n6\n1 8 2\n3 5 2\n5 7 3\n5 9 3\n8 10 5\n2 10 4```\n\n### Note\n\nIn the first test case, the array is already non-decreasing, so we do not need to perform any operations.\n\nIn the second test case, we can perform an operation with $i=4$, $j=1$, and $x=1$. $a_4$ decreases by $1$ to become $5 - 1 = 4$ while $a_1$ increases by $1$ to become $1 + 1 = 2$. After the operation, the array becomes $[2, 2, 3, 4, 4]$, which is non-decreasing.\n\nNote that there are other ways to make the array non-decreasing, all of which would be considered correct as long as they do not use more than $3 \\cdot n = 15$ operations.\n\nIn the third test case, it is not possible to make the array non-decreasing. This is because there are no distinct pairs of indices $i$ and $j$ where $a_i + a_j = 7$, so no operation can be done on the array.\n\nIn the fourth test case, the array is transformed as follows:\n\n1. $[\\textbf{0}, 5, 3, 2, 7, 3, 1, \\textbf{10}, 4, 0]$\n2. $[0, 5, \\textbf{1}, 2, \\textbf{9}, 3, 1, 10, 4, 0]$\n3. $[0, 5, 1, 2, \\textbf{6}, 3, \\textbf{4}, 10, 4, 0]$\n4. $[0, 5, 1, 2, \\textbf{3}, 3, 4, 10, \\textbf{7}, 0]$\n5. $[0, 5, 1, 2, 3, 3, 4, \\textbf{5}, 7, \\textbf{5}]$\n6. $[0, \\textbf{1}, 1, 2, 3, 3, 4, 5, 7, \\textbf{9}]$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=2e5+5;\nint n,k,arr[maxn],A,B,p[maxn];\nmap<int,int> pos;\nvector<tuple<int,int,int>> V; /// All operations\nvoid dooperation(int a,int b,int x){\n   arr[a]-=x;\n   arr[b]+=x;\n   V.push_back(make_tuple(a,b,x));\n}\nvoid setvalue(int pos,int b,int target){ /// Does operation on (pos, b) such that value of pos becomes target\n   if(arr[pos]==target)\n      return;\n   int dif=target-arr[pos];\n   dooperation(b,pos,dif);\n}\nvoid performswap(int x,int y){\n   int vx=arr[x],vy=arr[y];\n   setvalue(A,B,k-vx);\n   setvalue(x,A,vy);\n   setvalue(y,A,vx);\n}\nbool cmp(int a,int b){\n   return arr[a]<arr[b];\n}\nvoid solve(){\n   pos.clear();\n   V.clear();\n   A=B=-1;\n   cin>>n>>k;\n   for(int i=1;i<=n;i++)\n      cin>>arr[i];\n   bool issorted=true;\n   for(int i=2;i<=n;i++)\n      if(arr[i]<arr[i-1])\n         issorted=false;\n   if(issorted){\n      cout<<\"0\\n\";\n      return;\n   }\n   for(int i=1;i<=n;i++){\n      if(pos.find(k-arr[i])!=pos.end()){\n         B=i;\n         A=pos[k-arr[i]];\n         break;\n      }\n      pos[arr[i]]=i;\n   }\n   if(A==-1){\n      cout<<\"-1\\n\";\n      return;\n   }\n   if(A!=1){\n      setvalue(A,B,k-arr[1]);\n      setvalue(1,A,k-arr[B]);\n      A=1;\n   }\n   if(B!=n){\n      setvalue(B,A,k-arr[n]);\n      setvalue(n,B,k-arr[A]);\n      B=n;\n   }\n   vector<int> invp;\n   for(int i=2;i<n;i++)\n      invp.push_back(i);\n   sort(invp.begin(),invp.end(),cmp);\n   for(int i=0;i<invp.size();i++)\n      p[invp[i]]=i+2;\n   for(int i=2;i<n;i++){\n      if(p[i]==i)\n         continue;\n      performswap(p[i],i);\n      swap(p[p[i]],p[i]);\n      i--;\n   }\n   setvalue(B,A,k);\n   cout<<V.size()<<\"\\n\";\n   for(auto x:V)\n      cout<<(get<0>(x))<<\" \"<<(get<1>(x))<<\" \"<<(get<2>(x))<<\"\\n\";\n   return;\n}\nint main(){\n   int T;\n   cin>>T;\n   while(T--)\n      solve();\n   return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2103d",
      "PROBLEM_ID": "2103D",
      "PROBLEM_STATEMENT": "An element $b_i$ ($1\\le i\\le m$) in an array $b_1, b_2, \\ldots, b_m$ is a local minimum if at least one of the following holds:\n\n- $2\\le i\\le m - 1$ and $b_i < b_{i - 1}$ and $b_i < b_{i + 1}$, or\n- $i = 1$ and $b_1 < b_2$, or\n- $i = m$ and $b_m < b_{m - 1}$.\n\nSimilarly, an element $b_i$ ($1\\le i\\le m$) in an array $b_1, b_2, \\ldots, b_m$ is a local maximum if at least one of the following holds:\n\n- $2\\le i\\le m - 1$ and $b_i > b_{i - 1}$ and $b_i > b_{i + 1}$, or\n- $i = 1$ and $b_1 > b_2$, or\n- $i = m$ and $b_m > b_{m - 1}$.\n\nNote that local minima and maxima are not defined for arrays with only one element.\n\nThere is a hidden permutation$^{\\text{\u2217}}$ $p$ of length $n$. The following two operations are applied to permutation $p$ alternately, starting from operation 1, until there is only one element left in $p$:\n\n- Operation 1\u00a0\u2014 remove all elements of $p$ which are not local minima.\n- Operation 2\u00a0\u2014 remove all elements of $p$ which are not local maxima.\n\nMore specifically, operation 1 is applied during every odd iteration, and operation 2 is applied during every even iteration, until there is only one element left in $p$.\n\nFor each index $i$ ($1\\le i\\le n$), let $a_i$ be the iteration number that element $p_i$ is removed, or $-1$ if it was never removed.\n\nIt can be proven that there will be only one element left in $p$ after at most $\\lceil \\log_2 n\\rceil$ iterations (in other words, $a_i \\le \\lceil \\log_2 n\\rceil$).\n\nYou are given the array $a_1, a_2, \\ldots, a_n$. Your task is to construct any permutation $p$ of $n$ elements that satisfies array $a$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of elements in permutation $p$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le \\lceil\\log_2 n\\rceil$ or $a_i = -1$)\u00a0\u2014 the iteration number that element $p_i$ is removed.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nIt is guaranteed that there exists at least one permutation $p$ that satisfies array $a$.\n\n### Output\n\nFor each test case, output $n$ integers representing the elements of the permutation satisfying array $a$.\n\nIf there are multiple solutions, you may output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n3\n\n1 1 -1\n\n5\n\n1 -1 1 2 1\n\n8\n\n3 1 2 1 -1 1 1 2\n\n7\n\n1 1 1 -1 1 1 1\n\n5\n\n1 1 1 1 -1\n\n5\n\n-1 1 1 1 1\n\n5\n\n-1 1 2 1 2\n\n```\n\n#### Output #1\n\n```\n3 2 1\n4 3 5 1 2\n6 7 2 4 3 8 5 1\n6 5 2 1 3 4 7\n5 4 3 2 1\n1 2 3 4 5\n4 5 2 3 1```\n\n### Note\n\nIn the first test case, operations will be applied to permutation $[3, 2, 1]$ as follows:\n\n1. The only local minimum in $[3, 2, 1]$ is $1$. Hence, elements $3$ and $2$ are removed. There is only one remaining element; hence the process terminates.\n\nThis satisfies array $a = [1, 1, -1]$ as both $p_1$ and $p_2$ were removed on iteration number $1$, while $p_3$ was not removed.\n\nIn the second test case, operations will be applied to permutation $p = [4, 3, 5, 1, 2]$ as follows:\n\n1. The local minima in $[4, 3, 5, 1, 2]$ are $3$ and $1$. Hence, elements $4$, $5$, and $2$ are removed.\n2. The only local maximum in $[3, 1]$ is $3$. Hence, element $1$ is removed. There is only one remaining element; hence the process terminates.\n\nThis satisfies array $a = [1, -1, 1, 2, 1]$ as elements $p_1 = 4$, $p_3 = 5$, and $p_5 = 2$ were removed on iteration $1$, element $p_4 = 1$ was removed on iteration $2$, and element $p_2 = 3$ was not removed.\n\nIn the third test case, operations will be applied on permutation $[6, 7, 2, 4, 3, 8, 5, 1]$ as follows:\n\n1. The local minima in $[6, 7, 2, 4, 3, 8, 5, 1]$ are $6$, $2$, $3$, and $1$. Hence, elements $7$, $4$, $8$, and $5$ are removed.\n2. The local maxima in $[6, 2, 3, 1]$ are $6$ and $3$. Hence, elements $2$ and $1$ are removed.\n3. The only local minimum in $[6, 3]$ is $3$. Hence, element $6$ is removed. There is only one remaining element; hence the process terminates.\n\nIn the fourth test case, one permutation satisfying the constraints is \\[$6$, $5$, $2$, $1$, $3$, $4$, $7$\\]. $1$ is the only local minimum, so only it will stay after the first iteration. Note that there are other valid permutations; for example, \\[$6$, $4$, $3$, $1$, $2$, $5$, $7$\\] would also be considered correct.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\nstruct Cluster {\n    vi pos;      // positions in this cluster (sorted by original index)\n    int s_start; // start index in S_k\n    int s_end;   // end index in S_k\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n+1);\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        // Find T = max removal iteration excluding -1\n        int T = 0;\n        for (int i = 1; i <= n; i++) {\n            if (a[i] != -1) {\n                T = max(T, a[i]);\n            }\n        }\n        // K blocks: 1..T for removals, block K = T+1 for a_i=-1\n        int K = T + 1;\n        vector<int> a2(n+1);\n        for (int i = 1; i <= n; i++) {\n            if (a[i] == -1) a2[i] = K;\n            else a2[i] = a[i];\n        }\n        // g[k] = positions with a2[i]==k\n        vector<vi> g(K+1);\n        for (int i = 1; i <= n; i++) {\n            g[a2[i]].push_back(i);\n        }\n        // S[k] = positions with a2[i] >= k, in increasing index order\n        vector<vi> S(K+1);\n        // Build by for each i, push i into S[1..a2[i]]\n        for (int i = 1; i <= n; i++) {\n            int up = a2[i];\n            for (int k = 1; k <= up; k++) {\n                S[k].push_back(i);\n            }\n        }\n        // Build block list 1..K and sort into L\n        vi blocks(K);\n        iota(blocks.begin(), blocks.end(), 1);\n        auto cmpBlock = [&](int x, int y) {\n            bool even_x = (x % 2 == 0);\n            bool even_y = (y % 2 == 0);\n            if (even_x != even_y) {\n                // even blocks first\n                return even_x;\n            }\n            // both same parity\n            if (even_x) {\n                // both even: ascending\n                return x < y;\n            } else {\n                // both odd: descending\n                return x > y;\n            }\n        };\n        sort(blocks.begin(), blocks.end(), cmpBlock);\n\n        vector<int> p(n+1, 0);\n        int next_value = 1;\n\n        // Process blocks in order L\n        for (int bk : blocks) {\n            int k = bk;\n            int sz = (int)g[k].size();\n            if (sz == 0) {\n                // no positions in this block\n                continue;\n            }\n            // Block interval values [next_value .. next_value+sz-1]\n            int D_l = next_value;\n            int D_r = next_value + sz - 1;\n\n            // Build clusters of R_k in survivors list S[k]\n            vi &Sk = S[k];\n            int mS = Sk.size();\n            vector<Cluster> clusters;\n            Cluster cur;\n            bool in_cluster = false;\n            for (int idx = 0; idx < mS; idx++) {\n                int pos = Sk[idx];\n                if (a2[pos] == k) {\n                    if (!in_cluster) {\n                        in_cluster = true;\n                        cur.pos.clear();\n                        cur.s_start = idx;\n                    }\n                    cur.pos.push_back(pos);\n                } else {\n                    if (in_cluster) {\n                        cur.s_end = idx - 1;\n                        clusters.push_back(cur);\n                        in_cluster = false;\n                    }\n                }\n            }\n            if (in_cluster) {\n                cur.s_end = mS - 1;\n                clusters.push_back(cur);\n            }\n            // Assign values to clusters\n            for (auto &cl : clusters) {\n                int len = cl.pos.size();\n                bool head = (cl.s_start == 0);\n                bool tail = (cl.s_end == mS - 1);\n                bool doAscending;\n                if (k % 2 == 1) {\n                    // odd k: avoid local minima => tail clusters ascend, others descend\n                    if (tail) doAscending = true;\n                    else doAscending = false;\n                } else {\n                    // even k: avoid local maxima => head clusters ascend, others descend\n                    if (head) doAscending = true;\n                    else doAscending = false;\n                }\n                if (doAscending) {\n                    // assign ascending from D_l\n                    for (int j = 0; j < len; j++) {\n                        int pos = cl.pos[j];\n                        p[pos] = D_l;\n                        D_l++;\n                    }\n                } else {\n                    // assign descending from D_r\n                    for (int j = 0; j < len; j++) {\n                        int pos = cl.pos[j];\n                        p[pos] = D_r;\n                        D_r--;\n                    }\n                }\n            }\n            next_value += sz;\n        }\n\n        // Output\n        for (int i = 1; i <= n; i++) {\n            cout << p[i] << (i == n ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2103c",
      "PROBLEM_ID": "2103C",
      "PROBLEM_STATEMENT": "The median of an array $b_1, b_2, \\ldots b_m$, written as $\\operatorname{med}(b_1, b_2, \\ldots, b_m)$, is the $\\left\\lceil \\frac{m}{2} \\right\\rceil$-th$^{\\text{\u2217}}$ smallest element of array $b$.\n\nYou are given an array of integers $a_1, a_2, \\ldots, a_n$ and an integer $k$. You need to determine whether there exists a pair of indices $1 \\le l < r < n$ such that:\n\n\n\n$$\\operatorname{med}(\\operatorname{med}(a_1, a_2, \\ldots, a_l), \\operatorname{med}(a_{l+1}, a_{l+2}, \\ldots, a_r), \\operatorname{med}(a_{r+1}, a_{r+2}, \\ldots, a_n)) \\le k.$$\n\nIn other words, determine whether it is possible to split the array into three contiguous subarrays$^{\\text{\u2020}}$ such that the median of the three subarray medians is less than or equal to $k$.\n\n$^{\\\\text{\u2217}}$$\\\\lceil x \\\\rceil$ is the ceiling function which returns the least integer greater than or equal to $x$.\n\n$^{\\text{\u2020}}$An array $x$ is a subarray of an array $y$ if $x$ can be obtained from $y$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($3 \\le n \\le 2 \\cdot 10^5$, $1 \\le k \\le 10^9$)\u00a0\u2014 the length of the array $a$ and the constant $k$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each testcase, output \"YES\" if such a split exists, and \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n3 2\n\n3 2 1\n\n3 1\n\n3 2 1\n\n6 3\n\n8 5 3 1 6 4\n\n8 7\n\n10 7 12 16 3 15 6 11\n\n6 8\n\n7 11 12 4 9 17\n\n3 500000000\n\n1000 1000000000 1000\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nNO\nYES\nYES\nYES\n```\n\n### Note\n\nIn the first and second test case, the only possible partition of the array into three contiguous subarrays is $[3]$, $[2]$, $[1]$. Their respective medians are $3$, $2$, and $1$. The median of the three subarray medians is $\\operatorname{med}(3, 2, 1) = 2$. Therefore, the answer for the first test case is \"YES\" since $2\\le 2$, while the answer for the second test case is \"NO\" since $2 > 1$.\n\nIn the third test case, it can be proven that no partition satisfies the constraints.\n\nIn the fourth test case, one of the partitions satisfying the constraints is $[10, 7]$, $[12, 16, 3, 15]$, $[6, 11]$. The respective medians of subarrays are $7$, $12$, and $6$. The median of the three subarray medians is $\\operatorname{med}(7, 12, 6) = 7 \\le k$, hence this partition satisfies the constraints.\n\nIn the fifth test case, one of the partitions satisfying the constraints is $[7, 11]$, $[12, 4]$, $[9, 17]$. The respective medians of the subarrays are $7$, $4$, and $9$. The median of the three subarray medians is $\\operatorname{med}(7, 4, 9) = 7 \\le k$, hence this partition satisfies the constraints.\n\nIn the sixth test case, the only possible partition of the array into three contiguous subarrays is $[1000]$, $[10^9]$, $[1000]$. The respective medians of the subarrays are $1000$, $10^9$, and $1000$. The median of the three subarray medians is $\\operatorname{med}(1000, 10^9, 1000) = 1000 \\le k$, hence this partition satisfies the constraints.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000 + 5;\nint a[MAXN], B[MAXN], minB[MAXN], suff_max_B[MAXN];\nbool prefix_good[MAXN], suffix_good[MAXN], suffix_any[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        int k;\n        cin >> n >> k;\n        for (int i = 1; i <= n; ++i) {\n            cin >> a[i];\n        }\n\n        // Build prefix-sum B of b[i] = +1 if a[i] <= k, else -1\n        B[0] = 0;\n        for (int i = 1; i <= n; ++i) {\n            B[i] = B[i - 1] + (a[i] <= k ? 1 : -1);\n        }\n\n        // prefix_good[i] = whether subarray [1..i] has median <= k\n        for (int i = 1; i <= n; ++i) {\n            prefix_good[i] = (B[i] >= 0);\n        }\n\n        // suffix_good[j] = whether subarray [j..n] has median <= k\n        // i.e. sum b[j..n] = B[n] - B[j-1] >= 0\n        for (int i = 1; i <= n; ++i) {\n            suffix_good[i] = false;\n        }\n        for (int j = 2; j <= n; ++j) {\n            suffix_good[j] = (B[n] - B[j - 1] >= 0);\n        }\n\n        // suffix_any[i] = OR of suffix_good[j] for j >= i\n        suffix_any[n + 1] = false;\n        for (int i = n; i >= 1; --i) {\n            suffix_any[i] = suffix_good[i] || suffix_any[i + 1];\n        }\n\n        // minB[i] = min of B[1..i]\n        minB[1] = B[1];\n        for (int i = 2; i <= n; ++i) {\n            minB[i] = min(minB[i - 1], B[i]);\n        }\n\n        // suff_max_B[i] = max of B[i..(n-1)]\n        // We only need it for i <= n-1\n        if (n >= 2) {\n            suff_max_B[n - 1] = B[n - 1];\n            for (int i = n - 2; i >= 1; --i) {\n                suff_max_B[i] = max(B[i], suff_max_B[i + 1]);\n            }\n        }\n\n        bool ok = false;\n        // Case 1: \"bad = prefix\", i.e. middle and suffix are good.\n        // We look for r in [2..n-1], s.t. suffix_good[r+1] && exists s in [2..r] with sum b[s..r]>=0\n        // That exists s iff minB[r-1] <= B[r].\n        for (int r = 2; r <= n - 1 && !ok; ++r) {\n            if (suffix_good[r + 1] && minB[r - 1] <= B[r]) {\n                ok = true;\n            }\n        }\n        // Case 2: \"bad = suffix\", i.e. prefix and middle are good.\n        // Look for l in [1..n-2], prefix_good[l] && exists r in [l+1..n-1] with sum b[l+1..r]>=0\n        // That exists r iff max B[r] for r>=l+1..n-1 >= B[l].\n        for (int l = 1; l <= n - 2 && !ok; ++l) {\n            if (prefix_good[l] && suff_max_B[l + 1] >= B[l]) {\n                ok = true;\n            }\n        }\n        // Case 3: \"bad = middle\", i.e. prefix and suffix are good.\n        // Look for l in [1..n-2], prefix_good[l] && exists j>=l+2 with suffix_good[j].\n        for (int l = 1; l <= n - 2 && !ok; ++l) {\n            if (prefix_good[l] && suffix_any[l + 2]) {\n                ok = true;\n            }\n        }\n\n        cout << (ok ? \"YES\\n\" : \"NO\\n\");\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2103a",
      "PROBLEM_ID": "2103A",
      "PROBLEM_STATEMENT": "You are given an array of integers $a_1, a_2, \\ldots, a_n$. An array $x_1, x_2, \\ldots, x_m$ is beautiful if there exists an array $y_1, y_2, \\ldots, y_m$ such that the elements of $y$ are distinct (in other words, $y_i\\neq y_j$ for all $1 \\le i < j \\le m$), and the product of $x_i$ and $y_i$ is the same for all $1 \\le i \\le m$ (in other words, $x_i\\cdot y_i = x_j\\cdot y_j$ for all $1 \\le i < j \\le m$).\n\nYour task is to determine the maximum size of a subsequence$^{\\text{\u2217}}$ of array $a$ that is beautiful.\n\n$^{\\text{\u2217}}$A sequence $b$ is a subsequence of a sequence $a$ if $b$ can be obtained from $a$ by the deletion of several (possibly, zero or all) element from arbitrary positions.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$)\u00a0\u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the elements of array $a$.\n\nNote that there are no constraints on the sum of $n$ over all test cases.\n\n### Output\n\nFor each test case, output the maximum size of a subsequence of array $a$ that is beautiful.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n1 2 3\n\n5\n\n3 1 4 1 5\n\n1\n\n1\n\n```\n\n#### Output #1\n\n```\n3\n4\n1\n```\n\n### Note\n\nIn the first test case, the entire array $a = [1, 2, 3]$ is already beautiful. A possible array $y$ is $[6, 3, 2]$, which is valid since the elements of $y$ are distinct, and $1\\cdot 6 = 2\\cdot 3 = 3\\cdot 2$.\n\nIn the second test case, the subsequence $[3, 1, 4, 5]$ is beautiful. A possible array $y$ is $[20, 60, 15, 12]$. It can be proven that the entire array $a = [3, 1, 4, 1, 5]$ is not beautiful, so the maximum size of a subsequence of array $a$ that is beautiful is $4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nint main() {\n    int t;\n    std::cin >> t;\n\n    while (t--) {\n        int n;\n        std::cin >> n;\n\n        std::vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            std::cin >> a[i];\n        }\n\n        std::unordered_set<int> distinctElements;\n        for (int num : a) {\n            distinctElements.insert(num);\n        }\n\n        std::cout << distinctElements.size() << std::endl;\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2102b",
      "PROBLEM_ID": "2102B",
      "PROBLEM_STATEMENT": "You are given an array of integers $a_1, a_2, \\ldots, a_n$. You are allowed to do the following operation any number of times (possibly zero):\n\n- Choose an index $i$ ($1\\le i\\le n$). Multiply $a_i$ by $-1$ (i.e., update $a_i := -a_i$).\n\nYour task is to determine whether it is possible to make the element at index $1$ become the median of the array after doing the above operation any number of times. Note that operations can be applied to index $1$ as well, meaning the median can be either the original value of $a_1$ or its negation.\n\nThe median of an array $b_1, b_2, \\ldots, b_m$ is defined as the $\\left\\lceil \\frac{m}{2} \\right\\rceil$-th$^{\\text{\u2217}}$ smallest element of array $b$. For example, the median of the array $[3, 1, 2]$ is $2$, while the median of the array $[10, 1, 8, 3]$ is $3$.\n\nIt is guaranteed that the absolute value of the elements of $a$ are distinct. Formally, there are no pairs of indices $1\\le i < j\\le n$ where $|a_i| = |a_j|$.\n\n$^{\\\\text{\u2217}}$$\\\\lceil x \\\\rceil$ is the ceiling function which returns the least integer greater than or equal to $x$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 10^5$)\u00a0\u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($|a_i|\\le 10^6$, $|a_i|\\neq |a_j|$)\u00a0\u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each testcase, output \"YES\" if it is possible to make the element at index $1$ become the median of the array, and \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n3\n\n2 3 1\n\n5\n\n1 2 3 4 5\n\n4\n\n4 2 0 -5\n\n4\n\n-5 0 4 3\n\n4\n\n-10 8 3 2\n\n1\n\n1\n\n10\n\n9 1000 -999 -13 456 -223 23 24 10 0\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nYES\nNO\nNO\nYES\nYES\n```\n\n### Note\n\nIn the first test case, $a_1 = 2$ is already the median of the array $a = [2, 3, 1]$, so no operation is required.\n\nIn the second test case, we can do two operations: one on index $2$, and one on index $5$. The array becomes $[1, -2, 3, 4, -5]$, which has a median of $1$.\n\nIn the third test case, if you do an operation on index $1$, the array will become $[-4, 2, 0, -5]$, which has a median of $-4$.\n\nIn the fourth test case, it can be proven that no sequence of operations can make the median of the array become $5$ or $-5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool solve() {\n    int n;\n    cin >> n;\n    \n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    \n    // Find the rank of |a[0]| among all absolute values\n    int target_abs = abs(a[0]);\n    int rank = 1;\n    \n    for (int i = 1; i < n; i++) {\n        if (abs(a[i]) < target_abs) {\n            rank++;\n        }\n    }\n    \n    // Check conditions based on whether n is odd or even\n    if (n % 2 == 1) { // n is odd\n        return rank <= (n + 1) / 2;\n    } else { // n is even\n        return rank <= n / 2 + 1;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        cout << (solve() ? \"YES\" : \"NO\") << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2102a",
      "PROBLEM_ID": "2102A",
      "PROBLEM_STATEMENT": "Given four integers $n$, $m$, $p$, and $q$, determine whether there exists an integer array $a_1, a_2, \\ldots, a_n$ (elements may be negative) satisfying the following conditions:\n\n- The sum of all elements in the array is equal to $m$: \n\n$$a_1 + a_2 + \\ldots + a_n = m$$\n\nThe sum of every $p$ consecutive elements is equal to $q$: \n\n$$a_i + a_{i + 1} + \\ldots + a_{i + p - 1} = q,\\qquad\\text{ for all }1\\le i\\le n-p+1$$\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first and only line of each test case contains four integers $n$, $m$, $p$, and $q$ ($1 \\le p \\le n \\le 100$, $1 \\le q, m \\le 100$)\u00a0\u2014 the length of the array, the sum of elements, the length of a segment, and the sum of a segment, respectively.\n\n### Output\n\nFor each test case, output \"YES\" (without quotes) if there exists an array satisfying the above conditions, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\", and \"Yes\" will all be recognized as valid responses).\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3 2 2 1\n\n1 1 1 1\n\n5 4 2 3\n\n10 7 5 2\n\n4 4 1 3\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nYES\nNO\nNO\n```\n\n### Note\n\nIn the first test case, an example of an array satisfying the condition is $[1, 0, 1]$. This is because:\n\n- $a_1+a_2+a_3 = 1+0+1 = 2 = m$\n- $a_1+a_2=1+0=1=q$\n- $a_2+a_3=0+1=1=q$\n\nIn the second test case, the only array satisfying the condition is $[1]$.\n\nIn the third test case, an example of an array satisfying the condition is $[-2, 5, -2, 5, -2]$.\n\nIn the fourth test case, it can be proven that there is no array satisfying the condition.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, m, p, q;\n        cin >> n >> m >> p >> q;\n        \n        if (p == 1) {\n            // If p=1, every element must be q\n            if (m == n * q) {\n                cout << \"YES\\n\";\n            } else {\n                cout << \"NO\\n\";\n            }\n        } else if (n % p == 0) {\n            // If n is a multiple of p\n            if (m == (n / p) * q) {\n                cout << \"YES\\n\";\n            } else {\n                cout << \"NO\\n\";\n            }\n        } else {\n            // If n is not a multiple of p and p \u2265 2\n            cout << \"YES\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2101e",
      "PROBLEM_ID": "2101E",
      "PROBLEM_STATEMENT": "You are given a binary string $s$ of length $n$ and a tree $T$ with $n$ vertices. Let $k$ be the number of 1s in $s$. We will construct a complete undirected weighted graph with $k$ vertices as follows:\n\n- For each $1\\le i\\le n$ with $s_i = \\mathtt{1}$, create a vertex labeled $i$.\n- For any two vertices labeled $u$ and $v$ that are created in the above step, define the edge weight between them $w(u, v)$ as the distance$^{\\text{\u2217}}$ between vertex $u$ and vertex $v$ in the tree $T$.\n\nA simple path$^{\\text{\u2020}}$ that visits vertices labeled $v_1, v_2, \\ldots, v_m$ in this order is nice if for all $1\\le i\\le m - 2$, the condition $2\\cdot w(v_i, v_{i + 1})\\le w(v_{i + 1}, v_{i + 2})$ holds. In other words, the weight of each edge in the path must be at least twice the weight of the previous edge. Note that $s_{v_i} = \\mathtt{1}$ has to be satisfied for all $1\\le i\\le m$, as otherwise, there would be no vertex with the corresponding label.\n\nFor each vertex labeled $i$ ($1\\le i\\le n$ and $s_i = \\mathtt{1}$) in the complete undirected weighted graph, determine the maximum number of vertices in any nice simple path starting from the vertex labeled $i$.\n\n$^{\\text{\u2217}}$The distance between two vertices $a$ and $b$ in a tree is equal to the number of edges on the unique simple path between vertex $a$ and vertex $b$.\n\n$^{\\text{\u2020}}$A path is a sequence of vertices $v_1, v_2, \\ldots, v_m$ such that there is an edge between $v_i$ and $v_{i + 1}$ for all $1\\le i\\le m - 1$. A simple path is a path with no repeated vertices, i.e., $v_i\\neq v_j$ for all $1\\le i < j\\le m$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 7\\cdot10^4$)\u00a0\u2014 the length of the binary string $s$ and the number of vertices in the tree $T$.\n\nThe second line of each test case contains a binary string with $n$ characters $s_1s_2\\ldots s_n$ ($s_i\\in \\{\\mathtt{0}, \\mathtt{1}\\}$)\u00a0\u2014 the string representing the vertices to be constructed in the complete undirected weighted graph.\n\nEach of the next $n - 1$ lines contains two integers $u$ and $v$ ($1\\le u, v\\le n$)\u00a0\u2014 the endpoints of the edges of the tree $T$.\n\nIt is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $7\\cdot10^4$.\n\n### Output\n\nFor each test case, output $n$ integers, the $i$-th integer representing the maximum number of vertices in any nice simple path starting from the vertex labeled $i$. If there is no vertex labeled $i$, i.e., $s_i = \\mathtt{0}$, output $-1$ instead.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5\n\n01111\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n17\n\n01101011110101101\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n5 6\n\n6 7\n\n7 8\n\n8 9\n\n9 10\n\n10 11\n\n11 12\n\n12 13\n\n13 14\n\n14 15\n\n15 16\n\n16 17\n\n2\n\n01\n\n1 2\n\n```\n\n#### Output #1\n\n```\n-1 3 3 3 3\n-1 5 4 -1 4 -1 5 5 5 5 -1 4 -1 5 5 -1 3\n-1 1\n```\n\n### Note\n\nIn the first test case, the tree $T$ and the constructed graph are as follows:\n\n![](https://espresso.codeforces.com/2c018d3678fcc993cea93af930f4bc10bd9d0bed.png)Left side is the tree $T$ with selected nodes colored yellow. The right side is the constructed complete graph.\n\nThe nice path shown in the diagram is $3\\rightarrow 4\\rightarrow 2$. The path is nice as $w(4, 2) = 2$ is at least twice of $w(3, 4) = 1$. Extending the path using $2\\rightarrow 5$ is not possible as $w(2, 5) = 3$ is less than twice of $w(4, 2) = 2$.\n\nIn the second test case, the tree $T$ is a simple path of length $17$. An example of a nice path starting from the vertex labeled $2$ is $2\\rightarrow 3\\rightarrow 5\\rightarrow 9\\rightarrow 17$, which has edge weights of $1, 2, 4, 8$ doubling each time.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \n#define F first\n#define S second\n#define endl '\\n'\n#define Mp make_pair\n#define pb push_back\n#define pf push_front\n#define size(x) (ll)x.size()\n#define all(x) x.begin(), x.end()\n#define fuck(x) cout<<\"(\"<<#x<<\" : \"<<x<<\")\\n\"\n \nconst int N = 2e5 + 100, lg = 18;\nconst ll Mod = 1e9 + 7;\nconst ll inf = 1e18 + 10;\n \nll MOD(ll a, ll mod=Mod) {\n    a%=mod; (a<0)&&(a+=mod); return a;\n}\n\nll poww(ll a, ll b, ll mod=Mod) {\n    ll res = 1;\n    while(b > 0) {\n        if(b%2 == 1) res = MOD(res * a, mod);\n        b /= 2;\n        a = MOD(a * a, mod);\n    }\n    return res;\n}\n \nint t, n, a[N], dp[lg + 1][N], gl, subt[N], mark[N];\nint h[N], T[N], pd[N], tag[N];\nvector<int> adj[N], centAdj[N];\n \nvoid init(int v, int p=0) {\n    subt[v] = 1, h[v] = (p == 0 ? 0 : h[p] + 1);\n    for(int u : adj[v]) {\n        if(u == p || mark[u] == 1) continue;\n        init(u, v);\n        subt[v] += subt[u];\n    }\n}\n \nint findCent(int v, int p=0) {\n    for(int u : adj[v]) {\n        if(u == p || mark[u] == 1) continue;\n        if(subt[u] > subt[gl]/2) return findCent(u, v);\n    }\n    return v;\n}\n \nint createCentTree(int v) {\n    gl = v;\n    init(v);\n    int cent = findCent(v);\n    init(cent);\n \n    mark[cent] = 1;\n    for(int u : adj[cent]) {\n        if(mark[u] == 1) continue;\n        centAdj[cent].pb(createCentTree(u));\n    }\n \n    return cent;\n}\n \nstruct node {\n    pii mx1, mx2;\n    node() {\n        mx1 = {-1e9, -1}; mx2 = {-1e9, -2};\n    }\n} suff[N];\n \nnode util(node y, pii x) {\n    if(y.mx1 < y.mx2) swap(y.mx1, y.mx2);\n    if(y.mx1 < x) swap(y.mx1, x);\n    \n    if(y.mx2 < x) swap(y.mx2, x);\n    if(y.mx1.S == y.mx2.S) swap(y.mx2, x);\n    \n    return y;\n}\n \nvector<int> vec;\nvoid dfs1(int v, int p=0) {\n    // update v by gl\n    if(2*h[v] <= T[gl]) pd[v] = max(pd[v], h[v]);\n    // update gl by v\n    if(2*h[v] <= T[v]) pd[gl] = max(pd[gl], h[v]);\n    \n    if(p == 0) tag[v] = 0;\n    else if(p == gl) {\n        tag[v] = v;\n    } else tag[v] = tag[p];\n    \n    if(tag[v] != 0 && T[v] - h[v] * 2 >= 0) vec.pb(v);\n \n    for(int u : adj[v]) {\n        if(u == p || mark[u] == 1) continue;\n        dfs1(u, v);\n    }\n}\n \nvoid dfs2(int v, int p=0) {\n    if(p != 0) {\n        if(suff[2*h[v]].mx1.S != tag[v]) {\n            pd[v] = max(pd[v], suff[2*h[v]].mx1.F + h[v]);\n        } else {\n            pd[v] = max(pd[v], suff[2*h[v]].mx2.F + h[v]);\n        }\n    }\n \n    for(int u : adj[v]) {\n        if(u == p || mark[u] == 1) continue;\n        dfs2(u, v);\n    }\n}\n \nvoid solve(int v) {\n    init(v, 0);\n \n    gl = v;\n    dfs1(v);\n \n    for(auto it : vec) {\n        int wh = min(T[it] - 2*h[it], 2*subt[v]);\n        suff[wh] = util(suff[wh], {h[it], tag[it]});\n    }\n    \n    for(int i=2*subt[v]-1; i>=1; i--) {\n        suff[i] = util(suff[i], suff[i+1].mx1);\n        suff[i] = util(suff[i], suff[i+1].mx2);\n    }\n    \n    dfs2(v);\n    \n    vec.clear();\n    for(int i=0; i<=2*subt[v]+1; i++) suff[i] = node();\n    mark[v] = 1;\n    for(int u : centAdj[v]) {\n        solve(u);\n    }\n}\n \nvoid work() {\n    cin>>n;\n    \n    for(int i=1; i<=n; i++) {\n        char ch; cin>>ch;\n        a[i] = (ch == '1');\n    }\n    \n    for(int v,u,i=1; i<n; i++) {\n        cin>>v>>u; adj[v].pb(u); adj[u].pb(v);\n    }\n \n    int rt = createCentTree(1);\n    fill(mark, mark+n+2, 0);\n    fill(h, h+n+2, 0);\n        \n    for(int i=1; i<=n; i++) dp[0][i] = (a[i]==1 ? 2*n : -1);\n \n    for(int i=1; i<=lg; i++) {\n        for(int j=1; j<=n; j++) {\n            if(a[j] == 1) T[j] = dp[i-1][j];\n            else T[j] = -1;\n        }\n \n        solve(rt);\n \n        for(int j=1; j<=n; j++) {\n            tag[j] = mark[j] = 0;\n            dp[i][j] = pd[j];\n            pd[j] = 0;\n        } \n    }\n \n    for(int i=1; i<=n; i++) {\n        if(a[i] == 0) {cout<<-1<<' '; continue;}\n        for(int j=lg; j>=0; j--) {\n            if(dp[j][i] >= 1) {\n                cout<<j+1<<' ';\n                break;\n            }\n        }\n    }\n    cout<<endl;\n}\n \nvoid reset_work() {\n    for(int i=0; i<=lg; i++) for(int j=1; j<=n; j++) dp[i][j] = 0;\n \n    gl = 0;\n    for(int i=0; i<=n+1; i++) {\n        adj[i].clear();\n        centAdj[i].clear();\n        h[i] = T[i] = pd[i] = tag[i] = 0;\n        subt[i] = mark[i] = 0;\n    }\n \n    return;\n}\n \nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0);\n \n    cin>>t;\n    \n    while(t--) {\n        work();\n        reset_work();\n    }\n \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2101d",
      "PROBLEM_ID": "2101D",
      "PROBLEM_STATEMENT": "An array $b$ of length $|b|$ is cute if the sum of the length of its Longest Increasing Subsequence (LIS) and the length of its Longest Decreasing Subsequence (LDS)$^{\\text{\u2217}}$ is exactly one more than the length of the array. More formally, the array $b$ is cute if $\\operatorname{LIS}(b) + \\operatorname{LDS}(b) = |b| + 1$.\n\nYou are given a permutation $a$ of length $n$$^{\\\\text{\u2020}}$. Your task is to count the number of non-empty subarrays$^{\\\\text{\u2021}}$ of permutation $a$ that are cute.\n\n$^{\\text{\u2217}}$A sequence $x$ is a subsequence of a sequence $y$ if $x$ can be obtained from $y$ by the deletion of several (possibly, zero or all) element from arbitrary positions.\n\nThe longest increasing (decreasing) subsequence of an array is the longest subsequence such that its elements are ordered in strictly increasing (decreasing) order.\n\n$^{\\text{\u2020}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n$^{\\text{\u2021}}$An array $x$ is a subarray of an array $y$ if $x$ can be obtained from $y$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 2 \\cdot 10^5 $)\u00a0\u2014 the length of permutation $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the elements of permutation $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the number of cute non-empty subarrays of permutation $a$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3\n\n3 1 2\n\n5\n\n2 3 4 5 1\n\n4\n\n3 4 1 2\n\n7\n\n1 2 3 4 5 6 7\n\n10\n\n7 8 2 4 5 10 1 3 6 9\n\n```\n\n#### Output #1\n\n```\n6\n15\n9\n28\n36\n```\n\n### Note\n\nIn the first test case, all of the $6$ non-empty subarrays are cute:\n\n- $[3]$: $\\operatorname{LIS}([3]) + \\operatorname{LDS}([3]) = 1 + 1 = 2$.\n- $[1]$: $\\operatorname{LIS}([1]) + \\operatorname{LDS}([1]) = 1 + 1 = 2$.\n- $[2]$: $\\operatorname{LIS}([2]) + \\operatorname{LDS}([2]) = 1 + 1 = 2$.\n- $[3, 1]$: $\\operatorname{LIS}([3, 1]) + \\operatorname{LDS}([3, 1]) = 1 + 2 = 3$.\n- $[1, 2]$: $\\operatorname{LIS}([1, 2]) + \\operatorname{LDS}([1, 2]) = 2 + 1 = 3$.\n- $[3, 1, 2]$: $\\operatorname{LIS}([3, 1, 2]) + \\operatorname{LDS}([3, 1, 2]) = 2 + 2 = 4$.\n\nIn the second test case, one of the cute subarrays is $[2, 3, 4, 5, 1]$ as $\\operatorname{LIS}([2, 3, 4, 5, 1]) = 4$ and $\\operatorname{LDS}([2, 3, 4, 5, 1]) = 2$, which satisfies $4 + 2 = 5 + 1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n \n#define int long long\n \n// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n// #pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"unroll-loops\")\n \n \n#define F first \n#define S second\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define kill(x) cout << x << \"\\n\", exit(0);\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define endl \"\\n\"\n \n \n \nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n \n \nconst int MAXN = (int)1e6 + 7;\nconst int MOD = 998244353;\nconst int INF = (int)1e9 + 7;\n \n \nint n, m, k, tmp, t, tmp2, tmp3, tmp4, u, v, w, q, ans, flag;\nint arr[MAXN], L[MAXN], R[MAXN];\n \n \n/* Segment Tree */\n#define mid ((l+r)>>1)\n#define lid (mid<<1)\n#define rid (lid|1)\n \n \nint seg[MAXN<<2];\n \n \nvoid build(int l=0, int r=n, int id=1) {\n    if (l+1 == r) {\n        if (!flag) seg[id] = INF;\n        else seg[id] = -INF;\n \n        return;\n    }\n \n    build(l, mid, lid);\n    build(mid, r, rid);\n \n    if (!flag) seg[id] = min(seg[lid], seg[rid]);\n    else seg[id] = max(seg[lid], seg[rid]);\n}\n \n \nvoid upd(int ind, int k, int l=0, int r=n, int id=1) {\n    if (l+1 == r) {\n        seg[id] = k;\n        return;\n    }\n \n    if (ind < mid) upd(ind, k, l, mid, lid);\n    else upd(ind, k, mid, r, rid);\n \n    if (!flag) seg[id] = min(seg[lid], seg[rid]);\n    else seg[id] = max(seg[lid], seg[rid]);\n}\n \n \nint get(int s, int t, int l=0, int r=n, int id=1) {\n    if (l >= r || s >= t) {\n        if (!flag) return INF;\n        else return -INF;\n    }\n \n    if (s <= l && t >= r) return seg[id];\n    if (t <= mid) return get(s, t, l, mid, lid);\n    if (s >= mid) return get(s, t, mid, r, rid);\n    \n    if (!flag) return min(get(s, t, l, mid, lid), get(s, t, mid, r, rid));\n    else return max(get(s, t, l, mid, lid), get(s, t, mid, r, rid));\n}\n \n/* Segment Tree */\n \n \nvoid solve() {\n    cin >> n;\n \n    for (int i=1; i<=n; i++) {\n        cin >> arr[i];\n    }\n \n    fill(L, L+n+7, 1);\n    fill(R, R+n+7, n);\n \n \n    flag = 0;\n    build();\n \n    for (int i=n-2; i>=1; i--) {\n        upd(arr[i+2]-1, i+2);\n \n        R[i] = min(R[i], get(min(arr[i], arr[i+1]), max(arr[i], arr[i+1]))-1);\n    }\n \n    flag = 1;\n    build();\n \n    for (int i=3; i<=n; i++) {\n        upd(arr[i-2]-1, i-2);\n \n        L[i] = max(L[i], get(min(arr[i], arr[i-1]), max(arr[i], arr[i-1]))+1);\n    }\n \n    for (int i=n-1; i>=1; i--) R[i] = min(R[i], R[i+1]);\n    for (int i=2; i<=n; i++) L[i] = max(L[i], L[i-1]);\n \n    ans = R[1];\n \n    for (int i=2; i<=n; i++) {\n        ans += R[i-1]-i+1;\n        ans += (i-L[i]+1)*(R[i]-R[i-1]);\n    }\n \n    cout << ans << endl;\n}\n \n \n \nint32_t main() {\n    #ifdef LOCAL\n    freopen(\"inp.in\", \"r\", stdin);\n    freopen(\"res.out\", \"w\", stdout);\n    #else\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    #endif\n \n    cin >> t;\n \n    while (t--) solve();\n \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2101c",
      "PROBLEM_ID": "2101C",
      "PROBLEM_STATEMENT": "The distance of a value $x$ in an array $c$, denoted as $d_x(c)$, is defined as the largest gap between any two occurrences of $x$ in $c$.\n\nFormally, $d_x(c) = \\max(j - i)$ over all pairs $i < j$ where $c_i = c_j = x$. If $x$ appears only once or not at all in $c$, then $d_x(c) = 0$.\n\nThe beauty of an array is the sum of the distances of each distinct value in the array. Formally, the beauty of an array $c$ is equal to $\\sum\\limits_{1\\le x\\le n} d_x(c)$.\n\nGiven an array $a$ of length $n$, an array $b$ is nice if it also has length $n$ and its elements satisfy $1\\le b_i\\le a_i$ for all $1\\le i\\le n$. Your task is to find the maximum possible beauty of any nice array.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 2\\cdot10^5$)\u00a0\u2014 the length of array $a$.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1\\le a_i\\le n$)\u00a0\u2014 the elements of array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot10^5$.\n\n### Output\n\nFor each test case, output a single integer representing the maximum possible beauty among all nice arrays.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4\n\n1 2 1 2\n\n2\n\n2 2\n\n10\n\n1 2 1 5 1 2 2 1 1 2\n\n8\n\n1 5 2 8 4 1 4 2\n\n```\n\n#### Output #1\n\n```\n4\n1\n16\n16\n```\n\n### Note\n\nIn the first test case, if $b = [1, 2, 1, 2]$, then $d_1(b) = 3 - 1 = 2$ and $d_2(b) = 4 - 2 = 2$, resulting in a beauty of $2 + 2 = 4$. It can be proven that there are no nice arrays with a beauty greater than $4$.\n\nIn the second test case, both $b = [1, 1]$ and $b = [2, 2]$ are valid solutions with a beauty of $1$.\n\nIn the third test case, if $b = [1, 2, 1, 4, 1, 2, 1, 1, 1, 2]$ with $d_1(b) = 9 - 1 = 8$, $d_2(b) = 10 - 2 = 8$, and $d_4(b) = 0$, resulting in a beauty of $16$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\n#define int long long\n\n// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n// #pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#define F first \n#define S second\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define kill(x) cout << x << \"\\n\", exit(0);\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define endl \"\\n\"\n \n \n \nusing namespace std;\ntypedef long long ll;\n// typedef __int128_t lll;\ntypedef long double ld;\n\nconst int MAXN = (int)1e6 + 7;\nconst int MOD = (int)1e9 + 7;\nconst ll INF = (ll)1e18 + 7;\n\nint n, m, k, tmp, t, tmp2, tmp3, tmp4, u, v, w, p, q, ans, flag;\nint arr[MAXN], f[MAXN][2];\nset<int> st;\n\nvoid solve() {\n    cin >> n;\n\n    for (int i=1; i<=n; i++) cin >> arr[i];\n\n    for (int j=0; j<2; j++) {\n        st.clear();\n        for (int i=1; i<=n; i++) st.insert(i);\n\n        for (int i=(j? n : 1); (j?i>1 : i<n); (j? i-- : i++)) {\n            auto it = st.upper_bound(arr[i]);\n\n            if (it != st.begin()) it--, st.erase(*it);\n\n            f[i][j] = n-st.size();\n        }\n    }\n    \n    ans = 0;\n    for (int i=1; i<n; i++) ans += min(f[i][0], f[i+1][1]);\n\n    cout << ans << endl;\n}\n\nint32_t main() {\n    #ifdef LOCAL\n    freopen(\"inp.in\", \"r\", stdin);\n    freopen(\"res.out\", \"w\", stdout);\n    #else\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    #endif\n\n    cin >> t;\n\n    while (t--) solve();\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2101b",
      "PROBLEM_ID": "2101B",
      "PROBLEM_STATEMENT": "You are given a permutation $a$ of length $n$$^{\\\\text{\u2217}}$. You are allowed to do the following operation any number of times (possibly zero):\n\n- Choose an index $1\\le i\\le n - 3$. Then, swap $a_i$ with $a_{i + 2}$, and $a_{i + 1}$ with $a_{i + 3}$ simultaneously. In other words, permutation $a$ will be transformed from $[\\ldots, a_i, a_{i+1}, a_{i+2}, a_{i+3}, \\ldots]$ to $[\\ldots, a_{i+2}, a_{i+3}, a_{i}, a_{i+1}, \\ldots]$.\n\nDetermine the lexicographically smallest permutation$^{\\text{\u2020}}$ that can be obtained by applying the above operation any number of times.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n$^{\\text{\u2020}}$An array $x$ is lexicographically smaller than an array $y$ of the same size if and only if the following holds:\n\n- in the first position where $x$ and $y$ differ, the array $x$ has a smaller element than the corresponding element in $y$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($4\\le n\\le 2\\cdot 10^5$)\u00a0\u2014 the length of permutation $a$.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the elements of permutation $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output the lexicographically smallest permutation that can be obtained by applying the above operation any number of times.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4\n\n3 4 1 2\n\n5\n\n5 4 3 1 2\n\n10\n\n10 9 8 7 6 5 4 3 2 1\n\n```\n\n#### Output #1\n\n```\n1 2 3 4\n2 1 3 4 5\n2 1 4 3 6 5 8 7 10 9\n```\n\n### Note\n\nIn the first test case, an operation can be done on index $i = 1$, and the permutation will become $[1, 2, 3, 4]$, which is the lexicographically smallest permutation achievable.\n\nIn the second test case, we can do the following sequence of operations:\n\n- Do an operation on index $i = 2$. The permutation becomes $[5, 1, 2, 4, 3]$.\n- Do an operation on index $i = 1$. The permutation becomes $[2, 4, 5, 1, 3]$.\n- Do an operation on index $i = 2$. The permutation becomes $[2, 1, 3, 4, 5]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Fenwick Tree (BIT) for range-sum queries and point updates\nstruct Fenwick {\n    int n;\n    vector<int> f;\n    Fenwick(int _n): n(_n), f(n+1, 0) {}\n    // add value v at position i (1-based)\n    void update(int i, int v) {\n        for(; i <= n; i += i & -i)\n            f[i] += v;\n    }\n    // query sum of [1..i]\n    int query(int i) const {\n        int s = 0;\n        for(; i > 0; i -= i & -i)\n            s += f[i];\n        return s;\n    }\n    // query sum of [l..r]\n    int rangeQuery(int l, int r) const {\n        if(l > r) return 0;\n        return query(r) - query(l-1);\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++){\n            cin >> a[i];\n        }\n        // split into odd-indexed (0-based even idx) and even-indexed (0-based odd idx)\n        vector<int> O, E;\n        O.reserve((n+1)/2);\n        E.reserve(n/2);\n        for(int i = 0; i < n; i++){\n            if((i & 1) == 0) O.push_back(a[i]);\n            else           E.push_back(a[i]);\n        }\n        int oN = (int)O.size();\n        int eN = (int)E.size();\n\n        // compute parity of inversion count of O\n        long long invO = 0;\n        if(oN > 1) {\n            // compress O\n            vector<int> cp = O;\n            sort(cp.begin(), cp.end());\n            cp.erase(unique(cp.begin(), cp.end()), cp.end());\n            Fenwick fw(cp.size());\n            for(int i = 0; i < oN; i++){\n                int v = O[i];\n                int r = int(lower_bound(cp.begin(), cp.end(), v) - cp.begin()) + 1;\n                // count how many already seen > v\n                invO += fw.rangeQuery(r+1, cp.size());\n                fw.update(r, 1);\n            }\n        }\n        invO &= 1;\n\n        // compute parity of inversion count of E\n        long long invE = 0;\n        if(eN > 1) {\n            vector<int> cp = E;\n            sort(cp.begin(), cp.end());\n            cp.erase(unique(cp.begin(), cp.end()), cp.end());\n            Fenwick fw(cp.size());\n            for(int i = 0; i < eN; i++){\n                int v = E[i];\n                int r = int(lower_bound(cp.begin(), cp.end(), v) - cp.begin()) + 1;\n                invE += fw.rangeQuery(r+1, cp.size());\n                fw.update(r, 1);\n            }\n        }\n        invE &= 1;\n\n        // sort both subsequences ascending\n        vector<int> so = O;\n        vector<int> se = E;\n        sort(so.begin(), so.end());\n        sort(se.begin(), se.end());\n\n        // final sequences\n        vector<int> fo = so, fe = se;\n\n        if(invO == invE){\n            // parity match: can fully sort both\n        } else {\n            // parity mismatch: adjust minimal lex\n            if(n % 2 == 0) {\n                // even n: adjust E by one swap at last adjacent\n                if(eN >= 2) {\n                    swap(fe[eN-2], fe[eN-1]);\n                }\n            } else {\n                // odd n: adjust O by one swap at last adjacent\n                if(oN >= 2) {\n                    swap(fo[oN-2], fo[oN-1]);\n                }\n            }\n        }\n\n        // interleave fo and fe into result\n        vector<int> ans(n);\n        for(int i = 0; i < oN; i++){\n            ans[2*i] = fo[i];\n        }\n        for(int i = 0; i < eN; i++){\n            ans[2*i+1] = fe[i];\n        }\n\n        // output\n        for(int i = 0; i < n; i++){\n            cout << ans[i] << (i+1<n ? ' ' : '\\n');\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2101a",
      "PROBLEM_ID": "2101A",
      "PROBLEM_STATEMENT": "You are given $n^2$ cards with values from $0$ to $n^2-1$. You are to arrange them in a $n$ by $n$ grid such that there is exactly one card in each cell.\n\nThe MEX (minimum excluded value) of a subgrid$^{\\text{\u2217}}$ is defined as the smallest non-negative integer that does not appear in the subgrid.\n\nYour task is to arrange the cards such that the sum of MEX values over all $\\left(\\frac{n(n+1)}{2}\\right)^2$ subgrids is maximized.\n\n$^{\\text{\u2217}}$A subgrid of a $n$ by $n$ grid is specified by four numbers $l_1, r_1, l_2, r_2$ satisfying $1\\le l_1\\le r_1\\le n$ and $1\\le l_2\\le r_2\\le n$. The element in the $i$-th row and the $j$-th column of the grid is part of the subgrid if and only if $l_1\\le i\\le r_1$ and $l_2\\le j\\le r_2$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 500$)\u00a0\u2014 the side length of the grid.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $1000$.\n\n### Output\n\nFor each test case, output $n$ lines, each containing $n$ integers representing the elements of the grid.\n\nIf there are multiple answers, you can output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n2\n\n3\n\n```\n\n#### Output #1\n\n```\n0 1\n2 3\n8 4 5\n6 0 1\n7 2 3```\n\n### Note\n\nIn the first test case, one valid arrangement is:\n\n0123\n\nThere are $9$ subgrids in total, and the $4$ of them with non-zero MEX are shown below:\n\n0values:$[0]$\u00a0\u2014 MEX: $1$\n\n01values:$[0, 1]$ \u00a0\u2014 MEX: $2$\n\n02values:$[0, 2]$ \u00a0\u2014 MEX: $1$\n\n0123values:$[0, 1, 2, 3]$ \u00a0\u2014 MEX: $4$\n\nThe sum of MEX over all subgrids would be $1+2+1+4 = 8$. It can be proven that no other arrangements have a larger sum of MEX values.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        // Prepare the grid and visited flag\n        vector<vector<int>> grid(n, vector<int>(n, -1));\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\n\n        // Directions in the order: E, S, SE, N, NE, W, SW, NW\n        static const int dx[8] = { 0, 1, 1, -1, -1,  0,  1, -1 };\n        static const int dy[8] = { 1, 0, 1,  0,  1, -1, -1, -1 };\n\n        // Choose the \"center\" as (n-1)/2, 0-based\n        int cx = (n - 1) / 2;\n        int cy = (n - 1) / 2;\n\n        // BFS from the center over 8-connected grid\n        queue<pair<int,int>> q;\n        q.emplace(cx, cy);\n        vis[cx][cy] = true;\n\n        int val = 0;\n        while (!q.empty()) {\n            auto [x, y] = q.front();\n            q.pop();\n\n            // Assign the next number\n            grid[x][y] = val++;\n            // Explore neighbors\n            for (int d = 0; d < 8; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && !vis[nx][ny]) {\n                    vis[nx][ny] = true;\n                    q.emplace(nx, ny);\n                }\n            }\n        }\n\n        // Output the grid\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                cout << grid[i][j] << (j + 1 < n ? ' ' : '\\n');\n            }\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2098b",
      "PROBLEM_ID": "2098B",
      "PROBLEM_STATEMENT": "Sasha wants to buy an apartment on a street where the houses are numbered from $1$ to $10^9$ from left to right.\n\nThere are $n$ bars on this street, located in houses with numbers $a_1, a_2, \\ldots, a_n$. Note that there might be multiple bars in the same house, and in this case, these bars are considered distinct.\n\nSasha is afraid that by the time he buys the apartment, some bars may close, but no more than $k$ bars can close.\n\nFor any house with number $x$, define $f(x)$ as the sum of $|x - y|$ over all open bars $y$ (that is, after closing some bars).\n\nSasha can potentially buy an apartment in a house with number $x$ (where $1 \\le x \\le 10^9$) if and only if it is possible to close at most $k$ bars so that after that $f(x)$ becomes minimal among all houses.\n\nDetermine how many different houses Sasha can potentially buy an apartment in.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\leq n \\leq 10^5, 0 \\leq k < n$)\u00a0\u2014 the number of bars and the maximum number of bars that can close.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$)\u00a0\u2014 the house numbers where the bars are located.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the number of houses where Sasha can buy an apartment.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4 0\n\n1 2 3 4\n\n5 2\n\n7 6 6 7 1\n\n3 1\n\n6 7 9\n\n6 2\n\n5 1 9 10 13 2\n\n```\n\n#### Output #1\n\n```\n2\n2\n4\n9\n```\n\n### Note\n\nIn the first test case, none of the bars can close, so only houses numbered $2$ and $3$ are suitable. For the house numbered $2$, the sum of distances is $|2 - 1| + |2 - 2| + |2 - 3| + |2 - 4| = 4$, and for the house numbered $3$, the sum of distances is $|3 - 1| + |3 - 2| + |3 - 3| + |3 - 4| = 4$. However, for the house numbered $1$, the sum of distances will be $|1 - 1| + |1 - 2| + |1 - 3| + |1 - 4| = 6$, so the house numbered $1$ is not suitable. It can also be proven that Sasha cannot buy apartments in other houses.\n\nIn the second test case, the suitable houses are numbered $6$ and $7$. For Sasha to choose the house numbered $6$, it is sufficient that none of the bars close. For Sasha to choose the house numbered $7$, the bars in houses $1$ and $6$ can close. Then the bars will be located in houses numbered $6$, $7$, and $7$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        long long k;\n        std::cin >> n >> k;\n        std::vector<long long> a(n);\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n        }\n        std::sort(a.begin(), a.end());\n\n        // The sum of distances f(x) = sum |x - b_i| for a set of bar locations {b_i}\n        // is minimized when x is a median of the set {b_i}.\n        // If the sorted remaining bar locations are b_1 <= ... <= b_m,\n        // the minimum is achieved for any integer x in the range [b_floor((m+1)/2), b_ceil((m+1)/2)].\n        // Sasha can buy an apartment at x if it's possible to close at most k bars\n        // (leaving m >= n-k bars) such that x is a median for the remaining bars.\n        // This means x must be in [b_floor((m+1)/2), b_ceil((m+1)/2)] for some set of m bars chosen from the original n.\n        // The bars b_i must be from the original locations a_j.\n        \n        // A value v can be a median of some set of m bars if we can select m bars such that\n        // at most floor(m/2) are < v and at most floor(m/2) are > v.\n        // To maximize the number of bars m for which a specific value v can be a median,\n        // we must satisfy the conditions on counts of bars <v and >v among the selected bars.\n        // It can be shown that a value v can be a median of *some* set of m bars (n-k <= m <= n)\n        // if and only if count(original bars <= v) >= ceil((n-k)/2)\n        // AND count(original bars >= v) >= ceil((n-k)/2).\n        \n        // Let m_min = n-k. Let K = ceil((n-k)/2).\n        // K = (m_min + 1) / 2 using integer division for m_min >= 1.\n        // Since k < n, m_min = n-k >= 1, so K >= 1.\n        long long m_min = n - k;\n        long long K = (m_min + 1) / 2;\n\n        // count(original bars <= v) >= K implies v must be greater than or equal to\n        // the K-th smallest bar location in the original sorted list 'a'.\n        // In a 0-indexed sorted array 'a', the K-th smallest element is at index K-1.\n        long long min_possible_median_value = a[K - 1];\n\n        // count(original bars >= v) >= K implies count(original bars < v) <= n - K.\n        // This means v must be greater than the (n-K)-th smallest bar location.\n        // The (n-K+1)-th smallest element in 'a' (1-indexed) is at index n-K (0-indexed).\n        // Any value v >= a[n-K] has at least n-K+1 elements >= v IF there are no duplicates.\n        // More precisely: N_ge(v) >= K implies v must be less than or equal to the (n-K+1)-th largest bar location.\n        // The (n-K+1)-th largest element in sorted 'a' is at index n-K (0-indexed).\n        long long max_possible_median_value = a[n - K];\n\n        // The set of possible median values achievable by removing at most k bars is\n        // the range [min_possible_median_value, max_possible_median_value].\n        // Any integer house number x in this range is a potential optimal location.\n        long long result = max_possible_median_value - min_possible_median_value + 1;\n        std::cout << result << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2098a",
      "PROBLEM_ID": "2098A",
      "PROBLEM_STATEMENT": "We call a phone number a beautiful if it is a string of $10$ digits, where the $i$-th digit from the left is at least $10 - i$. That is, the first digit must be at least $9$, the second at least $8$, $\\ldots$, with the last digit being at least $0$.\n\nFor example, 9988776655 is a beautiful phone number, while 9099999999 is not, since the second digit, which is $0$, is less than $8$.\n\nVadim has a beautiful phone number. He wants to rearrange its digits in such a way that the result is the smallest possible beautiful phone number. Help Vadim solve this problem.\n\nPlease note that the phone numbers are compared as integers.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains a single string $s$ of length $10$, consisting of digits. It is guaranteed that $s$ is a beautiful phone number.\n\n### Output\n\nFor each test case, output a single string of length $10$ \u2014 the smallest possible beautiful phone number that Vadim can obtain.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n9999999999\n\n9988776655\n\n9988776650\n\n9899999999\n\n```\n\n#### Output #1\n\n```\n9999999999\n9876556789\n9876567890\n9899999999\n```\n\n### Note\n\nIn the first test case, for the first phone number 9999999999, regardless of the rearrangement of digits, the same phone number is obtained.\n\nIn the second test case, for the phone number 9988776655, it can be proven that 9876556789 is the smallest phone number that can be obtained by rearranging the digits.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid solve() {\n    string s;\n    cin >> s;\n    \n    // Count the frequency of each digit\n    vector<int> count(10, 0);\n    for (char c : s) {\n        count[c - '0']++;\n    }\n    \n    string result = \"\";\n    for (int i = 0; i < 10; i++) {\n        int min_required = 9 - i;  // Minimum digit needed at this position\n        \n        // Find the smallest available digit that satisfies the requirement\n        for (int digit = min_required; digit <= 9; digit++) {\n            if (count[digit] > 0) {\n                result += (digit + '0');\n                count[digit]--;\n                break;\n            }\n        }\n    }\n    \n    cout << result << '\\n';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2097f",
      "PROBLEM_ID": "2097F",
      "PROBLEM_STATEMENT": "As is known, the airline \"Trouble\" often loses luggage, and concerned journalists decided to calculate the maximum number of luggage pieces that may not return to travelers.\n\nThe airline \"Trouble\" operates flights between $n$ airports, numbered from $1$ to $n$. The journalists' experiment will last for $m$ days. It is known that at midnight before the first day of the experiment, there were $s_j$ lost pieces of luggage in the $j$-th airport. On the $i$-th day, the following occurs:\n\n- In the morning, $2n$ flights take off simultaneously, including $n$ flights of the first type and $n$ flights of the second type.\n  - The $j$-th flight of the first type flies from airport $j$ to airport $(((j-2) \\bmod n )+ 1)$ (the previous airport, with the first airport being the last), and it can carry no more than $a_{i,j}$ lost pieces of luggage.\n  - The $j$-th flight of the second type flies from airport $j$ to airport $((j \\bmod n) + 1)$ (the next airport, with the last airport being the first), and it can carry no more than $c_{i,j}$ lost pieces of luggage.\n- In the afternoon, a check of lost luggage is conducted at the airports. If after the flights have departed on that day, there are $x$ pieces of luggage remaining in the $j$-th airport and $x \\ge b_{i, j}$, then at least $x - b_{i, j}$ pieces of luggage are found, and they cease to be lost.\n- In the evening, all $2n$ flights conclude, and the lost luggage transported that day arrives at the corresponding airports.\n\nFor each $k$ from $1$ to $m$, the journalists want to know the maximum number of lost pieces of luggage that may be unfound during the checks over the first $k$ days. Note that for each $k$, these values are calculated independently.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($3 \\le n \\le 12$, $1 \\le m \\le 2000$)\u00a0\u2014 the number of airports and the number of days of the experiment.\n\nThe second line of each test case contains $n$ integers $s_1, s_2, \\ldots, s_n$ ($0 \\le s_i \\le 10^8$)\u00a0\u2014 the initial number of lost pieces of luggage in each airport.\n\nNext, the descriptions for each of the $m$ days follow in order.\n\nThe first line of the description of the $i$-th day contains $n$ integers $a_{i,1}, a_{i,2}, \\ldots, a_{i,n}$ ($0 \\le a_{i, j} \\le 10^8$)\u00a0\u2014 the maximum number of lost pieces of luggage that can be transported to the previous airport for each airport.\n\nThe second line of the description of the $i$-th day contains $n$ integers $b_{i,1}, \\ldots, b_{i,n}$ ($0 \\le b_{i, j} \\le 10^8$)\u00a0\u2014 the minimum number of lost pieces of luggage that will be found on the $i$-th day in each airport.\n\nThe third line of the description of the $i$-th day contains $n$ integers $c_{i,1}, \\ldots, c_{i,n}$ ($0 \\le c_{i, j} \\le 10^8$)\u00a0\u2014 the maximum number of lost pieces of luggage that can be transported to the next airport for each airport.\n\nIt is guaranteed that the sum of $m$ over all test cases does not exceed $2000$.\n\n### Output\n\nFor each test case, output $m$ integers\u00a0\u2014 the maximum number of unfound pieces of luggage for each number of days from $1$ to $m$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5 3\n\n1 1 1 1 1\n\n0 0 1 0 0\n\n0 1 0 0 1\n\n1 0 0 1 0\n\n0 1 0 0 0\n\n9 0 9 9 9\n\n0 1 0 0 0\n\n0 0 0 0 0\n\n9 0 9 0 0\n\n0 0 0 0 0\n\n3 1\n\n0 100000000 5\n\n0 100000000 5\n\n0 100000000 5\n\n0 100000000 5\n\n```\n\n#### Output #1\n\n```\n5\n4\n2\n100000005\n```\n\n### Note\n\nIn the first test case:\n\n- On the first day, all $5$ pieces of luggage may not be found, as the lost luggage can be sent on flights from each airport.\n- In the morning of the second day, there may be no more than $3$ pieces of luggage in the $2$-nd airport, no more than $2$ pieces in the $5$-th airport, and no luggage in the other airports. All luggage from the $5$-th airport may remain there. In the $2$-nd airport, no more than $2$ pieces of luggage can be sent on flights to neighboring airports. Thus, at least $1$ piece of luggage will be found.\n- By the end of the third day, lost luggage may only be in the $1$-st and $2$-nd airports. There can be no more than one piece in each, meaning that at most $2$ pieces of luggage will remain unfound in total.\n\n![](https://espresso.codeforces.com/75b781e883fa683f8e14854d82606ce873c13b96.png)The found luggage is marked in green.\n\nIn the second test case, all pieces of luggage may remain in their original airports, and the inspection won't find any lost suitcases. Therefore, the answer is $10^9 + 5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n#define LL long long\nint T,N,M,s[13],a[13][3];\nLL dp[(1<<12)+5],tp[(1<<12)+5],qq[(1<<12)+5][2];\nsigned main(void) {\nscanf(\"%d\",&T);\nwhile(T--) {\nscanf(\"%d %d\",&N,&M);\nfor(int i=1;i<=N;i++) scanf(\"%d\",&s[i]);\nfor(int i=0;i<(1<<N);i++) {\ndp[i]=0;\nfor(int j=1;j<=N;j++) if(((i>>j-1)&1)==0) dp[i]+=s[j];\n}\nwhile(M--) {\nfor(int i=1;i<=N;i++) scanf(\"%d\",&a[i][0]);\nfor(int i=1;i<=N;i++) scanf(\"%d\",&a[i][1]);\nfor(int i=1;i<=N;i++) scanf(\"%d\",&a[i%N+1][2]);\nmemset(tp,0x3f,sizeof(tp));\nfor(int st=0;st<2;st++) {\nmemset(qq,0x3f,sizeof(qq));\nfor(int j=st;j<(1<<N);j+=2) qq[j][(j>>N-1)]=dp[j];\nfor(int j=1;j<=N;j++) {\nint qc=((j==N)&&st)?a[1][0]:0;\nfor(int k=0,fl=0;k<(1<<N);k+=(1<<j),fl^=1) {\nLL vq=fl*a[j+1][0]+qc;\nfor(int k1=k;k1<k+(1<<j-1);k1++) {\nint k2=k1+(1<<j-1);\nLL aa=qq[k1][0],bb=qq[k1][1],cc=qq[k2][0],dd=qq[k2][1];\nqq[k1][0]=std::min(aa,bb+a[j][2])+vq;\nqq[k1][1]=std::min(cc,dd+a[j][2])+vq+a[j][1];\nqq[k2][0]=std::min(aa,bb);\nqq[k2][1]=std::min(cc,dd);\n}\n}\n}\nfor(int k=0;k<(1<<N);k++) tp[k]=std::min(tp[k],std::min(qq[k][0],qq[k][1]));\n}\nmemcpy(dp,tp,sizeof(dp));\nprintf(\"%lld\\n\",dp[0]);\n}\n}\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2097e",
      "PROBLEM_ID": "2097E",
      "PROBLEM_STATEMENT": "Boy Vasya loves to travel very much. In particular, flying in airplanes brings him extraordinary pleasure. He was about to fly to another city, but the runway was heavily covered with snow and needed to be cleared.\n\nThe runway can be represented as $n$ consecutive sections numbered from $1$ to $n$. The snowstorm was quite strong, but it has already stopped, so Vasya managed to calculate that the $i$-th section is covered with $a_i$ meters of snow. For such situations, the airport has a snowplow that works in a rather unusual way. In one minute, the snowplow can do the following:\n\n- Choose a consecutive segment of length no more than $d$ and remove one meter of snow from the most snow-covered sections.\nFormally, one can choose $1 \\le l \\le r \\le n$ ($r - l + 1 \\le d$). After that, $c = \\max \\{ a_l, a_{l + 1}, \\ldots , a_r \\}$ is calculated, and if $c > 0$, then for all $i \\colon l \\le i \\le r$ such that $a_i = c$, the value of $a_i$ is decreased by one.\n\n\nVasya has been preparing for the flight for a long time and wants to understand how much time he has left to wait until all sections are completely cleared of snow. In other words, it is required to calculate the minimum number of minutes that the snowplow will need to achieve $a_i = 0$ for all $i$ from $1$ to $n$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2 \\cdot 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $d$ ($1 \\le n \\le 5 \\cdot 10^5, 1 \\le d \\le n$) \u2014 the number of sections on the runway and the maximum length of the segment that the snowplow can choose.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the number of meters of snow on the $i$-th section.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of minutes required for the snowplow to achieve $a_i = 0$ for all $i$ from $1$ to $n$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5 2\n\n1 5 2 1 2\n\n3 1\n\n1000000000 1000000000 1000000000\n\n```\n\n#### Output #1\n\n```\n8\n3000000000\n```\n\n### Note\n\nIn the first test case, there is an optimal sequence of operations. First, select the segment $[2, 3]$ four times. After three operations, $a_2$ will turn into $2$, and the array $a$ will look like $[1, 2, 2, 1, 2]$. After the fourth operation, the array $a$ will become $[1, 1, 1, 1, 2]$. Next, the array can be transformed into zeros by selecting the segments $[1, 2]$, $[3, 3]$, $[5, 5]$, and $[4, 5]$ (in that exact order).\n\nIn the second test case, $d = 1$, which means that each section is cleared independently of the others, and the answer is equal to the sum of all $a_i$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef vector<int> vi;\ninline int rd(){\n\tint x=0,y=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')y=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*y;\n}\nconst int B=2000,N=500005;\nint n,m,t,be[N],L[N],R[N],b[N],ks,kc,f[N],g[N];pr a[N];long long an;\ninline int qr(){int sm=0;for(int i=1;i<=n;i=f[i])sm+=g[i];return sm;}\nint main(){\n\tfor(t=rd();t--;){\n        n=rd();m=rd();for(int i=1;i<=n;++i)a[i]={rd(),i},b[i]=0;a[n+1].F=an=0;\n        sort(a+1,a+1+n,greater<pr>());kc=min(B,n);ks=(n+kc-1)/kc;\n        for(int i=1;i<=ks;++i){\n            L[i]=R[i-1]+1;R[i]=min(R[i-1]+B,n);\n            for(int j=L[i];j<=R[i];++j)be[j]=i,f[j]=R[i]+1,g[j]=0;\n        }\n        for(int i=1,x;i<=n;++i){\n            b[x=a[i].S]=1;\n            int o=0;\n            for(int j=x;j>=L[be[x]];--j){\n                if(b[j])o=j;\n                if(o+m>R[be[x]])g[j]=1,f[j]=o+m;\n                else f[j]=f[o+m],g[j]=g[o+m]+1;\n            }\n            if(a[i].F!=a[i+1].F)an+=1ll*qr()*(a[i].F-a[i+1].F);\n        }\n        printf(\"%lld\\n\",an);\n    }\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2097d",
      "PROBLEM_ID": "2097D",
      "PROBLEM_STATEMENT": "Some teachers work at the educational center \"Sirius\" while simultaneously studying at the university. In this case, the trip does not exempt them from completing their homework, so they do their homework right on the plane. Artem is one of those teachers, and he was assigned the following homework at the university.\n\nWith an arbitrary string $a$ of even length $m$, he can perform the following operation. Artem splits the string $a$ into two halves $x$ and $y$ of equal length, after which he performs exactly one of three actions:\n\n- For each $i \\in \\left\\{ 1, 2, \\ldots, \\frac{m}{2}\\right\\}$ assign $x_i = (x_i + y_i) \\bmod 2$;\n- For each $i \\in \\left\\{ 1, 2, \\ldots, \\frac{m}{2}\\right\\}$ assign $y_i = (x_i + y_i) \\bmod 2$;\n- Perform an arbitrary number of operations (the same operations defined above, applied recursively) on the strings $x$ and $y$, independently of each other. Note that in this case, the strings $x$ and $y$ must be of even length.\n\nAfter that, the string $a$ is replaced by the strings $x$ and $y$, concatenated in the same order.\n\nUnfortunately, Artem fell asleep on the plane, so you will have to complete his homework. Artem has two binary strings $s$ and $t$ of length $n$, each consisting of $n$ characters 0 or 1. Determine whether it is possible to make string $s$ equal to string $t$ with an arbitrary number of operations.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^6$) \u2014 the length of the strings $s$ and $t$.\n\nThe second line of each test case contains the string $s$ of length $n$, consisting only of characters 0 and 1.\n\nThe third line of each test case contains the string $t$ of length $n$, consisting only of characters 0 and 1.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output \"Yes\" (without quotes) if it is possible to make string $s$ equal to string $t$, and \"No\" otherwise.\n\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n8\n\n00001001\n\n10101001\n\n8\n\n00000000\n\n00001001\n\n6\n\n010110\n\n100010\n\n```\n\n#### Output #1\n\n```\nYes\nNo\nYes\n```\n\n### Note\n\nIn the first test case, the string 00001001 can be transformed into the string 10101001 in two operations. The sequence of actions is illustrated in the figure below:\n\n![](https://espresso.codeforces.com/db22dab7fd76e815ff8fea8c2beaa45cc9e94441.png)\n\nIn the second test case, the string 00000000 cannot be transformed into any string other than 00000000, as no non-zero elements can be formed during any operation.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <cstdint> // For uint64_t\n\n// Use std::vector<uint64_t> to represent a bitset dynamically.\n// Each uint64_t stores 64 bits.\nusing Bitset = std::vector<uint64_t>;\n\n/**\n * @brief Performs XOR operation between two rows (Bitsets).\n * `dst = dst XOR src`. Assumes both Bitsets represent vectors of the same dimension `p`.\n * @param dst The destination Bitset, modified in place.\n * @param src The source Bitset.\n * @param p_words The number of uint64_t words required to store `p` bits (ceil(p/64)).\n */\nvoid xor_rows(Bitset& dst, const Bitset& src, int p_words) {\n    // The Bitsets are guaranteed to have size p_words by initialization logic.\n    for (int i = 0; i < p_words; ++i) {\n        dst[i] ^= src[i];\n    }\n}\n\n/**\n * @brief Checks if the bit at a specific column index `col` is set in a Bitset `row`.\n * @param row The Bitset representing a row vector.\n * @param col The column index (0-based).\n * @return True if the bit is 1, False otherwise.\n */\nbool get_bit(const Bitset& row, int col) {\n    int word_idx = col / 64; // Index of the uint64_t word containing the bit\n    int bit_idx = col % 64;  // Index of the bit within the word\n    \n    // Check if word_idx is within the bounds of the vector. This should generally be true\n    // if called correctly within the Gaussian elimination context where row size is p_words.\n    if (word_idx >= row.size()) return false; \n    \n    // Check the specific bit using bitwise operations.\n    return (row[word_idx] >> bit_idx) & 1ULL;\n}\n\n/**\n * @brief Computes a basis for the vector space spanned by the rows of the input matrix using Gaussian elimination.\n * The matrix is transformed into Reduced Row Echelon Form (RREF) in place.\n * @param matrix A vector of Bitsets, where each Bitset represents a row vector. The matrix is modified in place.\n * @param p The dimension of the vectors (number of columns).\n * @param num_rows The number of rows in the matrix.\n * @return A vector containing the basis vectors (non-zero rows of the RREF matrix), sorted lexicographically.\n */\nstd::vector<Bitset> compute_basis(std::vector<Bitset>& matrix, int p, int num_rows) {\n    // Handle edge cases: empty matrix or zero-dimensional vectors.\n    if (num_rows == 0 || p == 0) return {}; \n    \n    // Calculate the number of 64-bit words needed to store p bits.\n    int p_words = (p + 63) / 64;\n    int rank = 0; // Tracks the rank of the matrix / number of pivot rows found.\n\n    // Gaussian elimination process to achieve RREF.\n    // Iterate through columns `j` to find pivots.\n    for (int j = 0; j < p && rank < num_rows; ++j) {\n        // Find a row `pivot_row` starting from `rank` that has a 1 in column `j`.\n        int pivot_row = rank;\n        while (pivot_row < num_rows && !get_bit(matrix[pivot_row], j)) {\n            pivot_row++;\n        }\n\n        // If no pivot is found in column `j` at or below row `rank`, move to the next column.\n        if (pivot_row == num_rows) {\n            continue; \n        }\n\n        // Swap the found pivot row `pivot_row` with the current `rank`-th row.\n        std::swap(matrix[rank], matrix[pivot_row]);\n\n        // Eliminate 1s in column `j` in all other rows `i` (both above and below the pivot row `rank`).\n        // This is done by XORing the pivot row `matrix[rank]` into row `i` if `matrix[i][j]` is 1.\n        for (int i = 0; i < num_rows; ++i) {\n            if (i != rank && get_bit(matrix[i], j)) {\n                xor_rows(matrix[i], matrix[rank], p_words);\n            }\n        }\n        // Increment rank, signifying that we have processed one more pivot element / basis vector.\n        rank++;\n    }\n\n    // Collect the non-zero rows from the resulting RREF matrix. These form the basis.\n    std::vector<Bitset> basis;\n    basis.reserve(rank); // Reserve memory capacity for potentially `rank` basis vectors.\n    for (int i = 0; i < rank; ++i) {\n        // The first `rank` rows of the RREF matrix should form the basis.\n        // Verify the row is non-zero (it should be, but safety check is good).\n        bool non_zero = false;\n        for(int k = 0; k < p_words; ++k) {\n            if (matrix[i][k] != 0) {\n                non_zero = true;\n                break;\n            }\n        }\n        \n        if (non_zero) {\n           // Crucial step for canonical representation: Clear any bits beyond the p-th position\n           // in the last word. This ensures consistent comparison.\n           if (p > 0 && p % 64 != 0) {\n                // Create a mask with 1s for the first (p % 64) bits.\n                matrix[i][p_words - 1] &= (1ULL << (p % 64)) - 1;\n           }\n           basis.push_back(matrix[i]);\n        }\n    }\n    \n    // Sort the basis vectors lexicographically to get a canonical representation of the basis.\n    // Standard std::vector comparison works correctly for comparing Bitsets.\n    std::sort(basis.begin(), basis.end());\n\n    return basis;\n}\n\n/**\n * @brief Solves a single test case. Determines if string s can be transformed into string t.\n * @return True if transformation is possible, False otherwise.\n */\nbool solve() {\n    int N_orig; // Store the original length N\n    std::cin >> N_orig;\n    std::string s_str, t_str; // Input strings s and t\n    std::cin >> s_str >> t_str;\n\n    // Check if s is the all-zero string.\n    bool s_is_zero = true;\n    for (int i=0; i < N_orig; ++i) {\n        if (s_str[i] == '1') {\n            s_is_zero = false;\n            break;\n        }\n    }\n\n    // Check if t is the all-zero string.\n    bool t_is_zero = true;\n    for (int i=0; i < N_orig; ++i) {\n         if (t_str[i] == '1') {\n            t_is_zero = false;\n            break;\n        }\n    }\n\n    // Necessary condition: The transformation is possible only if both strings are zero\n    // or both are non-zero. If one is zero and the other isn't, return false.\n    if (s_is_zero != t_is_zero) {\n        return false;\n    }\n    // If both strings are zero, the transformation is trivial (identity operation).\n    if (s_is_zero) { // This implies t_is_zero is also true based on the previous check.\n        return true;\n    }\n\n    // At this point, we know both s and t are non-zero strings.\n\n    // Decompose N = 2^k * p, where p is odd. This determines the block structure.\n    int n_temp = N_orig; \n    int k = 0; // Exponent of 2 in the factorization of N\n    if (n_temp > 0) { \n       // Find the largest power of 2 that divides n_temp. This is equivalent to\n       // counting the number of trailing zeros in the binary representation of N_orig.\n       while ((n_temp & 1) == 0 && n_temp > 0) {\n           k++;\n           n_temp >>= 1; // Divide by 2\n       }\n    }\n    int p = n_temp; // p is the remaining odd factor.\n\n    // Optimization / Special Case: If p = 1, N = 2^k.\n    // Based on analysis (and potentially known results), any non-zero string can be transformed\n    // into any other non-zero string in this case. Since we know s and t are non-zero, return true.\n    if (p == 1) {\n        return true;\n    }\n    \n    // Calculate the number of blocks (2^k) and the number of 64-bit words needed per block (ceil(p/64)).\n    int num_blocks = 1 << k;\n    int p_words = (p + 63) / 64;\n\n    // Construct the matrix for string s. Each row corresponds to a block B_i of length p.\n    std::vector<Bitset> s_matrix(num_blocks, Bitset(p_words, 0));\n    for (int i = 0; i < num_blocks; ++i) { // Iterate through blocks\n        for (int j = 0; j < p; ++j) { // Iterate through bits within a block\n            int global_idx = i * p + j; // Global index in the original string s\n            // Check bounds, although global_idx should be < N_orig since N_orig = num_blocks * p.\n            if (global_idx < N_orig && s_str[global_idx] == '1') {\n                int word_idx = j / 64; // Word index for the bit\n                int bit_idx = j % 64;  // Bit index within the word\n                s_matrix[i][word_idx] |= (1ULL << bit_idx); // Set the bit\n            }\n        }\n    }\n\n    // Construct the matrix for string t similarly. Each row corresponds to a block C_i.\n    std::vector<Bitset> t_matrix(num_blocks, Bitset(p_words, 0));\n    for (int i = 0; i < num_blocks; ++i) {\n        for (int j = 0; j < p; ++j) {\n            int global_idx = i * p + j;\n            if (global_idx < N_orig && t_str[global_idx] == '1') {\n                int word_idx = j / 64;\n                int bit_idx = j % 64;\n                t_matrix[i][word_idx] |= (1ULL << bit_idx);\n            }\n        }\n    }\n\n    // Compute the canonical basis for the vector space spanned by the blocks of s.\n    std::vector<Bitset> s_basis = compute_basis(s_matrix, p, num_blocks);\n    // Compute the canonical basis for the vector space spanned by the blocks of t.\n    std::vector<Bitset> t_basis = compute_basis(t_matrix, p, num_blocks);\n    \n    // The transformation from s to t is possible if and only if their block spans are the same.\n    // This is checked by comparing their canonical bases.\n    return s_basis == t_basis;\n}\n\nint main() {\n    // Use fast I/O operations.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        // Solve each test case and print the result (\"Yes\" or \"No\").\n        if (solve()) {\n            std::cout << \"Yes\\n\";\n        } else {\n            std::cout << \"No\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2097a",
      "PROBLEM_ID": "2097A",
      "PROBLEM_STATEMENT": "The boarding process for various flights can occur in different ways: either by bus or through a telescopic jet bridge. Every day, exactly one flight is made from St. Petersburg to Minsk, and Vadim decided to demonstrate to the students that he always knows in advance how the boarding will take place.\n\nVadim made a bet with $n$ students, and with the $i$-th student, he made a bet on day $a_i$. Vadim wins the bet if he correctly predicts the boarding process on both day $a_i+1$ and day $a_i+2$.\n\nAlthough Vadim does not know in advance how the boarding will occur, he really wants to win the bet at least with one student and convince him of his predictive abilities. Check if there exists a strategy for Vadim that allows him to guarantee success.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$)\u00a0\u2014 the number of students Vadim made bets with.\n\nThe second line of each test case contains $n$ integers $a_1, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the days on which Vadim made bets with the students.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output \"Yes\" (without quotes) if Vadim can guarantee convincing at least one student, and \"No\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4\n\n1 1 1 1\n\n3\n\n2 2 2\n\n5\n\n2 4 3 2 4\n\n8\n\n6 3 1 1 5 1 2 6\n\n1\n\n1000000000\n\n```\n\n#### Output #1\n\n```\nYes\nNo\nYes\nNo\nNo\n```\n\n### Note\n\nIn the first test case, Vadim needs to make at least one correct prediction about the boarding process on the second and third days. There are a total of $4$ possible boarding scenarios for these days, so Vadim can give all $4$ students different predictions and guarantee that at least one of them will be correct.\n\nIn the second test case, Vadim only made bets with three students and cannot guarantee that he will provide at least one of them with a correct prediction.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \n// We represent a 2x2 boolean matrix as an int (0..15):\n// bit0: (0,0), bit1: (0,1), bit2: (1,0), bit3: (1,1)\n// Boolean product: (A\u25e6B)[i][j] = OR over k of (A[i,k] and B[k,j])\n \n// compMat[A][B] will store the Boolean product of matrices A and B.\nint compMat[16][16];\n \n// Precompute the Boolean composition for all matrices 0..15.\nvoid precomputeComp() {\n    for(int A = 0; A < 16; A++){\n        for(int B = 0; B < 16; B++){\n            int C = 0;\n            for(int i = 0; i < 2; i++){\n                for(int j = 0; j < 2; j++){\n                    bool entry = false;\n                    for(int k = 0; k < 2; k++){\n                        bool aik = (A & (1 << (2*i + k))) != 0;\n                        bool bkj = (B & (1 << (2*k + j))) != 0;\n                        if(aik && bkj) { entry = true; break; }\n                    }\n                    if(entry) C |= (1 << (2*i + j));\n                }\n            }\n            compMat[A][B] = C;\n        }\n    }\n}\n \n// We now \u201csimulate\u201d the situation of one window.\n// For a bet group with frequency f, Vadim can assign distinct predictions covering f outcomes.\n// Then the airline\u2019s allowed set on those two days is the complement \u2013 a 2x2 matrix with exactly (4 - f) ones.\n// (If f>=4 then he can cover all four and win immediately.)\n \n// We pre\u2010store, for f in {1,2,3}, all possible matrices (as bitmasks) with exactly (4 \u2013 f) ones.\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    precomputeComp();\n \n    // allowedFor[f] for f in {1,2,3}\n    // f = number of bets on that window, so allowed transitions count = 4 - f.\n    vector<int> allowedFor[4]; // we'll use indices 1,2,3.\n    // f=1 -> allowed matrix must have 3 ones.\n    for(int mask = 0; mask < 16; mask++){\n        if(__builtin_popcount(mask) == 3)\n            allowedFor[1].push_back(mask);\n    }\n    // f=2 -> allowed matrix: 4 - 2 = 2 ones.\n    for(int mask = 0; mask < 16; mask++){\n        if(__builtin_popcount(mask) == 2)\n            allowedFor[2].push_back(mask);\n    }\n    // f=3 -> allowed matrix: 4 - 3 = 1 one.\n    for(int mask = 0; mask < 16; mask++){\n        if(__builtin_popcount(mask) == 1)\n            allowedFor[3].push_back(mask);\n    }\n \n    int t; \n    cin >> t;\n    while(t--){\n        int n; \n        cin >> n;\n        vector<long long> a(n);\n        for (int i = 0; i < n; i++){\n            cin >> a[i];\n        }\n \n        // For each bet made on day a,\n        // the \u201cwindow\u201d (the two consecutive days on which his prediction matters)\n        // is associated with day d = a + 1.\n        unordered_map<long long,int> freq;\n        for (int i = 0; i < n; i++){\n            long long d = a[i] + 1;\n            freq[d]++;\n        }\n \n        bool canWin = false;\n        // Step1: if any window has frequency >= 4, Vadim can simply give all 4 distinct predictions.\n        for (auto &p : freq){\n            if(p.second >= 4){\n                canWin = true;\n                break;\n            }\n        }\n \n        if(canWin){\n            cout << \"Yes\\n\";\n            continue;\n        }\n \n        // Now consider only windows with frequency in {1,2,3}.\n        // We now look at windows (days d) that appear in bets and group them by contiguity.\n        vector<long long> days;\n        for(auto &p : freq)\n            days.push_back(p.first);\n        sort(days.begin(), days.end());\n \n        // We now iterate over contiguous blocks (where consecutive d differ by 1).\n        bool foundBlock = false;\n        for (int i = 0; i < (int)days.size(); ){\n            int j = i;\n            vector<int> block; // block holds freq values for consecutive windows.\n            block.push_back(freq[days[i]]);\n            j = i + 1;\n            while(j < days.size() && days[j] == days[j-1] + 1){\n                block.push_back(freq[days[j]]);\n                j++;\n            }\n            // A single window (block of length 1) does not \u201cforce\u201d the airline \n            // since the allowed matrix will be nonempty.\n            if(block.size() >= 2){\n                // We now simulate the chain. The idea: we \u201cchoose\u201d for each window \n                // one allowed matrix (from allowedFor[f]) so that when composed (using Boolean matrix product)\n                // starting from the identity matrix I we eventually \u201ckill\u201d all possibilities.\n                // Here the identity matrix is I = { (0,0) and (1,1) } \u2192 (bitmask = 1 + 8 = 9).\n                vector<bool> dp(16, false), nextDP(16, false);\n                dp[9] = true; // start\n                for (int k = 0; k < block.size(); k++){\n                    int fVal = block[k]; // fVal \u2208 {1,2,3}\n                    fill(nextDP.begin(), nextDP.end(), false);\n                    for (int state = 0; state < 16; state++){\n                        if(dp[state]){\n                            for (int m : allowedFor[fVal]){\n                                int ns = compMat[state][m];\n                                nextDP[ns] = true;\n                            }\n                        }\n                    }\n                    dp = nextDP;\n                }\n                // If it is possible to force the composed matrix to 0 then regardless how outcomes come out,\n                // some window\u2019s prediction will be correct.\n                if(dp[0]){\n                    foundBlock = true;\n                    break;\n                }\n            }\n            i = j;\n        }\n \n        cout << (foundBlock ? \"Yes\" : \"No\") << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2096h",
      "PROBLEM_ID": "2096H",
      "PROBLEM_STATEMENT": "You are the proud... never mind, just solve this problem.\n\nThere are $n$ intervals $[l_1, r_1], [l_2, r_2], \\ldots [l_n, r_n]$. For each $x$ from $0$ to $2^m - 1$, find the number, modulo $998\\,244\\,353$, of sequences $a_1, a_2, \\ldots a_n$ such that:\n\n- $l_i \\leq a_i \\leq r_i$ for all $i$ from $1$ to $n$;\n- $a_1 \\oplus a_2 \\oplus \\ldots \\oplus a_n = x$, where $\\oplus$ denotes the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line contains two integers $n$ and $m$ ($1 \\leq n \\leq 2 \\cdot 10^5$, $1 \\leq m \\leq 18$).\n\nThe $i$-th of the next $n$ lines contains two integers $l_i$ and $r_i$ ($0 \\leq l_i \\leq r_i < 2^m$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$, and the sum of $2^m$ over all test cases does not exceed $2^{18}$.\n\n### Output\n\nFor each $x$ from $0$ to $2^m - 1$, let:\n\n- $f_x$ be the number of valid sequences, modulo $998\\,244\\,353$;\n- $g_x = f_x \\cdot 2^x \\mod 998\\,244\\,353$.\n\nHere, $f_x$ and $g_x$ are both integers in the interval $[0, 998\\,244\\,352]$.\n\nLet $h = g_0 \\oplus g_1 \\oplus \\ldots \\oplus g_{2^m - 1}$.\n\nOutput a single integer\u00a0\u2014 the value of $h$ itself. Do not perform a modulo operation.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 2\n\n0 2\n\n1 3\n\n5 3\n\n3 7\n\n1 3\n\n0 2\n\n1 5\n\n3 6\n\n10 14\n\n314 1592\n\n653 5897\n\n932 3846\n\n264 3383\n\n279 5028\n\n841 9716\n\n939 9375\n\n105 8209\n\n749 4459\n\n230 7816\n\n1 5\n\n0 29\n\n```\n\n#### Output #1\n\n```\n22\n9812\n75032210\n1073741823\n```\n\n### Note\n\nFor the first test case, the values of $f_x$ are as follows:\n\n- $f_0 = 2$, because there are $2$ valid sequences: $[1, 1]$ and $[2, 2]$;\n- $f_1 = 2$, because there are $2$ valid sequences: $[0, 1]$ and $[2, 3]$;\n- $f_2 = 2$, because there are $2$ valid sequences: $[0, 2]$ and $[1, 3]$;\n- $f_3 = 3$, because there are $3$ valid sequences: $[0, 3]$, $[1, 2]$, and $[2, 1]$.\n\nThe values of $g_x$ are as follows:\n\n- $g_0 = f_0 \\cdot 2^0 = 2 \\cdot 2^0 = 2$;\n- $g_1 = f_1 \\cdot 2^1 = 2 \\cdot 2^1 = 4$;\n- $g_2 = f_2 \\cdot 2^2 = 2 \\cdot 2^2 = 8$;\n- $g_3 = f_3 \\cdot 2^3 = 3 \\cdot 2^3 = 24$.\n\nThus, the value to output is $2 \\oplus 4 \\oplus 8 \\oplus 24 = 22$.\n\nFor the second test case, the values of $f_x$ are as follows:\n\n- $f_{0} = 120$;\n- $f_{1} = 120$;\n- $f_{2} = 119$;\n- $f_{3} = 118$;\n- $f_{4} = 105$;\n- $f_{5} = 105$;\n- $f_{6} = 106$;\n- $f_{7} = 107$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\nconst int inv2=(mod+1)/2;\nint md(int x){return x>=mod?x-mod:x;}\nconst int N=(1<<18)|3;\nstruct node{int a,b;}B[N];\nnode make(int _a,int _b){return node{_a,_b};}\nnode operator * (node A,node B){\n\treturn make((1ll*A.a*B.a+1ll*A.b*B.b)%mod,(1ll*A.a*B.b+1ll*A.b*B.a)%mod);\n}\nint n,m,L[N],R[N],F[N],ss[N];\nvoid calc(int &u,int &v,int p,int r){\n\tint c=r>>(p+1);\n\tu=ss[r],v=c;\n\tif(c>0) u=md(u-ss[(c<<(p+1))-1]+mod);\n}\nvoid solve(){\n\tscanf(\"%d%d\",&n,&m);\n\tF[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&L[i],&R[i]);\n\t\tF[0]=1ll*F[0]*(R[i]-L[i]+1)%mod;\n\t}\n\tfor(int p=m-1;p>=0;p--){\n\t\tint k=m-p-1;\n\t\tfor(int i=0;i<(1<<k);i++) B[i]=make(1,0);\n\t\tfor(int i=0;i<(1<<m);i++) ss[i]=((i>>p)&1)?mod-1:1;\n\t\tfor(int i=1;i<(1<<m);i++) ss[i]=md(ss[i-1]+ss[i]);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint a,b=0,c,d=0;\n\t\t\tcalc(a,c,p,R[i]);\n\t\t\tif(L[i]>0){\n\t\t\t\tcalc(b,d,p,L[i]-1);\n\t\t\t\tb=mod-b;\n\t\t\t}\n\t\t\td^=c;\n\t\t\tB[d]=B[d]*make(a,b);\n\t\t\tswap(B[c].a,B[c].b);\n\t\t}\n\t\tfor(int i=0;i<k;i++){\n\t\t\tfor(int s=0;s<(1<<k);s++)\n\t\t\t\tif((s>>i)&1){\n\t\t\t\t\tint t=s-(1<<i);\n\t\t\t\t\tnode nt=B[t],ns=B[s];\n\t\t\t\t\tB[t]=nt*ns;\n\t\t\t\t\tns.b=mod-ns.b;\n\t\t\t\t\tB[s]=nt*ns;\n\t\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<k);i++)\n\t\t\tF[(i<<(p+1))+(1<<p)]=md(B[i].a+B[i].b);\n\t}\n\tfor(int i=0;i<m;i++)\n\t\tfor(int s=0;s<(1<<m);s++){\n\t\t\tif((s>>i)&1){\n\t\t\t\tint t=s-(1<<i);\n\t\t\t\tint wt=F[t],ws=F[s];\n\t\t\t\tF[t]=1ll*(wt+ws)*inv2%mod;\n\t\t\t\tF[s]=1ll*(wt-ws+mod)*inv2%mod;\n\t\t\t}\n\t\t}\n\tint ans=0;\n\tfor(int i=0,pw=1;i<(1<<m);i++,pw=md(pw*2)) ans^=(1ll*F[i]*pw%mod);\n\tprintf(\"%d\\n\",ans); \n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2096g",
      "PROBLEM_ID": "2096G",
      "PROBLEM_STATEMENT": "This is an interactive problem.\n\nYou are a proud teacher at the Millennium Science School. Today, a student named Alice challenges you to a guessing game.\n\nAlice is thinking of an integer from $1$ to $n$, and you must guess it by asking her some queries.\n\nTo make things harder, she says you must ask all the queries first, and she will ignore exactly $1$ query.\n\nFor each query, you choose an array of $k$ distinct integers from $1$ to $n$, where $k$ is even. Then, Alice will respond with one of the following:\n\n- $\\texttt{L}$: the number is one of the first $\\frac{k}{2}$ elements of the array;\n- $\\texttt{R}$: the number is one of the last $\\frac{k}{2}$ elements of the array;\n- $\\texttt{N}$: the number is not in the array;\n- $\\texttt{?}$: this query is ignored.\n\nAlice is impatient, so you must find a strategy that minimizes the number of queries. Can you do it?\n\nFormally, let $f(n)$ be the minimum number of queries required to determine Alice's number. Then you must find a strategy that uses exactly $f(n)$ queries.\n\nNote that the interactor is adaptive, which means Alice's number is not fixed at the beginning and may depend on your queries. However, it is guaranteed that there exists at least one number that is consistent with Alice's responses.\n\nWe can show that $f(n) \\leq 20$ for all $n$ such that $2 \\le n \\le 2 \\cdot 10^5$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the maximum possible value of Alice's number.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Interaction\n\nThe interaction begins by reading the integer $n$.\n\nThen, output a single integer $q$ ($1 \\leq q \\leq 20$)\u00a0\u2014 the number of queries.\n\nTo ask a query, output a line in the following format:\n\n- $k\\,a_1\\,a_2 \\ldots a_k$ ($2 \\leq k \\leq n$, $k$ is even, $1 \\leq a_i \\leq n$, the $a_i$ are distinct)\u00a0\u2014 the length of the array, and the array itself.\n\nOnce you've asked all $q$ queries, read a string $s$ ($|s| = q$)\u00a0\u2014 the responses to the queries as described above.\n\nWhen you know Alice's number, output a single integer $x$ ($1 \\leq x \\leq n$)\u00a0\u2014 the value of the number.\n\nThen, move on to the next test case, or terminate the program if there are no more test cases.\n\nAfter outputting all $q$ queries, do not forget to output the end of the line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\n\n- fflush(stdout) or cout.flush() in C++;\n- System.out.flush() in Java;\n- flush(output) in Pascal;\n- stdout.flush() in Python;\n- See the documentation for other languages.\n\nNote that even if you correctly determine Alice's number but use more than $f(n)$ queries, you will get Wrong answer.\n\nFor this problem, hacks are disabled.\n\n### Example\n\n#### Input #1\n\n```\n2\n3\n\n?N\n\n5\n\nR?L\n\n```\n\n#### Output #1\n\n```\n\n2\n2 1 2\n2 1 2\n\n3\n\n3\n4 3 2 4 1\n4 5 4 3 1\n4 1 5 3 4\n\n1\n```\n\n### Note\n\nIn the first test case, $n = 3$. We ask $2$ queries: $[1, 2]$, and $[1, 2]$ again.\n\n- For the first query, Alice's response is $\\texttt{?}$, which means this query is ignored.\n- For the second query, Alice's response is $\\texttt{N}$, which means her number is not in the array $[1, 2]$.\n\nFrom the information above, we can determine that Alice's number is $3$.\n\nIt can be shown that all valid strategies for $n = 3$ require at least $2$ queries.\n\nIn the second test case, $n = 5$. We ask $3$ queries: $[3, 2, 4, 1]$, $[5, 4, 3, 1]$, and $[1, 5, 3, 4]$.\n\n- For the first query, Alice's response is $\\texttt{R}$, which means her number is in the array $[4, 1]$.\n- For the second query, Alice's response is $\\texttt{?}$, which means this query is ignored.\n- For the third query, Alice's response is $\\texttt{L}$, which means her number is in the array $[1, 5]$.\n\nFrom the information above, we can determine that Alice's number is $1$.\n\nIt can be shown that all valid strategies for $n = 5$ require at least $3$ queries.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=200005;\nint N,Len,M;\nint A[15][maxn],F[maxn];\nchar S[15];\nvoid ins(int x){\n\tM++;F[M]=x;int t=0;\n\tfor(int i=Len-1;i>=1;i--) A[i][M]=x%3,x/=3,t+=A[i][M]-1;\n\tt=(4-t%3)%3;A[Len][M]=t;\n}\nvoid solve(){\n\tscanf(\"%d\",&N);Len=1;M=0;\n\tint ret=1;while(ret<N) ret*=3,Len++;\n\tfor(int i=0;i<N/2;i++) ins(i),ins(ret-i-1);\n\tif(N&1) ins(ret>>1);\n\tprintf(\"%d\\n\",Len);\n\tfor(int i=1;i<=Len;i++){\n\t\tint ret=0;\n\t\tfor(int j=1;j<=N;j++) ret+=(A[i][j]!=1);\n\t\tprintf(\"%d \",ret);\n\t\tfor(int j=1;j<=N;j++) if(A[i][j]==0) printf(\"%d \",j);\n\t\tfor(int j=1;j<=N;j++) if(A[i][j]==2) printf(\"%d \",j);\n\t\tputs(\"\");\n\t}\n\tfflush(stdout);\n\tscanf(\"%s\",S+1);\n\tret=0;int t=0;\n\tfor(int i=1;i<=Len;i++) if(S[i]=='L') t--;else if(S[i]=='R') t++;\n\tt=(4-t%3)%3;\n\tfor(int i=1;i<Len;i++){\n\t\tif(S[i]=='?'){\n\t\t\tif(t==0) S[i]='L';\n\t\t\tif(t==1) S[i]='N';\n\t\t\tif(t==2) S[i]='R';\n\t\t}\n\t\tret=ret*3;\n\t\tif(S[i]=='N') ret+=1;\n\t\tif(S[i]=='R') ret+=2;\n\t}\n\tfor(int i=1;i<=N;i++) if(ret==F[i]) {printf(\"%d\\n\",i);break;}\n\tfflush(stdout);\n}\nint main(){\n\tint T;scanf(\"%d\",&T);while(T--) solve();\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2096e",
      "PROBLEM_ID": "2096E",
      "PROBLEM_STATEMENT": "You are the proud owner of $n$ teddy bears, which are arranged in a row on a shelf. Each teddy bear is colored either black or pink.\n\nAn arrangement of teddy bears is beautiful if all the black teddy bears are to the left of all the pink teddy bears. In other words, there does not exist a pair of indices $(i, j)$ ($1 \\leq i < j \\leq n$) such that the $i$-th teddy bear is pink, and the $j$-th teddy bear is black.\n\nYou want to reorder the teddy bears into a beautiful arrangement. You are too short to reach the shelf, but luckily, you can send instructions to a robot to move the teddy bears around. In a single instruction, the robot can:\n\n- Choose an index $i$ ($1 \\le i \\le n - 2$) and reorder the teddy bears at positions $i$, $i + 1$ and $i + 2$ so that all the black teddy bears are to the left of all the pink teddy bears.\n\nWhat is the minimum number of instructions needed to reorder the teddy bears?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of teddy bears.\n\nThe second line of each test case contains a single string $s$ of length $n$ consisting of characters B and P\u00a0\u2014 the colors of the teddy bears. For each $i$ from $1$ to $n$, the $i$-th teddy bear is colored black if $s_i = \\texttt{B}$ and pink if $s_i = \\texttt{P}$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of instructions needed to reorder the teddy bears.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3\n\nPPP\n\n3\n\nBPP\n\n3\n\nPPB\n\n7\n\nPPBPPBB\n\n15\n\nBPBPBBBBBPBBBBB\n\n```\n\n#### Output #1\n\n```\n0\n0\n1\n5\n14\n```\n\n### Note\n\nFor the first test case, all the teddy bears are pink. Thus, the arrangement is already beautiful, so the answer is $0$.\n\nFor the second test case, all the black teddy bears are to the left of all the pink teddy bears. Thus, the answer is $0$.\n\nFor the third test case, we can perform $1$ instruction with $i = 1$.\n\nAfter the instruction, the sequence of colors changes from $\\texttt{PPB}$ to $\\texttt{BPP}$, and we are done.\n\nFor the fourth test case, we can perform $5$ instructions as follows:\n\n- $i = 1$: $\\texttt{}\\color{magenta}{\\texttt{PPB}}\\texttt{PPBB} \\rightarrow \\texttt{}\\color{magenta}{\\texttt{BPP}}\\texttt{PPBB}$\n- $i = 5$: $\\texttt{BPPP}\\color{magenta}{\\texttt{PBB}}\\texttt{} \\rightarrow \\texttt{BPPP}\\color{magenta}{\\texttt{BBP}}\\texttt{}$\n- $i = 4$: $\\texttt{BPP}\\color{magenta}{\\texttt{PBB}}\\texttt{P} \\rightarrow \\texttt{BPP}\\color{magenta}{\\texttt{BBP}}\\texttt{P}$\n- $i = 3$: $\\texttt{BP}\\color{magenta}{\\texttt{PBB}}\\texttt{PP} \\rightarrow \\texttt{BP}\\color{magenta}{\\texttt{BBP}}\\texttt{PP}$\n- $i = 2$: $\\texttt{B}\\color{magenta}{\\texttt{PBB}}\\texttt{PPP} \\rightarrow \\texttt{B}\\color{magenta}{\\texttt{BBP}}\\texttt{PPP}$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        // Count total blacks ('B')\n        int k = 0;\n        for (char c : s) {\n            if (c == 'B') ++k;\n        }\n        // We'll collect mismatches: P's in [1..k], B's in [k+1..n]\n        ll sumP = 0, sumB = 0;\n        ll cntP_even = 0, cntB_even = 0;\n        int cntP = 0, cntB = 0;\n        for (int i = 0; i < n; i++) {\n            int pos = i + 1;\n            if (pos <= k) {\n                // should be 'B'\n                if (s[i] == 'P') {\n                    sumP += pos;\n                    ++cntP;\n                    if ((pos & 1) == 0) ++cntP_even;\n                }\n            } else {\n                // pos > k, should be 'P'\n                if (s[i] == 'B') {\n                    sumB += pos;\n                    ++cntB;\n                    if ((pos & 1) == 0) ++cntB_even;\n                }\n            }\n        }\n        // They must match in count\n        // cntP == cntB  always holds\n        ll diff_even = llabs(cntP_even - cntB_even);\n        ll total_dist = sumB - sumP;\n        // Minimum operations:\n        ll ans = (total_dist + diff_even) / 2;\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2096d",
      "PROBLEM_ID": "2096D",
      "PROBLEM_STATEMENT": "You are the proud owner of an infinitely large grid of lightbulbs, represented by a [Cartesian coordinate system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system). Initially, all of the lightbulbs are turned off, except for one lightbulb, where you buried your proudest treasure.\n\nIn order to hide your treasure's position, you perform the following operation an arbitrary number of times (possibly zero):\n\n- Choose two integer numbers $x$ and $y$, and switch the state of the $4$ lightbulbs at $(x, y)$, $(x, y + 1)$, $(x + 1, y - 1)$, and $(x + 1, y)$. In other words, for each lightbulb, turn it on if it was off, and turn it off if it was on. Note that there are no constraints on $x$ and $y$.\n\nIn the end, there are $n$ lightbulbs turned on at coordinates $(x_1, y_1), (x_2, y_2), \\ldots, (x_n, y_n)$. Unfortunately, you have already forgotten where you buried your treasure, so now you have to figure out one possible position of the treasure. Good luck!\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of lightbulbs that are on.\n\nThe $i$-th of the next $n$ lines contains two integers $x_i$ and $y_i$ ($\\color{red}{-10^8} \\le x_i, y_i \\le \\color{red}{10^8}$)\u00a0\u2014 the coordinates of the $i$-th lightbulb. It is guaranteed that all coordinates are distinct.\n\nAdditional constraint: There exists at least one position $(s, t)$ ($\\color{red}{-10^9} \\le s, t \\le \\color{red}{10^9}$), such that if the lightbulb at position $(s, t)$ is initially turned on, then after performing an arbitrary number of operations (possibly zero), we will get the given configuration of lightbulbs.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output two integers $s$ and $t$ ($-10^9 \\le s, t \\le 10^9$)\u00a0\u2014 one possible position of the buried treasure. If there are multiple solutions, print any of them.\n\nFor this problem, hacks are disabled.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n2 3\n\n3\n\n-2 -1\n\n-1 -2\n\n-1 -3\n\n7\n\n7 26\n\n6 27\n\n6 28\n\n7 27\n\n8 26\n\n8 27\n\n7 28\n\n11\n\n70 9\n\n69 8\n\n69 0\n\n73 5\n\n70 -1\n\n70 5\n\n71 7\n\n70 4\n\n73 4\n\n71 3\n\n72 3\n\n```\n\n#### Output #1\n\n```\n2 3\n-2 -2\n7 27\n72 7\n```\n\n### Note\n\nFor the first test case, one possible scenario is that you hid your treasure at position $(2, 3)$. Then, you did not perform any operations.\n\nIn the end, only the lightbulb at $(2, 3)$ is turned on.\n\nFor the second test case, one possible scenario is that you hid your treasure at position $(-2, -2)$. Then, you performed $1$ operation with $x = -2$, $y = -2$.\n\nThe operation switches the state of the $4$ lightbulbs at $(-2, -2)$, $(-2, -1)$, $(-1, -3)$, and $(-1, -2)$.\n\nIn the end, the lightbulbs at $(-2, -1)$, $(-1, -2)$, and $(-1, -3)$ are turned on.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <map>\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        std::map<int, int> x_counts;\n        std::map<int, int> sum_counts;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            std::cin >> x >> y;\n            x_counts[x]++;\n            sum_counts[x + y]++;\n        }\n\n        int s = 0;\n        for (auto const& [val, count] : x_counts) {\n            if (count % 2 != 0) {\n                s = val;\n                break;\n            }\n        }\n\n        int sum_s_t = 0;\n        for (auto const& [val, count] : sum_counts) {\n            if (count % 2 != 0) {\n                sum_s_t = val;\n                break;\n            }\n        }\n\n        int t_val = sum_s_t - s;\n        std::cout << s << \" \" << t_val << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2096c",
      "PROBLEM_ID": "2096C",
      "PROBLEM_STATEMENT": "You are the proud leader of a city in Ancient Berland. There are $n^2$ buildings arranged in a grid of $n$ rows and $n$ columns. The height of the building in row $i$ and column $j$ is $h_{i, j}$.\n\nThe city is beautiful if no two adjacent by side buildings have the same height. In other words, it must satisfy the following:\n\n- There does not exist a position $(i, j)$ ($1 \\leq i \\leq n$, $1 \\leq j \\leq n - 1$) such that $h_{i, j} = h_{i, j + 1}$.\n- There does not exist a position $(i, j)$ ($1 \\leq i \\leq n - 1$, $1 \\leq j \\leq n$) such that $h_{i, j} = h_{i + 1, j}$.\n\nThere are $n$ workers at company A, and $n$ workers at company B. Each worker can be hired at most once.\n\nIt costs $a_i$ coins to hire worker $i$ at company A. After hiring, worker $i$ will:\n\n- Increase the heights of all buildings in row $i$ by $1$. In other words, increase $h_{i, 1}, h_{i, 2}, \\ldots, h_{i, n}$ by $1$.\n\nIt costs $b_j$ coins to hire worker $j$ at company B. After hiring, worker $j$ will:\n\n- Increase the heights of all buildings in column $j$ by $1$. In other words, increase $h_{1, j}, h_{2, j}, \\ldots, h_{n, j}$ by $1$.\n\nFind the minimum number of coins needed to make the city beautiful, or report that it is impossible.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 1000$)\u00a0\u2014 the size of the grid.\n\nThe $i$-th of the next $n$ lines of each test case contains $n$ integers $h_{i, 1}, h_{i, 2}, \\ldots, h_{i, n}$ ($1 \\le h_{i, j} \\le 10^9$)\u00a0\u2014 the heights of the buildings in row $i$.\n\nThe next line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the costs of hiring the workers at company A.\n\nThe next line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_j \\le 10^9$)\u00a0\u2014 the costs of hiring the workers at company B.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $1000$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of coins needed, or $-1$ if it is impossible.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n1 2\n\n2 1\n\n100 100\n\n100 100\n\n4\n\n1 2 1 2\n\n3 2 1 2\n\n1 2 1 1\n\n1 3 1 2\n\n1 2 3 4\n\n5 6 7 8\n\n3\n\n1 2 2\n\n2 2 1\n\n2 1 1\n\n100 100 100\n\n100 100 100\n\n6\n\n8 7 2 8 4 8\n\n7 7 9 7 1 1\n\n8 3 1 1 8 5\n\n6 8 3 1 1 4\n\n1 4 5 1 9 6\n\n7 1 1 6 8 2\n\n11 23 20 79 30 15\n\n15 83 73 57 34 63\n\n```\n\n#### Output #1\n\n```\n0\n14\n-1\n183\n```\n\n### Note\n\nFor the first test case, we can see that the city is already beautiful. Thus, the answer is $0$.\n\nFor the second test case, we can hire worker $2$ from company A, worker $4$ from company A, and worker $4$ from company B:\n\n$1\n\n$$2$$\n\n1\n\n$$\\color{red}2$$\n\nimplies\n\n$$1$$\n\n2\n\n$$1$$\n\ncolor{red}3\n\n$$\\color{red}3$$\n\ncolor{red}2\n\n$$\\color{red}1$$\n\ncolor{red}2\n\n$$\\color{red}4$$\n\ncolor{red}3\n\n$$\\color{red}2$$\n\ncolor{red}4\n\n$$1$$\n\n2\n\n$$1$$\n\ncolor{red}1\n\n$$1$$\n\n2\n\n$$1$$\n\ncolor{red}2\n\n$$\\color{red}1$$\n\ncolor{red}3\n\n$$\\color{red}1$$\n\ncolor{red}2\n\n$$\\color{red}2$$\n\ncolor{red}4\n\n$$\\color{red}2$$\n\ncolor{red}4$\n\nThe cost of hiring the workers is $2 + 4 + 8 = 14$. This is the minimum possible cost.\n\nFor the third test case, no matter what we do, it is impossible to make the city beautiful. Thus, the answer is $-1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nconst long long INF = 4e18; // Use a large value for infinity, larger than max possible cost\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<vector<int>> h(n, vector<int>(n));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> h[i][j];\n            }\n        }\n        vector<long long> a(n), b(n);\n        for (int i = 0; i < n; ++i) cin >> a[i];\n        for (int j = 0; j < n; ++j) cin >> b[j];\n\n        bool possible = true;\n\n        // DP for y variables (horizontal constraints). dpy[j][s] min cost for y[0...j] with y[j]=s\n        vector<vector<long long>> dpy(n, vector<long long>(2, INF));\n        dpy[0][0] = 0;\n        dpy[0][1] = b[0];\n\n        for (int j = 0; j < n - 1; ++j) {\n            set<int> forbidden_diff;\n            for (int i = 0; i < n; ++i) {\n                int diff = h[i][j+1] - h[i][j];\n                if (diff == 0) forbidden_diff.insert(0);\n                else if (diff == 1) forbidden_diff.insert(1);\n                else if (diff == -1) forbidden_diff.insert(-1);\n            }\n\n            if (forbidden_diff.count(0) && forbidden_diff.count(1) && forbidden_diff.count(-1)) {\n                possible = false;\n                break;\n            }\n\n            // DP transitions for y[j+1] from y[j]. Diff is y[j] - y[j+1].\n            // y[j]=0 -> y[j+1]=0. Diff = 0. Allowed if 0 not forbidden.\n            if (dpy[j][0] != INF && forbidden_diff.find(0) == forbidden_diff.end()) {\n                dpy[j+1][0] = min(dpy[j+1][0], dpy[j][0]);\n            }\n            // y[j]=1 -> y[j+1]=0. Diff = 1. Allowed if 1 not forbidden.\n            if (dpy[j][1] != INF && forbidden_diff.find(1) == forbidden_diff.end()) {\n                dpy[j+1][0] = min(dpy[j+1][0], dpy[j][1]);\n            }\n            // y[j]=0 -> y[j+1]=1. Diff = -1. Allowed if -1 not forbidden.\n            if (dpy[j][0] != INF && forbidden_diff.find(-1) == forbidden_diff.end()) {\n                dpy[j+1][1] = min(dpy[j+1][1], dpy[j][0] + b[j+1]);\n            }\n            // y[j]=1 -> y[j+1]=1. Diff = 0. Allowed if 0 not forbidden.\n            if (dpy[j][1] != INF && forbidden_diff.find(0) == forbidden_diff.end()) {\n                dpy[j+1][1] = min(dpy[j+1][1], dpy[j][1] + b[j+1]);\n            }\n        }\n\n        long long min_y_cost = min(dpy[n-1][0], dpy[n-1][1]);\n        if (min_y_cost == INF) possible = false;\n\n        if (!possible) {\n            cout << -1 << \"\\n\";\n            continue;\n        }\n\n        // DP for x variables (vertical constraints). dpx[i][s] min cost for x[0...i] with x[i]=s\n        vector<vector<long long>> dpx(n, vector<long long>(2, INF));\n        dpx[0][0] = 0;\n        dpx[0][1] = a[0];\n\n        for (int i = 0; i < n - 1; ++i) {\n            set<int> forbidden_diff_prime;\n            for (int j = 0; j < n; ++j) {\n                int diff = h[i+1][j] - h[i][j];\n                 if (diff == 0) forbidden_diff_prime.insert(0);\n                else if (diff == 1) forbidden_diff_prime.insert(1);\n                else if (diff == -1) forbidden_diff_prime.insert(-1);\n            }\n\n            if (forbidden_diff_prime.count(0) && forbidden_diff_prime.count(1) && forbidden_diff_prime.count(-1)) {\n                possible = false;\n                break;\n            }\n\n            // DP transitions for x[i+1] from x[i]. Diff is x[i] - x[i+1].\n            // x[i]=0 -> x[i+1]=0. Diff = 0. Allowed if 0 not forbidden.\n            if (dpx[i][0] != INF && forbidden_diff_prime.find(0) == forbidden_diff_prime.end()) {\n                dpx[i+1][0] = min(dpx[i+1][0], dpx[i][0]);\n            }\n            // x[i]=1 -> x[i+1]=0. Diff = 1. Allowed if 1 not forbidden.\n            if (dpx[i][1] != INF && forbidden_diff_prime.find(1) == forbidden_diff_prime.end()) {\n                dpx[i+1][0] = min(dpx[i+1][0], dpx[i][1]);\n            }\n            // x[i]=0 -> x[i+1]=1. Diff = -1. Allowed if -1 not forbidden.\n            if (dpx[i][0] != INF && forbidden_diff_prime.find(-1) == forbidden_diff_prime.end()) {\n                dpx[i+1][1] = min(dpx[i+1][1], dpx[i][0] + a[i+1]);\n            }\n            // x[i]=1 -> x[i+1]=1. Diff = 0. Allowed if 0 not forbidden.\n            if (dpx[i][1] != INF && forbidden_diff_prime.find(0) == forbidden_diff_prime.end()) {\n                dpx[i+1][1] = min(dpx[i+1][1], dpx[i][1] + a[i+1]);\n            }\n        }\n\n        long long min_x_cost = min(dpx[n-1][0], dpx[n-1][1]);\n        if (min_x_cost == INF) possible = false;\n\n        if (!possible) {\n            cout << -1 << \"\\n\";\n        } else {\n            cout << min_x_cost + min_y_cost << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2096b",
      "PROBLEM_ID": "2096B",
      "PROBLEM_STATEMENT": "You are the proud owner of many colorful gloves, and you keep them in a drawer. Each glove is in one of $n$ colors numbered $1$ to $n$. Specifically, for each $i$ from $1$ to $n$, you have $l_i$ left gloves and $r_i$ right gloves with color $i$.\n\nUnfortunately, it's late at night, so you can't see any of your gloves. In other words, you will only know the color and the type (left or right) of a glove after you take it out of the drawer.\n\nA matching pair of gloves with color $i$ consists of exactly one left glove and one right glove with color $i$. Find the minimum number of gloves you need to take out of the drawer to guarantee that you have at least $k$ matching pairs of gloves with different colors.\n\nFormally, find the smallest positive integer $x$ such that:\n\n- For any set of $x$ gloves you take out of the drawer, there will always be at least $k$ matching pairs of gloves with different colors.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $k$ ($1 \\leq k \\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the number of different colors, and the minimum number of required matching pairs of gloves.\n\nThe second line of each test case contains $n$ integers $l_1, l_2, \\ldots, l_n$ ($1 \\leq l_i \\leq 10^9$)\u00a0\u2014 the number of left gloves with color $i$ for each $i$ from $1$ to $n$.\n\nThe third line of each test case contains $n$ integers $r_1, r_2, \\ldots, r_n$ ($1 \\leq r_i \\leq 10^9$)\u00a0\u2014 the number of right gloves with color $i$ for each $i$ from $1$ to $n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of gloves you need to take out of the drawer.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3 3\n\n1 1 1\n\n1 1 1\n\n1 1\n\n100\n\n1\n\n3 2\n\n100 1 1\n\n200 1 1\n\n5 2\n\n97 59 50 87 36\n\n95 77 33 13 74\n\n10 6\n\n97 59 50 87 36 95 77 33 13 74\n\n91 14 84 33 54 89 68 34 14 15\n\n```\n\n#### Output #1\n\n```\n6\n101\n303\n481\n1010\n```\n\n### Note\n\nIn the first test case, you must take out all of the gloves, so the answer is $6$.\n\nIn the second test case, the answer is $101$. If you take out $100$ gloves or fewer, then it is possible that all of them are left gloves, which means you won't have a matching pair of gloves.\n\nIn the third test case, the answer is $303$. If you only take out $302$ gloves, then one possible scenario is as follows:\n\n- Color $1$: $100$ left gloves, $200$ right gloves\n- Color $2$: $1$ left glove, $0$ right gloves\n- Color $3$: $0$ left gloves, $1$ right glove\n\nYou only have multiple matching pairs of gloves with color $1$. So you won't have at least $2$ matching pairs of gloves with different colors.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        int n, k;\n        std::cin >> n >> k;\n        \n        std::vector<long long> l(n), r(n);\n        for (int i = 0; i < n; ++i) {\n            std::cin >> l[i];\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            std::cin >> r[i];\n        }\n        \n        std::vector<long long> minLR(n);\n        long long totalGloves = 0;\n        \n        for (int i = 0; i < n; ++i) {\n            minLR[i] = std::min(l[i], r[i]);\n            totalGloves += l[i] + r[i];\n        }\n        \n        std::sort(minLR.begin(), minLR.end());\n        \n        long long sumMin = 0;\n        for (int i = 0; i < n - k + 1; ++i) {\n            sumMin += minLR[i];\n        }\n        \n        std::cout << (totalGloves - sumMin + 1) << std::endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2096a",
      "PROBLEM_ID": "2096A",
      "PROBLEM_STATEMENT": "You are the proud owner of $n$ sticks. Each stick has an integer length from $1$ to $n$. The lengths of the sticks are distinct.\n\nYou want to arrange the sticks in a row. There is a string $s$ of length $n - 1$ that describes the requirements of the arrangement.\n\nSpecifically, for each $i$ from $1$ to $n - 1$:\n\n- If $s_i = \\texttt{<}$, then the length of the stick at position $i + 1$ must be smaller than all sticks before it;\n- If $s_i = \\texttt{>}$, then the length of the stick at position $i + 1$ must be larger than all sticks before it.\n\nFind any valid arrangement of sticks. We can show that an answer always exists.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 100$)\u00a0\u2014 the number of sticks.\n\nThe second line of each test case contains a single string $s$ of length $n - 1$ consisting of characters $\\texttt{<}$ and $\\texttt{>}$\u00a0\u2014 describing the requirements of the arrangement.\n\n### Output\n\nFor each test case, output $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq n$, the $a_i$ are distinct)\u00a0\u2014 the lengths of the sticks in order. If there are multiple solutions, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n<\n\n5\n\n<<><\n\n2\n\n>\n\n3\n\n<>\n\n7\n\n><>>><\n\n```\n\n#### Output #1\n\n```\n2 1\n4 3 2 5 1\n1 2\n2 1 3\n3 4 2 5 6 7 1\n```\n\n### Note\n\nFor the first test case, the requirements of the arrangement are as follows:\n\n- $s_1 = \\texttt{<}$, which means $a_2$ is smaller than $a_1$.\n\nThus, one possible arrangement is $[2, 1]$.\n\nFor the second test case, the requirements of the arrangement are as follows:\n\n- $s_1 = \\texttt{<}$, which means $a_2$ is smaller than $a_1$;\n- $s_2 = \\texttt{<}$, which means $a_3$ is smaller than $a_1$ and $a_2$;\n- $s_3 = \\texttt{>}$, which means $a_4$ is larger than $a_1$, $a_2$, and $a_3$;\n- $s_4 = \\texttt{<}$, which means $a_5$ is smaller than $a_1$, $a_2$, $a_3$, and $a_4$.\n\nThus, one possible arrangement is $[4, 3, 2, 5, 1]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> getValidArrangement(int n, const string& s) {\n    for (int firstStick = 1; firstStick <= n; ++firstStick) {\n        vector<int> arrangement(n);\n        set<int> availableSticks;\n        \n        // Initially, all sticks from 1 to n are available, except the firstStick\n        for (int i = 1; i <= n; ++i) {\n            if (i != firstStick) {\n                availableSticks.insert(i);\n            }\n        }\n        \n        arrangement[0] = firstStick;\n        \n        bool valid = true;\n        int minSoFar = firstStick;\n        int maxSoFar = firstStick;\n        \n        for (int i = 1; i < n; ++i) {\n            if (s[i-1] == '<') {\n                // Find the largest available stick smaller than minSoFar\n                auto it = availableSticks.lower_bound(minSoFar);\n                if (it == availableSticks.begin()) {\n                    valid = false;\n                    break;\n                }\n                --it;\n                arrangement[i] = *it;\n                availableSticks.erase(it);\n                minSoFar = min(minSoFar, arrangement[i]);\n                maxSoFar = max(maxSoFar, arrangement[i]);\n            } else {  // s[i-1] == '>'\n                // Find the smallest available stick larger than maxSoFar\n                auto it = availableSticks.upper_bound(maxSoFar);\n                if (it == availableSticks.end()) {\n                    valid = false;\n                    break;\n                }\n                arrangement[i] = *it;\n                availableSticks.erase(it);\n                minSoFar = min(minSoFar, arrangement[i]);\n                maxSoFar = max(maxSoFar, arrangement[i]);\n            }\n        }\n        \n        if (valid) {\n            return arrangement;\n        }\n    }\n    \n    // This should never happen as the problem guarantees a valid arrangement exists\n    return {};\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        string s;\n        cin >> s;\n        \n        vector<int> arrangement = getValidArrangement(n, s);\n        \n        for (int i = 0; i < n; ++i) {\n            cout << arrangement[i] << (i < n-1 ? \" \" : \"\");\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2094e",
      "PROBLEM_ID": "2094E",
      "PROBLEM_STATEMENT": "Boneca Ambalabu gives you a sequence of $n$ integers $a_1,a_2,\\ldots,a_n$.\n\nOutput the maximum value of $(a_k\\oplus a_1)+(a_k\\oplus a_2)+\\ldots+(a_k\\oplus a_n)$ among all $1 \\leq k \\leq n$. Note that $\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2013 the number of independent test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n\\leq 2\\cdot 10^5$)\u00a0\u2013 the length of the array.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($0 \\leq a_i < 2^{30}$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output the maximum value on a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3\n\n18 18 18\n\n5\n\n1 2 4 8 16\n\n5\n\n8 13 4 5 15\n\n6\n\n625 676 729 784 841 900\n\n1\n\n1\n\n```\n\n#### Output #1\n\n```\n0\n79\n37\n1555\n0\n```\n\n### Note\n\nIn the first test case, the best we can do is $(18\\oplus18)+(18\\oplus18)+(18\\oplus18)=0$.\n\nIn the second test case, we choose $k=5$ to get $(16\\oplus1)+(16\\oplus2)+(16\\oplus4)+(16\\oplus8)+(16\\oplus16)=79$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        \n        // Count the number of elements with each bit set\n        vector<int> bit_count(30, 0);\n        for (int i = 0; i < n; i++) {\n            for (int bit = 0; bit < 30; bit++) {\n                if (a[i] & (1 << bit)) {\n                    bit_count[bit]++;\n                }\n            }\n        }\n        \n        // Calculate the maximum sum\n        long long max_sum = 0;\n        for (int k = 0; k < n; k++) {\n            long long sum = 0;\n            for (int bit = 0; bit < 30; bit++) {\n                int count1 = bit_count[bit];  // Elements with bit set\n                int count0 = n - count1;      // Elements with bit not set\n                \n                if (a[k] & (1 << bit)) {\n                    // If a_k has this bit set, XORing with elements that don't have this bit set results in 1\n                    sum += (1LL * count0 * (1LL << bit));\n                } else {\n                    // If a_k doesn't have this bit set, XORing with elements that have this bit set results in 1\n                    sum += (1LL * count1 * (1LL << bit));\n                }\n            }\n            max_sum = max(max_sum, sum);\n        }\n        \n        cout << max_sum << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2094d",
      "PROBLEM_ID": "2094D",
      "PROBLEM_STATEMENT": "You have two drums in front of you: a left drum and a right drum. A hit on the left can be recorded as \"L\", and a hit on the right as \"R\".\n\nThe strange forces that rule this world are fickle: sometimes, a blow sounds once, and sometimes it sounds twice. Therefore, a hit on the left drum could have sounded as either \"L\" or \"LL\", and a hit on the right drum could have sounded as either \"R\" or \"RR\".\n\nThe sequence of hits made is recorded in the string $p$, and the sounds heard are in the string $s$. Given $p$ and $s$, determine whether it is true that the string $s$ could have been the result of the hits from the string $p$.\n\nFor example, if $p=$\"LR\", then the result of the hits could be any of the strings \"LR\", \"LRR\", \"LLR\", and \"LLRR\", but the strings \"LLLR\" or \"LRL\" cannot.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2013 the number of independent test cases.\n\nThe first line of each test case contains the string $p$ ($1 \\le |p| \\le 2 \\cdot 10^5$) consisting only of the characters \"R\" and \"L\", where $|p|$ denotes the length of the string $p$.\n\nThe second line of each test case contains the string $s$ ($1 \\le |p| \\le |s| \\le 2 \\cdot 10^5$) consisting only of the characters \"R\" and \"L\".\n\nIt is guaranteed that the sum of $|s|$ does not exceed $2\\cdot 10^5$ across all test cases.\n\n### Output\n\nFor each set of input data, output \"YES\" if $s$ can be the heard sound, and \"NO\" otherwise. You may output in any case.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\nR\n\nRR\n\nLRLR\n\nLRLR\n\nLR\n\nLLLR\n\nLLLLLRL\n\nLLLLRRLL\n\nLLRLRLRRL\n\nLLLRLRRLLRRRL\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\nNO\nYES\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMatch(const string& p, const string& s) {\n    int n = p.length();\n    int m = s.length();\n    int i = 0, j = 0;\n    \n    while (i < n && j < m) {\n        char p_char = p[i];\n        char s_char = s[j];\n        \n        if (p_char != s_char) {\n            return false;\n        }\n        \n        // Count the number of consecutive p_char in p\n        int p_count = 1;\n        while (i + 1 < n && p[i + 1] == p_char) {\n            i++;\n            p_count++;\n        }\n        \n        // Count the number of consecutive s_char in s\n        int s_count = 1;\n        while (j + 1 < m && s[j + 1] == s_char) {\n            j++;\n            s_count++;\n        }\n        \n        // Check if s_count is between p_count and 2 * p_count\n        if (s_count < p_count || s_count > 2 * p_count) {\n            return false;\n        }\n        \n        i++;\n        j++;\n    }\n    \n    // Check if both strings are fully processed\n    return i == n && j == m;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        string p, s;\n        cin >> p >> s;\n        \n        if (canMatch(p, s)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2094c",
      "PROBLEM_ID": "2094C",
      "PROBLEM_STATEMENT": "Brr Brrr Patapim is trying to learn of Tiramis\u00f9's secret passcode, which is a permutation$^{\\text{\u2217}}$ of $2\\cdot n$ elements. To help Patapim guess, Tiramis\u00f9 gave him an $n\\times n$ grid $G$, in which $G_{i,j}$ (or the element in the $i$-th row and $j$-th column of the grid) contains $p_{i+j}$, or the $(i+j)$-th element in the permutation.\n\nGiven this grid, please help Patapim crack the forgotten code. It is guaranteed that the permutation exists, and it can be shown that the permutation can be determined uniquely.\n\n$^{\\text{\u2217}}$A permutation of $m$ integers is a sequence of $m$ integers which contains each of $1,2,\\ldots,m$ exactly once. For example, $[1, 3, 2]$ and $[2, 1]$ are permutations, while $[1, 2, 4]$ and $[1, 3, 2, 3]$ are not.\n\n### Input\n\nThe first line contains an integer $t$\u00a0\u2014 the number of test cases ($1 \\leq t \\leq 200$).\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 800$).\n\nEach of the following $n$ lines contains $n$ integers, giving the grid $G$. The first of these lines contains $G_{1,1}, G_{1,2},\\ldots,G_{1,n}$; the second of these lines contains $G_{2,1}, G_{2,2},\\ldots,G_{2,n}$, and so on. ($1 \\leq G_{i,j} \\leq 2\\cdot n$).\n\nIt is guaranteed that the grid encodes a valid permutation, and the sum of $n$ over all test cases does not exceed $800$.\n\n### Output\n\nFor each test case, please output $2n$ numbers on a new line: $p_1,p_2,\\ldots,p_{2n}$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n1 6 2\n\n6 2 4\n\n2 4 3\n\n1\n\n1\n\n2\n\n2 3\n\n3 4\n\n```\n\n#### Output #1\n\n```\n5 1 6 2 4 3\n2 1\n1 2 3 4\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<vector<int>> grid(n+1, vector<int>(n+1));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        \n        vector<int> p(2*n+1);\n        vector<bool> used(2*n+1, false);\n        \n        // Extract p[2] through p[2*n] from the grid\n        for (int k = 2; k <= 2*n; k++) {\n            int i, j;\n            if (k-1 <= n) {\n                i = 1;\n                j = k-1;\n            } else {\n                i = k-n;\n                j = n;\n            }\n            p[k] = grid[i][j];\n            used[p[k]] = true;\n        }\n        \n        // Determine p[1]\n        for (int i = 1; i <= 2*n; i++) {\n            if (!used[i]) {\n                p[1] = i;\n                break;\n            }\n        }\n        \n        // Output the permutation\n        for (int i = 1; i <= 2*n; i++) {\n            cout << p[i];\n            if (i < 2*n) cout << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2094b",
      "PROBLEM_ID": "2094B",
      "PROBLEM_STATEMENT": "In Bobritto Bandito's home town of residence, there are an infinite number of houses on an infinite number line, with houses at $\\ldots, -2, -1, 0, 1, 2, \\ldots$. On day $0$, he started a plague by giving an infection to the unfortunate residents of house $0$. Each succeeding day, the plague spreads to exactly one healthy household that is next to an infected household. It can be shown that each day the infected houses form a continuous segment.\n\nLet the segment starting at the $l$-th house and ending at the $r$-th house be denoted as $[l, r]$. You know that after $n$ days, the segment $[l, r]$ became infected. Find any such segment $[l', r']$ that could have been infected on the $m$-th day ($m \\le n$).\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 100$)\u00a0\u2013 the number of independent test cases.\n\nThe only line of each test case contains four integers $n$, $m$, $l$, and $r$ ($1 \\leq m\\leq n \\leq 2000, -n \\leq l \\leq 0 \\leq r \\leq n, r-l=n$).\n\n### Output\n\nFor each test case, output two integers $l'$ and $r'$ on a new line. If there are multiple solutions, output any.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4 2 -2 2\n\n4 1 0 4\n\n3 3 -1 2\n\n9 8 -6 3\n\n```\n\n#### Output #1\n\n```\n-1 1\n0 1\n-1 2\n-5 3\n```\n\n### Note\n\nIn the first test case, it is possible that on the $1$-st, $2$-nd, and $3$-rd days the interval of houses affected is $[-1,0]$, $[-1,1]$, $[-2,1]$. Therefore, $[-1,1]$ is a valid output.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, m, l, r;\n        cin >> n >> m >> l >> r;\n        \n        // j represents how many days the infection grows to the left out of m days\n        int j = max(0, m - r);  // Choose the minimum valid j\n        \n        // On day m, the segment would be [-j, m-j]\n        int l_prime = -j;\n        int r_prime = m - j;\n        \n        cout << l_prime << \" \" << r_prime << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2094a",
      "PROBLEM_ID": "2094A",
      "PROBLEM_STATEMENT": "Trippi Troppi resides in a strange world. The ancient name of each country consists of three strings. The first letter of each string is concatenated to form the country's modern name.\n\nGiven the country's ancient name, please output the modern name.\n\n### Input\n\nThe first line contains an integer $t$\u00a0\u2013 the number of independent test cases ($1 \\leq t \\leq 100$).\n\nThe following $t$ lines each contain three space-separated strings. Each string has a length of no more than $10$, and contains only lowercase Latin characters.\n\n### Output\n\nFor each test case, output the string formed by concatenating the first letter of each word.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\nunited states america\n\noh my god\n\ni cant lie\n\nbinary indexed tree\n\nbelieve in yourself\n\nskibidi slay sigma\n\ngod bless america\n\n```\n\n#### Output #1\n\n```\nusa\nomg\nicl\nbit\nbiy\nsss\ngba\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    for (int i = 0; i < t; i++) {\n        string a, b, c;\n        cin >> a >> b >> c;\n        \n        cout << a[0] << b[0] << c[0] << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2093f",
      "PROBLEM_ID": "2093F",
      "PROBLEM_STATEMENT": "Hackers are once again trying to create entertaining phrases using the output of neural networks. This time, they want to obtain an array of strings $a$ of length $n$.\n\nInitially, they have an array $c$ of length $n$, filled with blanks, which are denoted by the symbol $*$. Thus, if $n=4$, then initially $c=[*,*,*,*]$.\n\nThe hackers have access to $m$ neural networks, each of which has its own version of the answer to their request \u2013 an array of strings $b_i$ of length $n$.\n\nThe hackers are trying to obtain the array $a$ from the array $c$ using the following operations:\n\n1. Choose a neural network $i$, which will perform the next operation on the array $c$: it will select a randomblank, for example, at position $j$, and replace $c_j$ with $b_{i, j}$.\nFor example, if the first neural network is chosen and $c = [*, \\text{\u00ablike\u00bb}, *]$, and $b_1 = [\\text{\u00abI\u00bb}, \\text{\u00ablove\u00bb}, \\text{\u00abapples\u00bb}]$, then after the operation with the first neural network, $c$ may become either $[\\text{\u00abI\u00bb}, \\text{\u00ablike\u00bb}, *]$ or $[*, \\text{\u00ablike\u00bb}, \\text{\u00abapples\u00bb}]$.\n\n2. Choose position $j$ and replace $c_j$ with a blank.\n\nUnfortunately, because of the way hackers access neural networks, they will only be able to see the modified array $c$ after all operations are completed, so they will have to specify the entire sequence of operations in advance.\n\nHowever, the random behavior of the neural networks may lead to the situation where the desired array is never obtained, or obtaining it requires an excessive number of operations.\n\nTherefore, the hackers are counting on your help in choosing a sequence of operations that will guarantee the acquisition of array $a$ in the minimum number of operations.\n\nMore formally, if there exists a sequence of operations that can guarantee obtaining array $a$ from array $c$, then among all such sequences, find the one with the minimum number of operations, and output the number of operations in it.\n\nIf there is no sequence of operations that transforms array $c$ into array $a$, then output $-1$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 500$)\u00a0\u2014 the length of the original array $a$ and the number of neural networks, respectively.\n\nThe second line of each test case contains the array $a$, consisting of $n$ strings $a_i$ ($1 \\le |a_i| \\le 10$), separated by spaces.\n\nThe next $m$ lines of each test case contain the arrays $b_i$\u00a0\u2014 one in each line, consisting of $n$ strings $b_{i, j}$ ($1 \\le |b_{i,j}| \\le 10$), separated by spaces.\n\nIt is guaranteed that the sum of $|a_i|$ and $|b_{i, j}|$ across all test cases does not exceed $2 \\cdot 10^5$, and that the sum of $n \\cdot m$ across all test cases also does not exceed $2 \\cdot 10^5$.\n\nIt is guaranteed that the input strings consist only of characters from the Latin alphabet in both lowercase and uppercase.\n\nNote that the length of each individual input string does not exceed $10$.\n\n### Output\n\nOutput $t$ numbers\u00a0\u2014 one number for each test case, each on a separate line.\n\nIf there exists a sequence of operations that guarantees obtaining array $a$ from the $i$-th test case, then the $i$-th number is the number of operations in the minimum such sequence.\n\nOtherwise, for the $i$-th number, output $-1$.\n\n### Example\n\n#### Input #1\n\n```\n4\n3 3\nI love apples\nHe likes apples\nI love cats\nThey love dogs\n3 2\nIcy wake up\nwake Icy up\nwake up Icy\n4 3\nc o D E\nc o D s\nc O l S\nc o m E\n4 5\na s k A\nd s D t\nO R i A\na X b Y\nb a k A\nu s k J\n```\n\n#### Output #1\n\n```\n5\n-1\n6\n8\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n\n        // Read target array a\n        vector<string> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n\n        // covered[j] will be true if there is at least one network\n        // whose output at position j matches a[j].\n        vector<bool> covered(n, false);\n        int maxMatches = 0;\n\n        // Process each network b_i\n        for (int i = 0; i < m; i++) {\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                string b;\n                cin >> b;\n                if (b == a[j]) {\n                    cnt++;\n                    covered[j] = true;\n                }\n            }\n            maxMatches = max(maxMatches, cnt);\n        }\n\n        // Check if every position is coverable by at least one network\n        bool possible = true;\n        for (int j = 0; j < n; j++) {\n            if (!covered[j]) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (!possible) {\n            cout << -1 << \"\\n\";\n        } else {\n            // The optimal strategy is:\n            //   1) Pick the network i with the largest number of matches |S_i|.\n            //   2) Use that network n times: n type\u20101 ops.\n            //      -- In the worst case, it makes (n - |S_i|) wrong fills,\n            //         and then |S_i| correct fills, emptying the blanks.\n            //   3) Clear each wrongly filled position (n - |S_i| clears),\n            //      then refill it correctly one by one (n - |S_i| type\u20101 ops),\n            //      choosing for each position a network that matches it.\n            //\n            // Total ops = n (initial fills) + (n - |S_i|) clears + (n - |S_i|) fills\n            //           = n + 2*(n - |S_i|) = 3n - 2*|S_i|.\n            int ans = 3 * n - 2 * maxMatches;\n            cout << ans << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2093d",
      "PROBLEM_ID": "2093D",
      "PROBLEM_STATEMENT": "Vadim loves filling square tables with integers. But today he came up with a way to do it for fun! Let's take, for example, a table of size $2 \\times 2$, with rows numbered from top to bottom and columns numbered from left to right. We place $1$ in the top left cell, $2$ in the bottom right, $3$ in the bottom left, and $4$ in the top right. That's all he needs for fun!\n\nFortunately for Vadim, he has a table of size $2^n \\times 2^n$. He plans to fill it with integers from $1$ to $2^{2n}$ in ascending order. To fill such a large table, Vadim will divide it into $4$ equal square tables, filling the top left one first, then the bottom right one, followed by the bottom left one, and finally the top right one. Each smaller table will be divided into even smaller ones as he fills them until he reaches tables of size $2 \\times 2$, which he will fill in the order described above.\n\nNow Vadim is eager to start filling the table, but he has $q$ questions of two types:\n\n- what number will be in the cell at the $x$-th row and $y$-th column;\n- in which cell coordinates will the number $d$ be located.\n\nHelp answer Vadim's questions.\n\n### Input\n\nEach test consists of several sets of input data. The first line contains a single integer $t$ $(1 \\leq t \\leq 10)$ \u00a0\u2014 the number of sets of input data. The following lines describe the input data sets.\n\nIn the first line of each data set, there is an integer $n$, describing the size of the table $(1 \\le n \\le 30)$.\n\nIn the second line of each data set, there is an integer $q$ \u00a0\u2014 the number of questions $(1 \\le q \\le 20\\,000)$.\n\nIn the following $q$ lines of each data set, the questions are described in the following formats:\n\n- -\\> x y \u00a0\u2014 What number will be in the cell $(1 \\le x, y \\le 2^n)$;\n- <\\- d \u00a0\u2014 In which cell coordinates will the number $(1 \\le d \\le 2^{2n})$ be located.\n\nIt is guaranteed that the sum of $q$ over all test cases does not exceed $20\\,000$.\n\n### Output\n\nOutput the answers to each question on a separate line.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n2\n\n5\n\n-\\> 4 3\n\n<\\- 15\n\n<\\- 4\n\n-\\> 3 1\n\n-\\> 1 3\n\n1\n\n8\n\n-\\> 1 1\n\n-\\> 1 2\n\n-\\> 2 1\n\n-\\> 2 2\n\n<\\- 1\n\n<\\- 2\n\n<\\- 3\n\n<\\- 4\n\n```\n\n#### Output #1\n\n```\n7\n2 3\n1 2\n9\n13\n1\n4\n3\n2\n1 1\n2 2\n2 1\n1 2\n```\n\n### Note\n\nThis is how the filled table from the first example looks:\n\n![](https://espresso.codeforces.com/da748157aec3b2f6a243518e84d255f6a0b8b6c6.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to find the value at cell (x, y) in a 2^n x 2^n table\nlong long getValue(int n, long long x, long long y) {\n    if (n == 1) {\n        if (x == 1 && y == 1) return 1;\n        if (x == 2 && y == 2) return 2;\n        if (x == 2 && y == 1) return 3;\n        if (x == 1 && y == 2) return 4;\n    }\n    \n    long long half = 1LL << (n - 1);\n    long long quadSize = 1LL << (2 * (n - 1));\n    \n    if (x <= half && y <= half) {\n        // Top-left quadrant\n        return getValue(n - 1, x, y);\n    } else if (x > half && y > half) {\n        // Bottom-right quadrant\n        return quadSize + getValue(n - 1, x - half, y - half);\n    } else if (x > half && y <= half) {\n        // Bottom-left quadrant\n        return 2 * quadSize + getValue(n - 1, x - half, y);\n    } else {\n        // Top-right quadrant\n        return 3 * quadSize + getValue(n - 1, x, y - half);\n    }\n}\n\n// Function to find the coordinates of a value d in a 2^n x 2^n table\npair<long long, long long> getCoordinates(int n, long long d) {\n    if (n == 1) {\n        if (d == 1) return {1, 1};\n        if (d == 2) return {2, 2};\n        if (d == 3) return {2, 1};\n        if (d == 4) return {1, 2};\n    }\n    \n    long long half = 1LL << (n - 1);\n    long long quadSize = 1LL << (2 * (n - 1));\n    \n    if (d <= quadSize) {\n        // Top-left quadrant\n        return getCoordinates(n - 1, d);\n    } else if (d <= 2 * quadSize) {\n        // Bottom-right quadrant\n        auto [x, y] = getCoordinates(n - 1, d - quadSize);\n        return {x + half, y + half};\n    } else if (d <= 3 * quadSize) {\n        // Bottom-left quadrant\n        auto [x, y] = getCoordinates(n - 1, d - 2 * quadSize);\n        return {x + half, y};\n    } else {\n        // Top-right quadrant\n        auto [x, y] = getCoordinates(n - 1, d - 3 * quadSize);\n        return {x, y + half};\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, q;\n        cin >> n >> q;\n        \n        string query;\n        while (q--) {\n            cin >> query;\n            \n            if (query == \"->\") {\n                long long x, y;\n                cin >> x >> y;\n                cout << getValue(n, x, y) << '\\n';\n            } else if (query == \"<-\") {\n                long long d;\n                cin >> d;\n                auto [x, y] = getCoordinates(n, d);\n                cout << x << \" \" << y << '\\n';\n            }\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2093c",
      "PROBLEM_ID": "2093C",
      "PROBLEM_STATEMENT": "Pasha loves prime numbers$^{\\text{\u2217}}$! Once again, in his attempts to find a new way to generate prime numbers, he became interested in an algorithm he found on the internet:\n\n- To obtain a new number $y$, repeat $k$ times the decimal representation of the number $x$ (without leading zeros).\n\nFor example, for $x = 52$ and $k = 3$, we get $y = 525252$, and for $x = 6$ and $k = 7$, we get $y = 6666666$.\n\nPasha really wants the resulting number $y$ to be prime, but he doesn't yet know how to check the primality of numbers generated by this algorithm. Help Pasha and tell him whether $y$ is prime!\n\n$^{\\text{\u2217}}$An integer $x$ is considered prime if it has exactly $2$ distinct divisors: $1$ and $x$. For example, $13$ is prime because it has only $2$ divisors: $1$ and $13$. Note that the number $1$ is not prime, as it has only one divisor.\n\n### Input\n\nEach test consists of several sets of input data. The first line contains a single integer $t$ ($1 \\leq t \\leq 100$)\u00a0\u2014 the number of sets of input data. The following lines describe the sets of input data.\n\nThe first and only line of each data set contains two integers: $x$ and $k$ ($1 \\leq x \\leq 10^9$, $1 \\leq k \\leq 7$).\n\n### Output\n\nFor each set of input data, output \u00abYES\u00bb (without quotes) if the resulting number $y$ will be prime, and \u00abNO\u00bb otherwise.\n\nYou may output \u00abYes\u00bb and \u00abNo\u00bb in any case (for example, the strings \u00abyES\u00bb, \u00abyes\u00bb, and \u00abYes\u00bb will be recognized as positive answers).\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n52 3\n\n6 7\n\n7 1\n\n1 7\n\n```\n\n#### Output #1\n\n```\nNO\nNO\nYES\nNO\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <cmath>\n\nbool isPrime(long long n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        long long x;\n        int k;\n        std::cin >> x >> k;\n        \n        if (k == 1) {\n            // When k=1, the number is just x\n            std::cout << (isPrime(x) ? \"YES\" : \"NO\") << std::endl;\n        } else if (x == 1 && k == 2) {\n            // Special case: 11 is prime\n            std::cout << \"YES\" << std::endl;\n        } else {\n            // All other cases will produce a composite number\n            std::cout << \"NO\" << std::endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2093b",
      "PROBLEM_ID": "2093B",
      "PROBLEM_STATEMENT": "The cost of a positive integer $n$ is defined as the result of dividing the number $n$ by the sum of its digits.\n\nFor example, the cost of the number $104$ is $\\frac{104}{1 + 0 + 4} = 20.8$, and the cost of the number $111$ is $\\frac{111}{1 + 1 + 1} = 37$.\n\nYou are given a positive integer $n$ that does not contain leading zeros. You can remove any number of digits from the number $n$ (including none) so that the remaining number contains at least one digit and is strictly greater than zero. The remaining digits cannot be rearranged. As a result, you may end up with a number that has leading zeros.\n\nFor example, you are given the number $103554$. If you decide to remove the digits $1$, $4$, and one digit $5$, you will end up with the number $035$, whose cost is $\\frac{035}{0 + 3 + 5} = 4.375$.\n\nWhat is the minimum number of digits you need to remove from the number so that its cost becomes the minimum possible?\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of test cases.\n\nThe only line of each test case contains a positive integer $n$ ($1 \\leq n < 10^{100}$) without leading zeros.\n\n### Output\n\nFor each test case, output one integer on a new line \u2014 the number of digits that need to be removed from the number so that its cost becomes minimal.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n666\n\n13700\n\n102030\n\n7\n\n```\n\n#### Output #1\n\n```\n2\n4\n3\n0\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream> // For input/output operations (cin, cout)\n#include <string>   // For using string data type\n#include <vector>   // Although not used directly, included for completeness in competitive programming context\n#include <algorithm> // Required for std::max function\n\nint main() {\n    // Use fast I/O operations to speed up reading input, especially for large inputs.\n    std::ios_base::sync_with_stdio(false); // Disable synchronization with C stdio\n    std::cin.tie(NULL); // Untie cin from cout\n\n    int t; // Declare variable to store the number of test cases\n    std::cin >> t; // Read the number of test cases\n\n    while (t--) { // Loop through each test case\n        std::string s; // Declare a string variable to store the input number\n        std::cin >> s; // Read the input number as a string\n        \n        int L = s.length(); // Get the length of the string (number of digits in n)\n        \n        int zero_count = 0; // Initialize a counter for zeros encountered so far while iterating through the string.\n                            // This counts zeros at indices strictly less than the current index j.\n\n        // Initialize max_len to 0. This variable will store the maximum length found\n        // for any subsequence that achieves the minimum possible cost.\n        // We proved that the minimum cost is 1, achieved by subsequences of the form \"0...0d\" where d is a non-zero digit (1-9).\n        // The problem requires the resulting number to be strictly greater than zero.\n        // Since the input number n is positive (n >= 1) and has no leading zeros, its first digit s[0] must be non-zero.\n        // The subsequence consisting solely of the first digit s[0] is valid (value s[0] > 0), has length 1, and its cost is s[0]/s[0] = 1.\n        // Therefore, max_len will be at least 1 after processing the first digit.\n        int max_len = 0;    \n\n        // Iterate through the digits of the input string s using index j from 0 to L-1.\n        for (int j = 0; j < L; ++j) {\n            // Check if the current digit s[j] is not '0'.\n            if (s[j] != '0') {\n                // If s[j] is a non-zero digit, it can serve as the final digit 'd'\n                // in a subsequence of the form \"0...0d\". Such subsequences have the minimum cost of 1.\n                // To maximize the length of such a subsequence ending with s[j],\n                // we should select all available zeros that appear before index j in the original string.\n                // The count of these preceding zeros is exactly the value currently stored in `zero_count`.\n                // The total length of this candidate subsequence is `zero_count` (number of zeros) + 1 (for the non-zero digit s[j]).\n                // We want to find the maximum possible length among all such minimum-cost subsequences.\n                // So, we update `max_len` if the current subsequence length (`zero_count + 1`) is greater than the maximum length found so far.\n                max_len = std::max(max_len, zero_count + 1);\n            }\n            \n            // If the current digit s[j] is '0', increment the `zero_count`.\n            // This counter keeps track of the number of zeros encountered up to the current position (index j).\n            // These zeros can potentially be used as leading zeros for subsequences ending at non-zero digits found later in the string.\n            if (s[j] == '0') {\n                zero_count++;\n            }\n        }\n        \n        // The problem asks for the minimum number of digits that need to be removed\n        // such that the cost of the resulting number is minimal.\n        // Minimizing the number of removed digits is equivalent to maximizing the length of the subsequence that remains.\n        // We found `max_len`, which is the maximum possible length of a subsequence achieving the minimum cost (cost = 1).\n        // Therefore, the minimum number of digits to remove is the original total length `L` minus this maximum length `max_len`.\n        std::cout << L - max_len << \"\\n\"; // Print the result for the current test case, followed by a newline.\n    }\n    \n    return 0; // Indicate successful program execution.\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2093a",
      "PROBLEM_ID": "2093A",
      "PROBLEM_STATEMENT": "We call an array $a$, consisting of $k$ positive integers, palindromic if $[a_1, a_2, \\dots, a_k] = [a_k, a_{k-1}, \\dots, a_1]$. For example, the arrays $[1, 2, 1]$ and $[5, 1, 1, 5]$ are palindromic, while the arrays $[1, 2, 3]$ and $[21, 12]$ are not.\n\nWe call a number $k$ an ideal generator if any integer $n$ ($n \\ge k$) can be represented as the sum of the elements of a palindromic array of length exactly $k$. Each element of the array must be greater than $0$.\n\nFor example, the number $1$ is an ideal generator because any natural number $n$ can be generated using the array $[n]$. However, the number $2$ is not an ideal generator \u2014 there is no palindromic array of length $2$ that sums to $3$.\n\nDetermine whether the given number $k$ is an ideal generator.\n\n### Input\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first and only line of each test case contains one integer $k$ ($1 \\le k \\le 1000$).\n\n### Output\n\nFor each number $k$, you need to output the word \"YES\" if it is an ideal generator, or \"NO\" otherwise.\n\nYou may output \"Yes\" and \"No\" in any case (for example, the strings \"yES\", \"yes\", and \"Yes\" will be recognized as a positive answer).\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n2\n\n3\n\n73\n\n1000\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nYES\nNO\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int k;\n        cin >> k;\n        \n        if (k % 2 == 1) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2092f",
      "PROBLEM_ID": "2092F",
      "PROBLEM_STATEMENT": "Let us define the beauty of a binary string $z$ as the number of indices $i$ such that $1 \\le i < |z|$ and $z_i \\neq z_{i+1}$.\n\nWhile waiting for his friends from the CCB, Andryusha baked a pie, represented by a binary string $s$ of length $n$. To avoid offending anyone, he wants to divide this string into $k$ substrings such that each digit belongs to exactly one substring, and the beauties of all substrings are the same.\n\nAndryusha does not know the exact number of friends from the CCB who will come to his house, so he wants to find the number of values of $k$ for which it is possible to split the pie into exactly $k$ parts with equal beauties.\n\nHowever, Andryusha's brother, Tristan, decided that this formulation of the problem is too simple. Therefore, he wants you to find the number of such values of $k$ for each prefix of the string. In other words, for each $i$ from $1$ to $n$, you need to find the number of values of $k$ for which it is possible to split the prefix $s_1 s_2 \\ldots s_i$ into exactly $k$ parts with equal beauties.\n\n### Input\n\nEach test consists of several test cases. The first line of the input data contains one integer $t$ ($1 \\le t \\le 10^5$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 10^6$) \u2014 the length of the binary string.\n\nThe second line of each test case contains a binary string of length $n$, consisting only of digits 0 and 1.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output a single line containing $n$ integers $c_i$ ($0 \\le c_i \\le n$) \u2014 the number of values of $k$ for which it is possible to split the prefix $s_1 s_2 \\ldots s_i$ into exactly $k$ parts with equal beauties.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5\n\n00011\n\n10\n\n0101010101\n\n7\n\n0010100\n\n```\n\n#### Output #1\n\n```\n1 2 3 4 5\n1 2 2 3 2 4 2 4 3 4\n1 2 3 3 4 3 4\n```\n\n### Note\n\nIn the third case, the values of $k$ that satisfy the conditions are:\n\n1. $i = 1$: $k \\in \\{1\\}$,\n2. $i = 2$: $k \\in \\{1, 2\\}$,\n3. $i = 3$: $k \\in \\{1, 2, 3\\}$,\n4. $i = 4$: $k \\in \\{1, 3, 4\\}$,\n5. $i = 5$: $k \\in \\{1, 2, 4, 5\\}$,\n6. $i = 6$: $k \\in \\{1, 5, 6\\}$,\n7. $i = 7$: $k \\in \\{1, 5, 6, 7\\}$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n \nusing namespace std;\n \nusing ll = long long;\n \nvoid solve() {\n    int n; cin >> n;\n    string s; cin >> s;\n    vector <int> a;\n    int curr = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i && s[i] != s[i - 1]) {\n            if (curr) a.push_back(curr);\n            curr = 1;\n        }\n        else ++curr;\n    }\n    a.push_back(curr);\n    int sz = a.size();\n \n    vector <int> ans(n, 0), left(sz, 0), right(sz, 0);\n    for (int i = 0; i < sz; ++i) {\n        if (!i) {\n            left[i] = 0; right[i] = a[i] - 1;\n        } else {\n            left[i] = right[i - 1] + 1;\n            right[i] = left[i] + a[i] - 1;\n        }\n    }\n    for (int i = 0; i < sz; ++i) {\n        for (int j = left[i]; j <= right[i]; ++j) {\n            ans[j] += j - i + 1;\n        }\n    }\n    vector <int> add(sz, 0);\n    for (int m = 1; m < sz; ++m) {\n        ll l = m, r = m, k = 1;\n        while (l < sz) {\n            ++add[l];\n            if (r + 1 < sz) --add[r + 1];\n \n            if (a[l] == 1) {\n                l += m + 1;\n            } else {\n                l += m;\n            }\n \n            r += m + 1;\n            ++k;\n        }\n    }\n    int pref = 0;\n    for (int i = 0; i < sz; ++i) {\n        pref += add[i];\n        for (int j = left[i]; j <= right[i]; ++j) {\n            ans[j] += pref;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        cout << ans[i];\n        if (i != n - 1) cout << ' ';\n    }\n    cout << '\\n';\n}\n \nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int t; cin >> t;\n    while (t--) {\n        solve();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2092d",
      "PROBLEM_ID": "2092D",
      "PROBLEM_STATEMENT": "In anticipation of a duel with his old friend Fernan, Edmond is preparing an energy drink called \"Mishkin Energizer\". The drink consists of a string $s$ of length $n$, made up only of the characters L, I, and T, which correspond to the content of three different substances in the drink.\n\nWe call the drink balanced if it contains an equal number of all substances. To boost his aura and ensure victory in the duel, Edmond must make the initial string balanced by applying the following operation:\n\n1. Choose an index $i$ such that $s_i \\neq s_{i+1}$ (where $i + 1$ must not exceed the current size of the string).\n2. Insert a character $x$, either L, I, or T, between them such that $x \\neq s_i$ and $x \\neq s_{i+1}$.\n\nHelp Edmond make the drink balanced and win the duel by performing no more than $\\textbf{2n}$ operations. If there are multiple solutions, any one of them can be output. If it is impossible, you must report this.\n\n### Input\n\nEach test consists of several test cases. The first line of the input data contains one integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 100$) \u2014 the length of the string $s$.\n\nThe second line of each test case contains a string $s$ of length $n$, consisting only of the characters L, I, and T.\n\n### Output\n\nFor each test case, output $-1$ if there is no solution. Otherwise, in the first line, output a single integer $m$ ($0 \\le m \\le 2n$) \u2014 the number of operations you performed.\n\nThen the $l$-th of the following $m$ lines should contain a single integer $i$ ($1 \\le i < n+l-1$), indicating the operation of inserting a character between $s_i$ and $s_{i+1}$. It must hold that $s_i \\neq s_{i+1}$.\n\nIf there are multiple solutions, any one of them can be output. Note that you do not need to minimize the number of operations in this problem.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5\n\nTILII\n\n1\n\nL\n\n3\n\nLIT\n\n```\n\n#### Output #1\n\n```\n4\n1\n2\n3\n4\n-1\n0\n```\n\n### Note\n\nIn the first test case, the following sequence of operations can be performed: TILII $\\rightarrow$ TLILII $\\rightarrow$ TLTILII $\\rightarrow$ TLTLILII $\\rightarrow$ TLTLTILII.\n\nIn the second test case, no operations can be performed, so the answer is $-1$.\n\nIn the third test case, the initial string already has equal quantities of all substances.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n\n        // Check if there is at least one adjacent distinct pair.\n        bool hasGap = false;\n        for (int i = 0; i + 1 < n; i++) {\n            if (s[i] != s[i+1]) {\n                hasGap = true;\n                break;\n            }\n        }\n        // If no gap, it's impossible to insert anything.\n        if (!hasGap) {\n            cout << \"-1\\n\";\n            continue;\n        }\n\n        // Map characters to indices: L->0, I->1, T->2\n        auto ch2id = [&](char c) {\n            if (c == 'L') return 0;\n            if (c == 'I') return 1;\n            return 2; // 'T'\n        };\n        char id2ch[3] = {'L','I','T'};\n\n        // Count initial frequencies\n        vector<int> cnt(3, 0);\n        for (char c : s) {\n            cnt[ch2id(c)]++;\n        }\n\n        // We choose final k = n, so total insertions m = 2n\n        // Each a[x] = n - cnt[x] > 0 for non-constant s.\n        vector<int> a(3);\n        for (int x = 0; x < 3; x++) {\n            a[x] = n - cnt[x];\n        }\n\n        vector<int> ops;\n        ops.reserve(2 * n);\n\n        // Greedy: while we still need to insert\n        int totalNeed = a[0] + a[1] + a[2];\n        // We know totalNeed == 2*n\n        while (a[0] + a[1] + a[2] > 0) {\n            bool did = false;\n            int len = (int)s.size();\n            for (int i = 0; i + 1 < len; i++) {\n                if (s[i] == s[i+1]) continue;\n                int u = ch2id(s[i]);\n                int v = ch2id(s[i+1]);\n                // find the third letter\n                int x = 0;\n                for (int c = 0; c < 3; c++) {\n                    if (c != u && c != v) {\n                        x = c;\n                        break;\n                    }\n                }\n                if (a[x] > 0) {\n                    // insert id2ch[x] between s[i] and s[i+1]\n                    s.insert(s.begin() + (i+1), id2ch[x]);\n                    // record operation (1-based position)\n                    ops.push_back(i+1);\n                    a[x]--;\n                    did = true;\n                    break;\n                }\n            }\n            // We should always be able to do an insertion for non-constant s\n            if (!did) {\n                // Should not happen in theory; but break to avoid infinite loop\n                break;\n            }\n        }\n\n        // Check if we succeeded\n        if (a[0] + a[1] + a[2] > 0) {\n            // fallback if something went wrong\n            cout << \"-1\\n\";\n        } else {\n            cout << ops.size() << \"\\n\";\n            for (int p : ops) {\n                cout << p << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2092c",
      "PROBLEM_ID": "2092C",
      "PROBLEM_STATEMENT": "For her birthday, each of Asuna's $n$ admirers gifted her a tower. The height of the tower from the $i$-th admirer is equal to $a_i$.\n\nAsuna evaluates the beauty of the received gifts as $\\max(a_1, a_2, \\ldots, a_n)$. She can perform the following operation an arbitrary number of times (possibly, zero).\n\n- Take such $1 \\le i \\neq j \\le n$ that $a_i + a_j$ is odd and $a_i > 0$, then decrease $a_i$ by $1$ and increase $a_j$ by $1$.\n\nIt is easy to see that the heights of the towers remain non-negative during the operations.\n\nHelp Asuna find the maximum possible beauty of the gifts after any number of operations!\n\n### Input\n\nEach test consists of several test cases. The first line of the input data contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the number of admirers of Asuna.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n \\ (1 \\le a_i \\le 10^9)$ \u2014 the heights of the towers.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer: the maximum value of the beauty of the gifts that Asuna can achieve.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\n5 3 9\n\n2\n\n3 2\n\n4\n\n1 2 2 1\n\n5\n\n5 4 3 2 9\n\n```\n\n#### Output #1\n\n```\n9\n5\n5\n21\n```\n\n### Note\n\nIn the first test case, no pair of towers satisfies the required condition for applying the operation, so no operations can be performed. In this case, the answer is $\\max(5, \\ 3, \\ 9) = 9$.\n\nIn the second test case, the operation with $i = 2$ and $j = 1$ can be applied twice. After that, the array becomes: $a \\ = \\ [5, \\ 0]$. Thus, the answer is 5.\n\nIn the third test case, the following sequence of operations can be applied:\n\n1. Operation with $i=1$ and $j=2$.\n$[1, \\ 2, \\ 2, \\ 1] \\quad \\rightarrow \\quad [0, \\ 3, \\ 2, \\ 1]$\n\n2. Operation with $i=3$ and $j=2$.\n$[0, \\ 3, \\ 2, \\ 1] \\quad \\rightarrow \\quad [0, \\ 4, \\ 1, \\ 1]$\n\n3. Operation with $i=3$ and $j=2$.\n$[0, \\ 4, \\ 1, \\ 1] \\quad \\rightarrow \\quad [0, \\ 5, \\ 0, \\ 1]$\n\n\n$\\max(0, \\ 5, \\ 0, \\ 1) \\ = \\ 5$.\n\nTherefore, the answer is 5.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Required for std::accumulate if used, though manual summation is fine\n#include <algorithm> // Required for std::max if used, though manual max tracking is fine\n\n// Function to solve a single test case\nvoid solve() {\n    int n; // Number of towers\n    std::cin >> n;\n    \n    // Use vector of long long to store tower heights, as heights can be up to 10^9\n    std::vector<long long> a(n); \n    \n    long long current_max = 0; // To store the maximum initial height among the towers\n    long long total_sum = 0;   // To store the sum of all tower heights\n    int odd_count = 0;         // To count the number of towers with odd height initially\n        \n    // Read the tower heights, calculate sum, find initial max, and count odd heights\n    for (int i = 0; i < n; ++i) {\n        std::cin >> a[i];\n        total_sum += a[i]; // Accumulate the total sum\n        \n        // Update the maximum initial height seen so far\n        if (a[i] > current_max) {\n            current_max = a[i];\n        }\n        \n        // Check if the current tower height is odd\n        if (a[i] % 2 != 0) {\n            odd_count++; // Increment the count of odd towers if it is\n        }\n    }\n        \n    // The core logic depends on the initial counts of odd and even towers.\n    // The operation requires choosing two towers i and j such that a_i + a_j is odd.\n    // This means one tower must have an odd height and the other must have an even height.\n    // If all towers initially have the same parity (all odd or all even), no operation can be performed.\n    \n    // Check if all towers have the same parity initially\n    // This is true if odd_count is 0 (all towers are even) or odd_count is n (all towers are odd)\n    if (odd_count == 0 || odd_count == n) {\n        // Case 1 & 2: All towers have the same parity.\n        // No operations can be performed. The heights remain unchanged.\n        // The maximum beauty is simply the maximum of the initial heights.\n        std::cout << current_max << \"\\n\";\n    } else {\n        // Case 3: There is a mix of odd and even tower heights initially (0 < odd_count < n).\n        // Operations are possible.\n        // Key invariant properties of the operation:\n        // 1. The total sum of heights (S = total_sum) remains invariant.\n        // 2. The number of odd towers (|O_0| = odd_count) and the number of even towers (|E_0| = n - odd_count) remain invariant.\n        \n        // We want to maximize the height of a single tower. The maximum possible value for a tower height\n        // is limited by the total sum S and the requirement to maintain the parity counts.\n        // To maximize one tower's height, we should try to make other towers as small as possible\n        // while satisfying the parity count constraint.\n        // The minimum possible height for an odd tower is 1.\n        // The minimum possible height for an even tower is 0.\n        \n        // Consider two potential final configurations that could yield the maximum height:\n        // Config 1: Make the tallest tower have odd height $M_{odd}$. To satisfy the parity counts, we need $|O_0|$ odd towers and $|E_0|$ even towers total.\n        // The minimal configuration requires $|O_0|-1$ additional odd towers (height 1 each) and $|E_0|$ even towers (height 0 each).\n        // The total sum $S = M_{odd} + (|O_0|-1) \\times 1 + |E_0| \\times 0$.\n        // This gives $M_{odd} = S - (|O_0|-1) = S - odd\\_count + 1$.\n        \n        // Config 2: Make the tallest tower have even height $M_{even}$. To satisfy parity counts, we need $|O_0|$ odd towers (height 1 each) and $|E_0|-1$ additional even towers (height 0 each).\n        // The total sum $S = M_{even} + |O_0| \\times 1 + (|E_0|-1) \\times 0$.\n        // This gives $M_{even} = S - |O_0| = S - odd\\_count$.\n        \n        // The maximum possible beauty is the maximum height achievable across all reachable states.\n        // Assuming these configurations are reachable (which seems plausible as operations allow mixing height between parities),\n        // the maximum beauty is $\\max(M_{odd}, M_{even})$.\n        \n        // We compare $M_{odd}$ and $M_{even}$:\n        // $M_{odd} = S - odd\\_count + 1$\n        // $M_{even} = S - odd\\_count$\n        // Since $S \\ge n$ (because $a_i \\ge 1$) and $1 \\le odd\\_count \\le n-1$ (because both parities exist),\n        // $M_{even} = S - odd\\_count \\ge n - (n-1) = 1$. So $M_{even}$ is at least 1.\n        // $M_{odd} = M_{even} + 1$, so $M_{odd}$ is always greater than $M_{even}$ (and at least 2).\n        // Therefore, the overall maximum achievable beauty is $M_{odd}$.\n        \n        long long max_beauty = total_sum - odd_count + 1;\n        std::cout << max_beauty << \"\\n\";\n    }\n}\n\nint main() {\n    // Use fast I/O operations for competitive programming\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Number of test cases\n    std::cin >> t; \n    while (t--) {\n        solve(); // Process each test case by calling the solve function\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2092b",
      "PROBLEM_ID": "2092B",
      "PROBLEM_STATEMENT": "As soon as Dasha Purova crossed the border of France, the villain Markaron kidnapped her and placed her in a prison under his large castle. Fortunately, the wonderful Lady Bug, upon hearing the news about Dasha, immediately ran to save her in Markaron's castle. However, to get there, she needs to crack a complex password.\n\nThe password consists of two bit strings $a$ and $b$, each of which has a length of $n$. In one operation, Lady Bug can choose any index $2 \\le i \\le n$ and perform one of the following actions:\n\n1. swap($a_i$, $b_{i-1}$) (swap the values of $a_i$ and $b_{i-1}$), or\n2. swap($b_i$, $a_{i-1}$) (swap the values of $b_i$ and $a_{i-1}$).\n\nLady Bug can perform any number of operations. The password is considered cracked if she can ensure that the first string consists only of zeros. Help her understand whether or not she will be able to save the unfortunate Dasha.\n\n### Input\n\nEach test consists of several test cases. The first line of the input data contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the length of the bit strings of the password.\n\nThe next two lines contain the bit strings of length $n$, $a$ and $b$, which represent the password. Each of the strings contains only the characters 0 and '1'.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output \"YES\" if Lady Bug can crack the password after any number of operations; otherwise, output \"NO\".\n\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\n000\n\n000\n\n6\n\n010001\n\n010111\n\n5\n\n10000\n\n01010\n\n2\n\n11\n\n00\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\nYES\n```\n\n### Note\n\nIn the first test case, the string $a$ immediately consists only of zeros.\n\nIn the second test case, a possible sequence of operations is:\n\n1. swap$(a_2, \\ b_{1})$\n\n$\\mathtt{0{\\color{red}{1}}0001}$\n\n$\\mathtt{{\\color{red}{0}}10111}$\n\n2. swap$(b_5, \\ a_{4})$\n\n$\\mathtt{000{\\color{red}{0}}01}$\n\n$\\mathtt{1101{\\color{red}{1}}1}$\n\n3. swap$(a_4, \\ b_{3})$\n\n$\\mathtt{000{\\color{red}{1}}01}$\n\n$\\mathtt{11{\\color{red}{0}}101}$\n\n4. swap$(a_5, \\ b_{4})$\n\n$\\mathtt{00000{\\color{red}{1}}}$\n\n$\\mathtt{1111{\\color{red}{0}}1}$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nbool solve() {\n    int n;\n    cin >> n;\n    string a_str, b_str;\n    cin >> a_str >> b_str;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = a_str[i] - '0';\n        b[i] = b_str[i] - '0';\n    }\n\n    int s1 = 0;\n    int s2 = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 1) {\n            s1 += a[i];\n            s2 += b[i];\n        } else {\n            s1 += b[i];\n            s2 += a[i];\n        }\n    }\n\n    int n_even = n / 2;\n    int n_odd = (n + 1) / 2;\n\n    if (s1 <= n_even && s2 <= n_odd) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        if (solve()) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2092a",
      "PROBLEM_ID": "2092A",
      "PROBLEM_STATEMENT": "Kamilka has a flock of $n$ sheep, the $i$-th of which has a beauty level of $a_i$. All $a_i$ are distinct. Morning has come, which means they need to be fed. Kamilka can choose a non-negative integer $d$ and give each sheep $d$ bunches of grass. After that, the beauty level of each sheep increases by $d$.\n\nIn the evening, Kamilka must choose exactly two sheep and take them to the mountains. If the beauty levels of these two sheep are $x$ and $y$ (after they have been fed), then Kamilka's pleasure from the walk is equal to $\\gcd(x, y)$, where $\\gcd(x, y)$ denotes the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers $x$ and $y$.\n\nThe task is to find the maximum possible pleasure that Kamilka can get from the walk.\n\n### Input\n\nEach test consists of several test cases. The first line contains one integer $t$ ($1 \\le t \\le 500$), the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($2 \\leq n \\leq 100$), the number of sheep Kamilka has.\n\nThe second line of each test case contains $n$ distinct integers $a_1, a_2, \\ldots, a_n \\ (1 \\le a_i \\le 10^9)$ \u2014 the beauty levels of the sheep.\n\nIt is guaranteed that all $a_i$ are distinct.\n\n### Output\n\nFor each test case, output a single integer: the maximum possible pleasure that Kamilka can get from the walk.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n1 3\n\n5\n\n5 4 3 2 1\n\n3\n\n5 6 7\n\n3\n\n1 11 10\n\n```\n\n#### Output #1\n\n```\n2\n4\n2\n10\n```\n\n### Note\n\nIn the first test case, $d=1$ works. In this case, the pleasure is $\\gcd(1+1, \\ 1+3)=\\gcd(2, \\ 4)=2$. It can be shown that a greater answer cannot be obtained.\n\nIn the second test case, let's take $d=3$. In this case, the pleasure is $\\gcd(1+3, \\ 5+3)=\\gcd(4, \\ 8)=4$. Thus, for this test case, the answer is $4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        int max_val = *max_element(a.begin(), a.end());\n        int min_val = *min_element(a.begin(), a.end());\n        cout << (max_val - min_val) << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2091g",
      "PROBLEM_ID": "2091G",
      "PROBLEM_STATEMENT": "Programmer Gleb frequently visits the IT Campus \"NEIMARK\" to participate in programming training sessions.\n\nNot only is Gleb a programmer, but he is also a renowned rower, so he covers part of his journey from home to the campus by kayaking along a river. Assume that Gleb starts at point $0$ and must reach point $s$ (i.e., travel $s$ meters along a straight line). To make the challenge tougher, Gleb has decided not to go outside the segment $[0, s]$. The dimensions of the kayak can be neglected.\n\nGleb is a strong programmer! Initially, his power is $k$. Gleb's power directly affects the movement of his kayak. If his current power is $x$, then with one paddle stroke the kayak moves $x$ meters in the current direction. Gleb can turn around and continue moving in the opposite direction, but such a maneuver is quite challenging, and after each turn, his power decreases by $1$. The power can never become $0$\u00a0\u2014 if his current power is $1$, then even after turning it remains $1$. Moreover, Gleb cannot make two turns in a row \u2014 after each turn, he must move at least once before making another turn. Similarly, Gleb cannot make a turn immediately after the start\u00a0\u2014 he must first perform a paddle stroke.\n\nGleb wants to reach point $s$ from point $0$ without leaving the segment $[0, s]$ and while preserving as much power as possible. Help him \u2014 given the value $s$ and his initial power $k$, determine the maximum possible power he can have upon reaching point $s$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\leq t \\leq 100$). The description of the test cases follows.\n\nA single line of each test case contains two integers $s$ and $k$ ($1 \\leq s \\leq 10^9$, $1 \\leq k \\leq 1000$, $k \\leq s$).\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $2000$.\n\n### Output\n\nFor each test case, output the maximum possible power Gleb can have at the end of his journey.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n9 6\n\n10 7\n\n24 2\n\n123456 777\n\n6 4\n\n99 6\n\n10 4\n\n99 4\n\n```\n\n#### Output #1\n\n```\n4\n1\n2\n775\n1\n4\n2\n2\n```\n\n### Note\n\nOne of the variants of Gleb's movement in the first example:\n\n![](https://espresso.codeforces.com/4e41b69eb4b8149b5fb4530e5f1e6eede1c4d340.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint s, k, p;\nvector<bool> was1, was2;\n\nvoid bfs() {\n    vector<int> v;\n    for (int i = 0; i < s; i++) {\n        if (was1[i])\n            v.push_back(i);\n    }\n\n    int q = 0;\n    while (q < v.size()) {\n        int x = v[q++];\n        int y = x + p * k;\n        if (y >= 0 && y <= s && !was1[y]) {\n            was1[y] = 1;\n            v.push_back(y);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> s >> k;\n    if (s % k == 0) {\n        cout << k << endl;\n        return;\n    }\n    if (s > k * k) {\n        cout << max(1, k - 2) << endl;\n        return;\n    }\n\n    was1.resize(s + 1);\n    was2.resize(s + 1);\n    for (int i = 0; i <= s; i++) {\n        was1[i] = was2[i] = 0;\n    }\n\n    p = 1;\n    was1[k] = 1;\n    while (1) {\n        bfs();\n        if (was1[s]) {\n            cout << k << endl;\n            return;\n        }\n        k = max(k - 1, 1);\n        p *= -1;\n        for (int i = 0; i <= s; i++) {\n            was2[i] = 0;\n        }\n        for (int i = 0; i < s; i++) {\n            if (was1[i]) {\n                if (i + p * k >= 0 && i + p * k <= s) {\n                    was2[i + p * k] = 1;\n                }\n            }\n        }\n        swap(was1, was2);\n    }\n\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2091f",
      "PROBLEM_ID": "2091F",
      "PROBLEM_STATEMENT": "The visitors of the IT Campus \"NEIMARK\" are not only strong programmers but also physically robust individuals! Some practice swimming, some rowing, and some rock climbing!\n\nMaster Igor is a prominent figure in the local rock climbing community. One day, he went on a mountain hike to ascend one of the peaks. As an experienced climber, Igor decided not to follow the established trails but to use his skills to climb strictly vertically.\n\nIgor found a rectangular vertical section of the mountain and mentally divided it into $n$ horizontal levels. He then split each level into $m$ segments using vertical partitions. Upon inspecting these segments, Igor discovered convenient protrusions that can be grasped (hereafter referred to as holds). Thus, the selected part of the mountain can be represented as an $n \\times m$ rectangle, with some cells containing holds.\n\nBeing an experienced programmer, Igor decided to count the number of valid routes. A route is defined as a sequence of distinct holds. A route is considered valid if the following conditions are satisfied:\n\n- The first hold in the route is located on the very bottom level (row $n$);\n- The last hold in the route is located on the very top level (row $1$);\n- Each subsequent hold is not lower than the previous one;\n- At least one hold is used on each level (i.e., in every row of the rectangle);\n- At most two holds are used on each level (since Igor has only two hands);\n- Igor can reach from the current hold to the next one if the distance between the centers of the corresponding sections does not exceed Igor's arm span.\n\nIgor's arm span is $d$, which means he can move from one hold to another if the Euclidean distance between the centers of the corresponding segments does not exceed $d$. The distance between sections ($i_1, j_1$) and ($i_2, j_2$) is given by $\\sqrt{(i_1 - i_2) ^ 2 + (j_1 - j_2) ^ 2}$.\n\nCalculate the number of different valid routes. Two routes are considered different if they differ in the list of holds used or in the order in which these holds are visited.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\leq t \\leq 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, $d$ ($2 \\leq n \\leq 2000$, $1 \\leq m, d \\leq 2000$).\n\nEach of the following $n$ lines contains $m$ characters\u00a0\u2014 the description of the corresponding level of the mountain. The symbol '#' represents an empty section, and the symbol 'X' represents a section with a hold. The levels are described from top to bottom.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $4 \\cdot 10^6$.\n\n### Output\n\nFor each test case, output the number of different routes modulo $998244353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3 4 1\n\nXX#X\n\n#XX#\n\n#X#X\n\n3 4 2\n\nXX#X\n\n#XX#\n\n#X#X\n\n3 1 3\n\nX\n\nX\n\n#\n\n```\n\n#### Output #1\n\n```\n2\n60\n0\n```\n\n### Note\n\nPossible routes in the first case:\n\n![](https://espresso.codeforces.com/4abfb72944041c37716a0906437d686506431681.png)\n\nIn the second example, Igor's arm span has become larger, so new routes are available to him, for example this one:\n\n![](https://espresso.codeforces.com/5d1a6871d19f072dc888770deff1f3cb1426148b.png)\n\nIn the third example, there are no holds on the lower level, so there are no correct routes.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 998244353;\n\n// Add modulo\ninline int add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\n// Subtract modulo\ninline int subm(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    return a;\n}\n// Multiply modulo\ninline int mul(ll a, ll b) {\n    return int((a * b) % MOD);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m, d;\n        cin >> n >> m >> d;\n        vector<string> grid(n);\n        for (int i = 0; i < n; i++) {\n            cin >> grid[i];\n        }\n\n        // Build list of holds per row, from bottom (row 0) to top (row n-1)\n        vector<vector<int>> c(n);\n        for (int i = 0; i < n; i++) {\n            int row = n - 1 - i; // bottom is grid[n-1]\n            for (int j = 0; j < m; j++) {\n                if (grid[row][j] == 'X') {\n                    c[i].push_back(j);\n                }\n            }\n            // c[i] is naturally sorted by j increasing\n        }\n\n        // Compute D = floor(sqrt(d^2 - 1))\n        ll dd2 = 1LL * d * d - 1;\n        int D;\n        if (dd2 < 0) {\n            D = -1;\n        } else {\n            // integer sqrt\n            ll sq = (ll)floor(sqrt((long double)dd2));\n            while ((sq + 1) * (sq + 1) <= dd2) sq++;\n            while (sq * sq > dd2) sq--;\n            D = int(sq);\n        }\n\n        // DP arrays\n        vector<int> c_cur = c[0];\n        int K_cur = int(c_cur.size());\n        if (K_cur == 0) {\n            // No holds at bottom row\n            cout << 0 << \"\\n\";\n            continue;\n        }\n        vector<int> DP_cur(K_cur, 0);\n\n        // Initial DP for bottom row: DP_cur[x] = number of holds in same row within horizontal distance <= d\n        {\n            int l = 0, r = 0;\n            for (int x = 0; x < K_cur; x++) {\n                int cx = c_cur[x];\n                while (l < K_cur && c_cur[l] < cx - d) l++;\n                while (r + 1 < K_cur && c_cur[r + 1] <= cx + d) r++;\n                // number of holds v s.t. |c_cur[v] - cx| <= d is (r - l + 1)\n                DP_cur[x] = r - l + 1;\n            }\n        }\n\n        // Temporary arrays for transitions\n        vector<ll> prefix;      // prefix sums (64-bit for safety) \n        vector<int> F_prev;     // intermediate sums from previous row\n        vector<int> DP_prev;    // DP for the next row\n\n        // Iterate climbing from row i to row i+1 (i = 0..n-2)\n        for (int i = 1; i < n; i++) {\n            vector<int> &c_prev = c[i];\n            int K_prev = int(c_prev.size());\n            if (K_prev == 0) {\n                // No holds on this row => no valid routes\n                DP_cur.clear();\n                break;\n            }\n            // Build prefix sums of DP_cur over c_cur\n            prefix.assign(K_cur + 1, 0LL);\n            for (int u = 0; u < K_cur; u++) {\n                ll v = prefix[u] + DP_cur[u];\n                if (v >= MOD) v %= MOD;\n                prefix[u + 1] = v;\n            }\n            // Compute F_prev[v]: sum of DP_cur[u] for holds u in row i-1 reachable from v\n            F_prev.assign(K_prev, 0);\n            int lo = 0, hi = -1;\n            for (int v = 0; v < K_prev; v++) {\n                ll left = (ll)c_prev[v] - D;\n                ll right = (ll)c_prev[v] + D;\n                while (lo < K_cur && c_cur[lo] < left) lo++;\n                while (hi + 1 < K_cur && c_cur[hi + 1] <= right) hi++;\n                if (lo <= hi) {\n                    ll sumv = prefix[hi + 1] - prefix[lo];\n                    sumv %= MOD;\n                    if (sumv < 0) sumv += MOD;\n                    F_prev[v] = int(sumv);\n                } else {\n                    F_prev[v] = 0;\n                }\n            }\n            // Build prefix sums of F_prev\n            prefix.assign(K_prev + 1, 0LL);\n            for (int v = 0; v < K_prev; v++) {\n                ll vv = prefix[v] + F_prev[v];\n                if (vv >= MOD) vv %= MOD;\n                prefix[v + 1] = vv;\n            }\n            // Compute DP_prev[x]: for each hold x in this row, sum F_prev[v] for v within horizontal d\n            DP_prev.assign(K_prev, 0);\n            int lo2 = 0, hi2 = -1;\n            for (int x = 0; x < K_prev; x++) {\n                ll left = (ll)c_prev[x] - d;\n                ll right = (ll)c_prev[x] + d;\n                while (lo2 < K_prev && c_prev[lo2] < left) lo2++;\n                while (hi2 + 1 < K_prev && c_prev[hi2 + 1] <= right) hi2++;\n                if (lo2 <= hi2) {\n                    ll sumv = prefix[hi2 + 1] - prefix[lo2];\n                    sumv %= MOD;\n                    if (sumv < 0) sumv += MOD;\n                    DP_prev[x] = int(sumv);\n                } else {\n                    DP_prev[x] = 0;\n                }\n            }\n            // Move to next row\n            c_cur = c_prev;\n            DP_cur.swap(DP_prev);\n            K_cur = K_prev;\n        }\n\n        // If DP_cur empty, no valid routes\n        if (DP_cur.empty()) {\n            cout << 0 << \"\\n\";\n            continue;\n        }\n        // Sum up all ways ending at the top row holds\n        ll ans = 0;\n        for (int x = 0; x < K_cur; x++) {\n            ans += DP_cur[x];\n            if (ans >= MOD) ans %= MOD;\n        }\n        ans %= MOD;\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2091e",
      "PROBLEM_ID": "2091E",
      "PROBLEM_STATEMENT": "Recently, Misha at the IT Campus \"NEIMARK\" camp learned a new topic\u00a0\u2014 the Euclidean algorithm.\n\nHe was somewhat surprised when he realized that $a \\cdot b = lcm(a, b) \\cdot gcd(a, b)$, where $gcd(a, b)$\u00a0\u2014 is [the greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the numbers $a$ and $b$ and $lcm(a, b)$\u00a0\u2014 is [the least common multiple (LCM)](https://en.wikipedia.org/wiki/Least_common_multiple). Misha thought that since the product of LCM and GCD exists, it might be interesting to consider their quotient: $F(a,b)=\\frac{lcm(a, b)}{gcd(a, b)}$.\n\nFor example, he took $a = 2$ and $b = 4$, computed $F(2, 4) = \\frac{4}{2} = 2$ and obtained a prime number (a number is prime if it has exactly two divisors)! Now he considers $F(a, b)$ to be an interesting ratio if $a < b$ and $F(a, b)$ is a prime number.\n\nSince Misha has just started studying number theory, he needs your help to calculate \u2014 how many different pairs of numbers $a$ and $b$ are there such that $F(a, b)$ is an interesting ratio and $1 \\leq a < b \\leq n$?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\leq t \\leq 10^3$). The description of the test cases follows.\n\nA single line of each test case contains a single integer $n$ ($2 \\leq n \\leq 10^7$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^7$.\n\n### Output\n\nFor each test case, output the number of interesting ratios $F(a, b)$ for pairs satisfying $1 \\leq a < b \\leq n$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n5\n\n10\n\n34\n\n10007\n\n```\n\n#### Output #1\n\n```\n4\n11\n49\n24317\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    vector<int> n_values(t);\n    int max_n = 0;\n    for (int i = 0; i < t; i++) {\n        cin >> n_values[i];\n        max_n = max(max_n, n_values[i]);\n    }\n    \n    // Sieve to find all primes up to max_n\n    vector<bool> is_prime(max_n + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i * i <= max_n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= max_n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Collect all primes up to max_n\n    vector<int> primes;\n    for (int i = 2; i <= max_n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    for (int n : n_values) {\n        // Count interesting ratios\n        long long count = 0;\n        for (int p : primes) {\n            if (p > n) break;\n            count += n / p;\n        }\n        \n        cout << count << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2091c",
      "PROBLEM_ID": "2091C",
      "PROBLEM_STATEMENT": "At the IT Campus \"NEIMARK\", there are several top-secret rooms where problems for major programming competitions are developed. To enter one of these rooms, you must unlock a circular lock by selecting the correct code. This code is updated every day.\n\nToday's code is a permutation$^{\\text{\u2217}}$ of the numbers from $1$ to $n$, with the property that in every cyclic shift$^{\\text{\u2020}}$ of it, there is exactly one fixed point. That is, in every cyclic shift, there exists exactly one element whose value is equal to its position in the permutation.\n\nOutput any valid permutation that satisfies this condition. Keep in mind that a valid permutation might not exist, then output $-1$.\n\n$^{\\text{\u2217}}$A permutation is defined as a sequence of length $n$ consisting of integers from $1$ to $n$, where each number appears exactly once. For example, (2 1 3), (1), (4 3 1 2) are permutations; (1 2 2), (3), (1 3 2 5) are not.\n\n$^{\\text{\u2020}}$A cyclic shift of an array is obtained by moving the last element to the beginning of the array. A permutation of length $n$ has exactly $n$ cyclic shifts.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\leq t \\leq 500$). The description of the test cases follows.\n\nA single line of each test case contains a single integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the desired permutation. If multiple solutions exist, output any one of them. If no suitable permutations exist, output $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4\n\n5\n\n3\n\n```\n\n#### Output #1\n\n```\n-1\n4 1 3 5 2\n1 3 2\n```\n\n### Note\n\nIn the second example, there is a permutation such that in each cyclic shift there is a fixed point (highlighted in dark red):\n\n![](https://espresso.codeforces.com/e1f7f024e13851731c4a34d583c32d16a0e2a8e9.png)\n\nThe first line contains the element numbers, and the second line contains all the shifts of the desired permutation.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        // If n is even, no solution exists\n        if (n % 2 == 0) {\n            cout << \"-1\" << endl;\n            continue;\n        }\n        \n        vector<int> pos(n), P(n + 1);\n        \n        // For each cyclic shift j, compute the position where the fixed point will be\n        for (int j = 0; j < n; j++) {\n            pos[j] = (2 * j % n) + 1;\n        }\n        \n        // Derive the permutation using the constraint that in shift j,\n        // the fixed point is at position pos[j]\n        for (int j = 0; j < n; j++) {\n            int idx = ((pos[j] - j + n) % n) + 1;\n            P[idx] = pos[j];\n        }\n        \n        // Output the permutation\n        for (int i = 1; i <= n; i++) {\n            cout << P[i] << (i == n ? \"\\n\" : \" \");\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2091b",
      "PROBLEM_ID": "2091B",
      "PROBLEM_STATEMENT": "At the IT Campus \"NEIMARK\", there are training sessions in competitive programming\u00a0\u2014 both individual and team-based!\n\nFor the next team training session, $n$ students will attend, and the skill of the $i$-th student is given by a positive integer $a_i$.\n\nThe coach considers a team strong if its strength is at least $x$. The strength of a team is calculated as the number of team members multiplied by the minimum skill among the team members.\n\nFor example, if a team consists of $4$ members with skills $[5, 3, 6, 8]$, then the team's strength is $4 \\cdot min([5, 3, 6, 8]) = 12$.\n\nOutput the maximum possible number of strong teams, given that each team must have at least one participant and every participant must belong to exactly one team.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\leq t \\leq 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\leq n \\leq 2 \\cdot 10^5$, $1 \\leq x \\leq 10^9$)\u00a0\u2014 the number of students in training and the minimum strength of a team to be considered strong.\n\nThe second line of each test case contains $n$ integers $a_i$ ($1 \\leq a_i \\leq 10^9$)\u00a0\u2014 the skill of each student.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the maximum possible number of teams with strength at least $x$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n6 4\n\n4 5 3 3 2 6\n\n4 10\n\n4 2 1 3\n\n5 3\n\n5 3 2 3 2\n\n3 6\n\n9 1 7\n\n6 10\n\n6 1 3 6 3 2\n\n```\n\n#### Output #1\n\n```\n4\n0\n4\n2\n1\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid solve() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, x;\n        cin >> n >> x;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n\n        // Sort skills in descending order\n        sort(a.rbegin(), a.rend());\n\n        int teamCount = 0;  // Maximum number of strong teams\n        int members = 0;    // Current number of members in the ongoing team\n\n        for (int i = 0; i < n; ++i) {\n            ++members;  // Add the current student to the team\n            if (a[i] * members >= x) {\n                // Form a team since it meets the strength criteria\n                ++teamCount;\n                members = 0;  // Reset members for a new team\n            }\n        }\n\n        cout << teamCount << \"\\n\";\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    solve();\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2091a",
      "PROBLEM_ID": "2091A",
      "PROBLEM_STATEMENT": "The final of the first Olympiad by IT Campus \"NEIMARK\" is scheduled for March 1, 2025. A nameless intern was tasked with forming the date of the Olympiad using digits\u00a0\u2014 01.03.2025.\n\nTo accomplish this, the intern took a large bag of digits and began drawing them one by one. In total, he drew $n$ digits\u00a0\u2014 the digit $a_i$ was drawn in the $i$-th turn.\n\nYou suspect that the intern did extra work. Determine at which step the intern could have first assembled the digits to form the date of the Olympiad (the separating dots can be ignored), or report that it is impossible to form this date from the drawn digits. Note that leading zeros must be displayed.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\leq t \\leq 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 20$).\n\nThe second line of each test case contains $n$ integers $a_i$ ($0 \\leq a_i \\leq 9$)\u00a0\u2014 the numbers that the intern pulled out in chronological order.\n\n### Output\n\nFor each test case, output the minimum number of digits that the intern could pull out. If all the digits cannot be used to make a date, output the number $0$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n10\n\n2 0 1 2 3 2 5 0 0 1\n\n8\n\n2 0 1 2 3 2 5 0\n\n8\n\n2 0 1 0 3 2 5 0\n\n16\n\n2 3 1 2 3 0 1 9 2 1 0 3 5 4 0 3\n\n```\n\n#### Output #1\n\n```\n9\n0\n8\n15\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        \n        // The date \"01032025\" requires:\n        int need0 = 3, need1 = 1, need2 = 2, need3 = 1, need5 = 1;\n        \n        int have0 = 0, have1 = 0, have2 = 0, have3 = 0, have5 = 0;\n        int step;\n        bool found = false;\n        \n        for (step = 0; step < n; step++) {\n            if (a[step] == 0) have0++;\n            else if (a[step] == 1) have1++;\n            else if (a[step] == 2) have2++;\n            else if (a[step] == 3) have3++;\n            else if (a[step] == 5) have5++;\n            \n            // Check if we have all required digits\n            if (have0 >= need0 && have1 >= need1 && have2 >= need2 && have3 >= need3 && have5 >= need5) {\n                found = true;\n                break;\n            }\n        }\n        \n        if (found) {\n            cout << step + 1 << endl;  // +1 because steps are 1-indexed\n        } else {\n            cout << 0 << endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2090c",
      "PROBLEM_ID": "2090C",
      "PROBLEM_STATEMENT": "Inside the large kingdom, there is an infinite dining hall. It can be represented as a set of cells ($x, y$), where $x$ and $y$ are non-negative integers. There are an infinite number of tables in the hall. Each table occupies four cells ($3x + 1, 3y + 1$), ($3x + 1, 3y + 2$), ($3x + 2, 3y + 1$), ($3x + 2, 3y + 2$), where $x$ and $y$ are arbitrary non-negative integers. All cells that do not belong to any of the tables are corridors.\n\nThere are $n$ guests that come to the dining hall one by one. Each guest appears in the cell $(0, 0)$ and wants to reach a table cell. In one step, they can move to any neighboring by side corridor cell, and in their last step, they must move to a neighboring by side a free table cell. They occupy the chosen table cell, and no other guest can move there.\n\nEach guest has a characteristic $t_i$, which can either be $0$ or $1$. They enter the hall in order, starting to walk from the cell ($0, 0$). If $t_i=1$, the $i$-th guest walks to the nearest vacant table cell. If $t_i=0$, they walk to the nearest table cell that belongs to a completely unoccupied table. Note that other guests may choose the same table later.\n\nThe distance is defined as the smallest number of steps needed to reach the table cell. If there are multiple table cells at the same distance, the guests choose the cell with the smallest $x$, and if there are still ties, they choose among those the cell with the smallest $y$.\n\nFor each guest, find the table cell which they choose.\n\n### Input\n\nThe first line contains a single integer $q$ ($1 \\leq q \\leq 5000$)\u00a0\u2014 the number of test cases. Then follows their description.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 50\\,000$)\u00a0\u2014 the number of guests.\n\nThe second line of each test case contains $n$ integers $t_1, t_2, \\ldots, t_n$ ($t_i \\in \\{0, 1\\}$) \u2014 the characteristics of the guests.\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $50\\,000$.\n\n### Output\n\nFor each test case, output $n$ lines\u00a0\u2014 for each guest, the cell where they sit.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n6\n\n0 1 1 0 0 1\n\n5\n\n1 0 0 1 1\n\n```\n\n#### Output #1\n\n```\n1 1\n1 2\n2 1\n1 4\n4 1\n1 5\n1 1\n1 4\n4 1\n1 2\n2 1\n```\n\n### Note\n\nConsider the first test case:\n\nThe distance from the first guest to the cell ($1, 1$) is $2$, so he sits there.\n\nThe distance from the second guest to the cell ($1, 2$) is $3$, as is the distance to the cell ($2, 1$), but since the first coordinate is smaller for the first option, he will choose it.\n\nThe distance from the third guest to the cell ($2, 1$) is $3$, so he will choose it.\n\nThe distance from the fourth guest to the cell ($1, 4$) is $5$, and he will choose it.\n\nThe distance from the fifth guest to the cell ($4, 1$) is $5$.\n\nThe distance from the sixth guest to the cell ($1, 5$) is $6$, as is the distance to the cell ($2, 2$), but since the first coordinate is smaller, he will choose the first option.\n\n![](https://espresso.codeforces.com/de2d3d52460fa589b580b4819006756c0733b1ab.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int CMAX = 1005;         // corridor grid size will be [0..CMAX]\nconst int TMAX = 350;          // table grid size [0..CMAX/3+1 <= 335]\nstatic bool visitedCorr[CMAX+1][CMAX+1];\nstatic bool tableMark[CMAX+1][CMAX+1];\nstatic int16_t distCorr[CMAX+1][CMAX+1];\n\nstatic bool seatUsed[CMAX+1][CMAX+1];\nstatic bool occupancyFlag[TMAX][TMAX];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int q;\n    cin >> q;\n    vector<int> ns(q);\n    vector<vector<int>> tests(q);\n    int max_n = 0;\n    for (int i = 0; i < q; i++) {\n        cin >> ns[i];\n        max_n = max(max_n, ns[i]);\n        tests[i].resize(ns[i]);\n        for (int j = 0; j < ns[i]; j++) {\n            cin >> tests[i][j];\n        }\n    }\n\n    // Determine how many table-cell entries we need to precompute.\n    // We use a factor of 5 to cover skips in A-list, plus a small margin.\n    int target = max_n * 5 + 5;\n    vector<array<int,3>> tableCells;\n    tableCells.reserve(target);\n\n    // BFS on corridor cells to discover table cells by increasing distance\n    // Corridor cell: (x%3==0 || y%3==0). Table cell otherwise.\n    // We record each table cell (nx,ny) with its distance = corridor-dist + 1.\n    // We stop when we have 'target' table cells discovered.\n    // Clear visited arrays\n    for (int i = 0; i <= CMAX; i++) {\n        for (int j = 0; j <= CMAX; j++) {\n            visitedCorr[i][j] = false;\n            tableMark[i][j] = false;\n        }\n    }\n    vector<pair<int,int>> qv;\n    qv.reserve((CMAX+1)*(CMAX+1)/2);\n    int head = 0;\n    visitedCorr[0][0] = true;\n    distCorr[0][0] = 0;\n    qv.emplace_back(0,0);\n\n    static const int dx[4] = {1,-1,0,0};\n    static const int dy[4] = {0,0,1,-1};\n\n    bool done = false;\n    while (head < (int)qv.size() && !done) {\n        int x = qv[head].first;\n        int y = qv[head].second;\n        int d = distCorr[x][y];\n        head++;\n        for (int dir = 0; dir < 4; dir++) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx < 0 || ny < 0 || nx > CMAX || ny > CMAX) continue;\n            // Corridor?\n            if ((nx % 3) == 0 || (ny % 3) == 0) {\n                if (!visitedCorr[nx][ny]) {\n                    visitedCorr[nx][ny] = true;\n                    distCorr[nx][ny] = d + 1;\n                    qv.emplace_back(nx, ny);\n                }\n            } else {\n                // It's a table cell\n                if (!tableMark[nx][ny]) {\n                    tableMark[nx][ny] = true;\n                    tableCells.push_back({d + 1, nx, ny});\n                    if ((int)tableCells.size() >= target) {\n                        done = true;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // Sort the discovered table cells by (distance, x, y)\n    sort(tableCells.begin(), tableCells.end(),\n         [](auto &a, auto &b) {\n             if (a[0] != b[0]) return a[0] < b[0];\n             if (a[1] != b[1]) return a[1] < b[1];\n             return a[2] < b[2];\n         });\n\n    // Simulation per test\n    // We'll maintain two pointers posA (for t=0 picks from A-list)\n    // and posB (for t=1 picks from B-list).\n    // We also track seatUsed[x][y] and occupancyFlag[u][v] for tables.\n    for (int ti = 0; ti < q; ti++) {\n        int n = ns[ti];\n        auto &tarr = tests[ti];\n\n        // Reserve space for clearing later\n        vector<pair<int,int>> usedSeats;\n        usedSeats.reserve(n);\n        vector<pair<int,int>> touchedTables;\n        touchedTables.reserve(n);\n\n        vector<pair<int,int>> answer(n);\n\n        int posA = 0, posB = 0;\n        for (int i = 0; i < n; i++) {\n            if (tarr[i] == 0) {\n                // t=0: pick from A-list: nearest cell in a completely unoccupied table\n                while (true) {\n                    auto &cell = tableCells[posA];\n                    int x = cell[1], y = cell[2];\n                    int u = x / 3, v = y / 3;\n                    if (!occupancyFlag[u][v]) {\n                        // found\n                        answer[i] = {x, y};\n                        occupancyFlag[u][v] = true;\n                        touchedTables.emplace_back(u, v);\n                        seatUsed[x][y] = true;\n                        usedSeats.emplace_back(x, y);\n                        posA++;\n                        break;\n                    }\n                    posA++;\n                }\n            } else {\n                // t=1: pick from B-list: nearest vacant table cell\n                while (true) {\n                    auto &cell = tableCells[posB];\n                    int x = cell[1], y = cell[2];\n                    if (!seatUsed[x][y]) {\n                        int u = x / 3, v = y / 3;\n                        answer[i] = {x, y};\n                        if (!occupancyFlag[u][v]) {\n                            occupancyFlag[u][v] = true;\n                            touchedTables.emplace_back(u, v);\n                        }\n                        seatUsed[x][y] = true;\n                        usedSeats.emplace_back(x, y);\n                        posB++;\n                        break;\n                    }\n                    posB++;\n                }\n            }\n        }\n\n        // Output answers for this test\n        for (int i = 0; i < n; i++) {\n            cout << answer[i].first << ' ' << answer[i].second << '\\n';\n        }\n\n        // Clear used flags for next test\n        for (auto &p : usedSeats) {\n            seatUsed[p.first][p.second] = false;\n        }\n        for (auto &p : touchedTables) {\n            occupancyFlag[p.first][p.second] = false;\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2090b",
      "PROBLEM_ID": "2090B",
      "PROBLEM_STATEMENT": "Ecrade has an $n \\times m$ grid, originally empty, and he has pushed several (possibly, zero) balls in it.\n\nEach time, he can push one ball into the grid either from the leftmost edge of a particular row or the topmost edge of a particular column of the grid.\n\nWhen a ball moves towards a position:\n\n- If there is no ball originally at that position, the incoming ball will stop and occupy the position.\n- If there is already a ball at that position, the incoming ball will stop and occupy the position, while the original ball will continue moving to the next position in the same direction.\n\nNote that if a row or column is full (i.e., all positions in that row or column have balls), he cannot push a ball into that row or column.\n\nGiven the final state of whether there is a ball at each position of the grid, you need to determine whether it is possible for Ecrade to push the balls to reach the final state.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10\\,000$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 50$).\n\nThis is followed by $n$ lines, each containing exactly $m$ characters and consisting only of $0$ and $1$, describing the final state of the grid. There is a ball at one position of the grid if and only if the corresponding position of the given input is $1$.\n\nIt is guaranteed that the sum of $n\\cdot m$ over all test cases does not exceed $10\\,000$.\n\n### Output\n\nFor each test case, output \"Yes\" (without quotes) if it is possible for Ecrade to push the balls to reach the final state, and \"No\" (without quotes) otherwise.\n\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"YES\", \"yEs\" and \"yes\" will be recognized as a positive response).\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3 3\n\n001\n\n001\n\n110\n\n3 3\n\n010\n\n111\n\n010\n\n3 3\n\n111\n\n111\n\n111\n\n3 3\n\n000\n\n000\n\n000\n\n3 3\n\n000\n\n000\n\n001\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nYES\nYES\nNO\n```\n\n### Note\n\nFor simplicity, if Ecrade pushes a ball from the leftmost edge of the $i$-th row, we call the operation $\\text{ROW}\\ i$; if he pushes a ball from the topmost edge of the $i$-th column, we call the operation $\\text{COL}\\ i$.\n\nFor intuitive understanding, a non-zero number $x$ in the matrix given below represents the $x$-th ball that is pushed in.\n\nIn the first test case, a possible series of operations:\n\n$\\begin{pmatrix}0&0&0\\\\0&0&0\\\\0&0&0\\end{pmatrix}\\xrightarrow{\\text{ROW}\\ 3}\\xrightarrow{\\text{ROW}\\ 3} \\begin{pmatrix}0&0&0\\\\0&0&0\\\\2&1&0\\end{pmatrix}\\xrightarrow{\\text{COL}\\ 3}\\xrightarrow{\\text{COL}\\ 3} \\begin{pmatrix}0&0&4\\\\0&0&3\\\\2&1&0\\end{pmatrix}$\n\nIn the second test case, a possible series of operations:\n\n$\\begin{pmatrix}0&0&0\\\\0&0&0\\\\0&0&0\\end{pmatrix}\\xrightarrow{\\text{ROW}\\ 2}\\xrightarrow{\\text{ROW}\\ 2}\\xrightarrow{\\text{ROW}\\ 2} \\begin{pmatrix}0&0&0\\\\3&2&1\\\\0&0&0\\end{pmatrix}\\xrightarrow{\\text{COL}\\ 2}\\xrightarrow{\\text{COL}\\ 2} \\begin{pmatrix}0&5&0\\\\3&4&1\\\\0&2&0\\end{pmatrix}$\n\nIn the third test case, a possible series of operations:\n\n$\\begin{pmatrix}0&0&0\\\\0&0&0\\\\0&0&0\\end{pmatrix}\\xrightarrow{\\text{ROW}\\ 1}\\xrightarrow{\\text{ROW}\\ 2}\\xrightarrow{\\text{ROW}\\ 3} \\begin{pmatrix}1&0&0\\\\2&0&0\\\\3&0&0\\end{pmatrix}\\xrightarrow{\\text{COL}\\ 3}\\xrightarrow{\\text{COL}\\ 3}\\xrightarrow{\\text{COL}\\ 3} \\begin{pmatrix}1&0&6\\\\2&0&5\\\\3&0&4\\end{pmatrix}\\xrightarrow{\\text{ROW}\\ 1}\\xrightarrow{\\text{ROW}\\ 2}\\xrightarrow{\\text{ROW}\\ 3} \\begin{pmatrix}7&1&6\\\\8&2&5\\\\9&3&4\\end{pmatrix}$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> grid[i];\n    }\n    \n    bool possible = true;\n    for (int i = 0; i < n && possible; ++i) {\n        for (int j = 0; j < m && possible; ++j) {\n            if (grid[i][j] == '1') {\n                // Check if there's a 0 to the left in the same row\n                bool left_ok = true;\n                for (int k = 0; k < j; ++k) {\n                    if (grid[i][k] == '0') {\n                        left_ok = false;\n                        break;\n                    }\n                }\n                // Check if there's a 0 above in the same column\n                bool top_ok = true;\n                for (int k = 0; k < i; ++k) {\n                    if (grid[k][j] == '0') {\n                        top_ok = false;\n                        break;\n                    }\n                }\n                if (!left_ok && !top_ok) {\n                    possible = false;\n                }\n            }\n        }\n    }\n    cout << (possible ? \"YES\" : \"NO\") << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2089e",
      "PROBLEM_ID": "2089E",
      "PROBLEM_STATEMENT": "The world of the black cat is collapsing.\n\nIn this world, which can be represented as a rooted tree with root at node $1$, Liki and Sasami need to uncover the truth about the world.\n\nEach day, they can explore a node $u$ that has not yet collapsed. After this exploration, the black cat causes $u$ and all nodes in its subtree to collapse. Additionally, at the end of the $i$ th day, if it exists, the number $n-i+1$ node will also collapse.\n\nFor each $i$ from $1$ to $n$, determine the number of exploration schemes where Liki and Sasami explore exactly $i$ days (i.e., they perform exactly $i$ operations), with the last exploration being at node $1$. The result should be computed modulo $998\\,244\\,353$.\n\nNote: It is guaranteed that nodes $1$ to $n$ can form a \"DFS\" order of the tree, meaning there exists a depth-first search traversal where the $i$ th visited node is $i$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains exactly one number $n$ ($3 \\le n \\le 80$).\n\nEach of the following $n - 1$ lines contains two integers $u_i$ and $v_i$, representing two vertices connected by an edge ($1 \\le u_i, v_i \\le n$). It is guaranteed that the given edges form a tree. It is also guaranteed that the vertices can form a \"DFS\" traversal order.\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $80$\n\n### Output\n\nFor each test case, print $n$ integers, where the $i$ th integer represents the number of exploration schemes for exactly $i$ days, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n4\n\n1 2\n\n2 3\n\n2 4\n\n7\n\n4 2\n\n6 1\n\n5 1\n\n7 6\n\n2 3\n\n1 2\n\n```\n\n#### Output #1\n\n```\n1 3 3 1\n1 6 23 48 43 17 1\n```\n\n### Note\n\nFor the first test case, the following operation sequences are legal:\n\n$\\{1\\},\\{2,1\\},\\{3,1\\},\\{4,1\\},\\{3,2,1\\},\\{4,2,1\\},\\{4,3,1\\},\\{4,3,2,1\\}$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint read() {\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') {\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();\n\treturn x*f;\n}\nnamespace tokido_saya {\n\tconst int maxn=81,mod=998244353;\n\ttypedef vector<int>::iterator iter;\n\tint n,lp[maxn],rp[maxn],siz[maxn],t;\n\tvector<int> v[maxn];\n\tll f[maxn][maxn][maxn][maxn],dp[maxn][maxn],fac[maxn],inv[maxn];\n\tint zc[maxn][maxn][maxn][maxn];\n\tll qpow(ll x,int y)\n\t{\n\t\tll w=1;\n\t\twhile(y)\n\t\t{\n\t\t\tif(y&1)w=w*x%mod;\n\t\t\tx=x*x%mod,y>>=1;\n\t\t}\n\t\treturn w;\n\t}\n\tll C(int x,int y)\n\t{\n\t\tif(y<0||y>x)return 0;\n\t\treturn fac[x]*inv[x-y]%mod*inv[y]%mod;\n\t}\n\tvoid dfs1(int u)\n\t{\n\t\tlp[u]=rp[u]=u;\n\t\tfor(iter it=v[u].begin();it!=v[u].end();it++)dfs1(*it),rp[u]=max(rp[u],rp[*it]);\n\t}\n\tvoid dfs2(int u)\n\t{\n\t\tf[u][0][0][0]=1,dp[u][0]=1;\n\t\tfor(iter it=v[u].begin();it!=v[u].end();it++)\n\t\t{\n\t\t\tint v=*it;\n\t\t\tdfs2(v);\n\t\t\tfor(int i=siz[u];i>=0;i--)\n\t\t\t\tfor(int j=siz[v];j;j--)dp[u][i+j]=(dp[u][i+j]+dp[u][i]*dp[v][j]%mod*C(i+j,j))%mod;\n\t\t\tfor(int j1=0;j1<=siz[v];j1++)\n\t\t\t\tfor(int k1=0;k1<=min(j1+1,siz[v]);k1++)\n\t\t\t\t{\n\t\t\t\t\tmemset(zc[j1][k1],0,sizeof(zc[j1][k1]));\n\t\t\t\t\tfor(int j=0;j<=siz[u];j++)\n\t\t\t\t\t\tfor(int k=0;k<=j+1;k++)\n\t\t\t\t\t\t\tfor(int w=0;w<=min(k1,j);w++)zc[j1][k1][j+j1-w][k+k1-w]=(zc[j1][k1][j+j1-w][k+k1-w]+f[u][0][j][k]*C(j,w)%mod*C(k+k1-w,k))%mod;\n\t\t\t\t}\t\n\t\t\tmemset(f[u][0],0,sizeof(f[u][0]));\n\t\t\tfor(int j=0;j<=siz[v];j++)\n\t\t\t\tfor(int k=0;k<=j+1;k++)\n\t\t\t\t\tfor(int j1=0;j1<=siz[u]+siz[v];j1++)\n\t\t\t\t\t\tfor(int k1=0;k1<=min(siz[u]+siz[v],j1+1);k1++)\n\t\t\t\t\t\t\tif(zc[j][k][j1][k1])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconst int w=zc[j][k][j1][k1];\n\t\t\t\t\t\t\t\tf[u][0][j1][k1]=(f[u][0][j1][k1]+f[v][0][j][k]*w)%mod;\n\t\t\t\t\t\t\t\tfor(int i=lp[v];i<=rp[v];i++)f[u][i][j1][k1]=(f[u][i][j1][k1]+f[v][i][j][k]*w)%mod;\n\t\t\t\t\t\t\t}\n\t\t\tfor(int i=rp[v]+1;i<=rp[u];i++)\n\t\t\t\tfor(int j=siz[u]-1;j>=i-rp[v]-1;j--)\n\t\t\t\t\tfor(int k=j+1;k>=0;k--)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst int val=f[u][i][j][k];\n\t\t\t\t\t\tf[u][i][j][k]=0;\n\t\t\t\t\t\tfor(int p=0;p<=siz[v];p++)\n\t\t\t\t\t\t\tfor(int w=0;w<=min(p,j-(i-rp[v]-1));w++)f[u][i][j+siz[v]-w][k+p-w]=(f[u][i][j+siz[v]-w][k+p-w]+dp[v][p]*val%mod*C(j-(i-rp[v]-1),w)%mod*C(k+p-w,k))%mod;\n\t\t\t\t\t}\n\t\t\tsiz[u]+=siz[v];\n\t\t}\n\t\tfor(int i=siz[u];i>=0;i--)dp[u][i+1]=(dp[u][i+1]+dp[u][i])%mod;\n\t\tif(u!=1)for(int j=siz[u];j>=0;j--)\n\t\t\tfor(int k=min(j+1,siz[u]);k>=0;k--)\n\t\t\t{\n\t\t\t\tll sum=0;\n\t\t\t\tfor(int i=rp[u];i>=lp[u];i--)\n\t\t\t\t{\n\t\t\t\t\tconst int w=f[u][i][j][k];\n\t\t\t\t\tf[u][i][j+1][k]=(f[u][i][j+1][k]+w)%mod;\n\t\t\t\t\tif(j==siz[u]-1)f[u][i][j+1][k+1]=(f[u][i][j+1][k+1]+w)%mod;\n\t\t\t\t\tf[u][i][j][k]=sum,sum=(sum+w)%mod;\n\t\t\t\t}\n\t\t\t\tconst int w=f[u][0][j][k];\n\t\t\t\tf[u][lp[u]][j][k]=(f[u][lp[u]][j][k]+w)%mod,f[u][0][j+1][k]=(f[u][0][j+1][k]+w+sum)%mod;\n\t\t\t\tif(j==siz[u])f[u][0][j+1][k+1]=(f[u][0][j+1][k+1]+w)%mod,f[u][lp[u]][j][k+1]=(f[u][lp[u]][j][k+1]+w)%mod;\n\t\t\t}\n\t\tsiz[u]++;\n\t}\n\tint main() {\n\t\tint x,y;\n\t\tt=read(),fac[0]=1;\n\t\tfor(int i=1;i<=80;i++)fac[i]=fac[i-1]*i%mod;\n\t\tinv[80]=qpow(fac[80],mod-2);\n\t\tfor(int i=80;i;i--)inv[i-1]=inv[i]*i%mod;\n\t\twhile(t--)\n\t\t{\n\t\t\tn=read(),memset(f,0,sizeof(f)),memset(dp,0,sizeof(dp)),memset(siz,0,sizeof(siz));\n\t\t\tfor(int i=1;i<=n;i++)v[i].clear();\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tx=read(),y=read();\n\t\t\t\tif(x>y)swap(x,y);\n\t\t\t\tv[x].push_back(y);\n\t\t\t}\n\t\t\tfor(int i=1;i<n;i++)sort(v[i].begin(),v[i].end()),reverse(v[i].begin(),v[i].end());\n\t\t\tdfs1(1),dfs2(1);\n\t\t\tfor(int i=n;i>1;i--)printf(\"%lld \",f[1][i][i-2][0]);\n\t\t\tputs(\"1\");\n\t\t}\n\t\treturn 0;\n\t}\n}\nint main() {\n\treturn tokido_saya::main();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2089d",
      "PROBLEM_ID": "2089D",
      "PROBLEM_STATEMENT": "In C++, the conditional operator ?: is used as the value of x?y:z is $y$ if $x$ is true; otherwise, the value is $z$. $x$, $y$, and $z$ may also be expressions. It is right-associated; that is, a?b:c?d:e is equivalent to a?b:(c?d:e). $0$ means false and $1$ means true.\n\nGiven a binary string with length $2n+1$, you need to show whether the value of the expression can be $1$ after inserting $n$ conditional operators into the string. You can use parentheses. For example, the string 10101 can be transformed into (1?0:1)?0:1, whose value is $1$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10\\,000)$, the number of test cases. The description of the test cases follows.\n\nIn the first line of each test case, there is a single integer $n$ ($1 \\le n \\le 1.5 \\cdot 10^5)$.\n\nIn the second line of each test case, there is a binary string of length $2n + 1$.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $1.5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, on the first line, output Yes if the string can be transformed into an expression of value $1$; otherwise, output No.\n\nIf the answer is Yes, output the expression on the second line. You can use parentheses, but the order of the characters in the original string must remain the same. The length of your expression must be no more than $10n+1000$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n2\n\n10101\n\n2\n\n00000\n\n```\n\n#### Output #1\n\n```\nYes\n(1?0:1)?(0):1\nNo\n```\n\n### Note\n\nThe first test case\u00a0\u2014 is the one mentioned in the problem description.\n\nIn the second test case, it is clear that regardless of how the conditional operator is used, the result will always be zero.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nchar s[333333];\nchar val(char x,char y,char z){\n\treturn x=='1'?y:z;\n}\nstd::pair<std::string, char> fold(int l,int r){\n\tstd::string str;\n\tchar v=s[r];\n\tfor(int i=l;i<r;i+=2){\n\t\tstr+=s[i];\n\t\tstr+='?';\n\t\tstr+=s[i+1];\n\t\tstr+=':';\n\t}\n\tstr+=s[r];\n\tfor(int i=r-2;i>=l;i-=2){\n\t\tv=val(s[i],s[i+1],v);\n\t}\n\treturn std::make_pair(str,v);\n}\nvoid solve(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tn=2*n+1;\n\tscanf(\"%s\",s+1);\n\tint last=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(s[i]=='1'&&last>0){\n\t\t\tif(i%2==0&&last&1){\n\t\t\t\tputs(\"Yes\");\n\t\t\t\tstd::string s4=fold(last+1,i).first;\n\t\t\t\tauto tmp=fold(i+1,n);\n\t\t\t\tstd::string s5=tmp.first;\n\t\t\t\tchar v5=tmp.second;\n\t\t\t\tif(last==1){\n\t\t\t\t\tprintf(\"1?(%s):(%s)\\n\",s4.c_str(),s5.c_str());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttmp=fold(1,last-2);\n\t\t\t\tstd::string s1=tmp.first;\n\t\t\t\tchar v1=tmp.second;\n\t\t\t\tif(v1=='1'){\n\t\t\t\t\tprintf(\"(%s)?(%c?1:(%s)):(%s)\\n\",s1.c_str(),s[last-1],s4.c_str(),s5.c_str());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tprintf(\"((%s)?%c:1)?(%s):(%s)\\n\",s1.c_str(),s[last-1],s4.c_str(),s5.c_str());\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(s[i]=='1'){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tif(s[n]=='1'&&std::string(s+1)!=\"101\"){\n\t\tputs(\"Yes\");\n\t\tauto left=s[1]=='0'?fold(1,1):fold(1,3);\n\t\tauto mid=s[1]=='0'?fold(2,n-1):fold(4,n-1);\n\t\tprintf(\"(%s)?(%s):1\\n\",left.first.c_str(),mid.first.c_str());\n\t\treturn;\n\t}\n\tputs(\"No\");\n\treturn;\n}\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tsolve();\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2089c2",
      "PROBLEM_ID": "2089C2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, $k$ can be non-zero. You can hack only if you solved all versions of this problem.\n\nA toy box is a refrigerator filled with childhood delight. Like weakness, struggle, hope ... When such a sleeper is reawakened, what kind of surprises will be waiting?\n\nM received her toy box as a birthday present from her mother. A jewellery designer would definitely spare no effort in decorating yet another priceless masterpiece as a starry firmament with exquisitely shaped gemstones. In addition, $l$ distinct locks secure the tiny universe of her lovely daughter: a hair clip featuring a flower design, a weathered feather pen, a balloon shaped like the letter M ... each piece obscures a precious moment.\n\nA few days ago, M rediscovered her toy box when she was reorganizing her bedroom, along with a ring of keys uniquely designed for the toy box. Attached to the key ring are $(l + k)$ keys, of which $l$ keys are able to open one of the $l$ locks correspondingly, while the other $k$ keys are nothing but counterfeits to discourage brute-force attack. To remind the correspondence, M's mother adorned each key with a gemstone of a different type. However, passing days have faded M's memory away.\n\n\"... So I have to turn to you all,\" M said while laying that ring of keys on the table.\n\nK picked up the keys and examined them carefully. \"The appearance of these keys unveils nothing fruitful. Thus, I am afraid that we shall inspect them sequentially.\"\n\nAlthough everyone is willing to help M, nobody has a plan. Observing others' reactions, T suggested, \"Let's play a game. Everyone tries a key in turn, and who opens the most locks is amazing.\"\n\n$n$ members, including M herself, take turns to unlock the toy box recursively in the same order until all the $l$ locks are unlocked. At each turn, the current member only selects a single key and tests it on exactly one of the locks. To open the toy box as soon as possible, every member chooses the key and the lock that maximize the probability of being a successful match. If there are multiple such pairs, a member will randomly choose one of such pairs with equal probability. Apparently, if a lock has been matched with a key, then neither the lock nor the key will be chosen again in following attempts.\n\nAssume that at the very beginning, the probability that a lock can be opened by any key is equal. If everyone always tries the optimal pairs of keys and locks based on all the historical trials, what will the expected number of successful matches be for each member?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe only line of the input contains three integers, $n$, $l$, $k$ ($1 \\leq n \\leq 100, 1 \\leq l \\leq 5000, 0 \\leq k \\leq 25$)\u00a0\u2014 the number of members participating in the game, the number of locks, and the number of counterfeit keys.\n\nIt is guaranteed that the sum of $l$ across all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, output a single line with $n$ integers $e_1, \\ldots, e_n$, where $e_i$ represents the expected number of successful matches, modulo $10^9 + 7$.\n\nFormally, let $M = 10^9 + 7$. It can be shown that the exact answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $e_i$ that $0 \\le x < M$ and $e_i \\cdot q \\equiv p \\pmod{M}$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 1 4\n\n3 2 0\n\n25 2 5\n\n4 102 9\n\n```\n\n#### Output #1\n\n```\n800000006 800000006 400000003\n500000004 1 500000004\n142857144 166666668 615646263 639455787 234126986 257936510 195918369 502040820 478316330 81264173 190523433 471438023 23809524 0 0 0 0 0 0 0 0 0 0 0 0\n568832210 85779764 969938175 375449967\n```\n\n### Note\n\nFor the first test case, there is only $1$ lock, so the strategy will always be choosing any key that no one has ever tried. Since there are $1 + 4 = 5$ keys in total, the probability that each member successfully opens the lock will be $2/5, 2/5, 1/5$ respectively, which are also the expected numbers of successful matches.\n\nFor the second test case, there are exactly $2$ locks and $2$ keys, with each key corresponding to one of the locks. Without extra information, the first member randomly chooses a key and a lock with equal probabilities, for which the probability of success is $1/2$.\n\n- If the first member succeeds, the second member will open the other lock with the other key.\n- If the first member fails, then the key she selected can open the other lock, and the other key must correspond to the lock she chose. This information allows both the second and the third member to open a lock.\n\nIn conclusion, the expected numbers of successful matches will be:\n\n\n\n$$ \\begin{split} e_1 &= \\frac{1}{2}\\times 1 + \\frac{1}{2}\\times 0 = \\frac{1}{2} \\equiv 500,000,004 \\pmod {10^9+7},\\\\ e_2 &= \\frac{1}{2}\\times 1 + \\frac{1}{2} \\times 1 = 1,\\\\ e_3 &= \\frac{1}{2}\\times 0 + \\frac{1}{2} \\times 1 = \\frac{1}{2} \\equiv 500,000,004\\pmod {10^9+7}. \\end{split} $$\n\n",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define MOD 1000000007\n#define MAXN 108\n#define MAXL 5004\n#define MAXK 27\nint e[MAXN], p[2][MAXK][MAXN], inv[2 * MAXL + MAXK];  \ninline void _update(int * const a, const int lbd, const int rbd, const int base, const int diff) {\n\t(a[0] += base) %= MOD;\n\t(a[lbd] += diff) %= MOD;\n\t(a[rbd] += MOD - diff) %= MOD;\n\treturn ;\n}\n#define Hill(_a, _lbd, _rbd, _base, _diff) _update(_a, _lbd, _rbd, _base, _diff)\n#define Valley(_a, _lbd, _rbd, _base, _diff) _update(_a, _rbd, _lbd, ((_base) + (_diff)) % MOD, MOD - (_diff))\n#define Update(_a, _lbd, _rbd, _base, _diff) { if (_lbd < _rbd) Hill(_a, _lbd, _rbd, _base, _diff); else Valley(_a, _lbd, _rbd, _base, _diff); }\nint like() {\n\tint n, l, k, i, j, a, b, dh, now, nxt, totk, ntry, prob, pd, pb, lbd, rbd;\n\tscanf(\"%d %d %d\", &n, &l, &k);\n\tif (n == 1) {\n\t\tprintf(\"%d\\n\", l);\n\t\treturn 0;\n\t}\n\tinv[1] = 1;\n\tj = 2 * l + k;\n\tfor (i = 2; i <= j; ++i) inv[i] = 1ll * (MOD - MOD / i) * inv[MOD % i] % MOD;\n\t\n\tmemset(p, 0, sizeof(p));\n\tmemset(e, 0, sizeof(e));\n\tp[0][0][0] = 1;\n\tp[0][0][1] = -1;\n\tnow = 0; nxt = 1;\n\tfor (i = 0; i < l; ++i) {\n\t\tfor (j = 0; j <= k; ++j) {\n\t\t\ttotk = l + k - i - j;\n\t\t\tfor (a = 1; a < n; ++a) (p[now][j][a] += p[now][j][a - 1]) %= MOD;\n\t\t\tfor (a = 0; a < n; ++a) {\n\t\t\t\t// Match at the first try\n\t\t\t\tprob = 1ll * p[now][j][a] * inv[totk] % MOD;\n\t\t\t\t(e[a] += prob) %= MOD;\n\t\t\t\tif (a != n - 1) (e[a + 1] += MOD - prob) %= MOD;\n\t\t\t\t(p[nxt][j][(a + 1) % n] += prob) %= MOD;\n\t\t\t\tif (a != n - 2) (p[nxt][j][(a + 2) % n] += MOD - prob) %= MOD;\n\n\t\t\t\tprob = 1ll * prob * inv[totk + l - i - 2] % MOD;\n\t\t\t\t// Same lock\n\t\t\t\tpd = 1ll * prob * (ntry = totk - 1) % MOD;\n\t\t\t\tpb = 1ll * (ntry / n) * pd % MOD;\n\t\t\t\tif (dh = ntry % n) {\n\t\t\t\t\tlbd = (a + 1) % n;\n\t\t\t\t\trbd = (a + dh) % n + 1; \n\t\t\t\t\tUpdate(e, lbd, rbd, pb, pd);\n\t\t\t\t\t(++lbd) %= n;\n\t\t\t\t\t++(rbd  %= n); \n\t\t\t\t\tUpdate(p[nxt][j], lbd, rbd, pb, pd);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(e[0] += pb) %= MOD;\n\t\t\t\t\t(p[nxt][j][0] += pb) %= MOD;\n\t\t\t\t}\n\n\t\t\t\t// Same key\n\t\t\t\tpd = 1ll * prob * (ntry = l - i - 1) % MOD;\n\t\t\t\tif (j < k) {\n\t\t\t\t\tpb = 1ll * pd * (k - j) % MOD; \n\t\t\t\t\tb = (a + l - i) % n;\n\t\t\t\t\t(p[now][j + 1][b] += pb) %= MOD;\n\t\t\t\t\tif (b != n - 1) (p[now][j + 1][b + 1] += MOD - pb) %= MOD;\n\t\t\t\t}\n\t\t\t\tpb = 1ll * (ntry / n) * pd % MOD;\n\t\t\t\tif (dh = ntry % n) {\n\t\t\t\t\tlbd = (a + 1) % n;\n\t\t\t\t\trbd = (a + dh) % n + 1; \n\t\t\t\t\tUpdate(e, lbd, rbd, pb, pd);\n\t\t\t\t\t(++lbd) %= n;\n\t\t\t\t\t++(rbd  %= n); \n\t\t\t\t\tUpdate(p[nxt][j], lbd, rbd, pb, pd);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(e[0] += pb) %= MOD;\n\t\t\t\t\t(p[nxt][j][0] += pb) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnow ^= 1;\n\t\tnxt ^= 1;\n\t\tmemset(p[nxt], 0, sizeof(int) * MAXK * MAXN);\n\t}\n\tfor (i = 1; i < n; ++i) (e[i] += e[i - 1]) %= MOD;\n\n\tfor (i = 0; i < n; ++i) printf(\"%d%c\", e[i], \" \\n\"[i == n - 1]);\n\treturn 0;\n}\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tlike();\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2089c1",
      "PROBLEM_ID": "2089C1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, it is guaranteed that $k=0$. You can hack only if you solved all versions of this problem.\n\nA toy box is a refrigerator filled with childhood delight. Like weakness, struggle, hope ... When such a sleeper is reawakened, what kind of surprises will be waiting?\n\nM received her toy box as a birthday present from her mother. A jewellery designer would definitely spare no effort in decorating yet another priceless masterpiece as a starry firmament with exquisitely shaped gemstones. In addition, $l$ distinct locks secure the tiny universe of her lovely daughter: a hair clip featuring a flower design, a weathered feather pen, a balloon shaped like the letter M ... each piece obscures a precious moment.\n\nA few days ago, M rediscovered her toy box when she was reorganizing her bedroom, along with a ring of keys uniquely designed for the toy box. Attached to the key ring are $(l + k)$ keys, of which $l$ keys are able to open one of the $l$ locks correspondingly, while the other $k$ keys are nothing but counterfeits to discourage brute-force attack. To remind the correspondence, M's mother adorned each key with a gemstone of a different type. However, passing days have faded M's memory away.\n\n\"... So I have to turn to you all,\" M said while laying that ring of keys on the table.\n\nK picked up the keys and examined them carefully. \"The appearance of these keys unveils nothing fruitful. Thus, I am afraid that we shall inspect them sequentially.\"\n\nAlthough everyone is willing to help M, nobody has a plan. Observing others' reactions, T suggested, \"Let's play a game. Everyone tries a key in turn, and who opens the most locks is amazing.\"\n\n$n$ members, including M herself, take turns to unlock the toy box recursively in the same order until all the $l$ locks are unlocked. At each turn, the current member only selects a single key and tests it on exactly one of the locks. To open the toy box as soon as possible, every member chooses the key and the lock that maximize the probability of being a successful match. If there are multiple such pairs, a member will randomly choose one of such pairs with equal probability. Apparently, if a lock has been matched with a key, then neither the lock nor the key will be chosen again in following attempts.\n\nAssume that at the very beginning, the probability that a lock can be opened by any key is equal. If everyone always tries the optimal pairs of keys and locks based on all the historical trials, what will the expected number of successful matches be for each member?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe only line of the input contains three integers, $n$, $l$, $k$ ($1 \\leq n \\leq 100, 1 \\leq l \\leq 5000, k = 0$)\u00a0\u2014 the number of members participating in the game, the number of locks, and the number of counterfeit keys.\n\nIt is guaranteed that the sum of $l$ across all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, output a single line with $n$ integers $e_1, \\ldots, e_n$, where $e_i$ represents the expected number of successful matches, modulo $10^9 + 7$.\n\nFormally, let $M = 10^9 + 7$. It can be shown that the exact answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $e_i$ that $0 \\le x < M$ and $e_i \\cdot q \\equiv p \\pmod{M}$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 1 0\n\n3 2 0\n\n2 5 0\n\n9 104 0\n\n```\n\n#### Output #1\n\n```\n1 0 0\n500000004 1 500000004\n200000004 800000008\n869203933 991076635 39374313 496894434 9358446 51822059 979588764 523836809 38844739\n```\n\n### Note\n\nFor the first test case, there is only $1$ lock, so the first member opens the only lock with the only key undoubtedly.\n\nFor the second test case, there are exactly $2$ locks and $2$ keys, with each key corresponding to one of the locks. Without extra information, the first member randomly chooses a key and a lock with equal probabilities, for which the probability of success is $1/2$.\n\n- If the first member succeeds, the second member will open the other lock with the other key.\n- If the first member fails, then the key she selected can open the other lock, and the other key must correspond to the lock she chose. This information allows both the second and the third member to open a lock.\n\nIn conclusion, the expected numbers of successful matches will be:\n\n\n\n$$ \\begin{split} e_1 &= \\frac{1}{2}\\times 1 + \\frac{1}{2}\\times 0 = \\frac{1}{2} \\equiv 500,000,004 \\pmod {10^9+7},\\\\ e_2 &= \\frac{1}{2}\\times 1 + \\frac{1}{2} \\times 1 = 1,\\\\ e_3 &= \\frac{1}{2}\\times 0 + \\frac{1}{2} \\times 1 = \\frac{1}{2} \\equiv 500,000,004\\pmod {10^9+7}. \\end{split} $$\n\n",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\n\n// Add x to a modulo MOD\ninline int add_mod(int a, int b) {\n    int s = a + b;\n    if (s >= MOD) s -= MOD;\n    return s;\n}\n// Subtract b from a modulo MOD\ninline int sub_mod(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += MOD;\n    return s;\n}\n// Multiply a and b modulo MOD\ninline int mul_mod(long long a, long long b) {\n    return int((a * b) % MOD);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int T;\n    cin >> T;\n    vector<tuple<int,int,int>> tests(T);\n    int maxL = 0;\n    for (int ti = 0; ti < T; ti++) {\n        int n, l, k;\n        cin >> n >> l >> k;\n        tests[ti] = make_tuple(n, l, k);\n        if (l > maxL) maxL = l;\n    }\n    // Precompute inverses up to maxL\n    vector<int> inv(maxL+1);\n    if (maxL >= 1) {\n        inv[1] = 1;\n        for (int i = 2; i <= maxL; i++) {\n            // Using inv[i] = MOD - (MOD/i) * inv[MOD % i] % MOD\n            inv[i] = int(MOD - (long long)(MOD / i) * inv[MOD % i] % MOD);\n        }\n    }\n\n    for (int ti = 0; ti < T; ti++) {\n        int n, l, k;\n        tie(n, l, k) = tests[ti];\n        // We ignore k since it's 0 in the easy version.\n\n        // Probability distribution of partial sums mod n\n        vector<int> P_prev(n, 0), P_new(n, 0), E(n, 0);\n        P_prev[0] = 1; // sum S_0 = 0 with probability 1\n\n        // Prefix sums array (size 2n+1)\n        vector<int> PS(2 * n + 1);\n\n        for (int ki = 1; ki <= l; ki++) {\n            int N_k = l - ki + 1;\n            int q = N_k / n;\n            int rem = N_k % n;\n            int invNk = inv[N_k];\n\n            // Build prefix sums of P_prev repeated twice\n            PS[0] = 0;\n            for (int j = 0; j < 2 * n; j++) {\n                int v = P_prev[j < n ? j : j - n];\n                int s = PS[j] + v;\n                if (s >= MOD) s -= MOD;\n                PS[j + 1] = s;\n            }\n            // Compute new distribution P_new\n            for (int i = 0; i < n; i++) {\n                int S = 0;\n                if (rem > 0) {\n                    int left = i + n - rem;\n                    int right = i + n;\n                    S = PS[right] - PS[left];\n                    if (S < 0) S += MOD;\n                }\n                int t = S + q;\n                if (t >= MOD) t -= MOD;\n                int pn = mul_mod(t, invNk);\n                P_new[i] = pn;\n                // Accumulate expected successes\n                E[i] = add_mod(E[i], pn);\n            }\n            // Swap distributions\n            P_prev.swap(P_new);\n        }\n\n        // Output results: player p=1..n => residue r = p mod n\n        // For p in [1..n-1], r = p; for p=n, r = 0.\n        for (int p = 1; p <= n; p++) {\n            int r = (p == n ? 0 : p);\n            cout << E[r] << (p == n ? \"\\n\" : \" \");\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2089b2",
      "PROBLEM_ID": "2089B2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, there are no additional limits on $k$. You can hack only if you solved all versions of this problem.\n\nEcrade has two sequences $a_0, a_1, \\ldots, a_{n - 1}$ and $b_0, b_1, \\ldots, b_{n - 1}$ consisting of integers. It is guaranteed that the sum of all elements in $a$ does not exceed the sum of all elements in $b$.\n\nInitially, Ecrade can make exactly $k$ changes to the sequence $a$. It is guaranteed that $k$ does not exceed the sum of $a$. In each change:\n\n- Choose an integer $i$ ($0 \\le i < n$) such that $a_i > 0$, and perform $a_i := a_i - 1$.\n\nThen Ecrade will perform the following three operations sequentially on $a$ and $b$, which constitutes one round of operations:\n\n1. For each $0 \\le i < n$: $t := \\min(a_i, b_i), a_i := a_i - t, b_i := b_i - t$;\n2. For each $0 \\le i < n$: $c_i := a_{(i - 1) \\bmod n}$;\n3. For each $0 \\le i < n$: $a_i := c_i$;\n\nEcrade wants to know the minimum number of rounds required for all elements in $a$ to become equal to $0$ after exactly $k$ changes to $a$.\n\nHowever, this seems a bit complicated, so please help him!\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2\\cdot 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $k$ ($1\\le n\\le 2\\cdot 10^5$, $0\\le k\\le 2\\cdot 10^{14}$).\n\nThe second line of each test case contains $n$ integers $a_0, a_1, \\ldots, a_{n - 1}$ ($1 \\le a_i \\le 10^9$).\n\nThe third line of each test case contains $n$ integers $b_0, b_1, \\ldots, b_{n - 1}$ ($1 \\le b_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\cdot 10^5$. It is also guaranteed that in each test case the sum of $a$ does not exceed the sum of $b$, and that $k$ does not exceed the sum of $a$.\n\n### Output\n\nFor each test case, output the minimum number of rounds required for all elements in $a$ to become equal to $0$ after exactly $k$ changes to $a$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n3 0\n\n1 1 4\n\n5 1 4\n\n4 0\n\n1 2 3 4\n\n4 3 2 1\n\n4 0\n\n2 1 1 2\n\n1 2 2 1\n\n8 0\n\n1 2 3 4 5 6 7 8\n\n8 7 6 5 4 3 2 1\n\n3 6\n\n1 1 4\n\n5 1 4\n\n4 1\n\n1 2 3 4\n\n4 3 2 1\n\n4 1\n\n2 1 1 2\n\n1 2 2 1\n\n4 2\n\n2 1 1 2\n\n1 2 2 1\n\n```\n\n#### Output #1\n\n```\n1\n4\n4\n8\n0\n2\n2\n1\n```\n\n### Note\n\nIn the fifth test case, all elements in $a$ become $0$ after exactly $6$ changes.\n\nIn the sixth test case, Ecrade can do exactly one change to $a_3$, then $a$ will become $[1,2,2,4]$.\n\n- After the first round, $a=[3,0,0,0],b=[3,1,0,0]$;\n- After the second round, $a=[0,0,0,0],b=[0,1,0,0]$.\n\nIn the seventh test case, Ecrade can do exactly one change to $a_4$, then $a$ will become $[2,1,1,1]$.\n\n- After the first round, $a=[0,1,0,0],b=[0,1,1,0]$;\n- After the second round, $a=[0,0,0,0],b=[0,0,1,0]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll t,n,k,pos,a[400009],stk[400009];\ninline ll read(){\n\tll s = 0,w = 1;\n\tchar ch = getchar();\n\twhile (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}\n\twhile (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();\n\treturn s * w;\n}\nbool judge(ll x){\n\tll l = 1,r = 0,res = 0;\n\tfor (ll i = pos;i >= pos - n;i -= 1){\n\t\tif (l <= r && stk[l] - i > x) l += 1;\n\t\tif (pos - i >= x) res += max(0ll,a[stk[l]] - a[i]);\n\t\tif (res > k) return 0;\n\t\twhile (l <= r && a[stk[r]] > a[i]) r -= 1;\n\t\tstk[++ r] = i;\n\t}\n\treturn 1;\n}\nint main(){\n\tt = read();\n\twhile (t --){\n\t\tn = read(),k = read();\n\t\tll suma = 0;\n\t\tfor (ll i = 1;i <= n;i += 1) a[i] = read(),suma += a[i];\n\t\tfor (ll i = 1;i <= n;i += 1) a[i] -= read(),a[i + n] = a[i];\n\t\tif (suma == k){puts(\"0\"); continue;}\n\t\tfor (ll i = 1;i <= 2 * n;i += 1) a[i] += a[i - 1];\n\t\tpos = n;\n\t\tfor (ll i = n + 1;i <= 2 * n;i += 1) if (a[i] < a[pos]) pos = i;\n\t\tll l = 1,r = n,ans = n;\n\t\twhile (l <= r){\n\t\t\tll mid = (l + r) >> 1;\n\t\t\tif (judge(mid)) ans = mid,r = mid - 1;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2089b1",
      "PROBLEM_ID": "2089B1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, $k=0$. You can hack only if you solved all versions of this problem.\n\nEcrade has two sequences $a_0, a_1, \\ldots, a_{n - 1}$ and $b_0, b_1, \\ldots, b_{n - 1}$ consisting of integers. It is guaranteed that the sum of all elements in $a$ does not exceed the sum of all elements in $b$.\n\nInitially, Ecrade can make exactly $k$ changes to the sequence $a$. It is guaranteed that $k$ does not exceed the sum of $a$. In each change:\n\n- Choose an integer $i$ ($0 \\le i < n$) such that $a_i > 0$, and perform $a_i := a_i - 1$.\n\nThen Ecrade will perform the following three operations sequentially on $a$ and $b$, which constitutes one round of operations:\n\n1. For each $0 \\le i < n$: $t := \\min(a_i, b_i), a_i := a_i - t, b_i := b_i - t$;\n2. For each $0 \\le i < n$: $c_i := a_{(i - 1) \\bmod n}$;\n3. For each $0 \\le i < n$: $a_i := c_i$;\n\nEcrade wants to know the minimum number of rounds required for all elements in $a$ to become equal to $0$ after exactly $k$ changes to $a$.\n\nHowever, this seems a bit complicated, so please help him!\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2\\cdot 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $k$ ($1 \\le n \\le 2 \\cdot 10^5$, $k = 0$).\n\nThe second line of each test case contains $n$ integers $a_0, a_1, \\ldots, a_{n - 1}$ ($1 \\le a_i \\le 10^9$).\n\nThe third line of each test case contains $n$ integers $b_0, b_1, \\ldots, b_{n - 1}$ ($1 \\le b_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\cdot 10^5$. It is also guaranteed that in each test case the sum of $a$ does not exceed the sum of $b$, and that $k$ does not exceed the sum of $a$.\n\n### Output\n\nFor each test case, output the minimum number of rounds required for all elements in $a$ to become equal to $0$ after exactly $k$ changes to $a$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 0\n\n1 1 4\n\n5 1 4\n\n4 0\n\n1 2 3 4\n\n4 3 2 1\n\n4 0\n\n2 1 1 2\n\n1 2 2 1\n\n8 0\n\n1 2 3 4 5 6 7 8\n\n8 7 6 5 4 3 2 1\n\n```\n\n#### Output #1\n\n```\n1\n4\n4\n8\n```\n\n### Note\n\nIn this version, Ecrade cannot make changes to $a$.\n\nIn the first test case:\n\n- After the first round, $a=[0,0,0],b=[4,0,0]$.\n\nIn the second test case:\n\n- After the first round, $a=[3,0,0,1],b=[3,1,0,0]$;\n- After the second round, $a=[1,0,0,0],b=[0,1,0,0]$;\n- After the third round, $a=[0,1,0,0],b=[0,1,0,0]$;\n- After the fourth round, $a=[0,0,0,0],b=[0,0,0,0]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// Event representing a group of balls arriving at a station\nstruct Event {\n    ll t;    // time (round) at which the group arrives for killing\n    int j;   // station index\n    ll c;    // remaining balls in the group\n};\n\n// Min-heap by time, tie-break by station index (not strictly needed but keeps ordering)\nstruct EventCmp {\n    bool operator()(Event const &a, Event const &b) const {\n        if (a.t != b.t) return a.t > b.t;\n        return a.j > b.j;\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        ll k;\n        cin >> n >> k;\n        // In this easy version, k == 0 always.\n        vector<ll> a(n), b(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> b[i];\n        }\n        // Set of stations with positive remaining capacity\n        set<int> st;\n        for (int i = 0; i < n; i++) {\n            if (b[i] > 0) st.insert(i);\n        }\n        // Priority queue of events: group arrival for killing\n        priority_queue<Event, vector<Event>, EventCmp> pq;\n        // Initialize with each non-zero a[i], arriving at station i at round 1\n        for (int i = 0; i < n; i++) {\n            if (a[i] > 0) {\n                pq.push(Event{1, i, a[i]});\n            }\n        }\n        ll ans = 0;\n        // Process events in time order\n        while (!pq.empty()) {\n            Event e = pq.top();\n            pq.pop();\n            ll t = e.t;\n            int j = e.j;\n            ll c = e.c;\n            // If no balls remain in this group, skip\n            if (c <= 0) continue;\n            // Update answer on each kill attempt\n            // Actually we update ans only when we perform a kill (when b[j]>0)\n            // But updating here ensures we record the round for an event\n            // We'll refine to only when b[j]>0 below.\n\n            // If station j has capacity left, kill as many as possible here\n            if (b[j] > 0) {\n                ll killed = min(c, b[j]);\n                c -= killed;\n                b[j] -= killed;\n                // Record the round of kill\n                ans = max(ans, t);\n                // If station j is exhausted now, remove it\n                if (b[j] == 0) {\n                    st.erase(j);\n                }\n                // If balls remain in the group, schedule next arrival\n                if (c > 0) {\n                    if (st.empty()) {\n                        // Should not happen if sum a <= sum b\n                        break;\n                    }\n                    // find next station in the cycle\n                    auto it = st.upper_bound(j);\n                    int nj;\n                    if (it != st.end()) nj = *it;\n                    else nj = *st.begin();\n                    // distance in rounds to next station\n                    int d = (nj - j + n) % n;\n                    if (d == 0) d = n; // wrap-around case, but normally nj!=j\n                    ll nt = t + d;\n                    pq.push(Event{nt, nj, c});\n                }\n            } else {\n                // station j is already empty: skip to next station\n                if (st.empty()) {\n                    // no more capacity anywhere\n                    break;\n                }\n                auto it = st.upper_bound(j);\n                int nj;\n                if (it != st.end()) nj = *it;\n                else nj = *st.begin();\n                int d = (nj - j + n) % n;\n                if (d == 0) d = n;\n                ll nt = t + d;\n                pq.push(Event{nt, nj, c});\n            }\n        }\n\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2089a",
      "PROBLEM_ID": "2089A",
      "PROBLEM_STATEMENT": "Given an integer $n$. Construct a permutation $p_1, p_2, \\ldots, p_n$ of length $n$ that satisfies the following property:\n\nFor $1 \\le i \\le n$, define $c_i = \\lceil \\frac{p_1+p_2+\\ldots +p_i}{i} \\rceil$, then among $c_1,c_2,\\ldots,c_n$ there must be at least $\\lfloor \\frac{n}{3} \\rfloor - 1$ prime numbers.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nIn a single line of each test case, there is a single integer $n$ ($2 \\le n \\le 10^5)$\u00a0\u2014 the size of the permutation.\n\n### Output\n\nFor each test case, output the permutation $p_1,p_2,\\ldots,p_n$ of length $n$ that satisfies the condition. It is guaranteed that such a permutation always exists.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2\n\n3\n\n5\n\n```\n\n#### Output #1\n\n```\n2 1\n2 1 3\n2 1 3 4 5\n```\n\n### Note\n\nIn the first test case, $c_1 = \\lceil \\frac{2}{1} \\rceil = 2$, $c_2 = \\lceil \\frac{2+1}{2} \\rceil = 2$. Both are prime numbers.\n\nIn the third test case, $c_1 = \\lceil \\frac{2}{1} \\rceil = 2$, $c_2 = \\lceil \\frac{3}{2} \\rceil = 2$, $c_3 = \\lceil \\frac{6}{3} \\rceil = 2$, $c_4 = \\lceil \\frac{10}{4} \\rceil = 3$, $c_5 = \\lceil \\frac{15}{5} \\rceil = 3$. All these numbers are prime.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    vector<int> ns(t);\n    int max_n = 0;\n    for (int i = 0; i < t; i++) {\n        cin >> ns[i];\n        max_n = max(max_n, ns[i]);\n    }\n    // Sieve primes up to max_n\n    int sieve_n = max(2, max_n);\n    vector<bool> is_prime(sieve_n + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i * i <= sieve_n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= sieve_n; j += i)\n                is_prime[j] = false;\n        }\n    }\n    vector<int> primes;\n    primes.reserve(sieve_n / 10);\n    for (int i = 2; i <= sieve_n; i++) {\n        if (is_prime[i])\n            primes.push_back(i);\n    }\n\n    for (int _ = 0; _ < t; _++) {\n        int n = ns[_];\n        // Required number of primes among c_i is floor(n/3) - 1 (clamped to >= 0)\n        int M = n / 3 - 1;\n        if (M < 0) M = 0;\n        // We choose a prime p0 in [ low, high ]\n        // low  = ceil(M/2) + 1  = (M+1)/2 + 1\n        // high = n - floor(M/2) = n - (M/2)\n        int low = (M + 1) / 2 + 1;\n        int high = n - (M / 2);\n        if (low < 2) low = 2;\n        // find smallest prime >= low\n        auto it = std::lower_bound(primes.begin(), primes.end(), low);\n        int p0;\n        if (it != primes.end() && *it <= high) {\n            p0 = *it;\n        } else {\n            // fallback, take the largest prime <= high\n            auto it2 = std::upper_bound(primes.begin(), primes.end(), high);\n            if (it2 == primes.begin()) {\n                p0 = 2;\n            } else {\n                --it2;\n                p0 = *it2;\n            }\n        }\n        // Maximum prefix length k so that we can keep c_j == p0\n        int k1 = 2 * (p0 - 1);\n        int k2 = 2 * (n - p0) + 1;\n        int k = min(k1, k2);\n\n        vector<int> ans;\n        ans.reserve(n);\n        vector<char> used(n + 1, 0);\n\n        // Build the first k elements to maintain c_j = p0 (prime) for j = 1..k\n        for (int j = 1; j <= k; j++) {\n            int val;\n            if (j & 1) {\n                // odd j: pick p0 + (j-1)/2\n                val = p0 + (j - 1) / 2;\n            } else {\n                // even j: pick p0 - j/2\n                val = p0 - (j / 2);\n            }\n            ans.push_back(val);\n            used[val] = 1;\n        }\n        // Append the rest of the numbers in increasing order (they won't affect the count)\n        for (int x = 1; x <= n; x++) {\n            if (!used[x]) {\n                ans.push_back(x);\n            }\n        }\n        // Output the permutation\n        for (int i = 0; i < n; i++) {\n            cout << ans[i] << (i + 1 < n ? ' ' : '\\n');\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2086e",
      "PROBLEM_ID": "2086E",
      "PROBLEM_STATEMENT": "We call a positive integer zebra-like if its binary representation has alternating bits up to the most significant bit, and the least significant bit is equal to $1$. For example, the numbers $1$, $5$, and $21$ are zebra-like, as their binary representations $1$, $101$, and $10101$ meet the requirements, while the number $10$ is not zebra-like, as the least significant bit of its binary representation $1010$ is $0$.\n\nWe define the zebra value of a positive integer $e$ as the minimum integer $p$ such that $e$ can be expressed as the sum of $p$ zebra-like numbers (possibly the same, possibly different)\n\nGiven three integers $l$, $r$, and $k$, calculate the number of integers $x$ such that $l \\le x \\le r$ and the zebra value of $x$ equals $k$.\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe only line of each test case contains three integers $l$, $r$ ($1 \\le l \\le r \\le 10^{18}$) and $k$ ($1 \\le k \\le 10^{18}$).\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the number of integers in $[l, r]$ with zebra value $k$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1 100 3\n\n1 1 1\n\n15 77 2\n\n2 10 100\n\n1234567 123456789101112131 12\n\n```\n\n#### Output #1\n\n```\n13\n1\n3\n0\n4246658701\n```\n\n### Note\n\nIn the first test case, there are $13$ suitable numbers: $3, 7, 11, 15, 23, 27, 31, 43, 47, 63, 87, 91, 95$.\n\nEach of them can be represented as a sum of $3$ zebra-like numbers.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <tuple> // needed for map key as tuple\n#include <algorithm> // needed for min\n\nusing namespace std;\n\n// Use unsigned long long for large numbers up to 10^18\ntypedef unsigned long long ull;\n\n// Precomputed Zebra numbers Z_{2j+1} = (4^{j+1}-1)/3\nvector<ull> Z; \n// Memoization table for DP states. Key: (index, remaining_k, tight_constraint, forced_zero_suffix)\nmap<tuple<int, int, bool, bool>, ull> memo;\n// Coefficients of the upper bound M in the Zebra basis representation\nvector<int> M_coeffs; \n\n// Precompute Zebra numbers. A positive integer is zebra-like if its binary representation \n// has alternating bits up to the most significant bit, and the least significant bit is 1.\n// Examples: 1 (1_2), 5 (101_2), 21 (10101_2). General form: Z_{2k+1} = (4^{k+1}-1)/3.\nvoid precompute_zebra() {\n    Z.clear(); // Clear any previous values if function called multiple times\n    ull current_val = 1; // Start with Z_1 = 1\n    Z.push_back(current_val);\n    \n    // Calculate subsequent Zebra numbers using the recurrence Z_{2k+3} = 4 * Z_{2k+1} + 1\n    // Continue as long as values are within reasonable range related to 10^18\n    for (int i = 0; ; ++i) {\n        ull term1;\n        // Check for overflow before multiplication: 4 * current_val\n        if (__builtin_mul_overflow(current_val, 4, &term1)) break; \n        ull next_val;\n        // Check for overflow before addition: 4 * current_val + 1\n        if (__builtin_add_overflow(term1, 1, &next_val)) break; \n        \n        current_val = next_val;\n\n        // Stop if the value significantly exceeds 10^18 to avoid unnecessary large numbers\n        // Use 2e18 as a safe upper bound check.\n        if (current_val > 2000000000000000000ULL) break; \n        Z.push_back(current_val);\n        \n        // Safety break to prevent excessively large vector Z, size ~31 needed for 10^18\n        if (Z.size() > 62) break; \n    }\n    // Z vector now contains {1, 5, 21, ..., up to numbers slightly larger than 10^18}\n}\n\n// Computes the unique representation M = sum a_j * Z_{2j+1} using the greedy algorithm.\n// This representation has the property that p(M) = sum a_j is minimized.\n// Stores coefficients a_j in the global vector M_coeffs.\nvoid represent(ull M) {\n    // Ensure M_coeffs has the same size as Z vector, initialized to 0\n    M_coeffs.assign(Z.size(), 0);\n    ull current_M = M;\n    int N = Z.size() - 1; // Start from the index of the largest precomputed Zebra number\n    \n    // Iterate downwards through Zebra number indices\n    for (int j = N; j >= 0; --j) {\n        if (current_M == 0) break; // Stop if M is fully represented\n        \n        // Defensive check: skip if Z[j] is 0 (should not happen with proper precomputation)\n        if (Z[j] == 0) continue; \n        \n        // If current M is greater than or equal to Z[j], determine coefficient a_j\n        if (current_M >= Z[j]) {\n            // Calculate how many times Z[j] fits into current_M\n            ull count = current_M / Z[j];\n            // The derived theory guarantees count <= 4 for this greedy representation. Store as int.\n            M_coeffs[j] = (int)count; \n            // Subtract the value contributed by a_j * Z[j] from current_M\n            current_M -= count * Z[j];\n        }\n    }\n}\n\n// Dynamic Programming function to count numbers up to M with Zebra value k.\n// Parameters:\n// idx: current index in Zebra basis representation (processing from N down to 0)\n// rem_k: remaining sum of coefficients needed to reach target k\n// tight: boolean, true if the number constructed so far matches the prefix of M, \n//        restricting choices for the current digit.\n// forced_zero: boolean, true if all subsequent coefficients (indices < idx) must be 0.\n//              This is triggered when a coefficient a_p = 4 was chosen for some p > idx.\null solve(int idx, int rem_k, bool tight, bool forced_zero) {\n    // If remaining k requirement becomes negative, this path is invalid.\n    if (rem_k < 0) return 0; \n    \n    // Base case: If we have processed all indices (down to -1)\n    if (idx == -1) {\n        // A valid representation is found if the required k sum is exactly met (rem_k == 0)\n        return (rem_k == 0) ? 1 : 0;\n    }\n\n    // Memoization: Check if the result for this state is already computed\n    tuple<int, int, bool, bool> state = {idx, rem_k, tight, forced_zero};\n    auto it = memo.find(state);\n    if (it != memo.end()) {\n        return it->second; // Return cached result\n    }\n\n    ull ans = 0; // Accumulator for the count of valid numbers\n    int limit; // Upper bound for the current digit coefficient a_idx\n    \n    // Determine the limit based on the forced_zero constraint\n    if (forced_zero) {\n        limit = 0; // If forced_zero is true, only digit 0 is allowed for a_idx\n    } else {\n        limit = 4; // Otherwise, the maximum possible coefficient derived is 4\n    }\n\n    // Apply the tight constraint if necessary\n    if (tight) {\n        // If the current index `idx` is within the bounds of M's coefficient vector M_coeffs\n        if (idx < M_coeffs.size()) {\n             // The digit cannot exceed the corresponding coefficient in M's representation\n            limit = min(limit, M_coeffs[idx]); \n        } else {\n             // If idx is out of bounds (e.g., M is small, N is large), the coefficient is effectively 0\n             limit = min(limit, 0);\n        }\n    }\n\n    // Iterate through all possible values for the current digit `a_idx` from 0 to limit\n    for (int digit = 0; digit <= limit; ++digit) {\n        \n        // Calculate the tight constraint for the recursive call (next state)\n        // It remains tight only if the current state is tight AND we choose the maximum allowed digit (M_coeffs[idx])\n        bool new_tight = tight && (idx < M_coeffs.size() ? (digit == M_coeffs[idx]) : (digit == 0));\n        \n        // Calculate the forced_zero constraint for the next state\n        // It becomes true if it was already true, or if we choose digit 4 now.\n        bool new_forced_zero = forced_zero || (digit == 4);\n\n        // Special condition derived from theory: if coefficient `a_j` is 4, then all subsequent coefficients\n        // `a_{j-1}, ..., a_0` must be 0. This implies the remaining sum `rem_k` must be exactly `digit` (which is 4).\n        if (digit == 4) {\n           // If we choose digit 4, check if the remaining k requirement is exactly 4.\n           // `rem_k - digit` must be 0 for the recursion to succeed.\n           if (rem_k - digit != 0) {\n               continue; // If not, this path is invalid because suffix must be zero and cannot contribute to k.\n           }\n        }\n        \n        // Make the recursive call for the next index (idx-1) with updated parameters\n        ans += solve(idx - 1, rem_k - digit, new_tight, new_forced_zero);\n    }\n\n    // Store the computed result in the memoization table and return it\n    return memo[state] = ans;\n}\n\n// Function to calculate the count of positive integers x such that 1 <= x <= M and zebra value p(x) = k\null count_up_to(ull M, int k) {\n    // If M is 0, there are no positive integers in the range [1, M].\n    if (M == 0) return 0;\n\n    // Check for invalid k values. k must be positive.\n    // Also check against the practical upper bound for k. Based on N~30 indices for R=10^18,\n    // max k is roughly 4 * 31 = 124. Use 130 as a safe threshold.\n     if (k <= 0 || k > 130) return 0; \n\n    // Compute the Zebra basis representation for the upper bound M\n    represent(M); \n\n    // Determine the highest relevant index N for the DP.\n    // This is the index of the largest Zebra number Z_i such that Z_i <= M.\n    int N = -1; // Initialize N to -1 (indicates M < 1, handled already)\n    for (int i = Z.size() - 1; i >= 0; --i) {\n        // Check Z[i] > 0 for safety, although Z[0]=1 is always > 0.\n        if (Z[i] > 0 && M >= Z[i]) { \n             N = i; // Found the largest index i s.t. Z[i] <= M\n             break;\n        }\n    }\n    // If M >= 1, Z[0]=1 exists and is <= M, so N will be at least 0.\n    if (N == -1) return 0; // Should not happen for M >= 1.\n     \n    memo.clear(); // Clear memoization table before starting a new count calculation\n    \n    // Initial call to the DP function. Start from the determined highest index N.\n    // Initial state: require sum k, tight constraint is true, not forced_zero.\n    return solve(N, k, true, false); \n}\n\nint main() {\n    // Use faster I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    // Precompute Zebra numbers once at the beginning of the program\n    precompute_zebra();\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        ull l, r; // Range boundaries [l, r]\n        long long k_long; // Input Zebra value k (can be large type, but value is effectively small)\n        cin >> l >> r >> k_long;\n\n        int k; // Use int for k in DP state after validation\n        \n        // Validate the input k against derived theoretical/practical bounds\n        if (k_long <= 0 || k_long > 130) { \n             k = 131; // Set k to an invalid value > 130. count_up_to will return 0.\n        } else {\n             k = (int)k_long; // Cast to int if k is within the valid range [1, 130]\n        }\n        \n        // Calculate the count in the range [l, r] using the inclusion-exclusion principle:\n        // Count(x in [l, r] with p(x)=k) = Count(x in [1, r] with p(x)=k) - Count(x in [1, l-1] with p(x)=k)\n        ull count_r = count_up_to(r, k);\n        ull count_l_minus_1 = count_up_to(l - 1, k);\n        \n        // Output the final count for the test case\n        cout << count_r - count_l_minus_1 << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2086c",
      "PROBLEM_ID": "2086C",
      "PROBLEM_STATEMENT": "A permutation of integers from $1$ to $n$ is an array of size $n$ where each integer from $1$ to $n$ appears exactly once.\n\nYou are given a permutation $p$ of integers from $1$ to $n$. You have to process $n$ queries. During the $i$-th query, you replace $p_{d_i}$ with $0$. Each element is replaced with $0$ exactly once. The changes made in the queries are saved, that is, after the $i$-th query, all integers $p_{d_1}, p_{d_2}, \\dots, p_{d_i}$ are zeroes.\n\nAfter each query, you have to find the minimum number of operations required to fix the array; in other words, to transform the current array into any permutation of integers from $1$ to $n$ (possibly into the original permutation $p$, possibly into some other permutation).\n\nThe operation you can perform to fix the array is the following one:\n\n- choose the integer $i$ from $1$ to $n$, replace the $i$-th element of the array with $i$.\n\nNote that the answer for each query is calculated independently, meaning you do not actually apply any operations, just calculate the minimum number of operations.\n\n### Input\n\nEach test consists of several test cases. The first line contains one integer $t$ ($1 \\le t \\le 10^{4}$)\u00a0\u2014 the number of test cases. Then the test cases follow.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^{5}$).\n\nThe second line of each test case contains $n$ integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_{i} \\le n$)\u00a0\u2014 the original permutation. All $p_i$ are distinct.\n\nThe third line of each test case contains $n$ integers $d_1, d_2, \\dots, d_n$ ($1 \\le d_{i} \\le n$). All $d_{i}$ are distinct.\n\nAdditional constraint on the input:\n\n- the sum of $n$ across all test cases does not exceed $2 \\cdot 10^{5}$.\n\n### Output\n\nFor each test case, output a line containing $n$ integers, where the $i$-th integer should be equal to the minimum number of operations required to fix the array which was obtained after the $i$-th query (i.e., the permutation $p$ where all integers $p_{d_1}, p_{d_2}, \\dots, p_{d_i}$ are replaced by zeroes).\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n1 2 3\n\n3 2 1\n\n5\n\n4 5 3 1 2\n\n4 5 1 3 2\n\n7\n\n4 3 1 2 7 5 6\n\n1 2 3 4 5 6 7\n\n```\n\n#### Output #1\n\n```\n1 2 3\n2 4 4 5 5\n4 4 4 4 7 7 7\n```\n\n### Note\n\nIn the first test case, after each query, every integer which was replaced by $0$ can be restored by one operation.\n\nIn the second test case, you can act as follows:\n\n- Query $1$: $p = [4, 5, 3, 0, 2]$, it can be transformed into $[{\\color{red}1}, 5, 3, {\\color{red}4}, 2]$.\n- Query $2$: $p = [4, 5, 3, 0, 0]$, it can be transformed into $[{\\color{red}1}, {\\color{red}2}, 3, {\\color{red}4}, {\\color{red}5}]$.\n- Query $3$: $p = [0, 5, 3, 0, 0]$, it can be transformed into $[{\\color{red}1}, {\\color{red}2}, 3, {\\color{red}4}, {\\color{red}5}]$.\n- Query $4$: $p = [0, 5, 0, 0, 0]$, it can be transformed into $[{\\color{red}1}, {\\color{red}2}, {\\color{red}3}, {\\color{red}4}, {\\color{red}5}]$.\n- Query $5$: $p = [0, 0, 0, 0, 0]$, it can be transformed into $[{\\color{red}1}, {\\color{red}2}, {\\color{red}3}, {\\color{red}4}, {\\color{red}5}]$.\n\nThe numbers that were changed are highlighted in red.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Included for standard library utilities, though not actively used in the final algorithm logic.\n\n/**\n * @brief Solves a single test case of the problem.\n * \n * The problem asks for the minimum number of operations to transform an array into a permutation\n * after sequentially setting elements to 0 based on query indices. An operation allows replacing\n * the value at index `j` with `j`.\n * \n * The core idea is that the minimum number of operations needed after query `i` (where elements\n * at indices `d_1, ..., d_i` are set to 0) is equal to the total number of elements\n * in all cycles of the permutation graph that contain at least one of the indices `d_1, ..., d_i`.\n * \n * The algorithm proceeds in three steps:\n * 1. Find the cycle decomposition of the initial permutation `p`. Each node `k` is mapped to a cycle ID,\n *    and the size of each cycle is recorded.\n * 2. Process the queries `d_1, ..., d_n` sequentially. For each query `d_i`, identify the cycle containing\n *    index `d_i`. If this cycle has not yet been marked as \"affected\", mark it and add its size to a\n *    running total `current_total_affected_size`.\n * 3. Store the value of `current_total_affected_size` after processing each query `i`. This value is the answer for query `i`.\n *    Finally, print all stored results.\n */\nvoid solve() {\n    int n; // Size of the permutation and number of queries.\n    std::cin >> n;\n    \n    // Read the initial permutation p. We use 1-based indexing for array elements and indices\n    // for easier mapping to the problem statement. Vectors are sized n+1, index 0 is unused.\n    std::vector<int> p(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        std::cin >> p[i];\n    }\n    \n    // Read the query indices d. These are the indices where elements of p are set to 0 sequentially.\n    // Using 1-based indexing. Vector size n+1, index 0 unused.\n    std::vector<int> d(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        std::cin >> d[i];\n    }\n    \n    // Step 1: Find the cycle decomposition of the permutation p.\n    // `cycle_id[k]` stores the ID of the cycle containing node k. IDs are 1-based. 0 means not assigned.\n    std::vector<int> cycle_id(n + 1, 0); \n    // `cycle_size_list` stores the size of each cycle. The size of cycle `cid` is at index `cid-1`.\n    std::vector<int> cycle_size_list; \n    // `visited[k]` tracks if node k has been visited during cycle finding.\n    std::vector<bool> visited(n + 1, false); \n    int cycle_count = 0; // Counter for assigning unique cycle IDs, starting from 1.\n    \n    // Iterate through all nodes 1 to n to find cycles.\n    for (int k = 1; k <= n; ++k) {\n        if (!visited[k]) { // If node k hasn't been visited, it starts a new cycle.\n            cycle_count++; // Increment cycle counter to assign a new ID.\n            int current_node = k;\n            int current_cycle_size = 0;\n            \n            // Traverse the permutation chain starting from k until we encounter a visited node.\n            // Due to permutation properties (each node has exactly one outgoing and one incoming edge),\n            // the first visited node encountered must be the starting node k, completing the cycle.\n            while (!visited[current_node]) {\n                visited[current_node] = true; // Mark the current node as visited.\n                cycle_id[current_node] = cycle_count; // Assign the current cycle ID to this node.\n                current_cycle_size++; // Increment the size counter for the current cycle.\n                current_node = p[current_node]; // Move to the next node defined by the permutation.\n            }\n            // The loop terminates once `current_node` is visited. `current_cycle_size` now holds the length of the cycle.\n            // Store the size of the found cycle. The list index corresponds to `cycle_id - 1`.\n            cycle_size_list.push_back(current_cycle_size); \n        }\n    }\n    \n    // Step 2: Process queries sequentially.\n    // `is_cycle_affected[cid]` tracks if cycle `cid` has been affected by any query up to the current one.\n    // Size is `cycle_count + 1` because cycle IDs are 1-based.\n    std::vector<bool> is_cycle_affected(cycle_count + 1, false); \n    // `current_total_affected_size` accumulates the total size of all affected cycles.\n    long long current_total_affected_size = 0; // Using long long is safer for potentially large sums, although N <= 10^5 suggests int might suffice. Max value is N.\n    // `results` vector stores the answer after each query. It will have N elements.\n    std::vector<long long> results; \n    \n    // Process each query from 1 to N.\n    for (int i = 1; i <= n; ++i) {\n        int node_idx = d[i]; // Get the index `d_i` specified by the i-th query. The element p[d_i] is set to 0.\n        int cid = cycle_id[node_idx]; // Find the cycle ID that this index `node_idx` belongs to.\n        \n        // Check if the cycle ID is valid (cid > 0 ensures it's a valid node index 1..N that belongs to a cycle)\n        // and if this cycle has not already been marked as affected.\n        if (cid > 0 && !is_cycle_affected[cid]) { \n            is_cycle_affected[cid] = true; // Mark this cycle as affected.\n            // Add the size of this newly affected cycle to the total accumulated size.\n            // `cycle_size_list` uses 0-based indexing, so the size for cycle `cid` (1-based) is at index `cid - 1`.\n            current_total_affected_size += cycle_size_list[cid - 1]; \n        }\n        // The answer after query `i` is the current total size of all affected cycles. Store this result.\n        results.push_back(current_total_affected_size);\n    }\n    \n    // Step 3: Output the results for this test case.\n    // Print the computed results for queries 1 through N, separated by spaces.\n    for (int i = 0; i < n; ++i) {\n        std::cout << results[i] << (i == n - 1 ? \"\" : \" \"); // Avoid trailing space after the last number.\n    }\n    std::cout << std::endl; // Print a newline character after the output for this test case.\n}\n\n// Main function: setup fast I/O and loop through test cases.\nint main() {\n    // Optimize standard C++ I/O operations for speed critical in competitive programming.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Variable to store the number of test cases.\n    std::cin >> t; // Read the number of test cases.\n    while (t--) { // Loop `t` times to process each test case.\n        solve(); // Call the function that solves a single test case.\n    }\n    return 0; // Indicate successful program execution.\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2086a",
      "PROBLEM_ID": "2086A",
      "PROBLEM_STATEMENT": "The most valuable berry of the Karelian forests is cloudberry. To make jam from cloudberries, you take equal amounts of berries and sugar and cook them. Thus, if you have $2$ kg of berries, you need $2$ kg of sugar. However, from $2$ kg of berries and $2$ kg of sugar, you will not get $4$ kg of jam, as one might expect, but only $3$ kg, since some of the jam evaporates during cooking. Specifically, during standard cooking, exactly a quarter (or $25\\%$) of the jam evaporates.\n\nHow many kilograms of cloudberries are needed to prepare $n$ $3$-kilogram jars of jam?\n\n![](https://espresso.codeforces.com/85e4f865ff1296d55236c63df0157f7da4c779b6.png)\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^{4}$)\u00a0\u2014 the number of test cases. The following lines describe the test cases.\n\nEach test case contains a single integer $n$ ($1 \\le n \\le 10^8$)\u00a0\u2014 the number of jars of jam that need to be prepared.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the amount of berries needed for the jam in kilograms.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n1\n\n3\n\n```\n\n#### Output #1\n\n```\n2\n6\n```\n\n### Note\n\nFor the test case $1$, explanations are given in the text of the statement\u00a0\u2014 to prepare $1$ jar of jam, you need $2$ kilograms of cloudberries.\n\nConsider the test case $2$: if we take $6$ kilograms of berries and $6$ kilograms of sugar, we get $\\frac{(6 + 6) \\cdot 3}{4} = 9$ kilograms of jam; which gives $\\frac{9}{3} = 3$ jars of jam.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long n;\n        cin >> n;\n        cout << 2 * n << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2085f2",
      "PROBLEM_ID": "2085F2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, $n\\le 4\\cdot 10^5$. You can hack only if you solved all versions of this problem.\n\nServal has a magic number $k$ ($k\\ge 2$). We call an array $r$ colorful if and only if:\n\n- The length of $r$ is $k$, and\n- Each integer between $1$ and $k$ appears exactly once in $r$.\n\nYou are given an array $a$ consisting of $n$ integers between $1$ and $k$. It is guaranteed that each integer between $1$ and $k$ appears in $a$ at least once. You can perform the following operation on $a$:\n\n- Choose an index $i$ ($1\\le i < n$), then swap $a_i$ and $a_{i+1}$.\n\nFind the minimum number of operations needed to make at least one subarray$^{\\text{\u2217}}$ of $a$ colorful. It can be shown that this is always possible under the constraints of the problem.\n\n$^{\\text{\u2217}}$An array $b$ is a subarray of an array $a$ if $b$ can be obtained from $a$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2\\leq k\\leq n\\leq 4\\cdot 10^5$) \u2014 the length of the array $a$ and Serval's magic number.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1\\leq a_i\\leq k$) \u2014 the elements of the array $a$. It is guaranteed that each integer between $1$ and $k$ appears in $a$ at least once.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $4\\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the minimum number of operations needed to make at least one subarray of $a$ colorful.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n3 2\n\n1 2 1\n\n7 3\n\n2 1 1 3 1 1 2\n\n6 3\n\n1 1 2 2 2 3\n\n6 3\n\n1 2 2 2 2 3\n\n10 5\n\n5 1 3 1 1 2 2 4 1 3\n\n9 4\n\n1 2 3 3 3 3 3 2 4\n\n```\n\n#### Output #1\n\n```\n0\n1\n2\n3\n4\n5\n```\n\n### Note\n\nIn the first test case, since the subarrays $[a_1, a_2] = [1, 2]$ and $[a_2, a_3] = [2, 1]$ are already colorful, we do not need to perform any operations. Thus, the answer is $0$.\n\nIn the second test case, we can swap $a_1$ and $a_2$ to obtain $[1, \\underline{2, 1, 3}, 1, 1, 2]$, which has a colorful subarray $[a_2, a_3, a_4] = [2, 1, 3]$. And the given array initially does not have any colorful subarrays, so the answer is $1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct BIT {\n    int n;\n    vector<ll> bit;\n    BIT(int _n = 0) { init(_n); }\n    void init(int _n) {\n        n = _n;\n        bit.assign(n+1, 0LL);\n    }\n    // add v at index idx (1-indexed)\n    void update(int idx, ll v) {\n        for (int i = idx; i <= n; i += i & -i) {\n            bit[i] += v;\n        }\n    }\n    // query prefix sum [1..idx]\n    ll query(int idx) const {\n        ll s = 0;\n        for (int i = idx; i > 0; i -= i & -i) {\n            s += bit[i];\n        }\n        return s;\n    }\n    // find smallest idx such that prefix sum >= k (1-indexed)\n    // assumes all values non-negative and total sum >= k >= 1\n    int find_kth(ll k) const {\n        int pos = 0;\n        // compute max power of two <= n\n        int LOG = 1;\n        while ((1 << LOG) <= n) LOG++;\n        for (int i = LOG; i >= 0; i--) {\n            int nxt = pos + (1 << i);\n            if (nxt <= n && bit[nxt] < k) {\n                k -= bit[nxt];\n                pos = nxt;\n            }\n        }\n        return pos + 1;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n+1);\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        // occurrences per color (1-indexed for colors and for positions in occ lists)\n        vector<vector<int>> occ(k+1);\n        for (int j = 1; j <= k; j++) {\n            occ[j].reserve(4); // some reserve\n            occ[j].push_back(0); // dummy at index 0\n        }\n        for (int i = 1; i <= n; i++) {\n            occ[a[i]].push_back(i);\n        }\n        // pointers ptr[j]: number of occurrences of color j seen so far (<= current pos0)\n        vector<int> ptr(k+1, 0);\n\n        // DS: counts and sums for FR, B, FL\n        ll sum_FR_R = 0; // sum of R_j for j in FR\n        int count_FR = 0;\n        ll sum_B_R = 0;  // sum of R_j for j in B\n        int count_B = 0;\n        ll sum_FL_L = 0; // sum of L_j for j in FL\n        int count_FL = 0;\n\n        // BIT for B weights\n        int maxW = 2*n + 5;\n        BIT bitCnt(maxW), bitSum(maxW);\n\n        // Initialize all colors as FR (ptr==0)\n        for (int j = 1; j <= k; j++) {\n            // each color appears at least once\n            int occ_size = (int)occ[j].size() - 1; // real occurrences\n            // ptr[j] = 0\n            // status FR\n            count_FR++;\n            // R_j = occ[j][1]\n            sum_FR_R += occ[j][1];\n        }\n\n        // Precompute constants\n        int m = (k + 1) / 2;  // median index (1-indexed)\n        // constant1 = (m-1)*m/2, constant2 = (k-m)*(k-m+1)/2\n        ll constant1 = ll(m - 1) * ll(m) / 2;\n        ll constant2 = ll(k - m) * ll(k - m + 1) / 2;\n        ll constant_const = constant1 + constant2;\n        // sign term for pos0: p_term = (k even ? -pos0 : 0)\n        bool keven = (k % 2 == 0);\n\n        ll ans = LLONG_MAX;\n\n        // Process positions as med picks\n        for (int pos0 = 1; pos0 <= n; pos0++) {\n            int c = a[pos0];\n            // DS update for color c: remove old status\n            int old_ptr = ptr[c];\n            int occ_size = (int)occ[c].size() - 1;\n            // determine old status\n            // old_status: 0=FR,1=B,2=FL\n            int old_status = 0;\n            if (old_ptr == 0) {\n                old_status = 0; // FR\n            } else if (old_ptr < occ_size) {\n                old_status = 1; // B\n            } else {\n                old_status = 2; // FL\n            }\n            if (old_status == 0) {\n                // FR -> remove from FR\n                count_FR--;\n                // old R = occ[c][1]\n                sum_FR_R -= occ[c][1];\n            } else if (old_status == 1) {\n                // B -> remove from B\n                count_B--;\n                // old R = occ[c][old_ptr+1]\n                int R_old = occ[c][old_ptr + 1];\n                sum_B_R -= R_old;\n                // old L = occ[c][old_ptr]\n                int L_old = occ[c][old_ptr];\n                int w_old = L_old + R_old;\n                // remove w_old from BITs\n                bitCnt.update(w_old, -1);\n                bitSum.update(w_old, -w_old);\n            } else { // old_status == 2\n                // FL -> remove\n                count_FL--;\n                // old L = occ[c][old_ptr]\n                sum_FL_L -= occ[c][old_ptr];\n            }\n            // advance ptr\n            ptr[c]++;\n            int new_ptr = ptr[c];\n            // determine new status and add\n            // new_ptr in [1..occ_size]\n            if (new_ptr < occ_size) {\n                // B\n                int R_new = occ[c][new_ptr + 1];\n                int L_new = occ[c][new_ptr];\n                count_B++;\n                sum_B_R += R_new;\n                int w_new = L_new + R_new;\n                bitCnt.update(w_new, +1);\n                bitSum.update(w_new, +w_new);\n            } else {\n                // FL (new_ptr == occ_size)\n                count_FL++;\n                int L_new = occ[c][new_ptr];\n                sum_FL_L += L_new;\n            }\n\n            // DS is updated for pos0. Now perform med pick\n            int status_c;\n            if (ptr[c] == 0) status_c = 0;\n            else if (ptr[c] < occ_size) status_c = 1;\n            else status_c = 2;\n            // status_c: 0=FR(not possible),1=B,2=FL\n\n            // counts excluding med color\n            int cnt_FR_excl = count_FR - (status_c == 0 ? 1 : 0);\n            int cnt_FL_excl = count_FL - (status_c == 2 ? 1 : 0);\n            int cnt_B_excl  = count_B  - (status_c == 1 ? 1 : 0);\n\n            // validity\n            if (cnt_FL_excl <= m - 1 && cnt_FR_excl <= (k - m)) {\n                int f_left = (m - 1) - cnt_FL_excl;\n                // prepare DS_B_excl: remove med if in B\n                if (status_c == 1) {\n                    // med is in B, remove its w\n                    int Lc = occ[c][ptr[c]];\n                    int Rc = occ[c][ptr[c] + 1];\n                    int w_c = Lc + Rc;\n                    bitCnt.update(w_c, -1);\n                    bitSum.update(w_c, -w_c);\n                }\n                ll sumTop = 0;\n                if (f_left > 0) {\n                    // DS_B_excl count\n                    ll totalB = bitCnt.query(maxW);\n                    // totalB should be cnt_B_excl\n                    // find threshold weight W* such that #elements with w>=W* >= f_left\n                    // skip X = totalB - f_left smallest, so we need find (X+1)-th smallest\n                    ll skip = totalB - f_left;\n                    // find weight threshold index\n                    int W = bitCnt.find_kth(skip + 1);\n                    // compute sum of elements > W\n                    ll cnt_le_W = bitCnt.query(W);\n                    ll sum_le_W = bitSum.query(W);\n                    ll cnt_tot = totalB;\n                    ll sum_tot = bitSum.query(maxW);\n                    ll cnt_gt_W = cnt_tot - cnt_le_W;\n                    ll sum_gt_W = sum_tot - sum_le_W;\n                    // need (f_left - cnt_gt_W) elements of weight exactly W\n                    ll need_eq = f_left - cnt_gt_W;\n                    sumTop = sum_gt_W + need_eq * (ll)W;\n                }\n                // re-add med if removed\n                if (status_c == 1) {\n                    int Lc = occ[c][ptr[c]];\n                    int Rc = occ[c][ptr[c] + 1];\n                    int w_c = Lc + Rc;\n                    bitCnt.update(w_c, +1);\n                    bitSum.update(w_c, +w_c);\n                }\n                // compute sum_R_excl and sum_L_excl\n                // total_sum_FRB_R = sum_FR_R + sum_B_R\n                ll total_sum_FRB_R = sum_FR_R + sum_B_R;\n                // subtract med's R if in FR or B (status_c==0 or 1), but status_c==0 never happens here\n                ll sum_R_excl = total_sum_FRB_R - ((status_c == 0 || status_c == 1) ? occ[c][ptr[c] + (status_c == 1 ? 1 : 1)] : 0);\n                // But since status_c==0 never occurs here, treat status_c==1:\n                if (status_c == 1) {\n                    ll Rc = occ[c][ptr[c] + 1];\n                    sum_R_excl = total_sum_FRB_R - Rc;\n                } else {\n                    sum_R_excl = total_sum_FRB_R;\n                }\n                // sum_L_excl = sum_FL_L - (status_c==FL ? L_c : 0)\n                ll sum_L_excl = sum_FL_L - (status_c == 2 ? occ[c][ptr[c]] : 0);\n                ll K_med = sum_R_excl - sum_L_excl;\n\n                ll p_term = keven ? - (ll)pos0 : 0LL;\n                ll cost = p_term - constant_const + K_med - sumTop;\n                ans = min(ans, cost);\n            }\n            // next pos\n        }\n\n        // It can be shown answer non-negative\n        if (ans < 0) ans = 0;\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2085f1",
      "PROBLEM_ID": "2085F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, $n\\le 3000$. You can hack only if you solved all versions of this problem.\n\nServal has a magic number $k$ ($k\\ge 2$). We call an array $r$ colorful if and only if:\n\n- The length of $r$ is $k$, and\n- Each integer between $1$ and $k$ appears exactly once in $r$.\n\nYou are given an array $a$ consisting of $n$ integers between $1$ and $k$. It is guaranteed that each integer between $1$ and $k$ appears in $a$ at least once. You can perform the following operation on $a$:\n\n- Choose an index $i$ ($1\\le i < n$), then swap $a_i$ and $a_{i+1}$.\n\nFind the minimum number of operations needed to make at least one subarray$^{\\text{\u2217}}$ of $a$ colorful. It can be shown that this is always possible under the constraints of the problem.\n\n$^{\\text{\u2217}}$An array $b$ is a subarray of an array $a$ if $b$ can be obtained from $a$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2\\leq k\\leq n\\leq 3000$) \u2014 the length of the array $a$ and Serval's magic number.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1\\leq a_i\\leq k$) \u2014 the elements of the array $a$. It is guaranteed that each integer between $1$ and $k$ appears in $a$ at least once.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3000$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the minimum number of operations needed to make at least one subarray of $a$ colorful.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n3 2\n\n1 2 1\n\n7 3\n\n2 1 1 3 1 1 2\n\n6 3\n\n1 1 2 2 2 3\n\n6 3\n\n1 2 2 2 2 3\n\n10 5\n\n5 1 3 1 1 2 2 4 1 3\n\n9 4\n\n1 2 3 3 3 3 3 2 4\n\n```\n\n#### Output #1\n\n```\n0\n1\n2\n3\n4\n5\n```\n\n### Note\n\nIn the first test case, since the subarrays $[a_1, a_2] = [1, 2]$ and $[a_2, a_3] = [2, 1]$ are already colorful, we do not need to perform any operations. Thus, the answer is $0$.\n\nIn the second test case, we can swap $a_1$ and $a_2$ to obtain $[1, \\underline{2, 1, 3}, 1, 1, 2]$, which has a colorful subarray $[a_2, a_3, a_4] = [2, 1, 3]$. And the given array initially does not have any colorful subarrays, so the answer is $1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    if(!(cin >> t)) return 0;\n    while(t--){\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n+1);\n        for(int i = 1; i <= n; i++){\n            cin >> a[i];\n        }\n        // Build positions for each color 1..k\n        vector<vector<int>> pos(k+1);\n        for(int i = 1; i <= n; i++){\n            pos[a[i]].push_back(i);\n        }\n        // m = median rank among k picks\n        int m = (k + 1) / 2;\n        // compute constant Cpos = sum_{j=1..k} |j-m|\n        ll Cpos = 0;\n        for(int j = 1; j <= k; j++){\n            Cpos += ll(abs(j - m));\n        }\n        // next_ptr[c] = index in pos[c] of first occurrence > current pivot\n        vector<int> next_ptr(k+1, 0);\n        // lastPos[c] = last occurrence < current pivot index\n        vector<int> lastPos(k+1, 0);\n        const ll INFLL = (ll)4e18;\n        ll bestPivotCost = INFLL;\n        // prepare delta vector outside to reuse capacity\n        vector<ll> deltas;\n        deltas.reserve(k);\n\n        // Scan pivot indices i = 1..n\n        for(int i = 1; i <= n; i++){\n            int pc = a[i];\n            // advance next_ptr for pivot color to skip position i\n            // we want next_ptr[pc] at first pos > i\n            while(next_ptr[pc] < (int)pos[pc].size() && pos[pc][next_ptr[pc]] <= i){\n                next_ptr[pc] ++;\n            }\n            // compute fl, fr, cost0, collect deltas for flexible colors\n            int fl = 0, fr = 0;\n            ll cost0 = 0;\n            deltas.clear();\n            // for each color c != pc\n            for(int c = 1; c <= k; c++){\n                if(c == pc) continue;\n                bool leftOK = (lastPos[c] > 0);\n                bool rightOK = (next_ptr[c] < (int)pos[c].size());\n                // count forced left / right\n                if(!rightOK){\n                    fl++;\n                }\n                if(!leftOK){\n                    fr++;\n                }\n                // compute default cost0 and deltas\n                if(!rightOK){\n                    // must assign left\n                    // since leftOK must be true if viable, but cost anyway\n                    cost0 += ll(i - lastPos[c]);\n                } else {\n                    // default assign to right\n                    ll rc = ll(pos[c][next_ptr[c]] - i);\n                    cost0 += rc;\n                    if(leftOK){\n                        // flexible: could switch to left\n                        ll lc = ll(i - lastPos[c]);\n                        // delta = extra cost if choose left instead of default right\n                        deltas.push_back(lc - rc);\n                    }\n                    // if leftOK false, forced_right, default right cost counted\n                }\n            }\n            // check viability: forced_left fl <= m-1, forced_right fr <= k-m\n            if(fl <= m-1 && fr <= (k - m)){\n                int needLeft = (m - 1) - fl;\n                ll sum_delta = 0;\n                if(needLeft > 0){\n                    // pick needLeft smallest deltas from deltas\n                    // deltas size should >= needLeft\n                    // use nth_element for partial selection\n                    nth_element(deltas.begin(), deltas.begin() + needLeft, deltas.end());\n                    for(int j = 0; j < needLeft; j++){\n                        sum_delta += deltas[j];\n                    }\n                }\n                ll pivotCost = cost0 + sum_delta;\n                if(pivotCost < bestPivotCost){\n                    bestPivotCost = pivotCost;\n                }\n            }\n            // update lastPos for pivot color\n            lastPos[pc] = i;\n        }\n\n        // bestPivotCost should be finite\n        ll ans = bestPivotCost - Cpos;\n        if(ans < 0) ans = 0; // safety, though ans should be >=0\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2085d",
      "PROBLEM_ID": "2085D",
      "PROBLEM_STATEMENT": "Serval has just found a Kaitenzushi buffet restaurant. Kaitenzushi means that there is a conveyor belt in the restaurant, delivering plates of sushi in front of the customer, Serval.\n\nIn this restaurant, each plate contains exactly $k$ pieces of sushi and the $i$-th plate has a deliciousness $d_i$. Serval will have a meal in this restaurant for $n$ minutes, and within the $n$ minutes, he must eat up all the pieces of sushi he took from the belt.\n\nDenote the counter for uneaten taken pieces of sushi as $r$. Initially, $r=0$. In the $i$-th minute ($1\\leq i\\leq n$), only the $i$-th plate of sushi will be delivered in front of Serval, and he can do one of the following:\n\n- Take the $i$-th plate of sushi (whose deliciousness is $d_i$) from the belt, and $r$ will be increased by $k$;\n- Eat one uneaten piece of sushi that he took from the belt before, and $r$ will be decreased by $1$. Note that you can do this only if $r>0$;\n- Or, do nothing, and $r$ will remain unchanged.\n\nNote that after the $n$ minutes, the value of $r$ must be $0$.\n\nServal wants to maximize the sum of the deliciousnesses of all the plates he took. Help him find it out!\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1\\leq k<n\\leq 2\\cdot 10^5$) \u2014 the number of minutes of the meal and the number of sushi pieces in each plate.\n\nThe second line contains $n$ integers $d_1, d_2, \\ldots, d_n$ ($1\\leq d_i\\leq 10^9$) \u2014 the deliciousness of each plate.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer \u2014 the maximum possible sum of the deliciousnesses of all the plates Serval took.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n5 2\n\n3 6 4 1 2\n\n7 1\n\n3 1 4 1 5 9 2\n\n4 3\n\n4 3 2 1\n\n6 2\n\n1 3 5 2 4 6\n\n6 1\n\n1000000000 1 1000000000 1 1000000000 1\n\n```\n\n#### Output #1\n\n```\n6\n16\n4\n6\n3000000000\n```\n\n### Note\n\nIn the first test case, it can be shown that Serval can eat up at most one plate of sushi. Since the second plate of sushi has the greatest deliciousness $6$ among all the plates, he will take it from the belt in the second minute, and then eat it up in the following $2$ minutes.\n\nMinute$1\n\n$$2$$\n\n3\n\n$$4$$\n\n5$Action\u00a0\u2014\u00a0TakeEatEat\u00a0\u2014\u00a0$r$ after action$0\n\n$$2$$\n\n1\n\n$$0$$\n\n0$Deliciousnesses gained$0\n\n$$6$$\n\n6\n\n$$6$$\n\n6$\n\nIn the second test case, it can be shown that it is optimal for Serval to eat up the first, third, and sixth plates of sushi. The sum of the deliciousnesses of these plates is $3 + 4 + 9 = 16$.\n\nMinute$1\n\n$$2$$\n\n3\n\n$$4$$\n\n5\n\n$$6$$\n\n7$ActionTakeEatTakeEat\u00a0\u2014\u00a0TakeEat$r$ after action$1\n\n$$0$$\n\n1\n\n$$0$$\n\n0\n\n$$1$$\n\n0$Deliciousnesses gained$3\n\n$$3$$\n\n7\n\n$$7$$\n\n7\n\n$$16$$\n\n16$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<ll> d(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> d[i];\n        }\n\n        // We reverse the array so that y[i] = d[n-i]\n        // and define a \"deadline\" for each y[i] as floor(i/(k+1)).\n        // We have exactly floor(n/(k+1)) slots; slot j is at time (k+1)*j.\n        // Standard greedy for weighted scheduling with deadlines:\n        priority_queue<ll, vector<ll>, greater<ll>> min_heap;\n        ll answer = 0;\n\n        for (int i = 1; i <= n; ++i) {\n            ll val = d[n - i];           // y[i] = d[n-i]\n            int deadline = i / (k + 1);  // floor(i/(k+1))\n            if (deadline > 0) {\n                min_heap.push(val);\n                answer += val;\n                // If we exceed the number of slots by time i, drop the smallest\n                if ((int)min_heap.size() > deadline) {\n                    answer -= min_heap.top();\n                    min_heap.pop();\n                }\n            }\n            // If deadline == 0, we cannot schedule any job here, so we skip.\n        }\n\n        cout << answer << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2085c",
      "PROBLEM_ID": "2085C",
      "PROBLEM_STATEMENT": "You are given two positive integers $x$ and $y$ ($1\\le x, y\\le 10^9$).\n\nFind a non-negative integer $k\\le 10^{18}$, such that $(x+k) + (y+k) = (x+k)\\oplus (y+k)$ holds$^{\\text{\u2217}}$, or determine that such an integer does not exist.\n\n$^{\\\\text{\u2217}}$$\\\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains two integers $x$ and $y$ ($1\\le x, y\\le 10^9$) \u2014 the given integers.\n\n### Output\n\nFor each test case, output a single integer $k$ ($0\\le k\\le 10^{18}$) \u2014 the integer you found. Print $-1$ if it is impossible to find such an integer.\n\nIf there are multiple answers, you may print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2 5\n\n6 6\n\n19 10\n\n1024 4096\n\n1198372 599188\n\n```\n\n#### Output #1\n\n```\n0\n-1\n1\n1024\n28\n```\n\n### Note\n\nIn the first test case, since $(2 + 0) + (5 + 0) = (2 + 0) \\oplus (5 + 0) = 7$, $k=0$ is a possible answer. Note that $k=4$ is also a possible answer because $(2 + 4) + (5 + 4) = (2 + 4) \\oplus (5 + 4) = 15$.\n\nIn the second test case, $(x+k)\\oplus (y+k) = (6+k)\\oplus (6+k) = 0$. However, $(x+k)+(y+k) > 0$ holds for every $k \\ge 0$, implying that such an integer $k$ does not exist.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm> // Required for std::max\n\n// Function to compute the solution k for a given pair (x, y)\nlong long solve() {\n    long long x, y;\n    // Read input values for x and y for the current test case\n    std::cin >> x >> y;\n    \n    // The problem asks for a non-negative integer k <= 10^18 such that\n    // the condition (x+k) + (y+k) == (x+k) ^ (y+k) holds.\n    // Here, '+' denotes standard addition and '^' denotes bitwise XOR.\n\n    // We use the property that for any non-negative integers A and B,\n    // A + B = A ^ B + 2 * (A & B), where '&' is bitwise AND.\n    // The given condition (x+k) + (y+k) == (x+k) ^ (y+k) is thus equivalent to\n    // 2 * ((x+k) & (y+k)) == 0, which simplifies to (x+k) & (y+k) == 0.\n    // So, we need to find a non-negative integer k such that the bitwise AND\n    // of (x+k) and (y+k) is zero.\n\n    // Check if k=0 is a valid solution.\n    // If k=0, the condition becomes (x+0) & (y+0) == 0, which is x & y == 0.\n    // If x & y == 0, then k=0 is a valid solution. Since we need to find *any* non-negative k,\n    // and k=0 is the smallest possible non-negative value, it's a perfect candidate.\n    if ((x & y) == 0) {\n        return 0; \n    }\n\n    // Consider the case when x == y.\n    // If x == y, the condition becomes (x+k) & (x+k) == 0.\n    // Since A & A = A for any A, this means x+k == 0.\n    // However, we are given that x and y are positive integers (x, y >= 1).\n    // And k must be non-negative (k >= 0).\n    // Therefore, x+k >= 1 + 0 = 1. So x+k can never be 0.\n    // Thus, if x == y (and x >= 1), no solution exists.\n    if (x == y) {\n        return -1;\n    }\n    \n    // Now consider the case where x != y and x & y != 0. We need to find a k > 0.\n    // A strategy is derived based on setting one of (x+k) or (y+k) to a power of 2.\n    // Let target = max(x, y).\n    // Find the smallest power of 2, let's call it `pow2`, such that `pow2 >= target`.\n    // Let's define a candidate k based on this `pow2`.\n    // If x >= y, we set A = x+k = pow2. This means k = pow2 - x. Then B = y+k = y + pow2 - x.\n    // We need to check if A & B = pow2 & (y + pow2 - x) == 0.\n    // This is equivalent to checking pow2 & (pow2 - (x-y)) == 0.\n    // Let D = x-y. Since x > y, D > 0. We check pow2 & (pow2 - D) == 0.\n    // A property of powers of 2 states that for $P=2^p$, $P \\& (P-D) = 0$ if $0 < D \\le P$.\n    // Since pow2 is the smallest power of 2 >= x, and x > y >= 1, we have x-y < x <= pow2.\n    // Thus D = x-y satisfies $0 < D < pow2$. The condition holds.\n    //\n    // If y > x, we set B = y+k = pow2. This means k = pow2 - y. Then A = x+k = x + pow2 - y.\n    // We need to check if A & B = (x + pow2 - y) & pow2 == 0.\n    // This is equivalent to checking (pow2 - (y-x)) & pow2 == 0.\n    // Let D = y-x. Since y > x, D > 0. We check (pow2 - D) & pow2 == 0.\n    // Since pow2 is the smallest power of 2 >= y, and y > x >= 1, we have y-x < y <= pow2.\n    // Thus D = y-x satisfies $0 < D < pow2$. The condition holds.\n    \n    // In both cases (x > y and y > x), the derived k works.\n    // k = pow2 - max(x, y) is always non-negative because pow2 >= max(x, y).\n    // The constraints on x, y (<= 10^9, approx 2^30) ensure pow2 will be at most 2^30.\n    // The resulting k will be less than 2^30, comfortably within the 10^18 limit.\n\n    long long target = std::max(x, y);\n    long long pow2 = 1;\n    // Find the smallest power of 2 that is greater than or equal to target.\n    // Using left shift (<<= 1) for efficient multiplication by 2.\n    while (pow2 < target) {\n        pow2 <<= 1; \n         // Check for potential overflow. If pow2 becomes non-positive after shift, it indicates overflow.\n         // Given x, y <= 10^9, target <= 10^9. The smallest pow2 >= target will be at most 2^30.\n         // Since 2^30 fits within a 64-bit signed long long, overflow is not expected here.\n         if (pow2 <= 0) { \n              // This case indicates an unexpected issue, possibly with extremely large inputs not covered by constraints.\n              return -1; // Return -1 to signal failure/error state.\n         }\n    }\n    // At this point, pow2 is the smallest power of 2 such that pow2 >= target.\n\n    long long k_candidate;\n    // Calculate the candidate k based on which value (x or y) determined the target.\n    // If x was the target (x >= y), k makes x+k = pow2.\n    // If y was the target (y > x), k makes y+k = pow2.\n    if (x >= y) { \n         k_candidate = pow2 - x;\n    } else { \n         k_candidate = pow2 - y;\n    }\n\n    // This k_candidate is mathematically proven to be a valid solution for x != y and x & y != 0.\n    return k_candidate;\n}\n\nint main() {\n    // Optimize input/output operations for faster execution\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Variable to store the number of test cases\n    std::cin >> t; // Read the number of test cases\n    \n    // Loop through each test case\n    while (t--) {\n        // Compute the solution for the current test case using the solve function\n        // and print the result followed by a newline character.\n        std::cout << solve() << \"\\n\";\n    }\n    \n    return 0; // Indicate successful execution\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2085b",
      "PROBLEM_ID": "2085B",
      "PROBLEM_STATEMENT": "You are given an array $a$ consisting of $n\\ge 4$ non-negative integers.\n\nYou need to perform the following operation on $a$ until its length becomes $1$:\n\n- Select two indices $l$ and $r$ ($1\\le {\\color{red}{ l < r }} \\le |a|$), and replace the subarray $[a_l,a_{l+1},\\ldots,a_r]$ with a single integer $\\operatorname{mex}([a_l,a_{l+1},\\ldots,a_r])$, where $\\operatorname{mex}(b)$ denotes the minimum excluded (MEX)$^{\\text{\u2217}}$ of the integers in $b$. In other words, let $x=\\operatorname{mex}([a_l,a_{l+1},\\ldots,a_r])$, the array $a$ will become $[a_1,a_2,\\ldots,a_{l-1},x,a_{r+1},a_{r+2},\\ldots,a_{|a|}]$. Note that the length of $a$ decreases by $(r-l)$ after this operation.\n\nServal wants the final element in $a$ to be $0$. Help him!\n\nMore formally, you have to find a sequence of operations, such that after performing these operations in order, the length of $a$ becomes $1$, and the final element in $a$ is $0$.\n\nIt can be shown that at least one valid operation sequence exists under the constraints of the problem, and the length of any valid operation sequence does not exceed $n$.\n\nNote that you do not need to minimize the number of operations.\n\n$^{\\text{\u2217}}$The minimum excluded (MEX) of a collection of integers $b_1, b_2, \\ldots, b_k$ is defined as the smallest non-negative integer $x$ which does not occur in the collection $b$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($4\\le n\\le 5000$) \u2014 the length of the array $a$.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0\\le a_i\\le n$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, output a single integer $k$ ($0\\le k\\le n$) in the first line of output \u2014 the length of the operation sequence.\n\nThen, output $k$ lines, the $i$-th line containing two integers $l_i$ and $r_i$ ($1\\le l_i<r_i\\le |a|$) \u2014 the two indices you choose in the $i$-th operation, where $|a|$ denotes the length of the array before this operation.\n\nIf there are multiple answers, you may print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n4\n\n1 2 3 4\n\n5\n\n0 1 0 0 1\n\n6\n\n0 0 0 0 0 0\n\n6\n\n5 4 3 2 1 0\n\n4\n\n0 0 1 1\n\n4\n\n1 0 0 0\n\n```\n\n#### Output #1\n\n```\n1\n1 4\n4\n1 2\n1 2\n1 2\n1 2\n4\n5 6\n3 4\n1 2\n1 3\n3\n4 5\n4 5\n1 4\n2\n1 2\n1 3\n2\n2 4\n1 2\n```\n\n### Note\n\nIn the first test case, since $\\operatorname{mex}([1,2,3,4])=0$, after the only operation, the array becomes $[0]$.\n\nIn the second test case, the array $a$ changes as follows: \n\n$$ [\\underline{0,1},0,0,1]\\to [\\underline{2,0},0,1]\\to [\\underline{1,0},1]\\to [\\underline{2,1}]\\to [0]. $$\n\nIn the third test case, the array $a$ changes as follows: \n\n$$ [0,0,0,0,\\underline{0,0}]\\to [0,0,\\underline{0,0},1]\\to [\\underline{0,0},1,1]\\to [\\underline{1,1,1}]\\to [0]. $$\n\n",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <set>\n#include <algorithm>\n#include <vector> // Standard library for dynamic arrays\n\n/**\n * @brief Computes the Minimum Excluded (MEX) value for a pair of non-negative integers {x, y}.\n * \n * The MEX of a collection of integers is the smallest non-negative integer not present in the collection.\n * For a pair {x, y}, the MEX can be 0, 1, or 2.\n * - If neither x nor y is 0, then 0 is not present, so MEX is 0.\n * - If 0 is present, but 1 is not present (i.e., x=0, y=0 or x=0, y>1 or x>1, y=0), then MEX is 1.\n * - If both 0 and 1 are present (i.e., {x, y} is {0, 1}), then MEX is 2.\n * \n * @param x The first integer.\n * @param y The second integer.\n * @return The MEX of the pair {x, y}.\n */\nint compute_mex_pair(int x, int y) {\n    // Check if 0 is present in the pair {x, y}.\n    if (x != 0 && y != 0) {\n        // Neither x nor y is 0. Smallest non-negative integer missing is 0.\n        return 0; \n    }\n    \n    // At this point, we know 0 is present in the pair {x, y}.\n    // Now check if 1 is present.\n    if (x != 1 && y != 1) {\n        // 0 is present, but 1 is not present. Smallest non-negative integer missing is 1.\n        return 1; \n    }\n    \n    // At this point, we know both 0 and 1 are present in the pair {x, y}.\n    // The distinct elements must be {0, 1}. Smallest non-negative integer missing is 2.\n    return 2; \n}\n\nint main() {\n    // Use fast I/O operations.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Length of the array\n        std::cin >> n;\n        std::vector<int> a(n); // The array\n        int zero_count = 0; // Count of zeros in the array\n        \n        // Read array elements and count initial zeros.\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n            if (a[i] == 0) {\n                zero_count++;\n            }\n        }\n\n        std::vector<std::pair<int, int>> ops; // Stores the sequence of operations\n\n        // Check if the initial array contains any zeros.\n        if (zero_count == 0) {\n            // If there are no zeros initially, the MEX of the whole array is 0.\n            // We can achieve the goal in a single operation by replacing the entire array [a_1, ..., a_n] with its MEX.\n            // The problem constraints state n >= 4, so the array length is always >= 2, satisfying the l < r condition for operation (1, n).\n             ops.push_back({1, n});\n        } else {\n            // If there are zeros initially, we need to eliminate them first.\n            // Strategy: Repeatedly find the first zero and apply an operation on it and its neighbor.\n            // This operation will always produce a non-zero value (1 or 2) because it involves a 0.\n            \n            while (zero_count > 0) {\n                // The array size must be at least 2 to perform pairwise operations.\n                // Based on analysis (N>=4 initial, operations reducing size by 1), this should hold until all zeros are eliminated.\n                // Add a safety break in case array size becomes less than 2 unexpectedly.\n                if (a.size() < 2) {\n                     break; \n                }\n\n                int first_zero_idx = -1;\n                // Find the 0-based index of the first zero element in the current array `a`.\n                for (int i = 0; i < a.size(); ++i) {\n                    if (a[i] == 0) {\n                        first_zero_idx = i;\n                        break;\n                    }\n                }\n                \n                // If zero_count > 0, a zero must exist. If not found, it indicates a logic error.\n                if (first_zero_idx == -1) {\n                    break; // Safety break.\n                }\n\n                // Apply an operation involving the first zero found.\n                // Choose adjacent pair operation (i, i+1) or (i-1, i).\n                if (first_zero_idx < a.size() - 1) {\n                    // If the first zero is not the last element, operate on indices `first_zero_idx` and `first_zero_idx + 1`.\n                    // The 1-based indices for the operation are `first_zero_idx + 1` and `first_zero_idx + 2`.\n                    int l = first_zero_idx + 1; \n                    int r = first_zero_idx + 2; \n                    \n                    int val1 = a[first_zero_idx]; // This value is 0.\n                    int val2 = a[first_zero_idx + 1]; // The neighbor value.\n                    int m = compute_mex_pair(val1, val2); // Compute MEX of the pair.\n                    \n                    ops.push_back({l, r}); // Record the operation.\n\n                    // Update zero_count: Decrement for each 0 removed.\n                    // Since val1 is always 0, decrement once for it.\n                    zero_count--; \n                    // Decrement again if val2 is also 0.\n                    if (val2 == 0) {\n                        zero_count--;\n                    }\n                    // The new value 'm' computed by compute_mex_pair when one element is 0 can only be 1 or 2.\n                    // It can never be 0. So, we don't need to check if 'm' is 0 and increment zero_count.\n                    \n                    // Update the array: Replace element at `first_zero_idx` with `m`, remove element at `first_zero_idx + 1`.\n                    a[first_zero_idx] = m;\n                    a.erase(a.begin() + first_zero_idx + 1);\n\n                } else {\n                    // If the first zero is the last element, operate on indices `first_zero_idx - 1` and `first_zero_idx`.\n                    // The 1-based indices for the operation are `first_zero_idx` and `first_zero_idx + 1`.\n                    int l = first_zero_idx; // Corresponds to 0-based index `first_zero_idx - 1`.\n                    int r = first_zero_idx + 1; // Corresponds to 0-based index `first_zero_idx`.\n                    \n                    int val1 = a[first_zero_idx - 1]; // The neighbor value.\n                    int val2 = a[first_zero_idx]; // This value is 0.\n                    int m = compute_mex_pair(val1, val2); // Compute MEX of the pair.\n\n                    ops.push_back({l, r}); // Record the operation.\n\n                    // Update zero_count: Decrement for each 0 removed.\n                    // Decrement once for val2 (which is 0).\n                    zero_count--; \n                    // Decrement again if val1 is also 0.\n                    if (val1 == 0) {\n                        zero_count--;\n                    }\n                    // 'm' cannot be 0 since val2 is 0.\n\n                    // Update the array: Replace element at `first_zero_idx - 1` with `m`, remove the last element.\n                    a[first_zero_idx - 1] = m;\n                    a.pop_back();\n                }\n            } // End while loop (zero_count > 0)\n\n            // After the loop, the array `a` contains no zeros.\n            // The final step is to replace the entire array with its MEX. Since it contains no zeros, its MEX is 0.\n            // This requires the array length to be at least 2 to satisfy `l < r`.\n            // Based on analysis (initial N>=4, operations reduce size by 1), the size should be >= 2.\n            if (a.size() >= 2) {\n                 // Replace the whole array [a_1, ..., a_{current_size}] with MEX = 0.\n                 ops.push_back({1, (int)a.size()});\n            } else if (a.size() == 1) {\n                 // If the array size is 1, it must contain a single non-zero element.\n                 // This state should not be reachable if the goal is to end with [0],\n                 // as the problem guarantees a solution exists.\n                 // Assuming the analysis holds and N>=4 guarantees final intermediate size >= 2.\n            }\n             // Case a.size() == 0 is impossible.\n        }\n\n        // Output the total number of operations and the sequence of operations.\n        std::cout << ops.size() << \"\\n\";\n        for (const auto& p : ops) {\n            std::cout << p.first << \" \" << p.second << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2085a",
      "PROBLEM_ID": "2085A",
      "PROBLEM_STATEMENT": "A string $r$ consisting only of lowercase Latin letters is called universal if and only if $r$ is lexicographically smaller$^{\\text{\u2217}}$ than the reversal$^{\\text{\u2020}}$ of $r$.\n\nYou are given a string $s$ consisting of $n$ lowercase Latin letters. You are required to make $s$ universal. To achieve this, you can perform the following operation on $s$ at most $k$ times:\n\n- Choose two indices $i$ and $j$ ($1\\le i,j\\le n$), then swap $s_i$ and $s_j$. Note that if $i=j$, you do nothing.\n\nDetermine whether you can make $s$ universal by performing the above operation at most $k$ times.\n\n$^{\\text{\u2217}}$A string $a$ is lexicographically smaller than a string $b$ of the same length, if and only if the following holds:\n\n- in the first position where $a$ and $b$ differ, the string $a$ has a letter that appears earlier in the alphabet than the corresponding letter in $b$.\n\n$^{\\text{\u2020}}$The reversal of a string $r$ is the string obtained by writing $r$ from right to left. For example, the reversal of the string $\\texttt{abcad}$ is $\\texttt{dacba}$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1\\le n\\le 100$, $0\\le k\\le 10^4$) \u2014 the length of the string $s$, and the maximum number of operations you can perform.\n\nThe second line contains a string $s$ consisting of $n$ lowercase Latin letters.\n\n### Output\n\nFor each test case, print \"YES\" if it is possible to make $s$ universal by performing the operation at most $k$ times. Otherwise, print \"NO\".\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n1 10000\n\na\n\n3 3\n\nrev\n\n6 0\n\nstring\n\n6 0\n\ntheory\n\n9 2\n\nuniversal\n\n19 0\n\ncodeforcesecrofedoc\n\n19 1\n\ncodeforcesecrofedoc\n\n3 1\n\nzzz\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nNO\nYES\nYES\nNO\nYES\nNO\n```\n\n### Note\n\nIn the first test case, $s$ will keep the same after any operations. However, the reversal of $\\texttt{a}$ is still $\\texttt{a}$, so it is impossible to make $s$ universal.\n\nIn the second test case, the string $\\texttt{rev}$ is lexicographically smaller than $\\texttt{ver}$. Thus, $s$ is already universal.\n\nIn the fifth test case, you can perform the operations as follows:\n\n1. Swap $s_4$ and $s_7$. After this operation, $s$ becomes $\\texttt{uniserval}$;\n2. Swap $s_1$ and $s_3$. After this operation, $s$ becomes $\\texttt{inuserval}$.\n\nAnd the string $\\texttt{inuserval}$ is universal.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if string a is lexicographically smaller than string b\nbool isLexSmaller(const string& a, const string& b) {\n    return a < b;\n}\n\n// Function to get reversed string\nstring getReversed(const string& s) {\n    string rev = s;\n    reverse(rev.begin(), rev.end());\n    return rev;\n}\n\n// Function to check if we can make string universal with k swaps\nbool canMakeUniversal(string s, int k) {\n    int n = s.length();\n    \n    // If string length is 1, it can never be universal\n    if (n == 1) return false;\n    \n    // If string is already universal, no swaps needed\n    if (isLexSmaller(s, getReversed(s))) return true;\n    \n    // If k = 0 and string is not universal, it's impossible\n    if (k == 0) return false;\n    \n    // For small strings, try all possible swaps\n    string rev = getReversed(s);\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            // Try swapping characters at positions i and j\n            swap(s[i], s[j]);\n            if (isLexSmaller(s, getReversed(s))) {\n                return true;\n            }\n            // Restore the string\n            swap(s[i], s[j]);\n        }\n    }\n    \n    // If k >= 2, we can always make the string universal by properly arranging characters\n    // unless all characters are same\n    if (k >= 2) {\n        char first = s[0];\n        bool allSame = true;\n        for (char c : s) {\n            if (c != first) {\n                allSame = false;\n                break;\n            }\n        }\n        return !allSame;\n    }\n    \n    return false;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        string s;\n        cin >> s;\n        \n        cout << (canMakeUniversal(s, k) ? \"YES\" : \"NO\") << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2084h",
      "PROBLEM_ID": "2084H",
      "PROBLEM_STATEMENT": "[LGR-205-Div.1 C Turtle and Nediam](https://www.luogu.com.cn/problem/P11283)\n\nYou are given a binary sequence $s$ of length $n$ which only consists of $0$ and $1$.\n\nYou can do the following operation at most $n - 2$ times (possibly zero):\n\n- Let $m$ denote the current length of $s$. Choose an integer $i$ such that $1 \\le i \\le m - 2$.\n- Let the median$^{\\text{\u2217}}$ of the subarray $[s_i, s_{i + 1}, s_{i + 2}]$ be $x$, and let $j$ be the smallest integer such that $j \\ge i$ and $s_j = x$.\n- Remove $s_j$ from the sequence and concatenate the remaining parts. In other words, replace $s$ with $[s_1, s_2, \\ldots, s_{j - 1}, s_{j + 1}, s_{j + 2}, \\ldots, s_m]$.\n\nNote that after every operation, the length of $s$ decreases by $1$.\n\nFind how many different binary sequences can be obtained after performing the operation, modulo $10^9 + 7$.\n\n$^{\\text{\u2217}}$The median of an array of odd length $k$ is the $\\frac{k + 1}{2}$-th element when sorted.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 2 \\cdot 10^6$) \u2014 the length of the binary sequence.\n\nThe second line of each test case contains a string $s$ of length $n$, consisting of only $0$ and $1$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^6$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the number of binary sequences that can be obtained, modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n5\n\n11111\n\n6\n\n100011\n\n9\n\n000111000\n\n14\n\n11001111111000\n\n16\n\n0010000110100011\n\n```\n\n#### Output #1\n\n```\n4\n8\n30\n114\n514\n```\n\n### Note\n\nIn the first test case, the following binary sequences can be obtained: $[1, 1]$, $[1, 1, 1]$, $[1, 1, 1, 1]$, $[1, 1, 1, 1, 1]$.\n\nIn the second test case, the following binary sequences can be obtained: $[0, 1]$, $[0, 1, 1]$, $[1, 0, 1]$, $[1, 0, 0, 1]$, $[1, 0, 1, 1]$, $[1, 0, 0, 0, 1]$, $[1, 0, 0, 1, 1]$, $[1, 0, 0, 0, 1, 1]$. For example, to obtain $[0, 1, 1]$, you can:\n\n- Choose $i = 2$. The median of $[0, 0, 0]$ is $0$. Remove $s_2$. The sequence becomes $[1, 0, 0, 1, 1]$.\n- Choose $i = 1$. The median of $[1, 0, 0]$ is $0$. Remove $s_2$. The sequence becomes $[1, 0, 1, 1]$.\n- Choose $i = 1$. The median of $[1, 0, 1]$ is $1$. Remove $s_1$. The sequence becomes $[0, 1, 1]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn = 2000100;\nconst ll mod = 1000000007;\n\nint n, a[maxn], m, nxt[maxn], stk[maxn], top;\nll f[maxn], g[maxn], d[maxn];\nchar s[maxn];\n\ninline ll calc() {\n\ttop = 0;\n\tfor (int i = m; i >= 1; i -= 2) {\n\t\twhile (top && a[stk[top]] - stk[top] / 2 < a[i] - i / 2) {\n\t\t\t--top;\n\t\t}\n\t\tnxt[i] = stk[top];\n\t\tstk[++top] = i;\n\t}\n\ttop = 0;\n\tfor (int i = m - 1; i >= 1; i -= 2) {\n\t\twhile (top && a[stk[top]] - stk[top] / 2 < a[i] - i / 2) {\n\t\t\t--top;\n\t\t}\n\t\tnxt[i] = stk[top];\n\t\tstk[++top] = i;\n\t}\n\tfor (int i = 1; i < m; ++i) {\n\t\tf[i] = g[i] = d[i] = 0;\n\t}\n\tf[1] = a[1];\n\tfor (int i = 3; i < m; i += 2) {\n\t\tf[i] = 1;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i < m; ++i) {\n\t\tif (i >= 3) {\n\t\t\td[i] = (d[i] + d[i - 2]) % mod;\n\t\t}\n\t\tf[i] = (f[i] + d[i]) % mod;\n\t\tg[i + 1] = (g[i + 1] + f[i]) % mod;\n\t\tf[i + 1] = (f[i + 1] + f[i] * a[i + 1]) % mod;\n\t\td[i + 2] = (d[i + 2] + g[i]) % mod;\n\t\tif (nxt[i]) {\n\t\t\tg[nxt[i]] = (g[nxt[i]] + g[i]) % mod;\n\t\t\tf[nxt[i]] = (f[nxt[i]] + g[i] * (a[nxt[i]] - a[i] - (nxt[i] - i) / 2 + 1)) % mod;\n\t\t\td[nxt[i]] = (d[nxt[i]] - g[i] + mod) % mod;\n\t\t}\n\t\tif ((m - i) & 1) {\n\t\t\tans = (ans + f[i]) % mod;\n\t\t}\n\t}\n\treturn ans * a[m] % mod;\n}\n\nvoid solve() {\n\tcin >> n >> s;\n\tm = 0;\n\tfor (int i = 0, j = 0; i < n; i = (++j)) {\n\t\twhile (j + 1 < n && s[j + 1] == s[i]) {\n\t\t\t++j;\n\t\t}\n\t\ta[++m] = j - i + 1;\n\t}\n\tif (m == 1) {\n\t\tcout << n - 1 << '\\n';\n\t\treturn;\n\t}\n\tif (m == 2) {\n\t\tcout << 1LL * a[1] * a[2] % mod << '\\n';\n\t\treturn;\n\t}\n\tll ans = calc();\n\t--m;\n\tfor (int i = 1; i <= m; ++i) {\n\t\ta[i] = a[i + 1];\n\t}\n\ta[1] = 1;\n\tans = (ans + calc()) % mod;\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2084g2",
      "PROBLEM_ID": "2084G2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, $t \\le 10^4$, $n \\le 5 \\cdot 10^5$ and the sum of $n$ does not exceed $5 \\cdot 10^5$. You can hack only if you solved all versions of this problem.\n\nFor a non-empty sequence $c$ of length $k$, define $f(c)$ as follows:\n\n- Turtle and Piggy are playing a game on a sequence. They are given the sequence $c_1, c_2, \\ldots, c_k$, and Turtle goes first. Turtle and Piggy alternate in turns (so, Turtle does the first turn, Piggy does the second, Turtle does the third, etc.).\n- The game goes as follows:\n  - Let the current length of the sequence be $m$. If $m = 1$, the game ends.\n  - If the game does not end and it's Turtle's turn, then Turtle must choose an integer $i$ such that $1 \\le i \\le m - 1$, set $c_i$ to $\\min(c_i, c_{i + 1})$, and remove $c_{i + 1}$.\n  - If the game does not end and it's Piggy's turn, then Piggy must choose an integer $i$ such that $1 \\le i \\le m - 1$, set $c_i$ to $\\max(c_i, c_{i + 1})$, and remove $c_{i + 1}$.\n- Turtle wants to maximize the value of $c_1$ in the end, while Piggy wants to minimize the value of $c_1$ in the end.\n- $f(c)$ is the value of $c_1$ in the end if both players play optimally.\n\nFor a permutation $p$ of length $n$$^{\\\\text{\u2217}}$, Turtle defines the beauty of the permutation as $\\sum\\limits_{i = 1}^n \\sum\\limits_{j = i}^n f([p_i, p_{i + 1}, \\ldots, p_j])$ (i.e., the sum of $f(c)$ where $c$ is a non-empty subsegment$^{\\text{\u2020}}$ of $p$).\n\nPiggy gives Turtle a permutation $a$ of length $n$ where some elements are missing and represented by $0$.\n\nTurtle asks you to determine a permutation $b$ of length $n$ such that:\n\n- $b$ can be formed by filling in the missing elements of $a$ (i.e., for all $1 \\le i \\le n$, if $a_i \\ne 0$, then $b_i = a_i$).\n- The beauty of the permutation $b$ is maximized.\n\nFor convenience, you only need to find the maximum beauty of such permutation $b$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n$^{\\text{\u2020}}$A sequence $a$ is a subsegment of a sequence $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 5 \\cdot 10^5$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le n$). It is guaranteed that the elements of $a$ that are not $0$ are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the maximum beauty of the permutation $b$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n2\n\n1 0\n\n3\n\n0 0 0\n\n3\n\n0 1 0\n\n5\n\n3 2 4 5 1\n\n7\n\n0 3 2 5 0 0 0\n\n10\n\n1 2 6 5 8 9 0 0 0 0\n\n5\n\n0 4 1 0 0\n\n5\n\n0 1 5 2 3\n\n```\n\n#### Output #1\n\n```\n4\n12\n11\n44\n110\n300\n45\n40\n```\n\n### Note\n\nIn the first test case, the permutation $b$ with the maximum beauty is $[1, 2]$. The beauty of $[1, 2]$ is $4$ since $f([1]) + f([2]) + f([1, 2]) = 1 + 2 + 1 = 4$. If $c = [1, 2]$, then $f(c) = 1$ since Turtle can only choose $i = 1$ and he will set $c_1$ to $\\min(c_1, c_2) = 1$.\n\nIn the second test case, one of the permutations $b$ with the maximum beauty is $[3, 2, 1]$. The beauty of $[3, 2, 1]$ is $12$ since $f([3]) + f([2]) + f([1]) + f([3, 2]) + f([2, 1]) + f([3, 2, 1]) = 3 + 2 + 1 + 2 + 1 + 3 = 12$.\n\nIn the third test case, one of the permutations $b$ with the maximum beauty is $[2, 1, 3]$.\n\nIn the fourth test case, if $c = [3, 2, 4, 5, 1]$, then $f(c) = 3$. One of the possible game processes is as follows:\n\n- Turtle can choose $i = 3$. Then he will set $c_3$ to $\\min(c_3, c_4) = 4$ and remove $c_4$. The sequence $c$ will become $[3, 2, 4, 1]$.\n- Piggy can choose $i = 1$. Then he will set $c_1$ to $\\max(c_1, c_2) = 3$ and remove $c_2$. The sequence $c$ will become $[3, 4, 1]$.\n- Turtle can choose $i = 2$. Then he will set $c_2$ to $\\min(c_2, c_3) = 1$ and remove $c_3$. The sequence $c$ will become $[3, 1]$.\n- Piggy can choose $i = 1$. Then he will set $c_1$ to $\\max(c_1, c_2) = 3$ and remove $c_2$. The sequence $c$ will become $[3]$.\n- The length of the sequence becomes $1$, so the game will end. The value of $c_1$ will be $3$ in the end.\n\nIn the fifth test case, one of the permutations $b$ with the maximum beauty is $[1, 3, 2, 5, 6, 4, 7]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn = 500100;\n\nint n, a[maxn];\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nint p[maxn], nt, ls[maxn], rs[maxn], sz[maxn];\nbool vis[maxn];\n\nstruct vec {\n\tll a0, a1, a2;\n\tvec(ll a = 0, ll b = 0, ll c = 0) : a0(a), a1(b), a2(c) {}\n} val[maxn];\n\nstruct mat {\n\tll a00, a01, a02, a10, a11, a12, a20, a21, a22;\n\tmat(ll a = 0, ll b = 0, ll c = 0, ll d = 0, ll e = 0, ll f = 0, ll g = 0, ll h = 0, ll i = 0) : a00(a), a01(b), a02(c), a10(d), a11(e), a12(f), a20(g), a21(h), a22(i) {}\n} I, tag[maxn];\n\ninline vec operator * (const vec &a, const mat &b) {\n\tvec res;\n\tres.a0 = a.a0 * b.a00 + a.a1 * b.a10 + a.a2 * b.a20;\n\tres.a1 = a.a0 * b.a01 + a.a1 * b.a11 + a.a2 * b.a21;\n\tres.a2 = a.a0 * b.a02 + a.a1 * b.a12 + a.a2 * b.a22;\n\treturn res;\n}\n\ninline mat operator * (const mat &a, const mat &b) {\n\tmat res;\n\tres.a00 = a.a00 * b.a00 + a.a01 * b.a10 + a.a02 * b.a20;\n\tres.a01 = a.a00 * b.a01 + a.a01 * b.a11 + a.a02 * b.a21;\n\tres.a02 = a.a00 * b.a02 + a.a01 * b.a12 + a.a02 * b.a22;\n\tres.a10 = a.a10 * b.a00 + a.a11 * b.a10 + a.a12 * b.a20;\n\tres.a11 = a.a10 * b.a01 + a.a11 * b.a11 + a.a12 * b.a21;\n\tres.a12 = a.a10 * b.a02 + a.a11 * b.a12 + a.a12 * b.a22;\n\tres.a20 = a.a20 * b.a00 + a.a21 * b.a10 + a.a22 * b.a20;\n\tres.a21 = a.a20 * b.a01 + a.a21 * b.a11 + a.a22 * b.a21;\n\tres.a22 = a.a20 * b.a02 + a.a21 * b.a12 + a.a22 * b.a22;\n\treturn res;\n}\n\ninline void init() {\n\tfor (int i = 0; i <= nt; ++i) {\n\t\tp[i] = ls[i] = rs[i] = sz[i] = 0;\n\t\tval[i] = vec();\n\t\ttag[i] = I;\n\t\tvis[i] = 0;\n\t}\n\tnt = 0;\n}\n\ninline int newnode(ll x, ll y) {\n\tint u = ++nt;\n\tp[u] = rnd();\n\tls[u] = rs[u] = 0;\n\tsz[u] = 1;\n\tval[u] = vec(x, y, 1);\n\ttag[u] = I;\n\tvis[u] = 0;\n\treturn u;\n}\n\ninline void pushup(int x) {\n\tsz[x] = sz[ls[x]] + sz[rs[x]] + 1;\n}\n\ninline void pushtag(int x, const mat &y) {\n\tif (!x) {\n\t\treturn;\n\t}\n\tval[x] = val[x] * y;\n\ttag[x] = tag[x] * y;\n\tvis[x] = 1;\n}\n\ninline void pushdown(int x) {\n\tif (!vis[x]) {\n\t\treturn;\n\t}\n\tpushtag(ls[x], tag[x]);\n\tpushtag(rs[x], tag[x]);\n\tvis[x] = 0;\n\ttag[x] = I;\n}\n\nvoid split(int u, int &x, int &y) {\n\tif (!u) {\n\t\tx = y = 0;\n\t\treturn;\n\t}\n\tpushdown(u);\n\tif (val[u].a0 < 0) {\n\t\tx = u;\n\t\tsplit(rs[u], rs[u], y);\n\t} else {\n\t\ty = u;\n\t\tsplit(ls[u], x, ls[u]);\n\t}\n\tpushup(u);\n}\n\nint merge(int x, int y) {\n\tif (!x || !y) {\n\t\treturn x | y;\n\t}\n\tpushdown(x);\n\tpushdown(y);\n\tif (p[x] < p[y]) {\n\t\trs[x] = merge(rs[x], y);\n\t\tpushup(x);\n\t\treturn x;\n\t} else {\n\t\tls[y] = merge(x, ls[y]);\n\t\tpushup(y);\n\t\treturn y;\n\t}\n}\n\nll f[maxn], tot;\n\nvoid dfs(int u) {\n\tif (!u) {\n\t\treturn;\n\t}\n\tpushdown(u);\n\tdfs(ls[u]);\n\tf[++tot] = val[u].a0;\n\tdfs(rs[u]);\n}\n\nvoid solve() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\ta[i] = -1;\n\t}\n\tfor (int i = 1, x; i <= n; ++i) {\n\t\tcin >> x;\n\t\tif (x) {\n\t\t\ta[x] = (i & 1);\n\t\t}\n\t}\n\tinit();\n\tint rt = 0;\n\tll l = 0, r = 0, x = 0;\n\tif (a[1] == 1) {\n\t\tl = r = 1;\n\t} else if (a[1] == -1) {\n\t\trt = newnode(0, 1);\n\t\tr = 1;\n\t}\n\tfor (ll i = 1; i < n; ++i) {\n\t\tx += l * l * 2 + (-i - i - (n & 1)) * l + i * ((n + 1) / 2);\n\t\tpushtag(rt, mat(1, 0, 0, 4, 1, 0, -i - i - (n & 1) - 2, 0, 1));\n\t\tif (a[i + 1] == 1) {\n\t\t\tpushtag(rt, mat(1, 0, 0, 0, 1, 0, 0, 1, 1));\n\t\t\t++l;\n\t\t\t++r;\n\t\t} else if (a[i + 1] == -1) {\n\t\t\tint u, v;\n\t\t\tsplit(rt, u, v);\n\t\t\tpushtag(v, mat(1, 0, 0, 0, 1, 0, 0, 1, 1));\n\t\t\trt = merge(merge(u, newnode(0, l + 1 + sz[u])), v);\n\t\t\t++r;\n\t\t}\n\t}\n\ttot = 0;\n\tdfs(rt);\n\tll ans = -x;\n\tfor (int i = 1; i <= (n + 1) / 2 - l; ++i) {\n\t\tans -= f[i];\n\t}\n\tfor (ll i = 1; i <= n; ++i) {\n\t\tans += i * i;\n\t}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tI.a00 = I.a11 = I.a22 = 1;\n\tint T;\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2084g1",
      "PROBLEM_ID": "2084G1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, $t \\le 1000$, $n \\le 5000$ and the sum of $n$ does not exceed $5000$. You can hack only if you solved all versions of this problem.\n\nFor a non-empty sequence $c$ of length $k$, define $f(c)$ as follows:\n\n- Turtle and Piggy are playing a game on a sequence. They are given the sequence $c_1, c_2, \\ldots, c_k$, and Turtle goes first. Turtle and Piggy alternate in turns (so, Turtle does the first turn, Piggy does the second, Turtle does the third, etc.).\n- The game goes as follows:\n  - Let the current length of the sequence be $m$. If $m = 1$, the game ends.\n  - If the game does not end and it's Turtle's turn, then Turtle must choose an integer $i$ such that $1 \\le i \\le m - 1$, set $c_i$ to $\\min(c_i, c_{i + 1})$, and remove $c_{i + 1}$.\n  - If the game does not end and it's Piggy's turn, then Piggy must choose an integer $i$ such that $1 \\le i \\le m - 1$, set $c_i$ to $\\max(c_i, c_{i + 1})$, and remove $c_{i + 1}$.\n- Turtle wants to maximize the value of $c_1$ in the end, while Piggy wants to minimize the value of $c_1$ in the end.\n- $f(c)$ is the value of $c_1$ in the end if both players play optimally.\n\nFor a permutation $p$ of length $n$$^{\\\\text{\u2217}}$, Turtle defines the beauty of the permutation as $\\sum\\limits_{i = 1}^n \\sum\\limits_{j = i}^n f([p_i, p_{i + 1}, \\ldots, p_j])$ (i.e., the sum of $f(c)$ where $c$ is a non-empty subsegment$^{\\text{\u2020}}$ of $p$).\n\nPiggy gives Turtle a permutation $a$ of length $n$ where some elements are missing and represented by $0$.\n\nTurtle asks you to determine a permutation $b$ of length $n$ such that:\n\n- $b$ can be formed by filling in the missing elements of $a$ (i.e., for all $1 \\le i \\le n$, if $a_i \\ne 0$, then $b_i = a_i$).\n- The beauty of the permutation $b$ is maximized.\n\nFor convenience, you only need to find the maximum beauty of such permutation $b$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n$^{\\text{\u2020}}$A sequence $a$ is a subsegment of a sequence $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 5000$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le n$). It is guaranteed that the elements of $a$ that are not $0$ are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the maximum beauty of the permutation $b$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n2\n\n1 0\n\n3\n\n0 0 0\n\n3\n\n0 1 0\n\n5\n\n3 2 4 5 1\n\n7\n\n0 3 2 5 0 0 0\n\n10\n\n1 2 6 5 8 9 0 0 0 0\n\n5\n\n0 4 1 0 0\n\n5\n\n0 1 5 2 3\n\n```\n\n#### Output #1\n\n```\n4\n12\n11\n44\n110\n300\n45\n40\n```\n\n### Note\n\nIn the first test case, the permutation $b$ with the maximum beauty is $[1, 2]$. The beauty of $[1, 2]$ is $4$ since $f([1]) + f([2]) + f([1, 2]) = 1 + 2 + 1 = 4$. If $c = [1, 2]$, then $f(c) = 1$ since Turtle can only choose $i = 1$ and he will set $c_1$ to $\\min(c_1, c_2) = 1$.\n\nIn the second test case, one of the permutations $b$ with the maximum beauty is $[3, 2, 1]$. The beauty of $[3, 2, 1]$ is $12$ since $f([3]) + f([2]) + f([1]) + f([3, 2]) + f([2, 1]) + f([3, 2, 1]) = 3 + 2 + 1 + 2 + 1 + 3 = 12$.\n\nIn the third test case, one of the permutations $b$ with the maximum beauty is $[2, 1, 3]$.\n\nIn the fourth test case, if $c = [3, 2, 4, 5, 1]$, then $f(c) = 3$. One of the possible game processes is as follows:\n\n- Turtle can choose $i = 3$. Then he will set $c_3$ to $\\min(c_3, c_4) = 4$ and remove $c_4$. The sequence $c$ will become $[3, 2, 4, 1]$.\n- Piggy can choose $i = 1$. Then he will set $c_1$ to $\\max(c_1, c_2) = 3$ and remove $c_2$. The sequence $c$ will become $[3, 4, 1]$.\n- Turtle can choose $i = 2$. Then he will set $c_2$ to $\\min(c_2, c_3) = 1$ and remove $c_3$. The sequence $c$ will become $[3, 1]$.\n- Piggy can choose $i = 1$. Then he will set $c_1$ to $\\max(c_1, c_2) = 3$ and remove $c_2$. The sequence $c$ will become $[3]$.\n- The length of the sequence becomes $1$, so the game will end. The value of $c_1$ will be $3$ in the end.\n\nIn the fifth test case, one of the permutations $b$ with the maximum beauty is $[1, 3, 2, 5, 6, 4, 7]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> a(n + 1, -1);\n\tvector< vector<ll> > f(n + 1, vector<ll>(n + 1, 1e18));\n\tfor (int i = 1, x; i <= n; ++i) {\n\t\tcin >> x;\n\t\tif (x) {\n\t\t\ta[x] = i & 1;\n\t\t}\n\t}\n\tif (a[1] != 1) {\n\t\tf[1][0] = 0;\n\t}\n\tif (a[1] != 0) {\n\t\tf[1][1] = 0;\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tf[i][j] += j * (n / 2 - (i - j)) + (i - j) * ((n + 1) / 2 - j);\n\t\t\tif (a[i + 1] != 1) {\n\t\t\t\tf[i + 1][j] = min(f[i + 1][j], f[i][j]);\n\t\t\t}\n\t\t\tif (a[i + 1] != 0) {\n\t\t\t\tf[i + 1][j + 1] = min(f[i + 1][j + 1], f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = -f[n][(n + 1) / 2];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tans += i * i;\n\t}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tint T;\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2084f",
      "PROBLEM_ID": "2084F",
      "PROBLEM_STATEMENT": "You are given a permutation $a$ of length $n$$^{\\\\text{\u2217}}$.\n\nWe say that a permutation $b$ of length $n$ is good if the two permutations $a$ and $b$ can become the same after performing the following operation at most $n$ times (possibly zero):\n\n- Choose two integers $l, r$ such that $1 \\le l < r \\le n$ and $a_r = \\min(a_l, a_{l + 1}, \\ldots, a_r)$.\n- Cyclically shift the subsegment $[a_l, a_{l + 1}, \\ldots, a_r]$ one position to the right. In other words, replace $a$ with $[a_1, \\ldots, a_{l - 1}, \\; a_r, a_l, a_{l + 1}, \\ldots, a_{r - 1}, \\; a_{r + 1}, \\ldots, a_n]$.\n\nYou are also given a permutation $c$ of length $n$ where some elements are missing and represented by $0$.\n\nYou need to find a good permutation $b_1, b_2, \\ldots, b_n$ such that $b$ can be formed by filling in the missing elements of $c$ (i.e., for all $1 \\le i \\le n$, if $c_i \\ne 0$, then $b_i = c_i$). If it is impossible, output $-1$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 5 \\cdot 10^5$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$). It is guaranteed that $a$ is a permutation of length $n$.\n\nThe third line of each test case contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($0 \\le c_i \\le n$). It is guaranteed that the elements of $c$ that are not $0$ are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case:\n\n- If it is impossible to find such a good permutation $b$, output a single integer $-1$.\n- Otherwise, output $n$ integers $b_1, b_2, \\ldots, b_n$ \u2014 the good permutation $b$ you've found. You need to ensure that for all $1 \\le i \\le n$, if $c_i \\ne 0$, then $b_i = c_i$. If there are multiple answers, output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n2\n\n2 1\n\n1 2\n\n4\n\n3 2 4 1\n\n2 0 0 1\n\n5\n\n3 2 1 5 4\n\n1 3 0 0 0\n\n5\n\n3 2 1 5 4\n\n3 2 1 5 4\n\n5\n\n3 2 1 5 4\n\n3 2 5 1 4\n\n6\n\n3 5 6 2 1 4\n\n0 2 0 5 0 0\n\n6\n\n3 5 6 2 1 4\n\n0 2 0 6 4 0\n\n9\n\n6 9 2 4 1 7 8 3 5\n\n0 2 5 9 0 0 0 8 0\n\n9\n\n8 5 3 9 1 7 4 6 2\n\n0 0 8 0 7 0 4 0 2\n\n```\n\n#### Output #1\n\n```\n1 2\n2 3 4 1\n1 3 2 4 5\n3 2 1 5 4\n-1\n3 2 1 5 4 6\n-1\n-1\n1 3 8 5 7 9 4 6 2\n```\n\n### Note\n\nIn the first test case, $b = [1, 2]$ is a valid answer since after performing the following operation, $a$ and $b$ will become the same:\n\n- Choose $l = 1, r = 2$ and cyclically shift the subsegment $[a_1, a_2]$ one position to the right. Then $a$ will become $[1, 2]$.\n\nIn the second test case, $b = [2, 3, 4, 1]$ is a valid answer since after performing the following operation, $a$ and $b$ will become the same:\n\n- Choose $l = 1, r = 2$ and cyclically shift the subsegment $[a_1, a_2]$ one position to the right. Then $a$ will become $[2, 3, 4, 1]$.\n\nIn the third test case, $b = [1, 3, 2, 4, 5]$ is a valid answer since after performing the following operation, $a$ and $b$ will become the same:\n\n- Choose $l = 1, r = 3$ and cyclically shift the subsegment $[a_1, a_2, a_3]$ one position to the right. Then $a$ will become $[1, 3, 2, 5, 4]$.\n- Choose $l = 4, r = 5$ and cyclically shift the subsegment $[a_4, a_5]$ one position to the right. Then $a$ will become $[1, 3, 2, 4, 5]$.\n\nIn the fourth test case, $b = [3, 2, 1, 5, 4]$ is a valid answer since $a$ and $b$ are already the same.\n\nIn the fifth test case, it is impossible to find such a good permutation $b$, so you should output $-1$.\n\nIn the sixth test case, $b = [3, 2, 1, 5, 4, 6]$ is a valid answer since after performing the following operation, $a$ and $b$ will become the same:\n\n- Choose $l = 2, r = 4$ and cyclically shift the subsegment $[a_2, a_3, a_4]$ one position to the right. Then $a$ will become $[3, 2, 5, 6, 1, 4]$.\n- Choose $l = 3, r = 5$ and cyclically shift the subsegment $[a_3, a_4, a_5]$ one position to the right. Then $a$ will become $[3, 2, 1, 5, 6, 4]$.\n- Choose $l = 5, r = 6$ and cyclically shift the subsegment $[a_5, a_6]$ one position to the right. Then $a$ will become $[3, 2, 1, 5, 4, 6]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 500100;\n\nint n, a[maxn], b[maxn], c[maxn], p[maxn], q[maxn];\n\nstruct node {\n\tint r, x;\n\tnode(int a = 0, int b = 0) : r(a), x(b) {}\n};\n\ninline bool operator < (const node &a, const node &b) {\n\treturn a.r > b.r || (a.r == b.r && a.x > b.x);\n}\n\nvector<node> vc[maxn];\n\nstruct DS1 {\n\tint c[maxn];\n\t\n\tinline void init() {\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tc[i] = 0;\n\t\t}\n\t}\n\t\n\tinline void update(int x, int d) {\n\t\tfor (int i = x; i <= n; i += (i & (-i))) {\n\t\t\tc[i] = max(c[i], d);\n\t\t}\n\t}\n\t\n\tinline int query(int x) {\n\t\tint res = 0;\n\t\tfor (int i = x; i; i -= (i & (-i))) {\n\t\t\tres = max(res, c[i]);\n\t\t}\n\t\treturn res;\n\t}\n} T1;\n\nstruct DS2 {\n\tint c[maxn];\n\t\n\tinline void init() {\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tc[i] = n + 1;\n\t\t}\n\t}\n\t\n\tinline void update(int x, int d) {\n\t\tfor (int i = x; i; i -= (i & (-i))) {\n\t\t\tc[i] = min(c[i], d);\n\t\t}\n\t}\n\t\n\tinline int query(int x) {\n\t\tint res = n + 1;\n\t\tfor (int i = x; i <= n; i += (i & (-i))) {\n\t\t\tres = min(res, c[i]);\n\t\t}\n\t\treturn res;\n\t}\n} T2;\n\nvoid solve() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i];\n\t\tp[a[i]] = i;\n\t\tq[i] = 0;\n\t\tvector<node>().swap(vc[i]);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> b[i];\n\t\tif (b[i]) {\n\t\t\tq[b[i]] = i;\n\t\t}\n\t}\n\tT1.init();\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (q[i]) {\n\t\t\tif (T1.query(p[i]) > q[i]) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tT1.update(p[i], q[i]);\n\t\t}\n\t}\n\tT1.init();\n\tT2.init();\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (q[a[i]]) {\n\t\t\tT1.update(a[i], q[a[i]]);\n\t\t} else {\n\t\t\tc[i] = T1.query(a[i]) + 1;\n\t\t}\n\t}\n\tfor (int i = n; i; --i) {\n\t\tif (q[a[i]]) {\n\t\t\tT2.update(a[i], q[a[i]]);\n\t\t} else {\n\t\t\tint r = T2.query(a[i]) - 1;\n\t\t\tif (c[i] > r) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvc[c[i]].emplace_back(r, a[i]);\n\t\t}\n\t}\n\tpriority_queue<node> pq;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (node u : vc[i]) {\n\t\t\tpq.push(u);\n\t\t}\n\t\tif (!b[i]) {\n\t\t\tif (pq.empty() || pq.top().r < i) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tb[i] = pq.top().x;\n\t\t\tpq.pop();\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcout << b[i] << \" \\n\"[i == n];\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2084e",
      "PROBLEM_ID": "2084E",
      "PROBLEM_STATEMENT": "You are given a permutation $a$ of length $n$$^{\\\\text{\u2217}}$ where some elements are missing and represented by $-1$.\n\nDefine the value of a permutation as the sum of the MEX$^{\\text{\u2020}}$ of all its non-empty subsegments$^{\\text{\u2021}}$.\n\nFind the sum of the value of all possible valid permutations that can be formed by filling in the missing elements of $a$ modulo $10^9 + 7$.\n\n$^{\\text{\u2217}}$ A permutation of length $n$ is an array consisting of $n$ distinct integers from $\\bf{0}$ to $\\bf{n - 1}$ in arbitrary order. For example, $[1,2,0,4,3]$ is a permutation, but $[0,1,1]$ is not a permutation ($1$ appears twice in the array), and $[0,2,3]$ is also not a permutation ($n=3$ but there is $3$ in the array).\n\n$^{\\text{\u2020}}$The minimum excluded (MEX) of a collection of integers $c_1, c_2, \\ldots, c_k$ is defined as the smallest non-negative integer $x$ which does not occur in the collection $c$.\n\n$^{\\text{\u2021}}$A sequence $a$ is a subsegment of a sequence $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 5000$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-1 \\le a_i < n$).\n\nIt is guaranteed that the elements of $a$ that are not $-1$ are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the sum of the value of all possible valid permutations modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n0 -1\n\n2\n\n-1 -1\n\n3\n\n2 0 1\n\n3\n\n-1 2 -1\n\n5\n\n-1 0 -1 2 -1\n\n```\n\n#### Output #1\n\n```\n3\n6\n7\n10\n104\n```\n\n### Note\n\nIn the first test case, the only valid permutation is $[0, 1]$, and the value of $[0, 1]$ is $3$ since:\n\n\n\n$$\\operatorname{mex}([0]) + \\operatorname{mex}([1]) + \\operatorname{mex}([0, 1]) = 1 + 0 + 2 = 3$$\n\nSo the answer is $3$.\n\nIn the second test case, there are two valid permutations: $[0, 1]$ and $[1, 0]$. The value of $[0, 1]$ and the value of $[1, 0]$ is $3$, so the answer is $3 + 3 = 6$.\n\nIn the fourth test case, there are two valid permutations: $[0, 2, 1]$ and $[1, 2, 0]$. The value of $[0, 2, 1]$ is $5$ since:\n\n\n\n$$\\operatorname{mex}([0]) + \\operatorname{mex}([2]) + \\operatorname{mex}([1]) + \\operatorname{mex}([0, 2]) + \\operatorname{mex}([2, 1]) + \\operatorname{mex}([0, 2, 1]) = 1 + 0 + 0 + 1 + 0 + 3 = 5$$\n\nAnd the value of $[1, 2, 0]$ is $5$ since:\n\n\n\n$$\\operatorname{mex}([1]) + \\operatorname{mex}([2]) + \\operatorname{mex}([0]) + \\operatorname{mex}([1, 2]) + \\operatorname{mex}([2, 0]) + \\operatorname{mex}([1, 2, 0]) = 0 + 0 + 1 + 0 + 1 + 3 = 5$$\n\nSo the answer is $5 + 5 = 10$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\n// Modular arithmetic constants and functions\nconst int MOD = 1000000007;\n\n// Computes (base^exp) % MOD using binary exponentiation\nlong long power(long long base, long long exp) {\n    long long res = 1;\n    base %= MOD;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return res;\n}\n\n// Computes modular inverse using Fermat's Little Theorem (MOD must be prime)\nlong long modInverse(long long n) {\n    return power(n, MOD - 2);\n}\n\n// Precomputed factorials and inverse factorials up to MAXN_FAC\nconst int MAXN_FAC = 5005; \nlong long fact[MAXN_FAC];\nlong long invFact[MAXN_FAC];\n\n// Function to precompute factorials and their inverses modulo MOD\nvoid precompute_factorials(int n) {\n    // Ensure precomputation up to the maximum needed index (N)\n    // Safeguard against n exceeding the array bounds\n    if (n >= MAXN_FAC) n = MAXN_FAC - 1; \n    fact[0] = 1;\n    invFact[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n        invFact[i] = modInverse(fact[i]); // Compute inverse using precomputed power function\n    }\n}\n\n// Function to compute P(n, k) = n! / (n-k)! mod MOD (permutations)\nlong long P(int n, int k) {\n    // Basic validity checks\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    // Ensure indices are within bounds of precomputed factorials\n    if (n >= MAXN_FAC || (n - k) >= MAXN_FAC || n < 0 || (n-k) < 0) {\n         // If indices are out of bounds, return 0 or handle as error.\n         // With N <= 5000, this should not be hit if precompute_factorials(5000) is called.\n         return 0; \n    }\n    // Compute P(n, k) using precomputed factorials and inverse factorials\n    return (fact[n] * invFact[n - k]) % MOD;\n}\n\n// Global arrays for storing problem state per test case\nconst int MAXN = 5005; // Max N based on problem constraints\nint pos[MAXN]; // Position of value i (0..n-1), -1 if missing\nint L[MAXN], R[MAXN]; // L[x]: min position, R[x]: max position of fixed values {0..x-1}\nint m[MAXN]; // m[x]: count of missing values among {0..x-1}\nint X1[MAXN], X2[MAXN]; // Precomputed bounds for x based on segment start 'l' and end 'r'\nint ps[MAXN]; // Prefix sum of -1 counts in the input array a\n\n// 2D array for prefix sums of function f(k, x) = P(k, m_x) * (k-m_x)!\n// ps_f[K][X] stores sum_{x=1}^X f(K, x) mod MOD\nlong long ps_f[MAXN][MAXN]; \n\nint main() {\n    // Fast I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    // Precompute factorials up to max possible N=5000\n    precompute_factorials(5000);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        int n; // Length of the permutation\n        cin >> n;\n        vector<int> a(n + 1); // Use 1-based indexing for the input array a\n        \n        // Reset pos array for the current test case. Initialize all positions to -1 (missing).\n        fill(pos, pos + n, -1); \n\n        int k = 0; // Count of -1s (total missing elements)\n        for (int i = 1; i <= n; ++i) {\n            cin >> a[i];\n            if (a[i] != -1) {\n                 // Value a[i] is fixed at position i. Store this mapping.\n                 pos[a[i]] = i; \n            } else {\n                // Increment count of missing elements\n                k++; \n            }\n        }\n\n        // Compute prefix sums of -1 counts for efficient lookup of k_lr\n        ps[0] = 0;\n        for (int i = 1; i <= n; ++i) {\n            ps[i] = ps[i - 1] + (a[i] == -1);\n        }\n\n        // Compute L(x), R(x), m(x) for x = 1 to n. These track properties of the set {0..x-1}.\n        L[0] = n + 1; // Initialize L[0] (empty set) to a value larger than any possible index\n        R[0] = 0;     // Initialize R[0] (empty set) to 0\n        m[0] = 0;     // Initialize m[0] (empty set) to 0\n        for (int x = 1; x <= n; ++x) {\n            int val = x - 1; // Current value being considered is x-1\n            // Inherit values from previous state (x-1)\n            L[x] = L[x - 1];\n            R[x] = R[x - 1];\n            m[x] = m[x - 1];\n            if (pos[val] != -1) { // If value `val` is present at a fixed position\n                 // Update min and max positions seen so far\n                 L[x] = min(L[x], pos[val]);\n                 R[x] = max(R[x], pos[val]);\n            } else { // If value `val` is missing (-1 initially)\n                 // Increment count of missing values in the set {0..x-1}\n                 m[x]++;\n            }\n        }\n\n        // Compute X1[l] = max {x | l <= L[x]} using a two-pointer approach\n        // X1[l] gives the max x such that all fixed elements {0..x-1} are at or after index l\n        int current_x_for_L = n;\n        for(int l=1; l<=n; ++l) {\n            // Since L[x] is non-increasing with x, we decrease current_x_for_L\n            while(current_x_for_L > 0 && L[current_x_for_L] < l) {\n                current_x_for_L--;\n            }\n            X1[l] = current_x_for_L;\n        }\n        \n        // Compute X2[r] = max {x | R[x] <= r} using a two-pointer approach\n        // X2[r] gives the max x such that all fixed elements {0..x-1} are at or before index r\n        int current_x_for_R = 0;\n         for(int r=1; r<=n; ++r) {\n             // Since R[x] is non-decreasing with x, we increase current_x_for_R\n             // Check R[current_x_for_R + 1] to safely access R values for x = 1..n\n             while(current_x_for_R < n && R[current_x_for_R + 1] <= r) {\n                 current_x_for_R++;\n             }\n             X2[r] = current_x_for_R;\n         }\n\n        // Precompute prefix sums ps_f[K][X] = sum_{x=1}^X P(K, m_x) * (k-m_x)!\n        // K represents k_lr, the count of -1s in a subsegment [l,r]. Max value is k.\n        // X ranges from 1 to n.\n        for (int K = 0; K <= k; ++K) {\n            ps_f[K][0] = 0; // Base case: prefix sum up to X=0 is 0\n            for (int x = 1; x <= n; ++x) {\n                long long term = 0;\n                // Check if m[x] <= K. P(K, m[x]) is 0 if m[x] > K.\n                if (m[x] <= K) { \n                    // Calculate the term P(K, m_x) * (k - m[x])!\n                    // k - m[x] is guaranteed non-negative because m[x] <= k.\n                    term = (P(K, m[x]) * fact[k - m[x]]) % MOD;\n                }\n                // Add the current term to the previous prefix sum value\n                ps_f[K][x] = (ps_f[K][x - 1] + term) % MOD;\n            }\n        }\n\n        // Calculate the total value by summing contributions over all subsegments [l, r]\n        long long total_value = 0;\n        for (int l = 1; l <= n; ++l) { // Iterate through all possible start indices l\n            for (int r = l; r <= n; ++r) { // Iterate through all possible end indices r >= l\n                int k_lr = ps[r] - ps[l - 1]; // Number of -1s in subsegment a[l..r]\n                // Effective upper bound for x based on fixed elements constraints for this segment\n                int X_lr = min(X1[l], X2[r]); \n                \n                // If X_lr > 0, there's potential contribution to the sum\n                if (X_lr > 0) {\n                   // Check if k_lr is within valid range [0, k] for indexing ps_f\n                   if (k_lr >= 0 && k_lr <= k) {\n                       // Add the precomputed prefix sum value ps_f[k_lr][X_lr] to total\n                       total_value = (total_value + ps_f[k_lr][X_lr]) % MOD;\n                   }\n                }\n            }\n        }\n        // Ensure the final result is non-negative (handle potential negative results from modulo operations)\n        if (total_value < 0) total_value += MOD;\n\n        cout << total_value << \"\\n\"; // Output the final sum modulo 10^9 + 7\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2084d",
      "PROBLEM_ID": "2084D",
      "PROBLEM_STATEMENT": "You are given three integers $n$, $m$, and $k$, where $m \\cdot k < n$.\n\nFor a sequence $b$ consisting of non-negative integers, define $f(b)$ as follows:\n\n- You may perform the following operation on $b$:\n  - Let $l$ denote the current length of $b$. Choose a positive integer $1 \\\\leq i \\\\leq l - k + 1$, remove the subarray from index $i$ to $i + k - 1$ and concatenate the remaining parts. In other words, replace $b$ with \n\n$$[b_1, b_2, \\ldots, b_{i - 1}, b_{i + k}, b_{i + k + 1}, \\ldots, b_l].$$\n\nf(b)$ is defined as the minimum possible value of $\\\\operatorname{mex}(b)$$^{\\\\text{\u2217}}$ after performing the above operation at most $m$ times (possibly zero).\n\nYou need to construct a sequence $a$ of length $n$ consisting of non-negative integers, such that:\n\n- For all $1 \\le i \\le n$, $0 \\le a_i \\le 10^9$.\n- Over all such sequences $a$, $f(a)$ is maximized.\n\n$^{\\text{\u2217}}$The minimum excluded (MEX) of a collection of integers $c_1, c_2, \\ldots, c_k$ is defined as the smallest non-negative integer $x$ which does not occur in the collection $c$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$ ($2 \\le n \\le 2 \\cdot 10^5$, $1 \\le m < n$, $1 \\le k < n$, $1 \\le m \\cdot k < n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$).\n\nIf there are multiple answers, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n2 1 1\n\n5 2 2\n\n6 1 4\n\n8 2 2\n\n8 1 5\n\n11 3 3\n\n22 6 3\n\n17 2 2\n\n```\n\n#### Output #1\n\n```\n0 0\n0 1 0 0 0\n0 1 2 2 0 1\n0 2 1 0 1 0 8 1\n0 1 2 1000000000 1 0 1 2\n1 0 0 1 0 2 1 0 2 1 0\n0 2 1 0 2 1 0 3 2 1 0 2 1 0 2 1 0 2 1 0 2 1\n4 0 2 1 3 4 0 2 1 0 3 4 0 1 2 1 3\n```\n\n### Note\n\nIn the first test case, it can be shown that $f(a) = 1$, which is maximized.\n\nIn the second test case, it can be shown that $f(a) = 1$, which is maximized. $f(a) = 1$ since you can perform the following operations:\n\n- Choose $i = 3$, remove the subarray from index $3$ to $4$ and concatenate the remaining parts. The sequence $a$ becomes $[0, 1, 0]$.\n- Choose $i = 1$, remove the subarray from index $1$ to $2$ and concatenate the remaining parts. The sequence $a$ becomes $[0]$.\n\nIn the third test case, it can be shown that $f(a) = 2$, which is maximized. $f(a) = 2$ since you can perform the following operation:\n\n- Choose $i = 2$, remove the subarray from index $2$ to $5$ and concatenate the remaining parts. The sequence $a$ becomes $[0, 1]$.\n\nIn the fourth test case, it can be shown that $f(a) = 2$, which is maximized.\n\nIn the fifth test case, it can be shown that $f(a) = 3$, which is maximized.\n\nIn the sixth test case, it can be shown that $f(a) = 2$, which is maximized.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t; \n    cin >> t;\n    while(t--){\n        int n, m, k;\n        cin >> n >> m >> k;\n        // Choose X = min( floor(n/(m+1)) , n - m*k ).\n        int candidate1 = n/(m+1);  // number of blocks possible if we plant one block in every segment\n        int candidate2 = n - m*k;  // to help ensure the span of occurrences is large enough\n        int X = min(candidate1, candidate2);\n        if(X <= 0) X = 1; // ensure at least one number is protected\n \n        // We will fill our answer array with a \"dummy\" safe number (here 10^9)\n        vector<int> ans(n, 1000000000);\n \n        // Compute gap for spacing the (m+1) segments.\n        // We wish to plant a block of X numbers in each segment.\n        int gap = (n - X) / m; // by our choice of X, we have (m+1)*X <= n so this works.\n \n        // For j = 0,...,m, let the starting index of that segment be:\n        //    start = 1 + j*gap   (1-indexed)\n        // and \u201cplant\u201d 0,1,...,X-1 in that segment.\n        for (int j = 0; j <= m; j++){\n            int start = 1 + j * gap;  // 1-indexed start position\n            // Make sure the block [start, start+X-1] fits in the array.\n            if(start + X - 1 > n) continue;\n            for (int x = 0; x < X; x++){\n                int pos = start + x; // 1-indexed position\n                ans[pos-1] = x;      // plant protected number x here\n            }\n        }\n \n        // Output the sequence.\n        for (int i = 0; i < n; i++){\n            cout << ans[i] << (i+1 == n ? \"\\n\" : \" \");\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2084c",
      "PROBLEM_ID": "2084C",
      "PROBLEM_STATEMENT": "You are given a permutation $a$ and $b$ of length $n$$^{\\\\text{\u2217}}$. You can perform the following operation at most $n$ times:\n\n- Choose two indices $i$ and $j$ ($1 \\le i, j \\le n$, $i \\ne j$), swap $a_i$ with $a_j$, swap $b_i$ with $b_j$.\n\nDetermine whether $a$ and $b$ can be reverses of each other after operations. In other words, for each $i = 1, 2, \\ldots, n$, $a_i = b_{n + 1 - i}$.\n\nIf it is possible, output any valid sequence of operations. Otherwise, output $-1$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of the permutations.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$).\n\nThe third line contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le n$).\n\nIt is guaranteed that $a$ and $b$ are permutations of length $n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, if it is impossible, output $-1$ in the only line. Otherwise, output a single integer $m$ ($0 \\le m \\le n$)\u00a0\u2014 the number of operations in the first line. In the following $m$ lines, output two integers\u00a0\u2014 the indices $i$ and $j$ ($1 \\le i, j \\le n$, $i \\ne j$) in each operation in order. If there are multiple solutions, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n1 2\n\n1 2\n\n2\n\n1 2\n\n2 1\n\n4\n\n1 3 2 4\n\n2 4 1 3\n\n5\n\n2 5 1 3 4\n\n3 5 4 2 1\n\n5\n\n3 1 2 4 5\n\n1 2 3 4 5\n\n```\n\n#### Output #1\n\n```\n-1\n0\n1\n1 2\n2\n1 2\n1 3\n-1\n```\n\n### Note\n\nIn the second test case, $b$ is already the reverse of $a$.\n\nIn the third test case, after performing the following operation, $b$ will become the reverse of $a$:\n\n- Swap $a_1, a_2$ and swap $b_1, b_2$. Now $a = [3, 1, 2, 4]$ and $b = [4, 2, 1, 3]$.\n\nIn the fourth test case, after performing the following operations in order, $b$ will become the reverse of $a$:\n\n- Swap $a_1, a_2$ and swap $b_1, b_2$. Now $a = [5, 2, 1, 3, 4]$ and $b = [5, 3, 4, 2, 1]$.\n- Swap $a_1, a_3$ and swap $b_1, b_3$. Now $a = [1, 2, 5, 3, 4]$ and $b = [4, 3, 5, 2, 1]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <utility> // For std::pair\n#include <map>     // For std::map\n#include <vector>\n#include <numeric>   // Not used here, but potentially useful for some problems\n#include <algorithm> // Not used explicitly, map handles key sorting\n\n// Structure to compute the swaps needed to achieve a target permutation\nstruct PermutationSwaps {\n    int n; // Size of the permutation\n    // p[i] stores the target position (1-based) for the element originally at index i (0-based).\n    // Example: If the element originally at index 0 should move to position 3, then p[0] = 3.\n    std::vector<int> p; \n    std::vector<bool> visited; // Tracks visited elements during cycle finding\n    std::vector<std::pair<int, int>> swaps; // Stores the sequence of swap operations\n\n    // Constructor initializes the structure with the size N\n    PermutationSwaps(int size) : n(size), p(size), visited(size, false) {}\n\n    // Finds cycles in the permutation defined by p and generates the minimum swaps needed.\n    // The swaps transform the identity permutation into the target permutation p.\n    void find_cycles_and_swaps() {\n        for (int i = 0; i < n; ++i) { // Iterate through elements by their original 0-based index i\n            if (!visited[i]) { // If element i hasn't been visited (i.e., not part of a cycle found earlier)\n                std::vector<int> cycle; // Stores elements (using 1-based indices) in the current cycle\n                int current = i; // Start tracing the cycle from 0-based index i\n                \n                // Trace the cycle until we return to a visited node (which will be the start of the cycle)\n                while (!visited[current]) {\n                    visited[current] = true; // Mark current element as visited\n                    cycle.push_back(current + 1); // Add its 1-based index to the cycle list\n                    \n                    // p[current] holds the target 1-based position for the element originally at index current.\n                    // To find the next element in the cycle, we need its 0-based index.\n                    // So, convert the target position p[current] (1-based) to 0-based index.\n                    current = p[current] - 1; \n                }\n                \n                // A cycle of length L > 1 requires L-1 swaps to resolve.\n                if (cycle.size() > 1) {\n                    // Generate swaps based on standard cycle decomposition method:\n                    // Swap the first element with each subsequent element in the cycle.\n                    // (c1, c2), (c1, c3), ..., (c1, cL)\n                    for (size_t j = 1; j < cycle.size(); ++j) {\n                        swaps.push_back({cycle[0], cycle[j]});\n                    }\n                }\n            }\n        }\n    }\n};\n\n// Function to solve a single test case\nvoid solve() {\n    int n; // Length of the permutations\n    std::cin >> n;\n    std::vector<int> a(n), b(n); // Input permutations a and b\n    \n    // Use a map to store the mapping from a pair (a_i, b_i) to a list of original indices i (1-based) where it occurs.\n    // This helps find pairs and their locations efficiently.\n    std::map<std::pair<int, int>, std::vector<int>> pair_to_indices;\n    \n    // Read input arrays a and b\n    for (int i = 0; i < n; ++i) std::cin >> a[i];\n    for (int i = 0; i < n; ++i) std::cin >> b[i];\n\n    // Populate the map: store initial positions (1-based) for each pair (a[i], b[i])\n    for (int i = 0; i < n; ++i) {\n        pair_to_indices[{a[i], b[i]}].push_back(i + 1); \n    }\n\n    std::vector<bool> visited(n + 1, false); // Keep track of visited status for 1-based indices during the partitioning step\n    std::vector<int> target_pos(n + 1); // target_pos[i] will store the target final position (1-based) for the element originally at index i\n    std::vector<std::pair<int, int>> index_pairs; // Stores pairs {i, j} of original indices such that the pair at j is the reverse of the pair at i\n    std::vector<int> singletons; // Stores original indices k where the pair is its own reverse (a_k == b_k)\n\n    bool possible = true; // Flag to track if a valid configuration is possible\n    \n    // Partition the indices {1, ..., n} into pairs {i, j} such that (a_j, b_j) = (b_i, a_i),\n    // or singletons {k} such that (a_k, b_k) = (b_k, a_k).\n    for (int i = 1; i <= n; ++i) { // Iterate through indices 1 to n\n        if (visited[i]) continue; // Skip if index i has already been processed (part of a pair/singleton found earlier)\n\n        std::pair<int, int> current_pair = {a[i-1], b[i-1]}; // The pair (a_i, b_i) using 0-based access to arrays\n        std::pair<int, int> reversed_pair = {b[i-1], a[i-1]}; // The reversed pair (b_i, a_i)\n\n        // Check if the reversed pair exists in our map\n        auto it_reversed = pair_to_indices.find(reversed_pair);\n        if (it_reversed != pair_to_indices.end()) { // Reversed pair found in the map\n            std::vector<int>& indices = it_reversed->second; // Get the list of indices where reversed_pair occurs\n            int found_j = -1; // Will store the partner index j (1-based)\n            int found_k = -1; // Will store the index within the vector `indices` where partner j is found\n\n            // Find an *unvisited* index j associated with the reversed pair\n            for (int k = 0; k < indices.size(); ++k) {\n                 if (!visited[indices[k]]) { // Found an unvisited partner index j\n                    found_j = indices[k];\n                    found_k = k; // Store the position in the vector for removal\n                    break;\n                 }\n            }\n\n            if (found_j != -1) { // Successfully found an unvisited partner index j\n                 // Crucial step: Remove index j from its list in the map *before* marking it visited.\n                 // This correctly handles the case i=j (singleton).\n                 indices.erase(indices.begin() + found_k);\n                 // If the list becomes empty after removal, erase the map entry for reversed_pair to save memory and potentially speed up lookups.\n                 if (indices.empty()) {\n                     pair_to_indices.erase(it_reversed);\n                 }\n\n                if (i == found_j) { // Singleton case: The index pairs with itself (a_i == b_i)\n                    visited[i] = true; // Mark index i as visited\n                    singletons.push_back(i); // Add i to the list of singletons\n                    // Index i was already removed from its list because found_j == i.\n                } else { // Paired case: Index i pairs with a distinct index j\n                    visited[i] = true; // Mark index i as visited\n                    visited[found_j] = true; // Mark index j as visited\n                    index_pairs.push_back({i, found_j}); // Record the pair of indices {i, j}\n                    \n                    // Now, remove index i from its list associated with current_pair.\n                    // Need to find current_pair in the map again, as it might be different from reversed_pair.\n                    auto it_current = pair_to_indices.find(current_pair);\n                    if (it_current != pair_to_indices.end()) { // Check if current_pair still exists (it might have been removed if i=j)\n                         std::vector<int>& indices_i = it_current->second;\n                         // Find index i in the list and remove it\n                         for (int k = 0; k < indices_i.size(); ++k) {\n                            if (indices_i[k] == i) {\n                                indices_i.erase(indices_i.begin() + k);\n                                break; // Found and removed i, exit inner loop\n                            }\n                         }\n                         // If list for current_pair becomes empty, remove the map entry\n                         if (indices_i.empty()) {\n                            pair_to_indices.erase(it_current);\n                         }\n                    }\n                }\n\n            } else { // No *unvisited* partner index j was found for reversed_pair among its listed indices\n                 possible = false; // Cannot form the required structure\n                 break; // Exit the loop early\n            }\n\n        } else { // Reversed pair doesn't exist in the map at all\n            possible = false; // Cannot form the required structure\n            break; // Exit the loop early\n        }\n    }\n\n    // After the loop, perform final checks:\n\n    // 1. Ensure all indices were visited. If not, it indicates an issue (e.g., inconsistent input or logic error).\n     if (possible) {\n        for(int i=1; i<=n; ++i) {\n            if (!visited[i]) {\n                 possible = false; \n                 break;\n            }\n        }\n     }\n\n    // 2. Check the number of singletons based on the parity of n.\n    if (possible) {\n      if (n % 2 != 0) { // If n is odd\n          if (singletons.size() != 1) { // Must have exactly one singleton\n              possible = false; \n          }\n      } else { // If n is even\n          if (singletons.size() != 0) { // Must have no singletons\n              possible = false; \n          }\n      }\n    }\n\n    // If any check failed, output -1 and return.\n    if (!possible) {\n         std::cout << -1 << std::endl;\n         return;\n    }\n    \n    // If possible, assign target positions (1-based) for each original index\n    // to achieve the desired final state where a[k] = b[n+1-k].\n    int left = 1, right = n; // Pointers for assigning symmetric positions\n    if (n % 2 != 0) {\n        // The single singleton element must go to the middle position\n        target_pos[singletons[0]] = (n + 1) / 2;\n    }\n    // Assign symmetric positions {left, right} to the paired indices {i, j}\n    for (const auto& p : index_pairs) {\n        // Assign original index p.first to position `left`, and p.second to position `right`.\n        // The assignment (i to left, j to right) vs (i to right, j to left) doesn't affect correctness, only the specific final permutation.\n        target_pos[p.first] = left;\n        target_pos[p.second] = right;\n        left++; // Move left pointer inwards\n        right--; // Move right pointer inwards\n    }\n\n    // Now we know the target position for each original element.\n    // We need to find the swaps to move elements from their initial positions to their target positions.\n    PermutationSwaps state(n); // Create the state object to calculate swaps\n    for(int i=1; i<=n; ++i) {\n        // Populate the permutation vector `p`. state.p uses 0-based indexing for elements,\n        // and stores the 1-based target position.\n        // state.p[i-1] = target position for element originally at index i (1-based).\n        state.p[i-1] = target_pos[i]; \n    }\n\n    // Find cycles in this permutation and generate the required swaps\n    state.find_cycles_and_swaps();\n\n    // Output the result: number of swaps and the sequence of swaps.\n    std::cout << state.swaps.size() << std::endl;\n    for (const auto& sw : state.swaps) {\n        std::cout << sw.first << \" \" << sw.second << std::endl;\n    }\n}\n\n// Main function to handle multiple test cases\nint main() {\n    // Optimize C++ standard streams for faster I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) { // Loop through each test case\n        solve(); // Solve the current test case\n    }\n    return 0; // Indicate successful execution\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2084b",
      "PROBLEM_ID": "2084B",
      "PROBLEM_STATEMENT": "You are given a positive integer sequence $a$ of length $n$. Determine if it is possible to rearrange $a$ such that there exists an integer $i$ ($1 \\\\le i<n$) satisfying \n\n$$ \\min([a_1,a_2,\\ldots,a_i])=\\gcd([a_{i+1},a_{i+2},\\ldots,a_n]). $$\n\nHere $\\gcd(c)$ denotes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of $c$, which is the maximum positive integer that divides all integers in $c$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^{18}$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output \"Yes\" if it is possible, and \"No\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n2\n\n1 1\n\n2\n\n1 2\n\n3\n\n2 2 3\n\n3\n\n2 3 4\n\n5\n\n4 5 6 9 3\n\n3\n\n998244359987710471 99824435698771045 1000000007\n\n6\n\n1 1 4 5 1 4\n\n```\n\n#### Output #1\n\n```\nYes\nNo\nYes\nNo\nYes\nYes\nYes\n```\n\n### Note\n\nIn the first test case, rearrange $a$ to $[1,1]$ and let $i=1$, then $\\min([1])=\\gcd([1])$.\n\nIn the second test case, it can be shown that it is impossible.\n\nIn the third test case, rearrange $a$ to $[3,2,2]$ and let $i=2$, then $\\min([3,2])=\\gcd([2])$.\n\nIn the fifth test case, rearrange $a$ to $[3,4,5,6,9]$ and let $i=3$, then $\\min([3,4,5])=\\gcd([6,9])$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Required for std::gcd in C++17\n#include <algorithm> // Required for std::min\n\n/*\n * Check if std::gcd is available (C++17 or later).\n * If not, provide a custom implementation.\n */\n#if __cplusplus >= 201703L\n// std::gcd is available in C++17\n#else\n// Manual implementation for GCD for C++ versions before C++17\nlong long custom_gcd(long long a, long long b) {\n    // Ensure non-negative inputs for standard Euclidean algorithm\n    if (a < 0) a = -a;\n    if (b < 0) b = -b;\n    while (b) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\n// Provide std::gcd like function for compatibility\nnamespace std {\n    long long gcd(long long a, long long b) {\n        return custom_gcd(a, b);\n    }\n}\n#endif\n\n/**\n * @brief Computes the greatest common divisor (GCD) of all elements in a vector.\n * \n * @param vec A const reference to a vector of long long integers. Assumed non-empty by caller.\n * @return The GCD of all elements in the vector. If the vector contains only one element, returns that element.\n */\nlong long vector_gcd(const std::vector<long long>& vec) {\n    // The caller logic ensures vec is not empty when this function is called.\n    // If vec could be empty, additional checks would be needed.\n    // For safety, check anyway (though it indicates a logical error upstream).\n    if (vec.empty()) {\n         // This state implies it's impossible to form the required set R,\n         // which is handled by the caller check S_prime_div.empty().\n         // Returning a value like -1 helps indicate error if this function were called incorrectly.\n        return -1; \n    }\n    \n    // Initialize GCD result with the first element.\n    long long result = vec[0];\n    \n    // Iterate through the rest of the vector elements, updating GCD.\n    for (size_t i = 1; i < vec.size(); ++i) {\n        // Use std::gcd (available in C++17 or provided custom implementation).\n        result = std::gcd(result, vec[i]);\n        // Early exit optimization: if GCD becomes 1, it can't become smaller positive integer.\n        // But we need the check G == a_min later. Let's complete the calculation.\n        // If a_min > 1 and result becomes 1, we know G != a_min, could optimize?\n        // Example: a_min = 6, S'_div = [12, 18, 7]. gcd(12, 18) = 6. gcd(6, 7) = 1. Final G=1.\n        // Check G == a_min becomes 1 == 6 -> No.\n        // So optimization by checking if result==1 is only useful if a_min==1.\n    }\n    return result;\n}\n\nint main() {\n    // Use fast I/O operations.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Length of the sequence\n        std::cin >> n;\n        std::vector<long long> a(n);\n        \n        // Read the sequence elements.\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n        }\n\n        // Find the minimum element a_min in the sequence.\n        // Constraints guarantee n >= 2 and a_i >= 1, so a_min exists and is positive.\n        long long a_min = a[0];\n        for (int i = 1; i < n; ++i) {\n             // Keep track of the minimum value found so far.\n             a_min = std::min(a_min, a[i]);\n        }\n\n        // Build the set S'_div.\n        // This set contains all elements from 'a' that are divisible by a_min,\n        // *except* for one instance of a_min itself (which is designated for set L).\n        std::vector<long long> S_prime_div;\n        bool found_min_instance = false; // Flag to track if we have excluded one instance of a_min.\n        \n        for (int i = 0; i < n; ++i) {\n            // Check if the current element a[i] is divisible by a_min.\n            if (a[i] % a_min == 0) {\n                // If the element is exactly a_min:\n                if (a[i] == a_min) {\n                    // If this is the first instance of a_min we encounter:\n                    if (!found_min_instance) {\n                        // Mark it as found/excluded (it's reserved for set L).\n                        found_min_instance = true; \n                    } else {\n                        // If we've already excluded one instance, add this one to S'_div.\n                        S_prime_div.push_back(a[i]);\n                    }\n                } else {\n                    // If the element is divisible by a_min but greater than a_min:\n                    // Add it to S'_div.\n                    S_prime_div.push_back(a[i]);\n                }\n            }\n            // Elements not divisible by a_min are implicitly forced into set L.\n            // We don't need to explicitly track them because the condition min(L) = a_min\n            // is satisfied as long as one instance of a_min is in L. The primary constraint\n            // comes from forming set R with gcd(R) = a_min.\n        }\n\n        // Determine if a valid partition exists based on S'_div.\n        // If S'_div is empty, it means we cannot form a non-empty set R consisting of\n        // elements divisible by a_min (besides the one reserved a_min instance).\n        if (S_prime_div.empty()) {\n            std::cout << \"No\\n\";\n        } else {\n            // If S'_div is non-empty, compute the GCD of all elements in it.\n            long long G = vector_gcd(S_prime_div);\n            \n            // A valid partition exists if and only if the GCD of S'_div is exactly a_min.\n            // If G > a_min, then all elements in S'_div are multiples of G. Any non-empty\n            // subset R of S'_div would have gcd(R) be a multiple of G, thus gcd(R) >= G > a_min.\n            // Therefore, it's impossible to achieve gcd(R) = a_min if G > a_min.\n            // If G = a_min, we can choose R = S'_div itself. This satisfies the conditions.\n            if (G == a_min) {\n                std::cout << \"Yes\\n\";\n            } else {\n                std::cout << \"No\\n\";\n            }\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2084a",
      "PROBLEM_ID": "2084A",
      "PROBLEM_STATEMENT": "You are given an integer $n$. Find any permutation $p$ of length $n$$^{\\\\text{\u2217}}$ such that:\n\n- For all $2 \\le i \\le n$, $\\max(p_{i - 1}, p_i) \\bmod i$ $^{\\text{\u2020}}$ $= i - 1$ is satisfied.\n\nIf it is impossible to find such a permutation $p$, output $-1$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n$^{\\\\text{\u2020}}$$x \\\\bmod y$ denotes the remainder from dividing $x$ by $y$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 99$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 100$).\n\n### Output\n\nFor each test case:\n\n- If such a permutation $p$ doesn't exist, output a single integer $-1$.\n- Otherwise, output $n$ integers $p_1, p_2, \\ldots, p_n$ \u2014 the permutation $p$ you've found. If there are multiple answers, output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n3\n\n4\n\n5\n\n```\n\n#### Output #1\n\n```\n-1\n3 2 1\n-1\n1 5 2 3 4\n```\n\n### Note\n\nIn the first test case, it is impossible to find such a permutation $p$, so you should output $-1$.\n\nIn the fourth test case, $p = [1, 5, 2, 3, 4]$ satisfies the condition:\n\n- For $i = 2$, $\\max(p_1, p_2) = 5$ and $5 \\bmod 2 = 1$.\n- For $i = 3$, $\\max(p_2, p_3) = 5$ and $5 \\bmod 3 = 2$.\n- For $i = 4$, $\\max(p_3, p_4) = 3$ and $3 \\bmod 4 = 3$.\n- For $i = 5$, $\\max(p_4, p_5) = 4$ and $4 \\bmod 5 = 4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Included for standard library concepts, though not strictly needed for this specific code\n\n/**\n * @brief Solves a single test case for the permutation problem.\n * \n * Reads an integer n. The problem asks to find any permutation p of length n\n * (using integers from 1 to n) such that for all 2 <= i <= n, the condition\n * max(p[i-1], p[i]) mod i = i - 1 is satisfied. (Here p uses 1-based indexing as per the problem statement).\n * If such a permutation exists, the function prints one such permutation.\n * Otherwise, it prints -1.\n * \n * Based on mathematical analysis:\n * - If n is even, no such permutation exists.\n * - If n is odd, the permutation p = [n, 1, 2, ..., n-1] satisfies the condition.\n *   (In 1-based indexing: p_1 = n, p_2 = 1, p_3 = 2, ..., p_n = n-1)\n */\nvoid solve() {\n    int n;\n    std::cin >> n; // Read the size of the permutation, n.\n    \n    // Check if n is even.\n    if (n % 2 == 0) {\n        // If n is even, we proved that no solution exists. Output -1.\n        std::cout << -1 << \"\\n\";\n    } else {\n        // If n is odd, we found a valid construction: p = [n, 1, 2, ..., n-1].\n        // Let's verify this construction:\n        // The elements are {n, 1, 2, ..., n-1}, which is exactly the set {1, 2, ..., n}. So it's a valid permutation.\n        // Now check the condition max(p_i-1, p_i) mod i = i - 1 for 2 <= i <= n.\n        // \n        // For i = 2: We check the pair (p_1, p_2) = (n, 1).\n        // max(p_1, p_2) = max(n, 1) = n.\n        // The condition is n mod 2 = 2 - 1 = 1. Since n is odd, n mod 2 = 1. This holds.\n        //\n        // For i >= 3: We check the pair (p_{i-1}, p_i).\n        // In our construction, p_{i-1} = i-2 and p_i = i-1. (For i=3, pair is (p_2, p_3) = (1, 2); for i=4, pair is (p_3, p_4) = (2, 3), etc.)\n        // max(p_{i-1}, p_i) = max(i-2, i-1) = i-1.\n        // The condition is (i-1) mod i = i - 1.\n        // Since 0 <= i-1 < i, the remainder of (i-1) divided by i is indeed i-1. This holds for all i >= 3.\n        //\n        // Thus, the construction p = [n, 1, 2, ..., n-1] is a valid solution for all odd n >= 3.\n\n        // Print the permutation. Start with n.\n        std::cout << n; \n        // Print the remaining elements 1, 2, ..., n-1, each preceded by a space.\n        for (int i = 1; i < n; ++i) {\n            std::cout << \" \" << i; \n        }\n        // Print a newline character to finalize the output for this test case.\n        std::cout << \"\\n\";\n    }\n}\n\n/**\n * @brief Main function: Handles multiple test cases.\n * \n * Sets up fast input/output and reads the number of test cases, t.\n * Then, it calls the solve() function for each test case.\n */\nint main() {\n    // Optimize C++ standard input/output streams for speed.\n    std::ios_base::sync_with_stdio(false); // Disable synchronization with C's stdio library.\n    std::cin.tie(NULL); // Untie std::cin from std::cout to avoid flushing cout before cin reads.\n    \n    int t;\n    std::cin >> t; // Read the number of test cases.\n    // Loop t times to process each test case.\n    while (t--) {\n        solve(); \n    }\n    \n    return 0; // Indicate successful program execution.\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2078b",
      "PROBLEM_ID": "2078B",
      "PROBLEM_STATEMENT": "[Axium Crisis - ak+q](https://youtu.be/1HyuI8Bvnsg?si=6amlU5OPKnJiydZs)\n\nThere are $n$ cells in a labyrinth, and cell $i$ ($1 \\leq i \\leq n$) is $n - i$ kilometers away from the exit. In particular, cell $n$ is the exit. Note also that each cell is connected to the exit but is not accessible from any other cell in any way.\n\nIn each cell, there is initially exactly one person stuck in it. You want to help everyone get as close to the exit as possible by installing a teleporter in each cell $i$ ($1 \\leq i \\leq n$), which translocates the person in that cell to another cell $a_i$.\n\nThe labyrinth owner caught you in the act. Amused, she let you continue, but under some conditions:\n\n- Everyone must use the teleporter exactly $k$ times.\n- No teleporter in any cell can lead to the same cell it is in. Formally, $i \\neq a_i$ for all $1 \\leq i \\leq n$.\n\nYou must find a teleporter configuration that minimizes the sum of distances of all individuals from the exit after using the teleporter exactly $k$ times while still satisfying the restrictions of the labyrinth owner.\n\nIf there are many possible configurations, you can output any of them.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first and only line of each test case contains two integers $n$ and $k$ ($2 \\leq n \\leq 2 \\cdot 10^5$, $1 \\leq k \\leq 10^9$)\u00a0\u2014 the number of cells in the labyrinth and the value $k$.\n\nIt is guaranteed that the total sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n$ integers\u00a0\u2014 the destinations of the teleporters $a_1, a_2, \\ldots, a_n$ in order, satisfying the given conditions ($1 \\leq a_i \\leq n$, $a_i \\neq i$).\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n2 1\n\n3 2\n\n```\n\n#### Output #1\n\n```\n2 1\n2 3 2\n```\n\n### Note\n\nIn the first test case, the position of each person is as follows.\n\n- Before teleporting: $[1, 2]$.\n- First teleportation: $[2, 1]$.\n\nThe distance sum is $(2-2) + (2-1) = 1$, which is the minimum possible.\n\nIn the second test case, the position of each person is as follows.\n\n- Before teleporting: $[1, 2, 3]$.\n- First teleportation: $[2, 3, 2]$.\n- Second teleportation: $[3, 2, 3]$.\n\nThe distance sum is $(3-3) + (3-2) + (3-3) = 1$, which is the minimum possible.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        int n;\n        long long k;\n        std::cin >> n >> k;\n        \n        // The key insight is to place everyone at cell n (exit) or n-1 after k teleportations\n        if (k % 2 == 1) {\n            // For odd k, people at even-indexed cells after (k-1) steps should go to cell n\n            // People at odd-indexed cells after (k-1) steps should go to cell n-1\n            for (int i = 1; i <= n; i++) {\n                // For every cell other than n-1 and n, direct to n\n                if (i == n) {\n                    std::cout << n - 1 << \" \"; // Exit can't teleport to itself\n                } else {\n                    std::cout << n << \" \"; // Direct everyone else to the exit\n                }\n            }\n        } else {\n            // For even k, we can create a 2-cycle between cells n and n-1\n            for (int i = 1; i <= n; i++) {\n                if (i == n) {\n                    std::cout << n - 1 << \" \";\n                } else if (i == n - 1) {\n                    std::cout << n << \" \";\n                } else {\n                    // For other cells, direct to n-1 so they'll end at n after an even number of steps\n                    std::cout << n - 1 << \" \";\n                }\n            }\n        }\n        \n        std::cout << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2078a",
      "PROBLEM_ID": "2078A",
      "PROBLEM_STATEMENT": "[Testify - void (Mournfinale) feat. \u661f\u718a\u5357\u5deb](https://www.youtube.com/watch?v=xkUN_9HFNPg)\n\nYou are given an array $a$ of length $n$, and must perform the following operation until the length of $a$ becomes $1$.\n\nChoose a positive integer $k < |a|$ such that $\\frac{|a|}{k}$ is an integer. Split $a$ into $k$ subsequences$^{\\text{\u2217}}$ $s_1, s_2, \\ldots, s_k$ such that:\n\n- Each element of $a$ belongs to exactly one subsequence.\n- The length of every subsequence is equal.\n\nAfter this, replace $a = \\left[ \\operatorname{avg}(s_1), \\operatorname{avg}(s_2), \\ldots, \\operatorname{avg}(s_k) \\right] $, where $\\operatorname{avg}(s) = \\frac{\\sum_{i = 1}^{|s|} s_i}{|s|}$ is the average of all the values in the subsequence. For example, $\\operatorname{avg}([1, 2, 1, 1]) = \\frac{5}{4} = 1.25$.\n\nYour task is to determine whether there exists a sequence of operations such that after all operations, $a = [x]$.\n\n$^{\\text{\u2217}}$A sequence $x$ is a subsequence of a sequence $y$ if $x$ can be obtained from $y$ by the deletion of several (possibly, zero or all) elements.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $x$ ($1 \\leq n, x \\leq 100$) \u2014 the length of the array $a$ and the final desired value.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 100$) \u2014 the array $a$.\n\n### Output\n\nFor each test case, output \"YES'\" (without quotes) if there exists such a sequence of operations, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1 3\n\n3\n\n4 9\n\n7 11 2 5\n\n6 9\n\n1 9 14 12 10 8\n\n10 10\n\n10 10 10 10 10 10 10 10 10 10\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nYES\n```\n\n### Note\n\nIn the first test case, $x = 3$ and $a = [3]$ already holds.\n\nIn the second test case, $x = 9$, and there exists no sequence of operations such that after all operations, $a = [9]$.\n\nIn the third test case, $x = 9$, and here is one possible sequence of operations.\n\n1. $k = 2$, $s_1 = [1, 12, 8]$ and $s_2 = [9, 14, 10]$. Hence, $a = [\\operatorname{avg}(s_1), \\operatorname{avg}(s_2)] = [7, 11]$.\n2. $k = 1$ and $s_1 = [7, 11]$. Hence, $a = [\\operatorname{avg}(s_1)] = [9]$.\n\nIn the fourth test case, $x = 10$, and here is one possible sequence of operations.\n\n1. $k = 1$ and $s_1 = [10, 10, 10, 10, 10, 10, 10, 10, 10, 10]$. Hence, $a = [\\operatorname{avg}(s_1)] = [10]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool canReachTargetValue(vector<int>& a, int x) {\n    // Calculate the sum of the array\n    long long sum = 0;\n    for (int num : a) {\n        sum += num;\n    }\n    \n    // Check if the average of the array equals x\n    return (sum == (long long)x * a.size());\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, x;\n        cin >> n >> x;\n        \n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        \n        if (canReachTargetValue(a, x)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2077g",
      "PROBLEM_ID": "2077G",
      "PROBLEM_STATEMENT": "[Red and Blue and Green - fn and Silentroom](https://www.youtube.com/watch?v=UeN7U474cxE)\n\n\u2800\n\nYou are given a connected graph with $n$ vertices and $m$ bidirectional edges with weight not exceeding $x$. The $i$-th edge connects vertices $u_i$ and $v_i$, has weight $w_i$, and is assigned a color $c_i$ ($1 \\leq i \\leq m$, $1 \\leq u_i, v_i \\leq n$). The color $c_i$ is either red, green, or blue. It is guaranteed that there is at least one edge of each color.\n\nFor a walk where vertices and edges may be repeated, let $s_r, s_g, s_b$ denote the sum of the weights of the red, green, and blue edges that the walk passes through, respectively. If an edge is traversed multiple times, each traversal is counted separately.\n\nFind the minimum value of $\\max(s_r, s_g, s_b) - \\min(s_r, s_g, s_b)$ over all possible walks from vertex $1$ to vertex $n$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $x$ ($4 \\leq n \\leq 2 \\cdot 10^5$, $n-1 \\leq m \\leq 2 \\cdot 10^5$, $1 \\leq x \\leq 2 \\cdot 10^5$)\u00a0\u2014 the number of vertices, the number of edges in the graph, and the upper bound on the weight of the edges, respectively.\n\nThe next $m$ lines each contain three integers $u_i, v_i, w_i$ and a letter $c_i$ ($1 \\leq u_i, v_i \\leq n$, $1 \\leq w_i \\leq x$), representing a bidirectional edge between vertices $u_i$ and $v_i$ with weight $w_i$ and color $c_i$. The color $c_i$ is either 'r', 'g', or 'b', denoting red, green, and blue, respectively.\n\nIt is guaranteed that the graph is connected and contains at least one edge of each color. The graph may also contain multiple edges and self-loops.\n\nAdditionally, it is guaranteed that the total sum of all values of $n$, the total sum of all values of $m$, and the total sum of all values of $x$ across all test cases do not exceed $2 \\cdot 10^5$ individually.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum value of $\\max(s_r, s_g, s_b) - \\min(s_r, s_g, s_b)$ over all walks from vertex $1$ to vertex $n$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4 3 3\n\n1 2 2 r\n\n2 3 3 g\n\n3 4 2 b\n\n4 5 4\n\n1 2 1 r\n\n1 1 1 r\n\n2 1 1 r\n\n2 3 4 g\n\n3 4 4 b\n\n4 6 4\n\n1 2 2 r\n\n1 2 2 r\n\n2 3 3 b\n\n1 3 4 r\n\n1 4 1 g\n\n3 4 4 g\n\n```\n\n#### Output #1\n\n```\n1\n0\n0\n```\n\n### Note\n\nIn the first test case, the optimal path is $1 \\to 2 \\to 3 \\to 4$. The edges used are:\n\n- $1 \\to 2$ (red, weight $2$)\n- $2 \\to 3$ (green, weight $3$)\n- $3 \\to 4$ (blue, weight $2$)\n\nWe have $s_r = 2$, $s_g = 3$, and $s_b = 2$. Thus, the answer is $1$.\n\nIn the second test case, one of the optimal paths is $1 \\to 1 \\to 2 \\to 1 \\to 2 \\to 3 \\to 4$. The edges used are:\n\n- $1 \\to 1$ (red, weight $1$)\n- $1 \\to 2$ (red, weight $1$)\n- $2 \\to 1$ (red, weight $1$)\n- $1 \\to 2$ (red, weight $1$)\n- $2 \\to 3$ (green, weight $4$)\n- $3 \\to 4$ (blue, weight $4$)\n\nWe have $s_r = s_g = s_b = 4$. Thus, the answer is $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n \n#define int long long\nusing namespace std;\ntypedef pair<int, int> pii;\n \nvoid test_case() {\n    // read input\n    int n, m, x;\n    cin >> n >> m >> x;\n    \n    vector<tuple<int, int, int>> edge_list[3];\n    map<char, int> color_map = {{'r', 0}, {'g', 1}, {'b', 2}};\n    \n    for (int i = 1; i <= m; i++) {\n        int u, v, w;\n        char c;\n        cin >> u >> v >> w >> c;\n        edge_list[color_map[c]].emplace_back(u, v, w);\n    }\n    \n    // graph constuction\n    int color_gcd[3];\n    vector<pii> edge[n+1];\n    for (int i = 0; i < 3; i++) {\n        color_gcd[i] = get<2>(edge_list[i][0]);\n        for (auto [u, v, w] : edge_list[i]) color_gcd[i] = __gcd(color_gcd[i], w);\n        \n        for (auto [u, v, w] : edge_list[i]) {\n            int val = (1<<i)*(w/color_gcd[i]%2);\n            edge[u].emplace_back(v, val);\n            edge[v].emplace_back(u, val);\n        }\n    }\n    \n    // bfs\n    bool visited[n+1][8];\n    memset(visited, 0, sizeof(visited));\n    queue<pii> bfs_q;\n    bfs_q.emplace(1, 0);\n    \n    while (!bfs_q.empty()) {\n        auto [u, mask] = bfs_q.front();\n        bfs_q.pop();\n        if (visited[u][mask]) continue;\n        visited[u][mask] = true;\n        for (auto [v, val] : edge[u]) bfs_q.emplace(v, mask^val);\n    }\n    \n    // solve answer for each mask\n    int ans = INT_MAX;\n    for (int mask = 0; mask < 8; mask++) {\n        if (!visited[n][mask]) continue;\n        \n        for (int i = 0; i < 3; i++) {\n            int ssz[2];\n            for (int j = 0, cj = 0; j < 3; j++) {\n                if (i == j) continue;\n                ssz[cj++] = color_gcd[j];\n            }\n            int sgcd = 2*__gcd(ssz[0], ssz[1]);\n            \n            int seq[2][sgcd];\n            for (int j = 0; j < sgcd; j++) seq[0][j] = seq[1][j] = (int)1e9;\n            for (int j = 0, cj = 0; j < 3; j++) {\n                if (i == j) continue;\n                for (int k = 0; k < 2*ssz[cj]; k++) {\n                    int vi = ((mask>>i)&1)*color_gcd[i];\n                    int mi = 2*color_gcd[i];\n                    int vj = ((mask>>j)&1)*color_gcd[j];\n                    int mj = 2*color_gcd[j];\n                    seq[cj][k%sgcd] = min(seq[cj][k%sgcd], ((vj - vi - k*mi)%mj + mj)%mj);\n                }\n                cj++;\n            }\n            \n            for (int k = 0; k < sgcd; k++) ans = min(ans, max(seq[0][k], seq[1][k]));\n        }\n    }\n    \n    cout << ans << \"\\n\";\n}\n \nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    while (t--) test_case();\n \n    return 0;\n}\n\n// model solution",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2077f",
      "PROBLEM_ID": "2077F",
      "PROBLEM_STATEMENT": "Suppose you have two arrays $c$ and $d$, each of length $k$. The pair $(c, d)$ is called good if $c$ can be changed to $d$ by performing the following operation any number of times.\n\n- Select two distinct indices $i$ and $j$ ($1 \\leq i, j \\leq k$, $i \\neq j$) and a nonnegative integer $x$ ($0 \\leq x < 2^{30}$). Then, apply the following transformations:\n  - $c_i := c_i \\mathbin{\\&} x$, where $\\&$ denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND).\n  - $c_j := c_j \\mathbin{|} x$, where $|$ denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\n\nYou are given two arrays $a$ and $b$, both of length $n$, containing nonnegative integers not exceeding $m$.\n\nYou can perform two types of moves on these arrays any number of times:\n\n1. Select an index $i$ ($1 \\leq i \\leq n$) and set $a_i := a_i + 1$.\n2. Select an index $i$ ($1 \\leq i \\leq n$) and set $b_i := b_i + 1$.\n\nNote that the elements of $a$ and $b$ may exceed $m$ at some point while performing the moves.\n\nFind the minimum number of moves required to make the pair $(a, b)$ good.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 2 \\cdot 10^6$)\u00a0\u2014 the length of arrays $a$ and $b$, and the maximum possible value in these arrays, respectively.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq m$)\u00a0\u2014 denoting the array $a$.\n\nThe third line contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($0 \\leq b_i \\leq m$)\u00a0\u2014 denoting the array $b$.\n\nAdditionally, it is guaranteed that the sum of all values of $n$ and the sum of all values of $m$ across all test cases do not exceed $2 \\cdot 10^6$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of moves required to make the pair $(a, b)$ good.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4 3\n\n0 1 2 3\n\n0 1 2 3\n\n3 32\n\n8 9 32\n\n8 6 32\n\n5 64\n\n5 7 16 32 64\n\n4 8 16 32 64\n\n4 11\n\n9 1 4 3\n\n8 11 6 2\n\n5 10\n\n7 9 5 4 2\n\n3 10 6 5 9\n\n```\n\n#### Output #1\n\n```\n0\n2\n2\n0\n1\n```\n\n### Note\n\nIn the first case, we already have $a = b$.\n\nIn the second case, we can perform move $2$ on index $i = 2$ twice. The array $b$ becomes $[8, 8, 32]$. We can see that $(a, b)$ is now good.\n\nIn the third case, we can perform move $2$ on index $i = 1$, then perform move $1$ on index $i = 2$. It can be proven that you cannot make the pair $(a, b)$ good in fewer than $2$ moves.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int INF = 1e9;\n \nvoid test_case() {\n    int n, m;\n    cin >> n >> m;\n \n    int c[n+1], d[n+1];\n    for (int i = 1; i <= n; i++) cin >> c[i];\n    for (int i = 1; i <= n; i++) cin >> d[i];\n \n    // Case 1: Change c to d\n    long long ans1 = 0;\n    for (int i = 1; i <= n; i++) ans1 += abs(c[i]-d[i]);\n \n    // Case 2: Edit array c or d\n    // Case 2.1: array d have duplicated\n    sort(d+1, d+n+1);\n    for (int i = 1; i < n; i++) {\n        if (d[i] == d[i+1]) {\n            cout << \"0\\n\";\n            return;\n        } \n    }\n \n    // Case 2.2: The hard part\n    int dp[2*m+1][2], source[2*m+1][2];\n    for (int i = 0; i <= 2*m; i++)\n        for (int k = 0; k < 2; k++) {\n            dp[i][k] = INF;\n            source[i][k] = -1;\n        }\n \n    for (int i = 1; i <= n; i++) {\n        dp[d[i]][0] = 0;\n        source[d[i]][0] = d[i];\n    }\n \n    // Phase 1\n    for (int i = 0; i < 2*m; i++) {\n        for (int k = 0; k < 2; k++) {\n            // Transit to +1\n            if (dp[i+1][0] >= dp[i][k]+1 && source[i+1][0] != source[i][k]) {\n                dp[i+1][1] = dp[i+1][0];\n                source[i+1][1] = source[i+1][0];\n                dp[i+1][0] = dp[i][k]+1;\n                source[i+1][0] = source[i][k];\n            } else if (dp[i+1][1] >= dp[i][k]+1 && source[i+1][0] != source[i][k]) {\n                dp[i+1][1] = dp[i][k]+1;\n                source[i+1][1] = source[i][k];\n            } else if (dp[i+1][0] >= dp[i][k]+1 && source[i+1][0] == source[i][k]) {\n                dp[i+1][0] = dp[i][k]+1;\n            }\n        }\n    }\n \n    // Phase 2\n    for (int i = 0; i < 2*m; i++) {\n        for (int k = 0; k < 2; k++) {\n            // Transit to supermask\n            for (int j = 0; j < 22; j++) {\n                int toset = (1<<j);\n                if (i&toset) continue;\n                int nextmask = i^toset;\n                if (nextmask > 2*m) continue;\n \n                if (dp[nextmask][0] >= dp[i][k] && source[nextmask][0] != source[i][k]) {\n                    dp[nextmask][1] = dp[nextmask][0];\n                    source[nextmask][1] = source[nextmask][0];\n                    dp[nextmask][0] = dp[i][k];\n                    source[nextmask][0] = source[i][k];\n                } else if (dp[nextmask][1] >= dp[i][k] && source[nextmask][0] != source[i][k]) {\n                    dp[nextmask][1] = dp[i][k];\n                    source[nextmask][1] = source[i][k];\n                } else if (dp[nextmask][0] >= dp[i][k] && source[nextmask][0] == source[i][k]) {\n                    dp[nextmask][0] = dp[i][k];\n                }\n            }\n        }\n    }\n \n    // Phase 3\n    for (int i = 2*m; i > 0; i--) {\n        for (int k = 0; k < 2; k++) {\n            // Transit to -1\n            if (dp[i-1][0] >= dp[i][k]+1 && source[i-1][0] != source[i][k]) {\n                dp[i-1][1] = dp[i-1][0];\n                source[i-1][1] = source[i-1][0];\n                dp[i-1][0] = dp[i][k]+1;\n                source[i-1][0] = source[i][k];\n            } else if (dp[i-1][1] >= dp[i][k]+1 && source[i-1][0] != source[i][k]) {\n                dp[i-1][1] = dp[i][k]+1;\n                source[i-1][1] = source[i][k];\n            } else if (dp[i-1][0] >= dp[i][k]+1 && source[i-1][0] == source[i][k]) {\n                dp[i-1][0] = dp[i][k]+1;\n            }\n        }\n    }\n \n    int ans2 = INT_MAX;\n    for (int i = 1; i <= n; i++) {\n        ans2 = min(ans2, dp[d[i]][1]);\n    }\n \n    cout << min(ans1, (long long)ans2) << \"\\n\";\n}\n \nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n \n    int t;\n    cin >> t;\n    while (t--) test_case();\n \n    return 0;\n}\n\n// model solution",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2077d",
      "PROBLEM_ID": "2077D",
      "PROBLEM_STATEMENT": "Given an array $a$ of length $n$, determine the lexicographically largest$^{\\text{\u2217}}$ subsequence$^{\\text{\u2020}}$ $s$ of $a$ such that $s$ can be the side lengths of a polygon.\n\nRecall that $s$ can be the side lengths of a polygon if and only if $|s| \\geq 3$ and\n\n\n\n$$ 2 \\cdot \\max(s_1, s_2, \\ldots, s_{|s|}) < s_1 + s_2 + \\ldots + s_{|s|}. $$\n\nIf no such subsequence $s$ exists, print $-1$.\n\n$^{\\text{\u2217}}$A sequence $x$ is lexicographically smaller than a sequence $y$ if and only if one of the following holds:\n\n- $x$ is a prefix of $y$, but $x \\ne y$;\n- in the first position where $x$ and $y$ differ, the sequence $x$ has a smaller element than the corresponding element in $y$.\n\n$^{\\text{\u2020}}$A sequence $x$ is a subsequence of a sequence $y$ if $x$ can be obtained from $y$ by deleting several (possibly zero or all) elements.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the length of the array $a$.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$)\u00a0\u2014 the array $a$.\n\nIt is guaranteed that the total sum of all values of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the answer in the following format:\n\nIf the answer exists, output the following.\n\nIn the first line, output the integer $k$ ($1 \\leq k \\leq n$) \u2014 the length of the subsequence $s$.\n\nIn the second line, output $k$ integers $s_1, s_2, \\ldots, s_k$ ($1 \\leq s_i \\leq 10^9$, $s$ is a subsequence of $a$) \u2014 the subsequence $s$. Note that the desired output is the value, not the index.\n\nOtherwise, output a single line with the integer $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3\n\n3 1 2\n\n4\n\n1 4 2 3\n\n6\n\n1 6 4 5 3 2\n\n6\n\n43 12 99 53 22 4\n\n7\n\n9 764 54 73 22 23 1\n\n```\n\n#### Output #1\n\n```\n-1\n3\n4 2 3\n4\n6 5 3 2\n5\n43 99 53 22 4\n4\n54 73 23 1\n```\n\n### Note\n\nIn the first test case, there are no subsequences that can be the side lengths of a polygon.\n\nIn the second test case, there are $2$ subsequences that can be the side lengths of a polygon: $1, 4, 2, 3$ and $4, 2, 3$. The latter is the lexicographically larger subsequence.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#pragma GCC optimize(\"Ofast\")\n \n#include <bits/stdc++.h>   \n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;   \nusing namespace std;\n#define ll long long\n#define ld long double\n#define nline \"\\n\"\n#define f first\n#define s second\nconst ll INF_MUL=1e13;\nconst ll INF_ADD=1e18;\n#define sz(x) (ll)x.size()\n#define vl vector<ll>\n#define all(x) x.begin(),x.end()\n#define rall(x) x.rbegin(),x.rend() \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pset;\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     \nconst ll MOD=998244353;\nconst ll MAX=500500;\nvoid solve(){\n  ll n; cin>>n;\n  vector<ll> ans,p(n+5);\n  vector<ll> track;\n  for(ll i=1;i<=n;i++){\n    cin>>p[i];\n    track.push_back(p[i]);\n  }\n  ll till=min(60ll,n);\n  sort(rall(track));\n  vector<ll> consider;\n  for(ll i=0;i<=till-1;i++){\n    consider.push_back(track[i]);\n  }\n  for(ll x:consider){\n    vector<ll> cur;\n    vector<ll> sum(n+5,0);\n    for(ll i=n;i>=1;i--){\n      sum[i]=sum[i+1];\n      if(p[i]<=x){\n        sum[i]+=p[i];\n      }\n    }\n    ll need=2*x+1;\n    if(sum[1]<=need-1){\n      continue;\n    }\n    ll have=0;\n    for(ll i=1;i<=n;i++){\n      if(p[i]>x){\n        continue;\n      }\n      while(!cur.empty()){\n        auto last=cur.back();\n        if(last<p[i] and have-last+sum[i]>=need){\n          cur.pop_back();\n          have-=last;\n        }\n        else{\n          break;\n        }\n      }\n      cur.push_back(p[i]);\n      have+=p[i];\n    }\n    ans=max(ans,cur);\n  }\n  if(ans.empty()){\n    cout<<\"-1\\n\";\n    return;\n  }\n  cout<<sz(ans)<<nline;\n  for(auto it:ans){\n    cout<<it<<\" \";\n  }\n  cout<<nline;\n  return;\n}\nint main()                                                                                 \n{         \n  ios_base::sync_with_stdio(false);                         \n  cin.tie(NULL);                             \n  ll test_cases=1;\n  cin>>test_cases;\n  while(test_cases--){\n    solve();\n  }\n  cout<<fixed<<setprecision(15); \n  cerr<<\"Time:\"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<\"ms\\n\"; \n}\n\n// model solution",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2077c",
      "PROBLEM_ID": "2077C",
      "PROBLEM_STATEMENT": "[Last \\| Moment - onoken](https://www.youtube.com/watch?v=l_fXX3Y0Pis)\n\nFor a binary string$^{\\text{\u2217}}$ $v$, the score of $v$ is defined as the maximum value of\n\n\n\n$$F\\big(v, 1, i\\big) \\cdot F\\big(v, i+1, |v|\\big)$$\n\nover all $i$ ($0 \\leq i \\leq |v|$).\n\nHere, $F\\big(v, l, r\\big) = r - l + 1 - 2 \\cdot \\operatorname{zero}(v, l, r)$, where $\\operatorname{zero}(v, l, r)$ denotes the number of $\\mathtt{0}$s in $v_lv_{l+1} \\ldots v_r$. If $l > r$, then $F\\big(v, l, r\\big) = 0$.\n\nYou are given a binary string $s$ of length $n$ and a positive integer $q$.\n\nYou will be asked $q$ queries.\n\nIn each query, you are given an integer $i$ ($1 \\leq i \\leq n$). You must flip $s_i$ from $\\mathtt{0}$ to $\\mathtt{1}$ (or from $\\mathtt{1}$ to $\\mathtt{0}$). Find the sum of the scores over all non-empty subsequences$^{\\text{\u2020}}$ of $s$ after each modification query.\n\nSince the result may be large, output the answer modulo $998\\,244\\,353$.\n\nNote that the modifications are persistent.\n\n$^{\\text{\u2217}}$A binary string is a string that consists only of the characters $\\mathtt{0}$ and $\\mathtt{1}$.\n\n$^{\\text{\u2020}}$A binary string $x$ is a subsequence of a binary string $y$ if $x$ can be obtained from $y$ by deleting several (possibly zero or all) characters.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\leq n \\leq 2 \\cdot 10^5$, $1 \\leq q \\leq 2 \\cdot 10^5$)\u00a0\u2014 the length of the string $s$ and the number of modification queries, respectively.\n\nThe second line contains the binary string $s$ of length $n$, consisting of characters $\\mathtt{0}$ and $\\mathtt{1}$.\n\nThe following $q$ lines each contain an integer $i$ ($1 \\leq i \\leq n$), indicating that $s_i$ is flipped from $\\mathtt{0}$ to $\\mathtt{1}$ or from $\\mathtt{1}$ to $\\mathtt{0}$.\n\nIt is guaranteed that neither the total sum of all values of $n$ nor the total sum of all values of $q$ across all test cases exceeds $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $q$ lines, each line containing a single integer\u00a0\u2014 the required sum modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3 2\n\n010\n\n1\n\n3\n\n10 3\n\n0101000110\n\n3\n\n5\n\n10\n\n24 1\n\n011001100110000101111000\n\n24\n\n```\n\n#### Output #1\n\n```\n1\n5\n512\n768\n1536\n23068672\n```\n\n### Note\n\nFor the first test case, after the first modification, we have $s = \\texttt{110}$. We can compute the sum of scores over all subsequences as follows:\n\nIndicesSubsequenceScore$1$1$0\n\n$$2$1$0$$\n\n1, 2$11$1\n\n$$3$0$0$$\n\n1, 3$10$0\n\n$$2, 3$10$0$$\n\n1, 2, 3$110$0$\n\nSumming up: $0+0+1+0+0+0+0 = 1$.\n\nAfter the second modification, we have $s = \\texttt{111}$. We can compute the sum of scores over all subsequences as follows:\n\nIndicesSubsequenceScore$1$1$0\n\n$$2$1$0$$\n\n1, 2$11$1\n\n$$3$1$0$$\n\n1, 3$11$1\n\n$$2, 3$11$1$$\n\n1, 2, 3$111$2$\n\nSumming up: $0+0+1+0+1+1+2 = 5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MAXN = 2e5 + 10;\n\nlong long pow2[MAXN];\n\nlong long my_pow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b % 2 == 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid precompute_pows() {\n    pow2[0] = 1;\n    for (int i = 1; i < MAXN; ++i) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n}\n\nint main() {\n    precompute_pows();\n    \n    long long inv16 = my_pow(16, MOD - 2);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        int n, q;\n        cin >> n >> q;\n        string s;\n        cin >> s;\n\n        long long S = 0;\n        vector<int> cw(n);\n        for (int i = 0; i < n; ++i) {\n            cw[i] = (s[i] == '1') ? 1 : -1;\n            S += cw[i];\n        }\n\n        long long term1 = (pow2[n] * inv16) % MOD;\n\n        while (q--) {\n            int pos;\n            cin >> pos;\n            pos--;\n\n            int old_v = cw[pos];\n            long long delta = -2 * old_v;\n            S += delta;\n            cw[pos] *= -1;\n\n            long long s_sq = (S * S) % MOD;\n            s_sq %= MOD;\n\n            long long numerator = (s_sq + n - 2) % MOD;\n            numerator = (numerator + MOD) % MOD;\n\n            long long ans = (term1 * numerator) % MOD;\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2077a",
      "PROBLEM_ID": "2077A",
      "PROBLEM_STATEMENT": "[Breach of Faith - Supire feat.eili](https://www.youtube.com/watch?v=nVTiCKIIQSM)\n\nYou and your team have worked tirelessly until you have a sequence $a_1, a_2, \\ldots, a_{2n+1}$ of positive integers satisfying these properties.\n\n- $1 \\le a_i \\le 10^{18}$ for all $1 \\le i \\le 2n + 1$.\n- $a_1, a_2, \\ldots, a_{2n+1}$ are pairwise distinct.\n- $a_1 = a_2 - a_3 + a_4 - a_5 + \\ldots + a_{2n} - a_{2n+1}$.\n\nHowever, the people you worked with sabotaged you because they wanted to publish this sequence first. They deleted one number from this sequence and shuffled the rest, leaving you with a sequence $b_1, b_2, \\ldots, b_{2n}$. You have forgotten the sequence $a$ and want to find a way to recover it.\n\nIf there are many possible sequences, you can output any of them. It can be proven under the constraints of the problem that at least one sequence $a$ exists.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$).\n\nThe second line of each test case contains $2n$ distinct integers $b_1, b_2, \\ldots, b_{2n}$ ($1 \\leq b_i \\leq 10^9$), denoting the sequence $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $2n+1$ distinct integers, denoting the sequence $a$ ($1 \\leq a_i \\leq 10^{18}$).\n\nIf there are multiple possible sequences, you can output any of them. The sequence $a$ should satisfy the given conditions, and it should be possible to obtain $b$ after deleting one element from $a$ and shuffling the remaining elements.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n9 2\n\n2\n\n8 6 1 4\n\n3\n\n99 2 86 33 14 77\n\n2\n\n1 6 3 2\n\n```\n\n#### Output #1\n\n```\n7 9 2\n1 8 4 6 9\n86 99 2 77 69 14 33\n4 6 1 2 3\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing int64 = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    // Sum of n over all tests <= 2e5\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int64> b(2 * n);\n        for (int i = 0; i < 2 * n; i++) {\n            cin >> b[i];\n        }\n        sort(b.begin(), b.end());\n        // Special case n == 1: simple construction\n        if (n == 1) {\n            // b[0] < b[1]\n            int64 x = b[0], y = b[1];\n            // a1 = x, a2 = x + y, a3 = y  gives x = (x+y) - y\n            cout << x << \" \" << (x + y) << \" \" << y << \"\\n\";\n            continue;\n        }\n        // General case n >= 2\n        // Let c = sorted b\n        // a1 = c[0]\n        // We'll remove position a2 (missing), place m there.\n        // Positions a3,a5,... get the n largest of b excluding c[0],\n        // positions a4,a6,... get the other n-1 values.\n        vector<int64>& c = b;\n        int64 a1 = c[0];\n        // sum of S_even = c[1..n-1]\n        // sum of S_odd  = c[n..2n-1]\n        int64 sum_even = 0, sum_odd = 0;\n        for (int i = 1; i < n; i++) {\n            sum_even += c[i];\n        }\n        for (int i = n; i < 2*n; i++) {\n            sum_odd += c[i];\n        }\n        // m = a1 + sum_odd - sum_even\n        int64 m = a1 + sum_odd - sum_even;\n        // Build the a array of size 2n+1\n        vector<int64> a(2*n + 1);\n        a[0] = a1;\n        a[1] = m;\n        // Fill remaining slots a[2..2n] (<-> positions 3..2n+1 in 1-index)\n        int idx_even = 1;  // runs over c[1..n-1], count = n-1\n        int idx_odd  = n;  // runs over c[n..2n-1], count = n\n        for (int k = 2; k < 2*n + 1; k++) {\n            if ((k % 2) == 0) {\n                // position k+1 is odd (3,5,..): put from S_odd\n                a[k] = c[idx_odd++];\n            } else {\n                // position k+1 is even (4,6,..): put from S_even\n                a[k] = c[idx_even++];\n            }\n        }\n        // Output a\n        for (int i = 0; i < 2*n + 1; i++) {\n            cout << a[i] << (i+1 == 2*n+1 ? \"\\n\" : \" \");\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2075f",
      "PROBLEM_ID": "2075F",
      "PROBLEM_STATEMENT": "Let's call an integer sequence beautiful if the following conditions hold:\n\n- for every element except the first one, there is an element to the left less than it;\n- for every element except the last one, there is an element to the right larger than it;\n\nFor example, $[1, 2]$, $[42]$, $[1, 4, 2, 4, 7]$, and $[1, 2, 4, 8]$ are beautiful, but $[2, 2, 4]$ and $[1, 3, 5, 3]$ are not.\n\nRecall that a subsequence is a sequence that can be obtained from another sequence by removing some elements (possibly zero) without changing the order of the remaining elements.\n\nYou are given an integer array $a$ of size $n$. Find the longest beautiful subsequence of the array $a$ and print its length.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. Next, $t$ independent cases follow.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 5 \\cdot 10^5$)\u00a0\u2014 the length of array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^6$)\u00a0\u2013 the array $a$.\n\nAdditional constraint on the input: the total sum of $n$ over all test cases doesn't exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print one integer\u00a0\u2014 the length of the longest beautiful subsequence of array $a$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n42\n\n5\n\n1 2 3 4 5\n\n6\n\n6 5 4 3 2 1\n\n7\n\n1 1 3 4 2 3 4\n\n6\n\n2 3 1 1 2 4\n\n```\n\n#### Output #1\n\n```\n1\n5\n1\n5\n3\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n \ntypedef long long li;\ntypedef pair<int, int> pt;\n \nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n \nvector<int> Tadd, Tmax;\n \nint getmax(int v) {\n\treturn Tmax[v] + Tadd[v];\n}\nvoid push(int v) {\n\tTadd[2 * v + 1] += Tadd[v];\n\tTadd[2 * v + 2] += Tadd[v];\n\tTadd[v] = 0;\n}\nvoid upd(int v) {\n\tTmax[v] = max(getmax(2 * v + 1), getmax(2 * v + 2));\n}\nvoid addVal(int v, int l, int r, int lf, int rg, int val) {\n\tif (l == lf && r == rg) {\n\t\tTadd[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r) >> 1;\n\tif (lf < mid)\n\t\taddVal(2 * v + 1, l, mid, lf, min(mid, rg), val);\n\tif (rg > mid)\n\t\taddVal(2 * v + 2, mid, r, max(lf, mid), rg, val);\n\tupd(v);\n}\n \nint n;\nvector<int> a;\n \ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\ta.resize(n);\n\tfore (i, 0, n)\n\t\tcin >> a[i];\n\treturn true;\n}\n \ninline void solve() {\n\tvector<int> ask(n, 0);\n\tint mx = -1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (a[i] > mx) {\n\t\t\task[i] = 1;\n\t\t\tmx = a[i];\n\t\t}\n\t}\n\tvector<int> left;\n\tfore (i, 0, n) {\n\t\tif (left.empty() || a[left.back()] > a[i])\n\t\t\tleft.push_back(i);\n\t}\n \n\tvector<pt> seg(n);\n\tfore (i, 0, n) {\n\t\tint lf = upper_bound(left.begin(), left.end(), i, [&left](int v, int i) {\n\t\t\treturn a[v] > a[i];\n\t\t}) - left.begin();\n\t\tint rg = lower_bound(left.begin(), left.end(), i) - left.begin();\n\t\tseg[i] = {lf, rg};\n\t}\n \n\tTadd.assign(4 * n, 0);\n\tTmax.assign(4 * n, 0);\n \n\tvector<int> ordToAdd(n);\n\tiota(ordToAdd.begin(), ordToAdd.end(), 0);\n\tsort(ordToAdd.begin(), ordToAdd.end(), [](int i, int j) {\n\t\treturn a[i] < a[j];\n\t});\n \n\tauto addToSeg = [&left, &seg](int id, int val) {\n\t\tauto [lf, rg] = seg[id];\n\t\tif (lf < rg)\n\t\t\taddVal(0, 0, sz(left), lf, rg, val);\n\t};\n \n\tint ans = 0;\n\tint pos = 0;\n\tvector<int> added(n, 0);\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (pos < n && a[ordToAdd[pos]] < a[i]) {\n\t\t\tif (ordToAdd[pos] <= i) {\n\t\t\t\taddToSeg(ordToAdd[pos], 1);\n\t\t\t\tadded[ordToAdd[pos]] = 1;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\tif (ask[i]) {\n\t\t\tauto [lf, rg] = seg[i];\n\t\t\tans = max(ans, 1 + (lf < rg ? 1 + getmax(0) : 0));\n\t\t}\n\t\tif (added[i]) {\n\t\t\taddToSeg(i, -1);\n\t\t\tadded[i] = 0;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n \nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint t; cin >> t;\n\twhile(t--) {\n\t\t(read());\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2075e",
      "PROBLEM_ID": "2075E",
      "PROBLEM_STATEMENT": "For two arrays $a = [a_1, a_2, \\dots, a_n]$ and $b = [b_1, b_2, \\dots, b_m]$, we define the XOR matrix $X$ of size $n \\times m$, where for each pair $(i,j)$ ($1 \\le i \\le n$; $1 \\le j \\le m$) it holds that $X_{i,j} = a_i \\oplus b_j$. The symbol $\\oplus$ denotes the bitwise XOR operation.\n\nYou are given four integers $n, m, A, B$. Count the number of such pairs of arrays $(a, b)$ such that:\n\n- $a$ consists of $n$ integers, each of which is from $0$ to $A$;\n- $b$ consists of $m$ integers, each of which is from $0$ to $B$;\n- in the XOR matrix formed from these arrays, there are no more than two distinct values.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of one line containing four integers $n, m, A, B$ ($2 \\le n, m, A, B \\le 2^{29} - 1$).\n\n### Output\n\nFor each test case, output one integer \u2014 the number of pairs of arrays $(a, b)$ that satisfy all three conditions. Since this number can be very large, output it modulo $998244353$.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n2 2 2 2\n\n2 3 4 5\n\n5 7 4 3\n\n1337 42 1337 42\n\n4 2 13 37\n\n536870902 536370902 536390912 466128231\n\n```\n\n#### Output #1\n\n```\n57\n864\n50360\n439988899\n112000\n732195491\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <cstring>\n\n// Use long long for potentially large intermediate values and final result\n// Input values N, M, A, B can be up to 2^29 - 1, fits in signed 64-bit integer.\nusing ll = long long; \n\n// Input variables read for each test case\nll N_in, M_in, A_in, B_in; \n// Modulo constants\nconst ll MOD = 998244353;\n// MOD - 1, used for modular exponentiation exponent based on Fermat's Little Theorem\nconst ll MOD_PHI = 998244352; \n\n// DP table for digit DP. State: dp[k][tightA1][tightA2][tightB1][tightB2]\n// Dimensions: bit position k (0-29), tightness flags for A1, A2, B1, B2 (0 or 1)\nll dp[30][2][2][2][2];\n// Bit arrays for A and B bounds, precomputed for efficient access in DP\nint A_bits[30];\nint B_bits[30];\n\n// Modular exponentiation function: computes (base^exp) % MOD efficiently\n// Uses binary exponentiation (also known as exponentiation by squaring)\nll power(ll base, ll exp) {\n    ll res = 1;\n    base %= MOD; // Reduce base modulo MOD first\n    while (exp > 0) {\n        // If exponent is odd, multiply result with base\n        if (exp % 2 == 1) res = (res * base) % MOD;\n        // Square the base and halve the exponent\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return res;\n}\n\n// Modular inverse function: computes n^(-1) % MOD\n// Uses Fermat's Little Theorem: n^(MOD-2) % MOD is the inverse of n modulo MOD, as MOD is prime.\nll modInverse(ll n) {\n    return power(n, MOD - 2);\n}\n\n// Digit DP function to compute S = sum_{K>=0} C_A(K) * C_B(K)\n// S represents the count of quadruples (A1, A2, B1, B2) satisfying:\n// 0 <= A1, A2 <= A_in, 0 <= B1, B2 <= B_in and A1 ^ A2 = B1 ^ B2 (which is equivalent to A1 ^ A2 ^ B1 ^ B2 = 0)\n// Parameters:\n// k: current bit position being processed (from 29 down to -1)\n// tightA1, tightA2, tightB1, tightB2: boolean flags indicating if the corresponding number is currently restricted by the upper bound (A_in or B_in)\nll solve(int k, bool tightA1, bool tightA2, bool tightB1, bool tightB2) {\n    // Base case: If all bits processed (k becomes -1), we have found one valid assignment. Return 1.\n    if (k < 0) {\n        return 1; \n    }\n    \n    // Memoization check: If the result for this state is already computed, return the stored value.\n    // Using a reference `memo` for direct access to the DP table entry.\n    ll &memo = dp[k][tightA1][tightA2][tightB1][tightB2];\n    if (memo != -1) {\n        return memo;\n    }\n\n    ll count = 0; // Initialize count for the current state to 0\n    \n    // Determine the upper limits for the current bit k based on tightness flags.\n    // If a number is 'tight', its k-th bit cannot exceed the k-th bit of its bound (A_in or B_in). Otherwise, the limit is 1.\n    int limitA1 = tightA1 ? A_bits[k] : 1;\n    int limitA2 = tightA2 ? A_bits[k] : 1;\n    int limitB1 = tightB1 ? B_bits[k] : 1;\n    int limitB2 = tightB2 ? B_bits[k] : 1;\n\n    // Iterate through all possible combinations for the k-th bits of A1, A2, B1\n    for (int a1 = 0; a1 <= limitA1; ++a1) {\n        for (int a2 = 0; a2 <= limitA2; ++a2) {\n            for (int b1 = 0; b1 <= limitB1; ++b1) {\n                // Calculate the required k-th bit for B2 using the XOR constraint: a1 ^ a2 ^ b1 ^ b2 = 0 => b2 = a1 ^ a2 ^ b1\n                int b2 = a1 ^ a2 ^ b1;\n                \n                // Check if the calculated bit b2 is valid (must be 0 or 1) and satisfies its upper limit.\n                // Since b2 is derived from XOR of bits, it is guaranteed to be 0 or 1. So we only need to check against limitB2.\n                if (b2 <= limitB2) { \n                    // Determine the tightness flags for the next recursive step (k-1).\n                    // A flag remains tight if and only if it was tight in the current step AND the chosen bit equals the limit bit.\n                     bool next_tightA1 = tightA1 && (a1 == limitA1);\n                     bool next_tightA2 = tightA2 && (a2 == limitA2);\n                     bool next_tightB1 = tightB1 && (b1 == limitB1);\n                     bool next_tightB2 = tightB2 && (b2 == limitB2);\n                        \n                    // Recursively call `solve` for the next bit position (k-1) with updated tightness flags.\n                    // Add the result to the total count for the current state, modulo MOD.\n                     count = (count + solve(k - 1, next_tightA1, next_tightA2, next_tightB1, next_tightB2)) % MOD;\n                }\n            }\n        }\n    }\n\n    // Store the computed result in the DP table (memoization) and return it.\n    return memo = count;\n}\n\nint main() {\n    // Optimize standard I/O operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        // Read inputs for the current test case\n        std::cin >> N_in >> M_in >> A_in >> B_in;\n\n        // Precompute the bits of A_in and B_in. Store them in arrays for quick access during DP.\n        // We need up to bit 29, as max value is 2^29 - 1 < 2^30.\n        for (int i = 0; i < 30; ++i) {\n            A_bits[i] = (A_in >> i) & 1;\n            B_bits[i] = (B_in >> i) & 1;\n        }\n\n        // Initialize DP table with -1 before each test case to indicate states are uncomputed.\n        memset(dp, -1, sizeof(dp));\n        \n        // Compute S = Sum_{K>=0} C_A(K) C_B(K) using the digit DP function `solve`.\n        // The initial call starts from the most significant bit position (29), with all tightness flags true.\n        ll S = solve(29, true, true, true, true);\n\n        // Calculate constants needed for the final formula, applying modulo MOD at each step.\n        ll A_plus_1 = (A_in + 1) % MOD;\n        ll B_plus_1 = (B_in + 1) % MOD;\n\n        // Pre-calculate modular inverses for 2 and 4, as they are used in calculating SA, SB, and P.\n        ll inv2 = modInverse(2);\n        ll inv4 = modInverse(4);\n\n        // Calculate SA = Sum_{K!=0} N_A(K). This equals Binomial(A+1, 2) mod MOD.\n        // Formula used: (A+1) * A / 2 mod MOD.\n        ll SA = (A_plus_1 * (A_in % MOD)) % MOD * inv2 % MOD;\n        // Calculate SB = Sum_{L!=0} N_B(L). This equals Binomial(B+1, 2) mod MOD.\n        // Formula used: (B+1) * B / 2 mod MOD.\n        ll SB = (B_plus_1 * (B_in % MOD)) % MOD * inv2 % MOD;\n\n        // Calculate P = Sum_{K!=0} N_A(K)N_B(K) using the computed value S.\n        // The relationship is S = (A+1)(B+1) + 4P. Rearranging gives P = (S - (A+1)(B+1))/4 mod MOD.\n        // Add MOD before taking modulo to ensure the result is non-negative after subtraction.\n        ll P_term = (S - (A_plus_1 * B_plus_1 % MOD) + MOD) % MOD; \n        ll P = P_term * inv4 % MOD;\n        \n        // Calculate modular exponentiation terms: 2^N - 2 and 2^M - 2 mod MOD.\n        // Exponent for modular exponentiation base 2 mod (prime MOD) should be N % (MOD-1).\n        ll N_mod_phi = N_in % MOD_PHI;\n        ll M_mod_phi = M_in % MOD_PHI;\n        \n        // Since N_in, M_in >= 2, the exponents N_mod_phi, M_mod_phi are handled correctly by the power function.\n        \n        ll pow2N = power(2, N_mod_phi);\n        ll pow2M = power(2, M_mod_phi);\n\n        // Calculate (2^N - 2) mod MOD and (2^M - 2) mod MOD. Add MOD before modulo to handle potential negative results.\n        ll pow2n_minus_2 = (pow2N - 2 + MOD) % MOD; \n        ll pow2m_minus_2 = (pow2M - 2 + MOD) % MOD; \n\n        // Calculate the final total count by summing up the contributions from the four identified cases.\n        // All intermediate calculations are performed modulo MOD.\n        ll total_count = 0;\n\n        // Term 1: Contribution from case (1 distinct value in a, 1 distinct value in b). Matrix has 1 value.\n        // Count = (A+1)(B+1)\n        total_count = (A_plus_1 * B_plus_1) % MOD;\n\n        // Term 2: Contribution from case (1 distinct value in a, 2 distinct values in b). Matrix has 2 values.\n        // Count = (A+1) * SB * (2^M - 2)\n        ll term2 = (A_plus_1 * SB) % MOD * pow2m_minus_2 % MOD;\n        total_count = (total_count + term2) % MOD;\n\n        // Term 3: Contribution from case (2 distinct values in a, 1 distinct value in b). Matrix has 2 values.\n        // Count = (B+1) * SA * (2^N - 2)\n        ll term3 = (B_plus_1 * SA) % MOD * pow2n_minus_2 % MOD;\n        total_count = (total_count + term3) % MOD;\n\n        // Term 4: Contribution from case (2 distinct values in a, 2 distinct values in b). Matrix has 2 values.\n        // Requires A1^A2 = B1^B2 = K != 0. Count = P * (2^N - 2) * (2^M - 2)\n        ll term4 = (P * pow2n_minus_2) % MOD * pow2m_minus_2 % MOD;\n        total_count = (total_count + term4) % MOD;\n\n        // Output the final calculated total count for the current test case.\n        std::cout << total_count << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2075d",
      "PROBLEM_ID": "2075D",
      "PROBLEM_STATEMENT": "You are given two non-negative integers $x$ and $y$.\n\nYou can perform the following operation any number of times (possibly zero): choose a positive integer $k$ and divide either $x$ or $y$ by $2^k$ rounding down. The cost of this operation is $2^k$. However, there is an additional constraint: you cannot select the same value of $k$ more than once.\n\nYour task is to calculate the minimum possible cost in order to make $x$ equal to $y$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^5$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains two integers $x$ and $y$ ($0 \\le x, y \\le 10^{17}$).\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the minimum possible cost in order to make $x$ equal to $y$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n0 1\n\n6 2\n\n3 3\n\n13 37\n\n4238659325782394 12983091057341925\n\n```\n\n#### Output #1\n\n```\n2\n6\n0\n26\n32764\n```\n\n### Note\n\nIn the first example, you can proceed as follows: choose $k=1$ and divide $y$ by $2$. After that, $x$ and $y$ are equal to $0$.\n\nIn the second example, you can proceed as follows: choose $k=2$ and divide $x$ by $4$; choose $k=1$ and divide $y$ by $2$. After that, $x$ and $y$ are equal to $1$.\n\nIn the third example, numbers already are equal.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = unsigned long long;\n\nstatic const int MAX_SUM = 60;\nstatic ull dp_table[MAX_SUM+1][MAX_SUM+1];\nstatic ull dp_suff[MAX_SUM+2][MAX_SUM+2];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    // Precompute dp_table[a][b]: minimal cost to choose disjoint sets S_x,S_y of exponents\n    // summing to a and b respectively, cost = sum of 2^k over all used k.\n    const ull INF = std::numeric_limits<ull>::max();\n    for(int a = 0; a <= MAX_SUM; a++) {\n        for(int b = 0; b <= MAX_SUM; b++) {\n            dp_table[a][b] = INF;\n        }\n    }\n    dp_table[0][0] = 0ULL;\n    // For each exponent k = 1..MAX_SUM, we can assign it to x (add to a) or y (add to b) or skip.\n    for(int k = 1; k <= MAX_SUM; k++) {\n        ull costk = (1ULL << k);\n        // iterate backward to avoid reuse in this iteration\n        for(int a = MAX_SUM; a >= 0; a--) {\n            for(int b = MAX_SUM; b >= 0; b--) {\n                ull cur = dp_table[a][b];\n                if (cur == INF) continue;\n                if (a + k <= MAX_SUM) {\n                    ull nc = cur + costk;\n                    if (nc < dp_table[a + k][b]) {\n                        dp_table[a + k][b] = nc;\n                    }\n                }\n                if (b + k <= MAX_SUM) {\n                    ull nc = cur + costk;\n                    if (nc < dp_table[a][b + k]) {\n                        dp_table[a][b + k] = nc;\n                    }\n                }\n            }\n        }\n    }\n\n    // Build 2D suffix minima dp_suff[a][b] = min over all dp_table[a'][b'] with a' >= a, b' >= b\n    for(int a = 0; a <= MAX_SUM+1; a++) {\n        for(int b = 0; b <= MAX_SUM+1; b++) {\n            dp_suff[a][b] = INF;\n        }\n    }\n    for(int a = MAX_SUM; a >= 0; a--) {\n        for(int b = MAX_SUM; b >= 0; b--) {\n            ull v = dp_table[a][b];\n            ull v1 = dp_suff[a+1][b];\n            ull v2 = dp_suff[a][b+1];\n            ull m = v < v1 ? v : v1;\n            if (v2 < m) m = v2;\n            dp_suff[a][b] = m;\n        }\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        ull x, y;\n        cin >> x >> y;\n        // Compute first index where fx[k] == 0, i.e. x >> k == 0\n        int Lx0 = MAX_SUM + 1, Ly0 = MAX_SUM + 1;\n        for(int k = 0; k <= MAX_SUM; k++) {\n            if ((x >> k) == 0) {\n                Lx0 = k;\n                break;\n            }\n        }\n        for(int k = 0; k <= MAX_SUM; k++) {\n            if ((y >> k) == 0) {\n                Ly0 = k;\n                break;\n            }\n        }\n        // Two-pointer on fx and fy for non-zero values\n        ull ans = INF;\n        int i = 0, j = 0;\n        while (i < Lx0 && j < Ly0) {\n            ull vx = (x >> i);\n            ull vy = (y >> j);\n            if (vx > vy) {\n                i++;\n            } else if (vx < vy) {\n                j++;\n            } else {\n                // vx == vy > 0\n                ull c = dp_table[i][j];\n                if (c < ans) ans = c;\n                i++; j++;\n            }\n        }\n        // Handle matching to zero: any A >= Lx0 and B >= Ly0 give fx=fy=0\n        if (Lx0 <= MAX_SUM && Ly0 <= MAX_SUM) {\n            ull c = dp_suff[Lx0][Ly0];\n            if (c < ans) ans = c;\n        }\n        // Output the result\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2075c",
      "PROBLEM_ID": "2075C",
      "PROBLEM_STATEMENT": "Monocarp has installed a new fence at his summer house. The fence consists of $n$ planks of the same size arranged in a row.\n\nMonocarp decided that he would paint his fence according to the following rules:\n\n- each plank of the fence will be painted in exactly one color;\n- the number of different colors that the planks will be painted in is exactly two;\n- the planks of the fence that are painted in the same color must form a continuous sequence, meaning that for all pairs of planks painted in the same color, there will be no planks painted in a different color between them.\n\nMonocarp has $m$ different paints, and the paint of the $i$-th color is sufficient to paint no more than $a_i$ planks of the fence. Monocarp will not buy any additional paints.\n\nYour task is to determine the number of different ways to paint the fence that satisfy all of Monocarp's described wishes. Two ways to paint are considered different if there exists a plank that is painted in different colors in these two ways.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($2 \\le n, m \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of planks in the fence and the number of different colors of paint that Monocarp has.\n\nThe second line contains $m$ integers $a_1, a_2, \\dots, a_m$ ($1 \\le a_i \\le n$), where $a_i$ is the maximum number of planks that can be painted with the paint of color $i$.\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$. The sum of $m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the number of different ways to paint the fence that satisfy all of Monocarp's described wishes.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5 2\n\n2 4\n\n5 2\n\n3 4\n\n12 3\n\n5 9 8\n\n```\n\n#### Output #1\n\n```\n4\n6\n22\n```\n\n### Note\n\nIn the first test case, there are $4$ different ways to paint the fence (the sequences of color numbers in which the planks can be painted from left to right are listed below):\n\n1. $[1, 2, 2, 2, 2]$;\n2. $[1, 1, 2, 2, 2]$;\n3. $[2, 2, 2, 1, 1]$;\n4. $[2, 2, 2, 2, 1]$.\n\nIn the second test case, there are $6$ different ways to paint the fence (the sequences of color numbers in which the planks can be painted from left to right are listed below):\n\n1. $[1, 2, 2, 2, 2]$;\n2. $[1, 1, 2, 2, 2]$;\n3. $[1, 1, 1, 2, 2]$;\n4. $[2, 2, 1, 1, 1]$;\n5. $[2, 2, 2, 1, 1]$;\n6. $[2, 2, 2, 2, 1]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> a[i];\n    }\n    \n    // We need to select two distinct colors i and j.\n    // The first color (i) paints k planks, the second (j) paints n-k planks.\n    // Conditions: k <= a_i and n -k <= a_j => k >= n - a_j.\n    // So for each pair (i, j), the valid k's are in [max(1, n - a_j), min(a_i, n-1)].\n    // The number of valid k's is max(0, min(a_i, n-1) - max(1, n - a_j) + 1).\n    // The total is sum over all i != j of this quantity, multiplied by 2 (since i and j can be swapped).\n    \n    // To compute this efficiently:\n    // Let's sort the array a.\n    // For each a_j, the condition for k is k >= n - a_j.\n    // For a given i, the valid j's are those with a_j >= n -k, but i != j.\n    // But for all possible k in [1, n-1], for each k, the number of i's with a_i >=k, and j's with a_j >= n -k, i != j.\n    // The total is sum_{k=1}^{n-1} [count(a_i >=k) * count(a_j >=n -k) - count(a_i >=k and a_i >=n -k)] * 2.\n    \n    sort(a.begin(), a.end());\n    \n    vector<int> sorted_a = a;\n    sort(sorted_a.begin(), sorted_a.end());\n    \n    long long total = 0;\n    \n    // Precompute prefix sums or use binary search.\n    for (int k = 1; k < n; ++k) {\n        int min_aj = n - k;\n        // Number of colors j with a_j >= min_aj.\n        int cnt_j = sorted_a.end() - lower_bound(sorted_a.begin(), sorted_a.end(), min_aj);\n        // Number of colors i with a_i >=k.\n        int cnt_i = sorted_a.end() - lower_bound(sorted_a.begin(), sorted_a.end(), k);\n        \n        // The valid pairs are (i, j) where i and j are distinct, a_i >=k and a_j >= min_aj.\n        // Total such pairs is cnt_i * cnt_j minus the number of colors that satisfy both (i.e., a_i >=k and a_i >= min_aj).\n        int cnt_both = sorted_a.end() - lower_bound(sorted_a.begin(), sorted_a.end(), max(k, min_aj));\n        long long valid_pairs = (long long)cnt_i * cnt_j - cnt_both;\n        total += valid_pairs;\n    }\n    \n    cout << total << '\\n';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2075b",
      "PROBLEM_ID": "2075B",
      "PROBLEM_STATEMENT": "You are given an integer array $a$ of size $n$. Initially, all elements of the array are colored red.\n\nYou have to choose exactly $k$ elements of the array and paint them blue. Then, while there is at least one red element, you have to select any red element with a blue neighbor and make it blue.\n\nThe cost of painting the array is defined as the sum of the first $k$ chosen elements and the last painted element.\n\nYour task is to calculate the maximum possible cost of painting for the given array.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^3$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2 \\le n \\le 5000$; $1 \\le k < n$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nAdditional constraint on the input: the sum of $n$ over all test cases doesn't exceed $5000$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the maximum possible cost of painting for the given array.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3 1\n\n1 2 3\n\n5 2\n\n4 2 3 1 3\n\n4 3\n\n2 2 2 2\n\n```\n\n#### Output #1\n\n```\n5\n10\n8\n```\n\n### Note\n\nIn the first example, you can initially color the $2$-nd element, and then color the elements in the order $1, 3$. Then the cost of painting is equal to $2+3=5$.\n\nIn the second example, you can initially color the elements $1$ and $5$, and then color the elements in the order $2, 4, 3$. Then the cost of painting is equal to $4+3+3=10$.\n\nIn the third example, you can initially color the elements $2, 3, 4$, and then color the $1$-st element. Then the cost of painting is equal to $2+2+2+2=8$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nlong long max_cost(vector<int>& a, int n, int k) {\n    long long max_result = 0;\n    \n    for (int last_element = 0; last_element < n; ++last_element) {\n        // Collect all elements except the last_element\n        vector<pair<int, int>> elements;\n        for (int i = 0; i < n; ++i) {\n            if (i != last_element) {\n                elements.push_back({a[i], i});\n            }\n        }\n        \n        // Sort elements by value in descending order\n        sort(elements.begin(), elements.end(), greater<pair<int, int>>());\n        \n        // Choose the k highest-value elements as initially blue\n        vector<bool> blue(n, false);\n        long long sum_of_k = 0;\n        for (int i = 0; i < k; ++i) {\n            blue[elements[i].second] = true;\n            sum_of_k += elements[i].first;\n        }\n        \n        // Simulate the coloring process using BFS\n        queue<int> q;\n        for (int i = 0; i < n; ++i) {\n            if (blue[i]) {\n                q.push(i);\n            }\n        }\n        \n        vector<bool> colored = blue;\n        \n        while (!q.empty()) {\n            int pos = q.front();\n            q.pop();\n            \n            if (pos > 0 && !colored[pos-1] && pos-1 != last_element) {\n                colored[pos-1] = true;\n                q.push(pos-1);\n            }\n            \n            if (pos < n-1 && !colored[pos+1] && pos+1 != last_element) {\n                colored[pos+1] = true;\n                q.push(pos+1);\n            }\n        }\n        \n        // Check if all elements (except the last_element) are colored\n        bool valid = true;\n        for (int i = 0; i < n; ++i) {\n            if (i != last_element && !colored[i]) {\n                valid = false;\n                break;\n            }\n        }\n        \n        // Check if the last_element can be colored (has at least one blue neighbor)\n        if (valid) {\n            bool last_element_colorable = false;\n            if (last_element > 0 && colored[last_element-1]) {\n                last_element_colorable = true;\n            }\n            if (last_element < n-1 && colored[last_element+1]) {\n                last_element_colorable = true;\n            }\n            \n            if (last_element_colorable) {\n                max_result = max(max_result, sum_of_k + a[last_element]);\n            }\n        }\n    }\n    \n    return max_result;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        \n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        \n        cout << max_cost(a, n, k) << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2075a",
      "PROBLEM_ID": "2075A",
      "PROBLEM_STATEMENT": "You are given two integers $n$ and $k$; $k$ is an odd number not less than $3$. Your task is to turn $n$ into $0$.\n\nTo do this, you can perform the following operation any number of times: choose a number $x$ from $1$ to $k$ and subtract it from $n$. However, if the current value of $n$ is even (divisible by $2$), then $x$ must also be even, and if the current value of $n$ is odd (not divisible by $2$), then $x$ must be odd.\n\nIn different operations, you can choose the same values of $x$, but you don't have to. So, there are no limitations on using the same value of $x$.\n\nCalculate the minimum number of operations required to turn $n$ into $0$.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10000$) \u2014 the number of test cases.\n\nEach test case consists of one line containing two integers $n$ and $k$ ($3 \\le k \\le n \\le 10^9$, $k$ is odd).\n\n### Output\n\nFor each test case, output one integer \u2014 the minimum number of operations required to turn $n$ into $0$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n39 7\n\n9 3\n\n6 3\n\n999967802 3\n\n5 5\n\n6 5\n\n999999999 3\n\n1000000000 3\n\n```\n\n#### Output #1\n\n```\n7\n4\n3\n499983901\n1\n2\n499999999\n500000000\n```\n\n### Note\n\nIn the first example from the statement, you can first subtract $5$ from $39$ to get $34$. Then subtract $6$ five times to get $4$. Finally, subtract $4$ to get $0$.\n\nIn the second example, you can subtract $3$ once, and then subtract $2$ three times.\n\nIn the third example, you can subtract $2$ three times.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long n, k;\n        cin >> n >> k;\n        \n        // Special case: if n is odd and n \u2264 k, we can reach 0 in one step\n        if (n % 2 == 1 && k >= n) {\n            cout << 1 << \"\\n\";\n            continue;\n        }\n        \n        // Special case: if n is even and n \u2264 k-1, we can reach 0 in one step\n        if (n % 2 == 0 && k-1 >= n) {\n            cout << 1 << \"\\n\";\n            continue;\n        }\n        \n        // Special case for k=3 which has a pattern\n        if (k == 3) {\n            if (n % 2 == 1) { // odd n\n                cout << 1 + (n-3)/2 << \"\\n\";\n            } else { // even n\n                cout << n/2 << \"\\n\";\n            }\n            continue;\n        }\n        \n        // For other cases, we can calculate using a formula\n        long long operations = 0;\n        \n        if (n % 2 == 1) { // odd n\n            operations = 1;  // First subtract k\n            n -= k;         // Now n is even\n            \n            // Calculate remaining operations for even n\n            operations += n / (k-1);\n            if (n % (k-1) != 0) {\n                operations += 1;\n            }\n        } else { // even n\n            operations = n / (k-1);\n            if (n % (k-1) != 0) {\n                operations += 1;\n            }\n        }\n        \n        cout << operations << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2074c",
      "PROBLEM_ID": "2074C",
      "PROBLEM_STATEMENT": "This time, the pink soldiers have given you an integer $x$ ($x \\ge 2$).\n\nPlease determine if there exists a positive integer $y$ that satisfies the following conditions.\n\n- $y$ is strictly less than $x$.\n- There exists a non-degenerate triangle$^{\\text{\u2217}}$ with side lengths $x$, $y$, $x \\oplus y$. Here, $\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nAdditionally, if there exists such an integer $y$, output any.\n\n$^{\\text{\u2217}}$A triangle with side lengths $a$, $b$, $c$ is non-degenerate when $a+b > c$, $a+c > b$, $b+c > a$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2000$). The description of the test cases follows.\n\nThe only line of each test case contains a single integer $x$ ($2 \\le x \\le 10^9$).\n\n### Output\n\nFor each test case, print one integer on a separate line. The integer you must output is as follows:\n\n- If there exists an integer $y$ satisfying the conditions, output the value of $y$ ($1 \\le y < x$);\n- Otherwise, output $-1$.\n\nIf there exist multiple integers that satisfy the conditions, you may output any.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n5\n\n2\n\n6\n\n3\n\n69\n\n4\n\n420\n\n```\n\n#### Output #1\n\n```\n3\n-1\n5\n-1\n66\n-1\n320\n```\n\n### Note\n\nIn the first test case, there exists a non-degenerate triangle with side lengths $3$, $5$, and $3 \\oplus 5 = 6$. Therefore, $y=3$ is a valid answer.\n\nIn the second test case, $1$ is the only possible candidate for $y$, but it cannot make a non-degenerate triangle. Therefore, the answer is $-1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nbool isNonDegenerateTriangle(long long a, long long b, long long c) {\n    return a + b > c && a + c > b && b + c > a;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long x;\n        cin >> x;\n        \n        long long y = -1;\n        \n        // Try x-1\n        if (isNonDegenerateTriangle(x, x-1, x^(x-1))) {\n            y = x-1;\n        }\n        // Try x/2\n        else if (x/2 >= 1 && isNonDegenerateTriangle(x, x/2, x^(x/2))) {\n            y = x/2;\n        }\n        // Try x-2\n        else if (x-2 >= 1 && isNonDegenerateTriangle(x, x-2, x^(x-2))) {\n            y = x-2;\n        }\n        \n        cout << y << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2074b",
      "PROBLEM_ID": "2074B",
      "PROBLEM_STATEMENT": "The pink soldiers have given you a sequence $a$ consisting of $n$ positive integers.\n\nYou must repeatedly perform the following operation until there is only $1$ element left.\n\n- Choose two distinct indices $i$ and $j$.\n- Then, choose a positive integer value $x$ such that there exists a non-degenerate triangle$^{\\text{\u2217}}$ with side lengths $a_i$, $a_j$, and $x$.\n- Finally, remove two elements $a_i$ and $a_j$, and append $x$ to the end of $a$.\n\nPlease find the maximum possible value of the only last element in the sequence $a$.\n\n$^{\\text{\u2217}}$A triangle with side lengths $a$, $b$, $c$ is non-degenerate when $a+b > c$, $a+c > b$, $b+c > a$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le 1000$)\u00a0\u2014 the elements of the sequence $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the maximum possible value of the only last element on a separate line.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n10\n\n3\n\n998 244 353\n\n5\n\n1 2 3 4 5\n\n9\n\n9 9 8 2 4 4 3 5 3\n\n```\n\n#### Output #1\n\n```\n10\n1593\n11\n39\n```\n\n### Note\n\nOn the first test case, there is already only one element. The value of the only last element is $10$.\n\nOn the second test case, $a$ is initially $[998,244,353]$. The following series of operations is valid:\n\n1. Erase $a_2=244$ and $a_3=353$, and append $596$ to the end of $a$. $a$ is now $[998,596]$.\n2. Erase $a_1=998$ and $a_2=596$, and append $1593$ to the end of $a$. $a$ is now $[1593]$.\n\nIt can be shown that the only last element cannot be greater than $1593$. Therefore, the answer is $1593$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        long long sum = 0;\n        for (int i = 0; i < n; i++) {\n            int a_i;\n            cin >> a_i;\n            sum += a_i;\n        }\n        \n        cout << sum - (n - 1) << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2074a",
      "PROBLEM_ID": "2074A",
      "PROBLEM_STATEMENT": "The pink soldiers have given you $4$ distinct points on the plane. The $4$ points' coordinates are $(-l,0)$, $(r,0)$, $(0,-d)$, $(0,u)$ correspondingly, where $l$, $r$, $d$, $u$ are positive integers.\n\n![](https://espresso.codeforces.com/06a14f0d152a975453adebbd64d246fd9055b78c.png)In the diagram, a square is drawn by connecting the four points $L$, $R$, $D$, $U$.\n\nPlease determine if it is possible to draw a square$^{\\text{\u2217}}$ with the given points as its vertices.\n\n$^{\\text{\u2217}}$A square is defined as a polygon consisting of $4$ vertices, of which all sides have equal length and all inner angles are equal. No two edges of the polygon may intersect each other.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains four integers $l$, $r$, $d$, $u$ ($1 \\le l,r,d,u \\le 10$).\n\n### Output\n\nFor each test case, if you can draw a square using the four points, output \"Yes\". Otherwise, output \"No\".\n\nYou can output the answer in any case. For example, the strings \"yEs\", \"yes\", and \"YES\" will also be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n2 2 2 2\n\n1 2 3 4\n\n```\n\n#### Output #1\n\n```\nYes\nNo\n```\n\n### Note\n\nOn the first test case, the four given points form a square, so the answer is \"Yes\".\n\nOn the second test case, the four given points do not form a square, so the answer is \"No\".",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int l, r, d, u;\n        cin >> l >> r >> d >> u;\n        \n        if (l == r && d == u && l == d) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2072f",
      "PROBLEM_ID": "2072F",
      "PROBLEM_STATEMENT": "Monsters are approaching the city, and to protect it, Akito must create a protective field around the city. As everyone knows, protective fields come in various levels. Akito has chosen the field of level $n$. To construct the field, a special phrase is required, which is the $n$-th row of the Great Magical Triangle, represented as a two-dimensional array. We will call this array $T$.\n\nThe triangle is defined as follows:\n\n- In the $i$-th row, there are $i$ integers.\n- The single integer in the first row is $k$.\n- Let the $j$-th element of the $i$-th row be denoted as $T\\_{i,j}$. Then \n\n$$T_{i,j} = \\begin{cases} T_{i-1,j-1} \\oplus T_{i-1,j}, &\\textrm{if } 1 < j < i \\\\ T_{i-1,j}, &\\textrm{if } j = 1 \\\\ T_{i-1,j-1}, &\\textrm{if } j = i \\end{cases}$$\n\nwhere $a \\oplus b$ is the bitwise [exclusive \"OR\"](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)(XOR) of the integers $a$ and $b$.\n\nHelp Akito find the integers in the $n$-th row of the infinite triangle before the monsters reach the city.\n\n### Input\n\nThe first line contains the integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nIn the only line of each test case, there are two integers $n$ and $k$ ($1 \\le n \\le 10^6,\\ 1 \\le k < 2^{31}$) \u2014 the row index that Akito needs and the integer in the first row of the Great Magical Triangle, respectively.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output $n$ integers \u2014 the elements of the $n$-th row of the Great Magical Triangle.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1 5\n\n2 10\n\n3 16\n\n9 1\n\n1 52\n\n```\n\n#### Output #1\n\n```\n5\n10 10\n16 0 16\n1 0 0 0 0 0 0 0 1\n52\n```\n\n### Note\n\nIn the first example, the first row of the Great Magical Triangle is $[5]$ by definition.\n\nIn the second example, $T_{2,1} = T_{1,1} = 10$ and $T_{2,2} = T_{1, 1} = 10$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        unsigned int k;\n        cin >> n >> k;\n        vector<unsigned int> result_row;\n        for (int j = 1; j <= n; ++j) {\n            int binom_mod_2 = 0;\n            if (((j - 1) & (n - 1)) == (j - 1)) {\n                binom_mod_2 = 1;\n            }\n            result_row.push_back(binom_mod_2 * k);\n        }\n        for (int i = 0; i < result_row.size(); ++i) {\n            cout << result_row[i] << (i == result_row.size() - 1 ? \"\" : \" \");\n        }\n        cout << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2072e",
      "PROBLEM_ID": "2072E",
      "PROBLEM_STATEMENT": "Akito decided to study a new powerful spell. Since it possesses immeasurable strength, it certainly requires a lot of space and careful preparation. For this, Akito went out into the field. Let's represent the field as a Cartesian coordinate system.\n\nFor the spell, Akito needs to place $0 \\le n \\le 500$ staffs at distinct integer coordinates in the field such that there will be exactly $k$ pairs $(i, j)$ such that $1 \\le i < j \\le n$ and $\\rho(i, j) = d(i, j)$.\n\nHere, for two points with integer coordinates $a = (x_a, y_a)$ and $b = (x_b, y_b)$, $\\rho(a, b) = \\sqrt{(x_a - x_b)^2 + (y_a - y_b)^2}$ and $d(a, b) = |x_a - x_b| + |y_a - y_b|$.\n\n### Input\n\nThe first line of input contains a single number $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nIn the only line of each test case, there is a single number $k$ ($0 \\le k \\le 10^5$) \u2014 the number of pairs of staffs for which the equality $\\rho(i, j) = d(i, j)$ must hold.\n\n### Output\n\nFor each test case, the first line of output should print the number $n$ ($0 \\le n \\le 500$) \u2014 the number of placed staffs.\n\nIn the following $n$ lines, pairs of integers $x_i, y_i$ $(-10^9 \\le x_i, y_i \\le 10^9)$ should be printed \u2014 the coordinates of the $i$-th staff. The points in which staffs stand must be distinct.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n0\n\n2\n\n5\n\n```\n\n#### Output #1\n\n```\n6\n69 52\n4 20\n789 9308706\n1337 1337\n-1234 -5678\n23456178 707\n10\n-236 -346262358\n273568 6435267\n2365437 31441367\n246574 -45642372\n-236 56\n4743623 -192892\n10408080 -8173135\n-237415357 31441367\n-78125638 278\n56 143231\n5\n1 1\n2 1\n1 5\n3 5\n1 10```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long k;\n        cin >> k;\n\n        // We will represent k as sum of binomial(c_i, 2),\n        // greedily taking the largest c_i such that c_i*(c_i-1)/2 <= k.\n        vector<int> groups;\n        while (k > 0) {\n            // Solve c*(c-1)/2 <= k  <=>  c^2 - c - 2k <= 0\n            // Approximate root by quadratic formula:\n            double d = sqrt(1.0 + 8.0 * k);\n            long long c = (long long)((1.0 + d) / 2.0);\n            // Adjust if necessary\n            while (c * (c - 1) / 2 > k) --c;\n            if (c < 2) c = 2;\n            groups.push_back((int)c);\n            k -= c * (c - 1) / 2;\n        }\n\n        // Total number of points is sum of all c_i\n        int n = 0;\n        for (int c : groups) n += c;\n        cout << n << \"\\n\";\n\n        // Now place the points.  We put each group on its own vertical line.\n        // X-coordinate = group index, Y-coordinates are taken from a global\n        // counter so that no two groups share the same Y, ensuring we only\n        // count vertical pairs.\n        int curY = 0;\n        for (int i = 0; i < (int)groups.size(); ++i) {\n            int c = groups[i];\n            int x = i;  // distinct x per group\n            for (int j = 0; j < c; ++j) {\n                cout << x << \" \" << (curY + j) << \"\\n\";\n            }\n            curY += c;\n        }\n        // If k was 0 from the start, n==0 and we print \"0\" and no points\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2072c",
      "PROBLEM_ID": "2072C",
      "PROBLEM_STATEMENT": "Akito still has nowhere to live, and the price for a small room is everywhere. For this reason, Akito decided to get a job at a bank as a key creator for storages.\n\nIn this magical world, everything is different. For example, the key for a storage with the code $(n, x)$ is an array $a$ of length $n$ such that:\n\n- $a_1 \\ | \\ a_2 \\ | \\ a_3 \\ | \\ \\ldots \\ | \\ a_n = x$, where $a \\ | \\ b$ is the [bitwise \"OR\"](https://en.wikipedia.org/wiki/Bitwise_operation#OR) of numbers $a$ and $b$.\n- $\\\\text{MEX}(\\\\{ a\\_1, a\\_2, a\\_3, \\\\ldots, a\\_n \\\\})$$^{\\\\text{\u2217}}$ is maximized among all such arrays.\n\nAkito diligently performed his job for several hours, but suddenly he got a headache. Substitute for him for an hour; for the given $n$ and $x$, create any key for the storage with the code $(n, x)$.\n\n$^{\\\\text{\u2217}}$$\\\\text{MEX}(S)$ is the minimum non-negative integer $z$ such that $z$ is not contained in the set $S$ and all $0 \\\\le y < z$ are contained in $S$.\n\n### Input\n\nThe first line contains the number $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nIn the only line of each test case, two numbers $n$ and $x$ ($1 \\le n \\le 2 \\cdot 10^5, 0 \\le x < 2^{30}$) are given \u2014 the length of the array and the desired value of the bitwise \"OR\".\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n$ integers $a_i$ ($0 \\le a_i < 2^{30}$) \u2014 the elements of the key array that satisfy all the conditions.\n\nIf there are multiple suitable arrays, output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n1 69\n\n7 7\n\n5 7\n\n7 3\n\n8 7\n\n3 52\n\n9 11\n\n6 15\n\n2 3\n\n```\n\n#### Output #1\n\n```\n69\n6 0 3 4 1 2 5\n4 1 3 0 2\n0 1 2 3 2 1 0\n7 0 6 1 5 2 4 3\n0 52 0\n0 1 8 3 0 9 11 2 10\n4 0 3 8 1 2\n0 3```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Not strictly needed for this solution, but good practice to include if using numeric algorithms\n\nint main() {\n    // Use faster I/O operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Length of the array\n        long long x; // Target bitwise OR value\n        std::cin >> n >> x;\n        \n        // We want to find the maximum k such that the array 'a' contains {0, 1, ..., k-1}\n        // and the bitwise OR of all elements in 'a' is x.\n        // Let P_k = 0 | 1 | ... | (k-1).\n        // A necessary condition for achieving MEX >= k is that P_k must be a bitwise subset of x.\n        // That is, P_k | x == x must hold.\n        // Also, to include {0, 1, ..., k-1}, we need at least k distinct elements. Since the array has length n,\n        // the number of distinct elements is at most n. Thus, we must have k <= n.\n        // We find the maximum k, let's call it k_max, such that k <= n and P_k | x == x.\n        \n        int k_max = 0; // Stores the maximum k found so far satisfying the conditions.\n        long long current_P = 0; // Stores P_k value during iteration. Initialized to P_0 = 0.\n        long long P_kmax_val = 0; // Stores the value P_{k_max} corresponding to the final k_max found.\n        long long P_kmax_minus_1_val = 0; // Stores the value P_{k_max - 1} corresponding to the final k_max found.\n        \n        // Iterate k from 1 up to n to determine the largest k satisfying the condition P_k | x == x.\n        for (int k = 1; k <= n; ++k) {\n            // The next integer to potentially include in the prefix OR sum for P_k is (k-1).\n            long long val_to_OR = k - 1; \n            // Calculate the potential P_k value based on P_{k-1} (which is stored in current_P).\n            long long next_P = current_P | val_to_OR; \n            \n            // Check if P_k is a bitwise subset of x. Equivalent to checking P_k | x == x.\n            if ((next_P | x) == x) { \n                // If the condition holds, this k is valid. Update k_max and store the relevant OR sum values.\n                k_max = k; // Update maximum valid k found so far.\n                P_kmax_val = next_P; // Store P_k value associated with this k_max.\n                P_kmax_minus_1_val = current_P; // Store P_{k-1} value associated with this k_max.\n                                               // P_{k-1} is the value of current_P *before* this update.\n                \n                // Update current_P to P_k, to be used in the next iteration for calculating P_{k+1}.\n                current_P = next_P; \n            } else {\n                // If P_k | x != x, then this k is the first one that fails the condition.\n                // Any k' > k will also fail because P_{k'} >= P_k.\n                // The maximum valid k is the value k_max found in the previous iteration (or 0 if k=1 fails, though k=1 always succeeds for P_1=0).\n                // Terminate the search for k_max.\n                break; \n            }\n        }\n\n        std::vector<long long> a; // The result array to construct.\n        a.reserve(n); // Pre-allocate memory capacity for efficiency.\n\n        // Construct the array based on the found k_max and problem constraints.\n        // The construction strategy aims to maximize MEX.\n        \n        if (n == k_max) { \n            // Case: The array length n exactly matches the maximum possible prefix length k_max.\n            // We must use exactly the elements {0, ..., k_max-1} if possible, or modify minimally.\n            \n            if (P_kmax_val == x) {\n                // Subcase: n=K and P_K = x. \n                // The array [0, ..., K-1] satisfies both conditions: OR is P_K = x, and includes {0..K-1}.\n                // The MEX of {0..K-1} is K. This is the maximum possible MEX.\n                for (int i = 0; i < k_max; ++i) {\n                    a.push_back(i);\n                }\n            } else { // P_kmax_val < x. \n                // Subcase: n=K and P_K < x.\n                // We need to modify the elements {0..K-1} to achieve OR x.\n                // We cannot add new elements since n=K.\n                // The strategy is to use [0, ..., K-2, z], where z = x XOR P_{K-1}.\n                // This construction achieves OR x. The set of elements is {0..K-2, z}.\n                // It can be shown z != K-1. The MEX achieved is K-1.\n                \n                // Add elements 0 to K-2.\n                for (int i = 0; i < k_max - 1; ++i) { \n                   a.push_back(i);\n                }\n                // Calculate z = x XOR P_{K-1}. P_{K-1} value is stored in P_kmax_minus_1_val.\n                long long z = x ^ P_kmax_minus_1_val; \n                a.push_back(z); // Add z as the last element.\n            }\n        } else { // n > k_max. \n            // Case: Array length n is greater than the maximum prefix length K. We have extra slots.\n            \n             if (P_kmax_val == x) {\n                 // Subcase: n > K and P_K = x.\n                 // We can use [0, ..., K-1] and fill the remaining n-K positions with 0.\n                 // The OR sum is P_K | 0 | ... | 0 = P_K = x.\n                 // The set of elements contains {0..K-1}. The MEX is K.\n                 \n                 for (int i = 0; i < k_max; ++i) {\n                     a.push_back(i);\n                 }\n                 // Fill the remaining positions with 0.\n                 for (int i = 0; i < n - k_max; ++i) {\n                     a.push_back(0);\n                 }\n             } else { // P_kmax_val < x. Need to include additional bits to reach x.\n                 // Subcase: n > K and P_K < x.\n                 // We can use [0, ..., K-1]. Their OR is P_K. We need additional bits to reach x.\n                 // Let y = x XOR P_K. These are the bits missing from P_K to form x.\n                 // Since n > K, we have at least one extra slot. Use it for y.\n                 // The array becomes [0, ..., K-1, y, 0, ..., 0].\n                 // The OR sum is P_K | y | 0 | ... | 0 = P_K | (x XOR P_K) = x.\n                 // The set of elements contains {0..K-1} and possibly y. \n                 // It can be shown y != K. The MEX achieved is K.\n\n                 // Include elements 0 to K-1.\n                 for (int i = 0; i < k_max; ++i) { \n                     a.push_back(i);\n                 }\n                 // Calculate y = x XOR P_K. P_K value is stored in P_kmax_val.\n                 long long y = x ^ P_kmax_val; \n                 a.push_back(y); // Add y into one of the extra slots.\n                 // Fill the remaining n - k_max - 1 positions with 0.\n                 for (int i = 0; i < n - k_max - 1; ++i) {\n                     a.push_back(0);\n                 }\n             }\n        }\n\n        // Output the constructed array elements, space-separated.\n        for (int i = 0; i < n; ++i) {\n            std::cout << a[i] << (i == n - 1 ? \"\" : \" \"); // Print space between elements, but not after the last one.\n        }\n        std::cout << \"\\n\"; // Print a newline at the end of the output for this test case.\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2072b",
      "PROBLEM_ID": "2072B",
      "PROBLEM_STATEMENT": "After completing the first quest, Akito left the starting cave. After a while, he stumbled upon a goblin village.\n\nSince Akito had nowhere to live, he wanted to find out the price of housing. It is well known that goblins write numbers as a string of characters '-' and '\\_', and the value represented by the string $s$ is the number of distinct subsequences$^{\\text{\u2217}}$ of the string $s$ that are equal to the string \"\\-\\_\\-\" (this is very similar to goblin faces).\n\nFor example, the string $s=$\"\\-\\_\\-\\-\\_-\" represents the number $6$, as it has $6$ subsequences \"\\-\\_\\-\":\n\n1. $s_1+s_2+s_3$\n2. $s_1+s_2+s_4$\n3. $s_1+s_2+s_6$\n4. $s_1+s_5+s_6$\n5. $s_3+s_5+s_6$\n6. $s_4+s_5+s_6$\n\nInitially, the goblins wrote a random string-number $s$ in response to Akito's question, but then they realized that they wanted to take as much gold as possible from the traveler. To do this, they ask you to rearrange the characters in the string $s$ so that the value of the number represented by the string $s$ is maximized.\n\n$^{\\text{\u2217}}$A subsequence of a string $a$ is a string $b$ that can be obtained by deleting several (possibly $0$) characters from $a$. Subsequences are considered different if they are obtained by deleting different sets of indices.\n\n### Input\n\nThe first line contains the number $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nIn the first line of each test case, there is one number $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of the string written by the goblins.\n\nIn the second line of each test case, there is a string $s$ of length $n$, consisting only of characters '-' and '\\_'\u00a0\u2014 the string written by the goblins.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, you need to output one number \u2014 the maximum number of subsequences equal to the string \"-\\_-\", if the characters in the string $s$ are optimally rearranged.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n3\n\n\\-\\-\\_\n\n5\n\n\\_\\_\\-\\_\\_\n\n9\n\n\\-\\-\\_\\_\\-\\_---\n\n4\n\n\\_\\-\\-\\_\n\n10\n\n\\_\\-\\_\\-\\_\\-\\_-\\_-\n\n7\n\n\\_\\-\\-\\----\n\n1\n\n-\n\n2\n\n\\_-\n\n```\n\n#### Output #1\n\n```\n1\n0\n27\n2\n30\n9\n0\n0\n```\n\n### Note\n\nIn the first test case, it is beneficial to rearrange the characters to form the string \"-\\_-\". This is the only string of three characters that has at least one subsequence \"-\\_-\".\n\nIn the second test case, there is only one character \"-\", and at least two are needed for the subsequence \"-\\_-\". This means that for any rearrangement of characters, the answer will be $0$.\n\nIn the seventh and eighth test cases, the length of the string $n < 3$, which means that subsequences of length $3$ do not exist.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n\n        // Count the number of '-' and '_'\n        int count_minus = 0, count_underscore = 0;\n        for (char c : s) {\n            if (c == '-') count_minus++;\n            else if (c == '_') count_underscore++;\n        }\n\n        // If there are fewer than 2 '-' or no '_', no valid subsequence exists\n        if (count_minus < 2 || count_underscore == 0) {\n            cout << \"0\\n\";\n            continue;\n        }\n\n        // Distribute '-' characters between left and right as evenly as possible\n        int left = count_minus / 2;\n        int right = count_minus - left;\n\n        // Calculate the maximum number of subsequences\n        long long subsequences = 1LL * left * count_underscore * right;\n        cout << subsequences << \"\\n\";\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2072a",
      "PROBLEM_ID": "2072A",
      "PROBLEM_STATEMENT": "Natsume Akito has just woken up in a new world and immediately received his first quest! The system provided him with an array $a$ of $n$ zeros, an integer $k$, and an integer $p$.\n\nIn one operation, Akito chooses two integers $i$ and $x$ such that $1 \\le i \\le n$ and $-p \\le x \\le p$, and performs the assignment $a_i = x$.\n\nAkito is still not fully accustomed to controlling his new body, so help him calculate the minimum number of operations required to make the sum of all elements in the array equal to $k$, or tell him that it is impossible.\n\n### Input\n\nThe first line of input contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe only line of each test case contains three integers $n$, $k$, $p$ ($1 \\le n \\le 50$, $-2500 \\le k \\le 2500$, $1 \\le p \\le 50$) \u2014 the length of the array, the required sum, and the boundary of the segment from which numbers can be replaced.\n\n### Output\n\nFor each test case, output the minimum number of operations to achieve the final sum $k$ in the array, or $-1$ if it is impossible to achieve the sum $k$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n21 100 10\n\n9 -420 42\n\n5 -7 2\n\n13 37 7\n\n10 0 49\n\n1 10 9\n\n7 -7 7\n\n20 31 1\n\n```\n\n#### Output #1\n\n```\n10\n-1\n4\n6\n0\n-1\n1\n-1\n```\n\n### Note\n\nIn the fifth example, the sum of the array is initially zero, so no operations are needed.\n\nIn the sixth example, the maximum sum in the array that we can achieve is $9$ (by assigning the number $9$ to the single element), so the sum $10$ cannot be obtained by any operations.\n\nIn the seventh example, only one operation $a_3 = -7$ is needed.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k, p;\n        cin >> n >> k >> p;\n        int maxSum = n * p;\n        int minSum = -n * p;\n        if (k > maxSum || k < minSum) {\n            cout << -1 << endl;\n        } else {\n            int ans = 0;\n            if (k < 0) {\n                k = -k;\n            }\n            ans = (k + p - 1) / p;\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2071f",
      "PROBLEM_ID": "2071F",
      "PROBLEM_STATEMENT": "An array $b = [b_1, b_2, \\ldots, b_m]$ of length $m$ is called $p$-towering if there exists an index $i$ ($1\\\\le i\\\\le m$) such that for every index $j$ ($1 \\\\le j \\\\le m$), the following condition holds: \n\n$$b_j \\ge p - |i - j|.$$\n\nGiven an array $a = [a_1, a_2, \\ldots, a_n]$ of length $n$, you can remove at most $k$ elements from it. Determine the maximum value of $p$ for which the remaining array can be made $p$-towering.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($0 \\le k < n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximum value of $p$ for which the remaining array can be made $p$-towering.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n5 0\n\n2 1 4 5 2\n\n5 3\n\n2 1 4 5 2\n\n6 1\n\n1 2 3 4 5 1\n\n11 6\n\n6 3 8 5 8 3 2 1 2 7 1\n\n14 3\n\n3 2 3 5 5 2 6 7 4 8 10 1 8 9\n\n2 0\n\n1 1\n\n```\n\n#### Output #1\n\n```\n3\n5\n5\n7\n9\n1\n```\n\n### Note\n\nIn the first test case, you cannot delete any element. The array remains $[2, 1, 4, \\color{red}{5}, 2]$ and is p-towering for $p = 3$ by picking $i = 4$:\n\n- $a_1 = 2 \\ge p - |i - 1| = 3 - |4 - 1| = 0$;\n- $a_2 = 1 \\ge p - |i - 2| = 3 - |4 - 2| = 1$;\n- $a_3 = 4 \\ge p - |i - 3| = 3 - |4 - 3| = 2$;\n- $a_4 = 5 \\ge p - |i - 4| = 3 - |4 - 4| = 3$;\n- $a_5 = 2 \\ge p - |i - 5| = 3 - |4 - 5| = 2$.\n\nIn the second test case, you can remove the first, second, and fifth elements to obtain the array $[4, \\color{red}{5}]$. Clearly, the obtained array is p-towering for $p = 5$ by picking $i = 2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\n#define len(a) (int)a.size()\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\nconst int MAXI = 1e9 + 1e7;\n\nconst int MAXN = 2e5 + 100;\nstruct Node {\n    int min_on_subtree = 0, push_addition = 0;\n};\nNode t[MAXN * 4];\nint a[MAXN], pref[MAXN], suf[MAXN];\n\nclass Segtree {\nprivate:\n    int n;\n    void add_on_subtree(int u, int val) {\n        t[u].push_addition += val;\n        t[u].min_on_subtree += val;\n    }\n    void push(int u) {\n        if (t[u].push_addition) {\n            add_on_subtree(u * 2 + 1, t[u].push_addition);\n            add_on_subtree(u * 2 + 2, t[u].push_addition);\n            t[u].push_addition = 0;\n        }\n    }\n    void recalc(int u) {\n        t[u].min_on_subtree = min(t[u * 2 + 1].min_on_subtree, t[u * 2 + 2].min_on_subtree);\n    }\n    void update(int u, int l, int r, int pos, int val) {\n        if (l == r) {\n            t[u].min_on_subtree = val;\n        } else {\n            push(u);\n            int mid = (l + r) / 2;\n            if (pos <= mid)\n                update(u * 2 + 1, l, mid, pos, val);\n            else\n                update(u * 2 + 2, mid + 1, r, pos, val);\n            recalc(u);\n        }\n    }\n    void add_on_segment(int u, int l, int r, int ql, int qr, int val) {\n        if (ql <= l && r <= qr)\n            add_on_subtree(u, val);\n        else {\n            push(u);\n            int mid = (l + r) / 2;\n            if (ql <= mid)\n                add_on_segment(u * 2 + 1, l, mid, ql, qr, val);\n            if (qr > mid)\n                add_on_segment(u * 2 + 2, mid + 1, r, ql, qr, val);\n            recalc(u);\n        }\n    }\n    int find_prev_non_pos_put_inf(int u, int l, int r, int pos) {\n        if (t[u].min_on_subtree > 0)\n            return -1;\n        if (l == r) {\n            t[u].min_on_subtree = MAXI;\n            return l;\n        }\n        push(u);\n        int mid = (l + r) / 2, res = -1;\n        if (pos > mid)\n            res = find_prev_non_pos_put_inf(u * 2 + 2, mid + 1, r, pos);\n        if (res == -1)\n            res = find_prev_non_pos_put_inf(u * 2 + 1, l, mid, pos);\n        recalc(u);\n        return res;\n    }\npublic:\n    explicit Segtree(int n): n(n) {\n        fill(t, t + 4 * n, Node{MAXI, 0});\n    };\n\n    void update(int pos, int val) {\n        update(0, 0, n - 1, pos, val);\n    }\n    void add_on_segment(int ql, int qr, int val) {\n        add_on_segment(0, 0, n - 1, ql, qr, val);\n    }\n    int find_prev_non_pos_put_inf(int pos) {\n        return find_prev_non_pos_put_inf(0, 0, n - 1, pos);\n    }\n};\n\nvoid f(int n, int p, int *res) {\n    Segtree tree(n);\n    int cur_sz = 0;\n    for (int i = 0; i < n; i++) {\n        tree.update(i, p - a[i]);\n        int pos = i;\n        while ((pos = tree.find_prev_non_pos_put_inf(pos)) != -1) {\n            cur_sz++;\n            tree.add_on_segment(0, pos, -1);\n        }\n        res[i] = cur_sz;\n    }\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int testcases;\n    cin >> testcases;\n    while (testcases--) {\n        int n, k;\n        cin >> n >> k;\n        int max_a = -1;\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            max_a = max(max_a, a[i]);\n        }\n        int l = 0, r = max_a + 1;\n        while (l + 1 < r) {\n            int mid = (l + r) / 2;\n            f(n, mid, pref);\n            reverse(a, a + n);\n            f(n, mid, suf);\n            reverse(a, a + n);\n            reverse(suf, suf + n);\n            int mx = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] >= mid)\n                    mx = max(mx, pref[i] + suf[i] - 1);\n            }\n            if (n - mx <= k)\n                l = mid;\n            else\n                r = mid;\n        }\n        cout << l << '\\n';\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2071d2",
      "PROBLEM_ID": "2071D2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, $l\\le r$. You can hack only if you solved all versions of this problem.\n\nYou are given a positive integer $n$ and the first $n$ terms of an infinite binary sequence $a$, which is defined as follows:\n\n- For $m>n$, $a\\_m = a\\_1 \\\\oplus a\\_2 \\\\oplus \\\\ldots \\\\oplus a\\_{\\\\lfloor \\\\frac{m}{2} \\\\rfloor}$$^{\\\\text{\u2217}}$.\n\nYour task is to compute the sum of elements in a given range $[l, r]$: $a_l + a_{l + 1} + \\ldots + a_r$.\n\n$^{\\\\text{\u2217}}$$\\\\oplus$ denotes the bitwise XOR operation.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $l$, and $r$ ($1 \\le n \\le 2 \\cdot 10^5$, $1 \\le l \\leq r \\le 10^{18}$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($\\color{red}{a_i \\in \\{0, 1\\}}$)\u00a0\u2014 the first $n$ terms of the sequence $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the sum of elements in the given range.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n1 1 1\n\n1\n\n2 3 10\n\n1 0\n\n3 5 25\n\n1 1 1\n\n1 234 567\n\n0\n\n5 1111 10000000000\n\n1 0 1 0 1\n\n1 1000000000000000000 1000000000000000000\n\n1\n\n10 41 87\n\n0 1 1 1 1 1 1 1 0 0\n\n12 65 69\n\n1 0 0 0 0 1 0 1 0 1 1 0\n\n13 46 54\n\n0 1 0 1 1 1 1 1 1 0 1 1 1\n\n```\n\n#### Output #1\n\n```\n1\n5\n14\n0\n6666665925\n0\n32\n3\n2\n```\n\n### Note\n\nIn the first test case, the sequence $a$ is equal to \n\n$$[\\underline{\\color{red}{1}}, 1, 1, 0, 0, 1, 1, 1, 1, 1, \\ldots]$$\n\nwhere $l = 1$, and $r = 1$. The sum of elements in the range $\\[1, 1\\]$ is equal to \n\n$$a_1 = 1.$$\n\nIn the second test case, the sequence $a$ is equal to \n\n$$[\\color{red}{1}, \\color{red}{0}, \\underline{1, 1, 1, 0, 0, 1, 1, 0}, \\ldots]$$\n\nwhere $l = 3$, and $r = 10$. The sum of elements in the range $\\[3, 10\\]$ is equal to \n\n$$a_3 + a_4 + \\ldots + a_{10} = 1 + 1 + 1 + 0 + 0 + 1 + 1 + 0 = 5.$$\n\n",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = unsigned long long;\nconst int MAX = 200010;\nint M0;                // small cutoff: compute explicitly up to M0\nint Cval;              // constant value for odd tail in P sequence\n// small arrays\nuint8_t a_small[MAX];\nuint8_t P_small[MAX];\null Q_small[MAX];\null prefixA_small[MAX];\n\n// Compute Q(x) = number of 1s in P_small[1..x] for the infinite P sequence\null getQ(ull x) {\n    if (x <= (ull)M0) {\n        return Q_small[x];\n    }\n    // sum_tail = sum of P_small[i] for i=M0+1..x\n    ull len = x - (ull)M0;\n    ull T0 = (ull)M0 + 1ULL;\n    // number of odd i in [T0 .. x]\n    ull number_odd = 0;\n    if (T0 & 1ULL) {\n        number_odd = (len + 1ULL) >> 1;  // (len+1)/2\n    } else {\n        number_odd = len >> 1;           // len/2\n    }\n    ull number_even = len - number_odd;\n    // even positions i = 2*j, j from j_start..j_end\n    ull j_start = (T0 + 1ULL) >> 1;      // ceil(T0/2)\n    ull j_end = x >> 1;                  // floor(x/2)\n    // sum of b[j] for j in [j_start..j_end]\n    ull Q_end = getQ(j_end);\n    ull Q_before = (j_start > 1ULL ? getQ(j_start - 1ULL) : 0ULL);\n    ull sum_bj = Q_end - Q_before;\n    // sum_even: if Cval==0, sum_even=sum_bj else = number_even - sum_bj\n    ull sum_even = (Cval == 0 ? sum_bj : (number_even - sum_bj));\n    // odd tail all = Cval\n    ull sum_odd = (ull)Cval * number_odd;\n    // total\n    return Q_small[M0] + sum_odd + sum_even;\n}\n\n// Compute P[x] (prefix XOR) for infinite sequence\nint getB(ull x) {\n    if (x <= (ull)M0) {\n        return (int)P_small[x];\n    }\n    // for x > M0: if odd, P[x]=Cval; else x even: P[x] = Cval XOR P[x/2]\n    if (x & 1ULL) {\n        return Cval;\n    } else {\n        return Cval ^ getB(x >> 1);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        ull l, r;\n        cin >> n >> l >> r;\n        // read initial a[1..n]\n        for (int i = 1; i <= n; i++) {\n            int v;\n            cin >> v;\n            a_small[i] = (uint8_t)v;\n        }\n        // prefix sum for a_small initial, for sum queries on initial part\n        prefixA_small[0] = 0ULL;\n        for (int i = 1; i <= n; i++) {\n            prefixA_small[i] = prefixA_small[i - 1] + (ull)a_small[i];\n        }\n        // compute M0 = n + 4\n        M0 = n + 4;\n        if (M0 >= MAX) M0 = MAX - 1;  // safe guard, though n<=2e5 so n+4 < MAX\n        // compute P_small (prefix XOR) and Q_small (count of ones in P_small)\n        P_small[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            P_small[i] = P_small[i - 1] ^ a_small[i];\n        }\n        // compute tail of small region a_small and P_small up to M0\n        for (int i = n + 1; i <= M0; i++) {\n            // a[i] = P[floor(i/2)]\n            a_small[i] = P_small[i >> 1];\n            P_small[i] = P_small[i - 1] ^ a_small[i];\n        }\n        // Q_small prefix sums of P_small bits\n        Q_small[0] = 0ULL;\n        for (int i = 1; i <= M0; i++) {\n            Q_small[i] = Q_small[i - 1] + (ull)P_small[i];\n        }\n        // compute Cval, the constant for odd tail P values\n        // if n even => C = P[n+1], else C = P[n+2]\n        if ((n % 2) == 0) {\n            Cval = (int)P_small[n + 1];\n        } else {\n            Cval = (int)P_small[n + 2];\n        }\n\n        // function to compute sum of a[i] in [l..r]\n        auto solveRange = [&](ull lq, ull rq) {\n            // sum bits of a in [lq..rq]\n            ull ans = 0ULL;\n            if (rq <= (ull)n) {\n                // entirely in initial region\n                ans = prefixA_small[rq] - (lq >= 1 ? prefixA_small[lq - 1] : 0ULL);\n                return ans;\n            }\n            // part in initial region\n            ull l2 = lq;\n            if (l2 <= (ull)n) {\n                ans += prefixA_small[n] - (l2 >= 1 ? prefixA_small[l2 - 1] : 0ULL);\n                l2 = (ull)n + 1ULL;\n            }\n            if (l2 > rq) {\n                return ans;\n            }\n            // now sum for a[l2..rq], l2 >= n+1\n            // for i >= n+1, a[i] = P[floor(i/2)] = getB(floor(i/2))\n            ull k1 = l2 >> 1;  // floor(l2/2)\n            ull k2 = rq >> 1;  // floor(rq/2)\n            if (k1 == k2) {\n                // all use same P[k1]\n                // count positions i in [l2..rq] with floor(i/2)==k1\n                ull left = max(l2, k1 << 1);\n                ull right = min(rq, (k1 << 1) + 1ULL);\n                ull cnt = 0ULL;\n                if (right >= left) cnt = right - left + 1ULL;\n                ans += cnt * (ull)getB(k1);\n                return ans;\n            }\n            // boundary k1\n            {\n                ull left = max(l2, k1 << 1);\n                ull right = min(rq, (k1 << 1) + 1ULL);\n                if (right >= left) {\n                    ull cnt1 = right - left + 1ULL;\n                    ans += cnt1 * (ull)getB(k1);\n                }\n            }\n            // boundary k2\n            {\n                ull left = max(l2, k2 << 1);\n                ull right = min(rq, (k2 << 1) + 1ULL);\n                if (right >= left) {\n                    ull cnt2 = right - left + 1ULL;\n                    ans += cnt2 * (ull)getB(k2);\n                }\n            }\n            // full pairs for k in [k1+1 .. k2-1]\n            if (k2 > k1 + 1) {\n                // each contributes 2 * P[k]\n                ull sumMid = getQ(k2 - 1ULL) - getQ(k1);\n                ans += 2ULL * sumMid;\n            }\n            return ans;\n        };\n\n        ull answer = solveRange(l, r);\n        cout << answer << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2071d1",
      "PROBLEM_ID": "2071D1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, $l=r$. You can hack only if you solved all versions of this problem.\n\nYou are given a positive integer $n$ and the first $n$ terms of an infinite binary sequence $a$, which is defined as follows:\n\n- For $m>n$, $a\\_m = a\\_1 \\\\oplus a\\_2 \\\\oplus \\\\ldots \\\\oplus a\\_{\\\\lfloor \\\\frac{m}{2} \\\\rfloor}$$^{\\\\text{\u2217}}$.\n\nYour task is to compute the sum of elements in a given range $[l, r]$: $a_l + a_{l + 1} + \\ldots + a_r$.\n\n$^{\\\\text{\u2217}}$$\\\\oplus$ denotes the bitwise XOR operation.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $l$, and $r$ ($1 \\le n \\le 2 \\cdot 10^5$, $1 \\le l=r\\le 10^{18}$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($\\color{red}{a_i \\in \\{0, 1\\}}$)\u00a0\u2014 the first $n$ terms of the sequence $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the sum of elements in the given range.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n1 1 1\n\n1\n\n2 3 3\n\n1 0\n\n3 5 5\n\n1 1 1\n\n1 234 234\n\n0\n\n5 1111 1111\n\n1 0 1 0 1\n\n1 1000000000000000000 1000000000000000000\n\n1\n\n10 87 87\n\n0 1 1 1 1 1 1 1 0 0\n\n12 69 69\n\n1 0 0 0 0 1 0 1 0 1 1 0\n\n13 46 46\n\n0 1 0 1 1 1 1 1 1 0 1 1 1\n\n```\n\n#### Output #1\n\n```\n1\n1\n0\n0\n1\n0\n1\n0\n0\n```\n\n### Note\n\nIn the first test case, the sequence $a$ is equal to \n\n$$[\\underline{\\color{red}{1}}, 1, 1, 0, 0, 1, 1, 1, 1, 1, \\ldots]$$\n\nwhere $l = 1$, and $r = 1$. The sum of elements in the range $\\[1, 1\\]$ is equal to \n\n$$a_1 = 1.$$\n\nIn the second test case, the sequence $a$ is equal to \n\n$$[\\color{red}{1}, \\color{red}{0}, \\underline{1}, 1, 1, 0, 0, 1, 1, 0, \\ldots]$$\n\nwhere $l = 3$, and $r = 3$. The sum of elements in the range $\\[3, 3\\]$ is equal to \n\n$$a_3 = 1.$$\n\n",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <map>\n\n// Using long long for indices which can be up to 10^18\nusing namespace std;\n\ntypedef long long ll;\n\n// Global variables necessary for the recursive computation across function calls.\n// These variables store data specific to a test case and are reset or recomputed \n// for each test case within the solve() function.\nint n; // The number of initial terms provided in the input\nvector<int> a; // Stores the first n terms a_1..a_n (1-indexed)\nvector<int> prefix_xor_sum_upto_n; // Stores prefix XOR sums S_1..S_n (1-indexed). S_0 = 0.\nint Sn_val; // Stores S_n = XOR sum of a_1..a_n\nint fn_val; // Stores f(n) = XOR sum_{i=1..n} S_{floor(i/2)}\nmap<ll, int> memo_S; // Memoization table for computed S_k values where k > n\n\n// Recursive function to compute S_k = a_1 ^ a_2 ^ ... ^ a_k\n// It utilizes memoization (dynamic programming) to avoid recomputing values for the same k.\nint getPrefixXOR(ll k) {\n    // Base case 1: k = 0. The XOR sum of an empty sequence is defined as 0.\n    if (k == 0) {\n        return 0;\n    }\n    // Base case 2: If k is within the range [1, n], the value S_k is precomputed and stored\n    // in `prefix_xor_sum_upto_n`. We can directly return it.\n    if (k <= n) {\n        // Access the precomputed prefix XOR sum for index k.\n        return prefix_xor_sum_upto_n[k];\n    }\n    \n    // Check memoization table: If S_k for k > n has already been computed, return the stored value.\n    if (memo_S.count(k)) {\n        return memo_S[k];\n    }\n    \n    // Recursive step for k > n:\n    // We derived the recurrence relation S_k = S_n ^ f(k) ^ f(n) for k > n.\n    // f(p) is defined as XOR sum_{i=1..p} S_{floor(i/2)}.\n    // We found that f(p) = S_{p/2} if p is even, and f(p) = 0 if p is odd.\n    \n    int fk_val; // Variable to store the value of f(k)\n    if (k % 2 == 0) {\n        // If k is even, f(k) = S_{k/2}. We need to compute S_{k/2} recursively.\n        fk_val = getPrefixXOR(k / 2);\n    } else {\n        // If k is odd, f(k) = 0.\n        fk_val = 0;\n    }\n    \n    // Compute S_k using the derived formula.\n    // Sn_val and fn_val are precomputed global values specific to the current test case.\n    int result_Sk = Sn_val ^ fk_val ^ fn_val;\n    \n    // Store the computed value S_k in the memoization table before returning,\n    // so future calls with the same k can retrieve it instantly.\n    memo_S[k] = result_Sk;\n    return result_Sk;\n}\n\n// Function to handle input/output and setup for a single test case\nvoid solve() {\n    ll l, r;\n    // Read input: n (number of initial terms), l and r (range indices)\n    cin >> n >> l >> r;\n    // In the easy version of the problem, l is guaranteed to equal r.\n    // We need to find the value of the sequence element at index m = l.\n    ll m = l; \n    \n    // Resize vector `a` to hold n+1 elements (using 1-based indexing, so index 0 is unused).\n    // As `a` is global, it must be resized for each test case.\n    a.resize(n + 1); \n    // Read the first n terms of the sequence a_1, ..., a_n.\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n    }\n\n    // Precompute prefix XOR sums S_1 through S_n.\n    // Resize the global vector `prefix_xor_sum_upto_n` for the current n.\n    prefix_xor_sum_upto_n.resize(n + 1);\n    prefix_xor_sum_upto_n[0] = 0; // By definition, S_0 = 0.\n    for (int i = 1; i <= n; ++i) {\n        // S_i = S_{i-1} ^ a_i\n        prefix_xor_sum_upto_n[i] = prefix_xor_sum_upto_n[i-1] ^ a[i];\n    }\n    \n    // Store S_n, the XOR sum of the first n terms, in a global variable for easy access in recursion.\n    Sn_val = prefix_xor_sum_upto_n[n];\n    \n    // Precompute f(n) based on the parity of n.\n    // The formula f(p) = S_{p/2} if p is even, 0 if p is odd.\n    // Need to handle the case n=0 safely although problem constraints state 1 <= n.\n     if (n == 0) { // Defensive check, though n >= 1 guaranteed.\n         fn_val = 0;\n     } else if (n % 2 == 0) {\n        // If n is even, f(n) = S_{n/2}. The value S_{n/2} is already precomputed.\n        fn_val = prefix_xor_sum_upto_n[n/2];\n    } else {\n        // If n is odd, f(n) = 0.\n        fn_val = 0;\n    }\n    \n    // Clear the memoization table `memo_S`. Since it's global, it must be cleared\n    // for each test case to prevent interference between test cases.\n    memo_S.clear();\n\n    // Compute the required value a_m.\n    int result;\n    if (m <= n) {\n        // If m is within the initial sequence range [1, n], a_m is directly given in the input.\n        result = a[m];\n    } else {\n        // If m > n, the definition is a_m = S_{floor(m/2)}.\n        // We compute S_{floor(m/2)} using our recursive function getPrefixXOR.\n        result = getPrefixXOR(m / 2);\n    }\n    \n    // Output the computed value for a_m. Use \"\\n\" for faster output compared to endl.\n    cout << result << \"\\n\"; \n}\n\n// Main function: sets up fast I/O and handles multiple test cases.\nint main() {\n    // Disable synchronization with C standard input/output streams for performance.\n    ios_base::sync_with_stdio(false);\n    // Untie cin from cout, potentially speeding up input operations.\n    cin.tie(NULL);\n    \n    int t; // Variable to store the number of test cases.\n    cin >> t; // Read the number of test cases.\n    // Loop through all test cases.\n    while (t--) {\n        solve(); // Process and solve one test case.\n    }\n    return 0; // Indicate successful program execution.\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2071c",
      "PROBLEM_ID": "2071C",
      "PROBLEM_STATEMENT": "In an Italian village, a hungry mouse starts at vertex $\\textrm{st}$ on a given tree$^{\\text{\u2217}}$ with $n$ vertices.\n\nGiven a permutation $p$ of length $n$$^{\\\\text{\u2020}}$, there are $n$ steps. For the $i$-th step:\n\n- A tempting piece of Parmesan cheese appears at vertex $p_i$. If the mouse is currently at vertex $p_i$, it will stay there and enjoy the moment. Otherwise, it will move along the simple path to vertex $p_i$ by one edge.\n\nYour task is to find such a permutation so that, after all $n$ steps, the mouse inevitably arrives at vertex $\\textrm{en}$, where a trap awaits.\n\nNote that the mouse must arrive at $\\textrm{en}$ after all $n$ steps, though it may pass through $\\textrm{en}$ earlier during the process.\n\n$^{\\text{\u2217}}$A tree is a connected graph without cycles.\n\n$^{\\text{\u2020}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $\\textrm{st}$, and $\\textrm{en}$ ($1 \\le n \\le 10^5$; $1 \\le \\textrm{st}, \\textrm{en} \\le n$)\u00a0\u2014 the number of vertices of the tree, the starting vertex, and the trap vertex.\n\nEach of the next $n - 1$ lines contains two integers $u$ and $v$ ($1 \\le u, v \\le n$, $u \\neq v$)\u00a0\u2014 the indices of the vertices connected by an edge.\n\nIt is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case:\n\n- If no such permutation exists, output $-1$.\n- Otherwise, output $n$ integers $p_1, p_2, \\ldots, p_n$, representing the order in which the cheese will appear at the vertices, ensuring the mouse will eventually be caught at vertex $\\textrm{en}$.\n\nIf there are multiple solutions, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1 1 1\n\n2 1 2\n\n1 2\n\n3 2 2\n\n1 2\n\n2 3\n\n6 1 4\n\n1 2\n\n1 3\n\n4 5\n\n5 6\n\n1 4\n\n```\n\n#### Output #1\n\n```\n1\n1 2\n3 1 2\n1 4 3 2 6 5```\n\n### Note\n\nIn the first test case, there is only one permutation with length $n = 1$ that is $p = [1]$, which successfully catches the mouse:\n\n\n\n$$\\textrm{st} = 1 \\overset{p_1 = 1}{\\xrightarrow{\\hspace{1.3cm}}} 1 = \\textrm{en}.$$\n\nIn the second test case, one possible permutation with length $n = 2$ is $p = [1, 2]$:\n\n\n\n$$\\textrm{st} = 1 \\overset{p_1 = 1}{\\xrightarrow{\\hspace{1.3cm}}} 1 \\overset{p_2 = 2}{\\xrightarrow{\\hspace{1.3cm}}} 2 = \\textrm{en}.$$\n\nIn the third test case, one possible permutation with length $n = 3$ is $p = [3, 1, 2]$:\n\n\n\n$$\\textrm{st} = 2 \\overset{p_1 = 3}{\\xrightarrow{\\hspace{1.3cm}}} 3 \\overset{p_2 = 1}{\\xrightarrow{\\hspace{1.3cm}}} 2 \\overset{p_3 = 2}{\\xrightarrow{\\hspace{1.3cm}}} 2 = \\textrm{en}.$$\n\n",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, st, en;\n        cin >> n >> st >> en;\n        if (n == 1) {\n            if (st == en) {\n                cout << 1 << endl;\n            } else {\n                cout << -1 << endl;\n            }\n            continue;\n        }\n        vector<vector<int>> adj(n + 1);\n        for (int i = 1; i <= n - 1; ++i) {\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        vector<int> parent(n + 1, -1);\n        queue<int> q;\n        q.push(en);\n        parent[en] = -1;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (int v : adj[u]) {\n                if (parent[v] == -1 && v != en) {\n                    parent[v] = u;\n                    q.push(v);\n                }\n            }\n        }\n        vector<vector<int>> children(n + 1);\n        for (int v = 1; v <= n; ++v) {\n            if (v == en) continue;\n            int u = parent[v];\n            children[u].push_back(v);\n        }\n        vector<int> post_order;\n        stack<pair<int, bool>> s;\n        s.push({en, false});\n        while (!s.empty()) {\n            auto top = s.top();\n            s.pop();\n            if (top.second) {\n                post_order.push_back(top.first);\n            } else {\n                s.push({top.first, true});\n                for (int i = children[top.first].size() - 1; i >= 0; --i) {\n                    s.push({children[top.first][i], false});\n                }\n            }\n        }\n        for (int num : post_order) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2071b",
      "PROBLEM_ID": "2071B",
      "PROBLEM_STATEMENT": "A permutation $p$ of length $n$$^{\\\\text{\u2217}}$ is perfect if, for each index $i$ ($1 \\le i \\le n$), it satisfies the following:\n\n- The sum of the first $i$ elements $p_1 + p_2 + \\ldots + p_i$ is not a perfect square$^{\\text{\u2020}}$.\n\nYou would like things to be perfect. Given a positive integer $n$, find a perfect permutation of length $n$, or print $-1$ if none exists.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n$^{\\text{\u2020}}$A perfect square is an integer that is the square of an integer, e.g., $9=3^2$ is a perfect square, but $8$ and $14$ are not.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first and only line of each test case contains a single integer $n$ ($1 \\le n \\le 5 \\cdot 10^5$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case:\n\n- If no solution exists, print a single integer $-1$.\n- Otherwise, print $n$ integers $p_1,p_2,\\ldots,p_n$\u00a0\u2014 the perfect permutation you find.\n\nIf there are multiple solutions, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n3\n1\n4\n5\n```\n\n#### Output #1\n\n```\n-1\n2 4 1 3\n5 1 4 3 2```\n\n### Note\n\nIn the first test case, there is only one permutation with length $n = 1$ that is $p = [1]$, which is not perfect:\n\n- $p_1 = 1 = x^2$ for $x = 1$.\n\nIn the second test case, one possible perfect permutation with length $n = 4$ is $p = [2, 4, 1, 3]$:\n\n- $p_1 = 2 \\neq x^2$;\n- $p_1 + p_2 = 2 + 4 = 6 \\neq x^2$;\n- $p_1 + p_2 + p_3 = 2 + 4 + 1 = 7 \\neq x^2$;\n- $p_1 + p_2 + p_3 + p_4 = 2 + 4 + 1 + 3 = 10 \\neq x^2$.\n\nIn the third test case, one possible perfect permutation with length $n = 5$ is $p = [5, 1, 4, 3, 2]$:\n\n- $p_1 = 5 \\neq x^2$;\n- $p_1 + p_2 = 5 + 1 = 6 \\neq x^2$;\n- $p_1 + p_2 + p_3 = 5 + 1 + 4 = 10 \\neq x^2$;\n- $p_1 + p_2 + p_3 + p_4 = 5 + 1 + 4 + 3 = 13 \\neq x^2$;\n- $p_1 + p_2 + p_3 + p_4 + p_5 = 5 + 1 + 4 + 3 + 2 = 15 \\neq x^2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Check if x is a perfect square\ninline bool isSquare(long long x) {\n    if (x < 0) return false;\n    long long k = (long long)floor(sqrtl((long double)x));\n    // adjust k if necessary\n    while ((k+1)*(long long)(k+1) <= x) ++k;\n    while (k*(long long)k > x) --k;\n    return k*k == x;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        // Total sum of 1..n\n        long long T = 1LL * n * (n + 1) / 2;\n        // If total sum itself is a square, no permutation can avoid it on the last prefix\n        if (isSquare(T)) {\n            cout << -1 << \"\\n\";\n            continue;\n        }\n        // Build the permutation greedily\n        // We keep the \"available\" numbers in a tail-driven array,\n        // always taking the largest unless it creates a square-prefix, in which case we take the 2nd largest.\n        vector<int> avail(n);\n        for (int i = 0; i < n; i++) {\n            avail[i] = i + 1;\n        }\n        int sz = n;\n        vector<int> perm;\n        perm.reserve(n);\n\n        long long prefix = 0;\n        while (sz > 0) {\n            int x1 = avail[sz - 1];\n            long long cand = prefix + x1;\n            if (isSquare(cand)) {\n                // x1 would make a square prefix sum, so skip it once and take the next largest\n                int forbid = x1;\n                --sz;  // remove x1 temporarily\n                int x2 = avail[sz - 1];\n                --sz;  // permanently remove x2\n                perm.push_back(x2);\n                prefix += x2;\n                // put x1 back as the new largest\n                avail[sz++] = forbid;\n            } else {\n                // safe to take x1\n                perm.push_back(x1);\n                prefix = cand;\n                --sz;\n            }\n        }\n        // Output the permutation\n        for (int i = 0; i < n; i++) {\n            if (i) cout << ' ';\n            cout << perm[i];\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2071a",
      "PROBLEM_ID": "2071A",
      "PROBLEM_STATEMENT": "Let's introduce a two-player game, table tennis, where a winner is always decided and draws are impossible.\n\nThree players, Sosai, Fofo, and Hohai, want to spend the rest of their lives playing table tennis. They decided to play forever in the following way:\n\n- In each match, two players compete while the third spectates.\n\n- To ensure fairness, no player can play three times in a row. The player who plays twice in a row must sit out as a spectator in the next match, which will be played by the other two players. Otherwise, the winner and the spectator will play in the next match, while the loser will spectate.\n\nNow, the players, fully immersed in this infinite loop of matches, have tasked you with solving the following problem:\n\nGiven an integer $k$, determine whether the spectator of the first match can be the spectator in the $k$-th match.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe only line of each test case contains one integer $k$ ($1 \\le k \\le 10^9$).\n\n### Output\n\nFor each test case, print \"YES\" (without quotes) if the spectator of the first match can be the spectator of the $k$-th match, and \"NO\" (without quotes) otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n2\n\n333\n\n1000000000\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nNO\nYES\n```\n\n### Note\n\nIn the first test case, the spectator of the first match is already a spectator in the $1$st match.\n\nIn the second test case, the spectator of the first match will play in the $2$nd match regardless of the result of the first match.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int k;\n        cin >> k;\n        // Check if (k - 1) is divisible by 3\n        if ((k - 1) % 3 == 0) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2070f",
      "PROBLEM_ID": "2070F",
      "PROBLEM_STATEMENT": "Monocarp has $n$ pizzas, the $i$-th pizza consists of $a_i$ slices. Pizzas are denoted by uppercase Latin letters from A to the $n$-th letter of the Latin alphabet.\n\nMonocarp also has $m$ friends, and he wants to invite exactly two of them to eat pizza. For each friend, Monocarp knows which pizzas that friend likes.\n\nAfter the friends arrive at Monocarp's house, for each pizza, the following happens:\n\n- if the pizza is not liked by any of the two invited friends, Monocarp eats it;\n- if the pizza is liked by exactly one of the two invited friends, that friend eats it;\n- and if the pizza is liked by both friends, they try to split it. If it consists of an even number of slices, they both eat exactly half of the slices. But if the pizza consists of an odd number of slices, they start quarrelling, trying to decide who will eat an extra slice \u2014 and Monocarp doesn't like that.\n\nFor each $k$ from $0$ to $\\sum a_i$, calculate the number of ways to choose exactly two friends to invite so that the friends don't quarrel, and Monocarp eats exactly $k$ slices.\n\n### Input\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 20$; $2 \\le m \\le 5 \\cdot 10^5$) \u2014 the number of pizzas and the number of friends, respectively.\n\nThe second line contains $m$ strings $s_1, s_2, \\dots, s_m$ ($1 \\le |s_i| \\le n$), where $s_i$ is a string consisting of distinct characters from A to the $n$-th letter of the Latin alphabet, denoting which pizzas the $i$-th friend likes. In every string $s_i$, the characters are sorted in lexicographical (alphabetic) order.\n\nThe third line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 2 \\cdot 10^4$) \u2014 the sizes of the pizzas.\n\n### Output\n\nPrint $\\sum a_i + 1$ integers, where the $k$-th integer (starting from $0$) should be the number of ways to choose exactly two friends to invite so that the friends don't quarrel, and Monocarp eats exactly $k$ slices.\n\n### Example\n\n#### Input #1\n\n```\n\n3 6\n\nA AB ABC AB BC C\n\n2 3 5\n\n```\n\n#### Output #1\n\n```\n4 0 0 1 0 2 0 0 0 0 0\n```\n\n### Note\n\nLet's consider all pairs of friends from the first example:\n\n- if Monocarp invites friends $1$ and $2$, they will eat pizzas $1$ and $2$, and he'll eat the $3$-rd pizza;\n- if Monocarp invites friends $1$ and $3$, they will eat all of the pizzas;\n- if Monocarp invites friends $1$ and $4$, they will eat pizzas $1$ and $2$, and he'll eat the $3$-rd pizza;\n- if Monocarp invites friends $1$ and $5$, they will eat all of the pizzas;\n- if Monocarp invites friends $1$ and $6$, they will eat pizzas $1$ and $3$, and he'll eat the $2$-nd pizza;\n- if Monocarp invites friends $2$ and $3$, they will quarrel because of the $2$-nd pizza;\n- if Monocarp invites friends $2$ and $4$, they will quarrel because of the $2$-nd pizza;\n- if Monocarp invites friends $2$ and $5$, they will quarrel because of the $2$-nd pizza;\n- if Monocarp invites friends $2$ and $6$, they will eat all of the pizzas;\n- if Monocarp invites friends $3$ and $4$, they will quarrel because of the $2$-nd pizza;\n- if Monocarp invites friends $3$ and $5$, they will quarrel because of the $2$-nd pizza;\n- if Monocarp invites friends $3$ and $6$, they will quarrel because of the $3$-rd pizza;\n- if Monocarp invites friends $4$ and $5$, they will quarrel because of the $2$-nd pizza;\n- if Monocarp invites friends $4$ and $6$, they will eat all of the pizzas;\n- if Monocarp invites friends $5$ and $6$, they will quarrel because of the $3$-rd pizza.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n \nusing namespace std;             \n \nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<long long> cnt(1 << n);\n    for(int i = 0; i < m; i++)\n    {\n        string s;\n        cin >> s;\n        int mask = 0;\n        for(auto c : s) mask += (1 << (c - 'A'));\n        cnt[mask]++;\n    }\n    vector<int> a(n);\n    for(int i = 0; i < n; i++)\n        cin >> a[i];\n \n    vector<bool> odd(n);\n    int odd_pizzas = 0;\n    int odd_mask = 0;\n    for(int i = 0; i < n; i++)\n        if(a[i] % 2 == 1)\n        {\n            odd[i] = true;\n            odd_pizzas++;\n            odd_mask += (1 << i);\n        }\n \n    // calculating the number of bits representing odd-sized pizzas in each mask\n    vector<int> cnt_odd(1 << n);\n    for(int i = 0; i < (1 << n); i++)\n        for(int j = 0; j < n; j++)\n            if(odd[j] && ((i >> j) & 1) == 1)\n                cnt_odd[i]++;\n \n    // transforming the sequence a to a' (and b to b', since a and b are the same)\n    vector<vector<long long>> A(odd_pizzas + 1, vector<long long>(1 << n, 0ll));\n    for(int i = 0; i < (1 << n); i++)\n        A[cnt_odd[i]][i] = cnt[i];\n \n    // applying SOS DP to every row of the matrix\n    for(int k = 0; k <= odd_pizzas; k++)\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < (1 << n); j++)\n                if((j >> i) & 1)\n                    A[k][j] += A[k][j ^ (1 << i)];\n \n    // getting the SOS DP of the matrix c' from the editorial\n    vector<vector<long long>> B(odd_pizzas + 1, vector<long long>(1 << n, 0ll));\n    for(int x = 0; x <= odd_pizzas; x++)\n        for(int y = 0; y <= odd_pizzas - x; y++)\n            for(int i = 0; i < (1 << n); i++)\n                B[x + y][i] += A[x][i] * A[y][i];\n \n    // applying inverse SOS DP to every row\n    for(int k = 0; k <= odd_pizzas; k++)\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < (1 << n); j++)\n                if((j >> i) & 1)\n                    B[k][j] -= B[k][j ^ (1 << i)];\n \n    int size_ans = 0;\n    for(auto x : a) size_ans += x;\n    vector<long long> ans(size_ans + 1);\n    for(int i = 0; i < (1 << n); i++)\n    {\n        long long cur_cnt = B[cnt_odd[i]][i];\n        int sum = 0;\n        for(int j = 0; j < n; j++)\n            if((i >> j) & 1)\n                sum += a[j];\n        ans[sum] += cur_cnt;\n    }\n \n    for(int i = 0; i < (1 << n); i++)\n    {\n        if(i & odd_mask) continue;\n        int sum = 0;\n        for(int j = 0; j < n; j++)\n            if((i >> j) & 1)\n                sum += a[j];\n        ans[sum] -= cnt[i];\n    }\n    \n    reverse(ans.begin(), ans.end());\n    \n    for(auto x : ans) cout << x / 2 << \" \";\n    cout << endl;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2070e",
      "PROBLEM_ID": "2070E",
      "PROBLEM_STATEMENT": "Consider the following game. Two players have a binary string (a string consisting of characters 0 and/or 1). The players take turns, the first player makes the first turn. During a player's turn, he or she has to choose exactly two adjacent elements of the string and remove them (the first element and the last element are also considered adjacent). Furthermore, there are additional constraints depending on who makes the move:\n\n- if it's the first player's move, both chosen characters should be 0;\n- if it's the second player's move, at least one of the chosen characters should be 1.\n\nThe player who can't make a valid move loses the game. This also means that if the string currently has less than $2$ characters, the current player loses the game.\n\nYou are given a binary string $s$ of length $n$. You have to calculate the number of its substrings such that, if the game is played on that substring and both players make optimal decisions, the first player wins. In other words, calculate the number of pairs $(l, r)$ such that $1 \\le l \\le r \\le n$ and the first player has a winning strategy on the string $s_l s_{l+1} \\dots s_r$.\n\n### Input\n\nThe first line contains one integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe second line contains the string $s$, consisting of exactly $n$ characters. Each character of the string is either 0 or 1.\n\n### Output\n\nPrint one integer \u2014 the number of substrings such that, if the game is played on that substring, the first player wins.\n\n### Example\n\n#### Input #1\n\n```\n\n10\n\n0010010011\n\n```\n\n#### Output #1\n\n```\n12\n```\n\n### Note\n\nIn the first example, the following substrings are winning for the first player ($s[l:r]$ denotes $s_l s_{l+1} \\dots s_r$):\n\n- $s[1:2]$;\n- $s[1:3]$;\n- $s[1:7]$;\n- $s[2:4]$;\n- $s[2:8]$;\n- $s[3:5]$;\n- $s[4:5]$;\n- $s[4:6]$;\n- $s[5:7]$;\n- $s[6:8]$;\n- $s[7:8]$;\n- $s[7:9]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nconst int N = 300003;\nconst int M = 3 * N;\nconst int S = 4 * N;\n \nstruct segtree\n{\n    vector<int> T;\n \n    void add(int v, int l, int r, int pos, int val)\n    {\n        T[v] += val;\n        if(l != r - 1)\n        {\n            int m = (l + r) / 2;\n            if(pos < m) add(v * 2 + 1, l, m, pos, val);\n            else add(v * 2 + 2, m, r, pos, val);\n        }\n    }\n \n    int get(int v, int l, int r, int L, int R)\n    {\n        if(L >= R) return 0;\n        if(l == L && r == R) return T[v];\n        int m = (l + r) / 2;\n        return get(v * 2 + 1, l, m, L, min(m, R)) + get(v * 2 + 2, m, r, max(m, L), R);\n    }\n \n    int getSumLess(int l)\n    {\n        return get(0, 0, S, 0, l + M);\n    }\n \n    void add(int pos, int val)\n    {\n        add(0, 0, S, pos + M, val);\n    }\n \n    segtree()\n    {\n        T.resize(4 * S);\n    }\n};\n \nint threshold[] = {0, 1, 1, -2};\n \nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<int> p(n + 1);\n    for(int i = 0; i < n; i++)\n        p[i + 1] = p[i] + (s[i] == '1' ? -3 : 1);\n    vector<segtree> trees(4);\n    long long ans = 0;\n    for(int i = 0; i <= n; i++)\n    {\n        for(int j = 0; j < 4; j++)\n        {\n            int len = (i - j + 4) % 4;\n            int bound = p[i] - threshold[len];\n            ans += trees[j].getSumLess(bound); \n        }\n        trees[i % 4].add(p[i], 1);\n    }\n    cout << ans << endl;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2070d",
      "PROBLEM_ID": "2070D",
      "PROBLEM_STATEMENT": "You are given a rooted tree, consisting of $n$ vertices. The vertices in the tree are numbered from $1$ to $n$, and the root is the vertex $1$. Let $d_x$ be the distance (the number of edges on the shortest path) from the root to the vertex $x$.\n\nThere is a chip that is initially placed at the root. You can perform the following operation as many times as you want (possibly zero):\n\n- move the chip from the current vertex $v$ to a vertex $u$ such that $d_u = d_v + 1$. If $v$ is the root, you can choose any vertex $u$ meeting this constraint; however, if $v$ is not the root, $u$ should not be a neighbor of $v$ (there should be no edge connecting $v$ and $u$).\n\n![](https://espresso.codeforces.com/769463352aac7806978d82f0bd49238491821303.png)\n\nFor example, in the tree above, the following chip moves are possible: $1 \\rightarrow 2$, $1 \\rightarrow 5$, $2 \\rightarrow 7$, $5 \\rightarrow 3$, $5 \\rightarrow 4$, $3 \\rightarrow 6$, $7 \\rightarrow 6$.\n\nA sequence of vertices is valid if you can move the chip in such a way that it visits all vertices from the sequence (and only them), in the order they are given in the sequence.\n\nYour task is to calculate the number of valid vertex sequences. Since the answer might be large, print it modulo $998244353$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 3 \\cdot 10^5$).\n\nThe second line contains $n-1$ integers $p_2, p_3, \\dots, p_n$ ($1 \\le p_i < i$), where $p_i$ is the parent of the $i$-th vertex in the tree. Vertex $1$ is the root.\n\nAdditional constraint on the input: the sum of $n$ over all test cases doesn't exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the number of valid vertex sequences, taken modulo $998244353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4\n\n1 2 1\n\n3\n\n1 2\n\n7\n\n1 2 2 1 4 5\n\n```\n\n#### Output #1\n\n```\n4\n2\n8\n```\n\n### Note\n\nIn the first example, the following sequences are valid: $[1]$, $[1, 2]$, $[1, 4]$, $[1, 4, 3]$.\n\nIn the second example, the following sequences are valid: $[1]$, $[1, 2]$.\n\nIn the third example, the following sequences are valid: $[1]$, $[1, 2]$, $[1, 2, 7]$, $[1, 2, 7, 6]$, $[1, 5]$, $[1, 5, 3]$, $[1, 5, 3, 6]$, $[1, 5, 4]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nconst int MOD = 998244353;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> parent(n + 1); // parent[1] is unused (root)\n        for (int i = 2; i <= n; ++i) {\n            cin >> parent[i];\n        }\n\n        // Calculate depths for each node\n        vector<int> depth(n + 1);\n        depth[1] = 0;\n        for (int i = 2; i <= n; ++i) {\n            depth[i] = depth[parent[i]] + 1;\n        }\n\n        // Find maximum depth and group nodes by depth\n        int max_d = 0;\n        for (int i = 1; i <= n; ++i) {\n            max_d = max(max_d, depth[i]);\n        }\n        vector<vector<int>> levels(max_d + 1);\n        for (int i = 1; i <= n; ++i) {\n            levels[depth[i]].push_back(i);\n        }\n\n        vector<ll> count(n + 1);\n        count[1] = 1; // The root's only path is itself\n        vector<ll> S(max_d + 1); // S[d] is the sum for depth d\n        S[0] = 1; // Initial value for root depth\n\n        for (int d = 1; d <= max_d; ++d) {\n            ll S_prev = S[d - 1];\n            ll current_sum = 0;\n            for (int u : levels[d]) {\n                int p = parent[u];\n                ll val = S_prev;\n                if (p != 1) {\n                    val -= count[p];\n                }\n                val %= MOD;\n                if (val < 0) {\n                    val += MOD;\n                }\n                count[u] = val;\n                current_sum = (current_sum + val) % MOD;\n            }\n            S[d] = current_sum;\n        }\n\n        // Sum all counts to get the total valid sequences\n        ll ans = 0;\n        for (int i = 1; i <= n; ++i) {\n            ans = (ans + count[i]) % MOD;\n        }\n        // Ensure positive even after modulo if needed\n        if (ans < 0) ans += MOD;\n        cout << ans << '\\n';\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2070c",
      "PROBLEM_ID": "2070C",
      "PROBLEM_STATEMENT": "You are given a strip, consisting of $n$ cells, all cells are initially colored red.\n\nIn one operation, you can choose a segment of consecutive cells and paint them blue. Before painting, the chosen cells can be either red or blue. Note that it is not possible to paint them red. You are allowed to perform at most $k$ operations (possibly zero).\n\nFor each cell, the desired color after all operations is specified: red or blue.\n\nIt is clear that it is not always possible to satisfy all requirements within $k$ operations. Therefore, for each cell, a penalty is also specified, which is applied if the cell ends up the wrong color after all operations. For the $i$-th cell, the penalty is equal to $a_i$.\n\nThe penalty of the final painting is calculated as the maximum penalty among all cells that are painted the wrong color. If there are no such cells, the painting penalty is equal to $0$.\n\nWhat is the minimum penalty of the final painting that can be achieved?\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 3 \\cdot 10^5$; $0 \\le k \\le n$)\u00a0\u2014 the length of the strip and the maximum number of operations.\n\nThe second line contains a string $s$, consisting of $n$ characters 'R' and/or 'B'. 'R' means that the cell should be painted red. 'B' means that the cell should be painted blue.\n\nThe third line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the penalty for each cell.\n\nThe sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the minimum penalty of the final painting.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4 1\n\nBRBR\n\n9 3 5 4\n\n4 1\n\nBRBR\n\n9 5 3 4\n\n4 2\n\nBRBR\n\n9 3 5 4\n\n10 2\n\nBRBRBBRRBR\n\n5 1 2 4 5 3 6 1 5 4\n\n5 5\n\nRRRRR\n\n5 3 1 2 4\n\n```\n\n#### Output #1\n\n```\n3\n3\n0\n4\n0\n```\n\n### Note\n\nIn the first test case, you can paint the cells from $1$ to $3$. The painting will be BBBR. So, only cell $2$ is painted the wrong color. Therefore, the penalty for it is the final penalty and equals $3$.\n\nIn the second test case, the painting BBBR will now result in a penalty of $5$. However, if you paint the cells from $1$ to $1$, resulting in BRRR, then only cell $3$ is painted the wrong color. The final penalty is $3$.\n\nIn the third test case, you can paint the cells from $1$ to $1$ and from $3$ to $3$. Then all cells will be the correct color, the penalty equals $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canPaint(string &s, vector<int> &a, int n, int k, int maxPenalty) {\n    int segments = 0;\n    int i = 0;\n    while (i < n) {\n        if (s[i] == 'B' && a[i] > maxPenalty) {\n            segments++;\n            int j = i;\n            while (j < n && (s[j] != 'R' || a[j] <= maxPenalty)) j++;\n            i = j;\n        } \n        else i++;\n    }\n    return segments <= k;\n}\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    vector<int> a(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n\n    int l = 0, r = *max_element(a.begin(), a.end()), answer = r;\n    \n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (canPaint(s, a, n, k, mid)) {\n            answer = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    cout << answer << \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2070a",
      "PROBLEM_ID": "2070A",
      "PROBLEM_STATEMENT": "FizzBuzz is one of the most well-known problems from coding interviews. In this problem, we will consider a remixed version of FizzBuzz:\n\nGiven an integer $n$, process all integers from $0$ to $n$. For every integer such that its remainders modulo $3$ and modulo $5$ are the same (so, for every integer $i$ such that $i \\bmod 3 = i \\bmod 5$), printFizzBuzz.\n\nHowever, you don't have to solve it. Instead, given the integer $n$, you have to report how many times the correct solution to that problem will print FizzBuzz.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case contains one line consisting of one integer $n$ ($0 \\le n \\le 10^9$).\n\n### Output\n\nFor each test case, print one integer \u2014 the number of times the correct solution will print FizzBuzz with the given value of $n$.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n0\n\n5\n\n15\n\n42\n\n1337\n\n17101997\n\n998244353\n\n```\n\n#### Output #1\n\n```\n1\n3\n4\n9\n270\n3420402\n199648872\n```\n\n### Note\n\nIn the first test case, the solution will print FizzBuzz for the integer $0$.\n\nIn the second test case, the solution will print FizzBuzz for the integers $0, 1, 2$.\n\nIn the third test case, the solution will print FizzBuzz for the integers $0, 1, 2, 15$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nusing namespace std;\n\n// Function to solve each test case\nlong long solve(long long n) {\n    // The pattern repeats every LCM(3,5) = 15\n    // Within each cycle, we need numbers where i%3 == i%5\n    // These numbers are 0,1,2,15,16,17,30,31,32,...\n    \n    // Calculate complete cycles\n    long long complete_cycles = n / 15;\n    long long result = complete_cycles * 3; // Each complete cycle contributes 3 numbers\n    \n    // Handle remaining numbers\n    long long remainder = n % 15;\n    \n    // Count additional numbers in the incomplete cycle\n    for(int i = 0; i <= remainder; i++) {\n        if(i % 3 == i % 5) {\n            result++;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while(t--) {\n        long long n;\n        cin >> n;\n        cout << solve(n) << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2069f",
      "PROBLEM_ID": "2069F",
      "PROBLEM_STATEMENT": "A connected component of an undirected graph is defined as a set of vertices $S$ of this graph such that:\n\n- for every pair of vertices $(u, v)$ in $S$, there exists a path between vertices $u$ and $v$;\n- there is no vertex outside $S$ that has a path to a vertex within $S$.\n\nFor example, the graph in the picture below has three components: $\\{1, 3, 7, 8\\}$, $\\{2\\}$, $\\{4, 5, 6\\}$.\n\n![](https://espresso.codeforces.com/7715b47246248fe80ce09cff1f675d0918eda77e.png)\n\nWe say that graph $A$ includes graph $B$ if every component of graph $B$ is a subset of some component of graph $A$.\n\nYou are given two graphs, $A$ and $B$, both consisting of $n$ vertices numbered from $1$ to $n$. Initially, there are no edges in the graphs. You must process queries of two types:\n\n- add an edge to one of the graphs;\n- remove an edge from one of the graphs.\n\nAfter each query, you have to calculate the minimum number of edges that have to be added to $A$ so that $A$ includes $B$, and print it. Note that you don't actually add these edges, you just calculate their number.\n\n### Input\n\nThe first line contains two integers $n$ and $q$ ($2 \\le n \\le 4 \\cdot 10^5$; $1 \\le q \\le 4 \\cdot 10^5$) \u2014 the number of vertices and queries, respectively.\n\nNext, there are $q$ lines, where the $i$-th line describes the $i$-th query. The description of the query begins with the character $c_i$ (either A or B) \u2014 the graph to which the query should be applied. Then, two integers $x_i$ and $y_i$ follow ($1 \\le x_i, y_i \\le n$; $x_i \\ne y_i$). If there is an edge $(x_i, y_i)$ in the corresponding graph, it should be removed; otherwise, it should be added to that graph.\n\n### Output\n\nFor each query, print one integer \u2014 the minimum number of edges that you have to add to the graph $A$ so that it includes $B$.\n\n### Example\n\n#### Input #1\n\n```\n\n6 9\n\nA 2 3\n\nB 1 3\n\nA 2 1\n\nA 3 2\n\nB 5 6\n\nA 6 5\n\nA 3 4\n\nA 4 2\n\nA 4 3\n\n```\n\n#### Output #1\n\n```\n0\n1\n0\n1\n2\n1\n1\n0\n1\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\n// We maintain two dynamic connectivity structures with rollback: one for graph A alone,\n// and one for the union graph (A \u222a B).  It can be shown that the minimum number of edges\n// to add in A so that A includes B equals\n//    (#components in A) - (#components in A\u222aB).\n//\n// We handle the edge\u2010add/remove queries offline by a standard divide\u2010and\u2010conquer on time\n// + DSU with rollback.  Each edge lives on some interval [l, r), and we recurse on\n// time segments, adding those edges that fully cover the segment, recursing to children\n// for partially covering intervals, and rolling back afterwards.\n\nstruct EdgeKey {\n    char g;     // 'A' or 'B'\n    int u, v;   // endpoints, stored with u < v\n    bool operator<(EdgeKey const& o) const {\n        if (g != o.g) return g < o.g;\n        if (u != o.u) return u < o.u;\n        return v < o.v;\n    }\n    bool operator==(EdgeKey const& o) const {\n        return g == o.g && u == o.u && v == o.v;\n    }\n};\n\nstruct Interval {\n    int l, r, id;\n};\n\nstruct DSU_RB {\n    // Rollback\u2010able DSU storing parent as negative size for roots.\n    // We record merges so we can undo them.\n    struct Rec { int x, old_px, y; };\n    int n;\n    vector<int> parent;\n    int comp;\n    vector<Rec> st;\n\n    DSU_RB(int _n = 0) { init(_n); }\n\n    void init(int _n) {\n        n = _n;\n        parent.assign(n+1, -1);\n        comp = n;\n        st.clear();\n    }\n\n    int find(int x) {\n        while (parent[x] >= 0) x = parent[x];\n        return x;\n    }\n\n    int snapshot() const {\n        return (int)st.size();\n    }\n\n    void unite(int a, int b) {\n        int x = find(a), y = find(b);\n        if (x == y) {\n            // marker for \"no merge\"\n            st.push_back({0, 0, 0});\n            return;\n        }\n        // union by size: parent[x] <= parent[y] means |x| >= |y|\n        if (parent[x] > parent[y]) swap(x, y);\n        // record the merge: we will attach y under x\n        st.push_back({x, parent[x], y});\n        parent[x] += parent[y];\n        parent[y] = x;\n        --comp;\n    }\n\n    void rollback(int snap) {\n        // undo until we reach the saved snapshot\n        while ((int)st.size() > snap) {\n            Rec r = st.back();\n            st.pop_back();\n            if (r.y == 0) {\n                // no\u2010op marker\n            } else {\n                // undo the merge of y into x\n                int x = r.x;\n                int old_px = r.old_px;\n                int new_px = parent[x];\n                // parent[x] was old_px + old_py; so old_py = new_px - old_px\n                int old_py = new_px - old_px;\n                parent[x] = old_px;\n                parent[r.y] = old_py;\n                ++comp;\n            }\n        }\n    }\n};\n\nint n, q;\nvector<EdgeKey> edgesList;\nvector<int>  id_map;\nvector<int>  ans;\nDSU_RB dsuA, dsuU;\n\n// Divide-and-conquer on the time interval [l, r), with the list of intervals\n// that may partially or fully cover [l, r).  We apply merges for intervals that\n// fully cover [l, r), recurse on children with the partially covering ones, and\n// then roll back.\nvoid solve(int l, int r, const vector<Interval>& iv) {\n    int snapA = dsuA.snapshot();\n    int snapU = dsuU.snapshot();\n\n    int mid = (l + r) >> 1;\n    vector<Interval> left, right;\n    left.reserve(iv.size());\n    right.reserve(iv.size());\n\n    // Process all intervals\n    for (auto &I : iv) {\n        if (I.l <= l && r <= I.r) {\n            // fully covers this node's segment => apply the edge now\n            const EdgeKey &ek = edgesList[I.id];\n            if (ek.g == 'A') {\n                dsuA.unite(ek.u, ek.v);\n                dsuU.unite(ek.u, ek.v);\n            } else {\n                // B-edge only goes into the union DSU\n                dsuU.unite(ek.u, ek.v);\n            }\n        } else {\n            // partial coverage => send to children where it overlaps\n            if (I.l < mid && I.r > l) {\n                left.push_back(I);\n            }\n            if (I.l < r && I.r > mid) {\n                right.push_back(I);\n            }\n        }\n    }\n\n    if (r - l == 1) {\n        // Leaf: time = l\n        // answer = (#components in A) - (#components in A\u222aB)\n        ans[l] = dsuA.comp - dsuU.comp;\n    } else {\n        solve(l, mid, left);\n        solve(mid, r, right);\n    }\n\n    // rollback to state at entry\n    dsuA.rollback(snapA);\n    dsuU.rollback(snapU);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> q;\n    vector<EdgeKey> queries(q);\n    queries.reserve(q);\n    edgesList.reserve(q);\n\n    // Read queries, normalize edges so that u < v\n    for (int i = 0; i < q; i++) {\n        char c; int x, y;\n        cin >> c >> x >> y;\n        if (x > y) swap(x,y);\n        queries[i] = {c, x, y};\n        edgesList.push_back(queries[i]);\n    }\n\n    // Extract unique edge\u2010keys (graph type + endpoints)\n    sort(edgesList.begin(), edgesList.end());\n    edgesList.erase(unique(edgesList.begin(), edgesList.end()), edgesList.end());\n\n    // Map each query to its edge\u2010key index\n    id_map.resize(q);\n    for (int i = 0; i < q; i++) {\n        auto &k = queries[i];\n        int pos = int(lower_bound(edgesList.begin(), edgesList.end(), k)\n                       - edgesList.begin());\n        id_map[i] = pos;\n    }\n\n    // Build active intervals [l, r) for each edge\n    vector<int> last(edgesList.size(), -1);\n    vector<Interval> intervals;\n    intervals.reserve(q);\n\n    for (int i = 0; i < q; i++) {\n        int gid = id_map[i];\n        if (last[gid] == -1) {\n            // start of a new active interval\n            last[gid] = i;\n        } else {\n            // end of the active interval\n            intervals.push_back({ last[gid], i, gid });\n            last[gid] = -1;\n        }\n    }\n    // any still\u2010open intervals run until time = q\n    for (int gid = 0; gid < (int)edgesList.size(); gid++) {\n        if (last[gid] != -1) {\n            intervals.push_back({ last[gid], q, gid });\n            last[gid] = -1;\n        }\n    }\n\n    // Initialize DSUs\n    dsuA.init(n);\n    dsuU.init(n);\n    // Reserve rollback stacks (approx q * log2(q) merges max)\n    int approx = q * 20;\n    dsuA.st.reserve(approx);\n    dsuU.st.reserve(approx);\n\n    ans.assign(q, 0);\n\n    // Recurse over time\n    solve(0, q, intervals);\n\n    // Output answers\n    for (int i = 0; i < q; i++) {\n        cout << ans[i] << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2069e",
      "PROBLEM_ID": "2069E",
      "PROBLEM_STATEMENT": "You are given a string $s$ consisting of characters A and B.\n\nYour task is to split it into blocks of length $1$ and $2$ in such a way that\n\n- there are no more than $a$ strings equal to \"A\";\n- there are no more than $b$ strings equal to \"B\";\n- there are no more than $ab$ strings \"AB\";\n- there are no more than $ba$ strings \"BA\";\n\nStrings \"AA\" and \"BB\" are prohibited. Each character of the initial string $s$ should belong to exactly one block.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. Next, $t$ independent cases follow.\n\nThe first line of each test case contains a single string $s$ ($1 \\le |s| \\le 5 \\cdot 10^5$) consisting only of characters A and/or B.\n\nThe second line of each test case contains four integers $a$, $b$, $ab$, and $ba$ ($0 \\le a, b, ab, ba \\le 5 \\cdot 10^5$)\u00a0\u2014 the maximum allowed number of strings \"A\", \"B\", \"AB\", and \"BA\" correspondingly.\n\nIt's guaranteed that the total length of $s$ doesn't exceed $5 \\cdot 10^5$ over all test cases.\n\n### Output\n\nFor each test case, print YES if it's possible to split string $s$. Otherwise, print NO.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\nA\n\n0 0 10 10\n\nB\n\n0 1 0 0\n\nABA\n\n0 0 1 1\n\nABBABAAB\n\n5 5 0 0\n\nABABBAABBAAB\n\n1 1 2 3\n\nABBBBAB\n\n0 3 2 0\n\nBAABBA\n\n1 3 2 0\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nNO\nYES\nYES\nYES\nNO\n```\n\n### Note\n\nIn the third test case, all possible splits are: A\\|B\\|A, AB\\|A or A\\|BA. All of them have at least one \"A\".\n\nIn the fourth test case, one of the possible splits is the following: A\\|B\\|B\\|A\\|B\\|A\\|A\\|B.\n\nIn the fifth test case, one of the possible splits is the following: A\\|BA\\|B\\|BA\\|AB\\|BA\\|AB.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        string s;\n        cin >> s;\n        int n = s.size();\n        ll a, b, ab_quota, ba_quota;\n        cin >> a >> b >> ab_quota >> ba_quota;\n        // Count total As and Bs\n        ll totA = 0, totB = 0;\n        for (char c : s) {\n            if (c == 'A') totA++;\n            else totB++;\n        }\n        // Compute required number of length-2 blocks to reduce singles\n        ll req = 0;\n        if (totA > a) req = max(req, totA - a);\n        if (totB > b) req = max(req, totB - b);\n        // If no blocks needed, always possible\n        if (req == 0) {\n            cout << \"YES\\n\";\n            continue;\n        }\n        // Decompose s into maximal alternating segments\n        ll k0 = 0; // total favored edge capacity = sum posFav\n        ll AB_FavTotal = 0; // sum posFav for segments starting 'A'\n        ll BA_FavTotal = 0; // sum posFav for segments starting 'B'\n        ll AB_OddTotal = 0; // sum posUnfav for 'B' segments with odd length\n        ll BA_OddTotal = 0; // sum posUnfav for 'A' segments with odd length\n        vector<int> supply1_AB; // capacities posUnfav for BA-even segments (supply AB with penalty)\n        vector<int> supply1_BA; // capacities posUnfav for AB-even segments (supply BA with penalty)\n\n        int i = 0;\n        while (i < n) {\n            int j = i;\n            // extend while alternating\n            while (j + 1 < n && s[j] != s[j + 1]) {\n                j++;\n            }\n            int L = j - i + 1;\n            char sc = s[i];\n            if (L >= 2) {\n                int posFav = L / 2;\n                int posUnfav = (L % 2 == 1 ? posFav : (posFav - 1));\n                k0 += posFav;\n                if (sc == 'A') {\n                    // AB-fav segment\n                    AB_FavTotal += posFav;\n                    if (L % 2 == 1) {\n                        // odd segment can supply BA without penalty\n                        BA_OddTotal += posUnfav;\n                    } else {\n                        // even AB-fav segment: BA supply has penalty\n                        if (posUnfav > 0) supply1_BA.push_back(posUnfav);\n                    }\n                } else {\n                    // BA-fav segment\n                    BA_FavTotal += posFav;\n                    if (L % 2 == 1) {\n                        // odd segment can supply AB without penalty\n                        AB_OddTotal += posUnfav;\n                    } else {\n                        // even BA-fav segment: AB supply has penalty\n                        if (posUnfav > 0) supply1_AB.push_back(posUnfav);\n                    }\n                }\n            }\n            i = j + 1;\n        }\n\n        // If not enough total possible edges, impossible\n        if (k0 < req) {\n            cout << \"NO\\n\";\n            continue;\n        }\n        // Precompute supply0 and supply1 prefix sums\n        ll supply0_AB = AB_FavTotal + AB_OddTotal;\n        ll supply0_BA = BA_FavTotal + BA_OddTotal;\n        // supply1 lists sorted descending\n        sort(supply1_AB.begin(), supply1_AB.end(), greater<int>());\n        sort(supply1_BA.begin(), supply1_BA.end(), greater<int>());\n        int n1_AB = (int)supply1_AB.size();\n        int n1_BA = (int)supply1_BA.size();\n        vector<ll> pref1_AB(n1_AB + 1, 0), pref1_BA(n1_BA + 1, 0);\n        for (int j = 0; j < n1_AB; j++) {\n            pref1_AB[j + 1] = pref1_AB[j] + supply1_AB[j];\n        }\n        for (int j = 0; j < n1_BA; j++) {\n            pref1_BA[j + 1] = pref1_BA[j] + supply1_BA[j];\n        }\n        // Total supply capacity per type\n        ll AB_totalcap = supply0_AB + pref1_AB[n1_AB];\n        ll BA_totalcap = supply0_BA + pref1_BA[n1_BA];\n        // Quick check: if even quotas-supply can't reach req, impossible\n        ll maxAB = min(ab_quota, AB_totalcap);\n        ll maxBA = min(ba_quota, BA_totalcap);\n        if (maxAB + maxBA < req) {\n            cout << \"NO\\n\";\n            continue;\n        }\n        // dropBudget: how many initial posFav picks we can drop (= k0 - req)\n        ll dropBudget = k0 - req;\n        bool ok = false;\n        // M_AB in [0..min(dropBudget, n1_AB)] is number of BA-even segments used for AB supply\n        int max_mAB = (int)min<ll>(dropBudget, n1_AB);\n        for (int mAB = 0; mAB <= max_mAB; mAB++) {\n            // supply AB picks using mAB penalized segments\n            ll f_sup = supply0_AB + pref1_AB[mAB];\n            // But AB picks <= ab_quota\n            ll f_alloc = f_sup;\n            if (f_alloc > ab_quota) f_alloc = ab_quota;\n            // Now compute needed BA picks\n            ll u_need = req - f_alloc;\n            if (u_need <= 0) {\n                // no BA needed, done\n                ok = true;\n                break;\n            }\n            if (u_need > ba_quota) {\n                // exceeds BA quota\n                continue;\n            }\n            // supply BA picks from cost-free supply0_BA, rest from supply1_BA with penalty\n            ll u_bad = u_need - supply0_BA;\n            if (u_bad <= 0) {\n                // all BA supply free\n                ok = true;\n                break;\n            }\n            // need some penalized BA supply\n            if (u_bad > pref1_BA[n1_BA]) {\n                // not enough BA-even capacity\n                continue;\n            }\n            // find minimal mBA such that pref1_BA[mBA] >= u_bad\n            int mBA = int(lower_bound(pref1_BA.begin(), pref1_BA.end(), u_bad) - pref1_BA.begin());\n            // Check total penalty\n            if ((ll)mAB + (ll)mBA <= dropBudget) {\n                ok = true;\n                break;\n            }\n        }\n        cout << (ok ? \"YES\\n\" : \"NO\\n\");\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2069d",
      "PROBLEM_ID": "2069D",
      "PROBLEM_STATEMENT": "You are given a string $s$ consisting of lowercase Latin letters.\n\nYou can perform the following operation with the string $s$: choose a contiguous substring (possibly empty) of $s$ and shuffle it (reorder the characters in the substring as you wish).\n\nRecall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\n\nYour task is to determine the minimum possible length of the substring on which the aforementioned operation must be performed in order to convert the given string $s$ into a palindrome.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains a string $s$ ($2 \\le |s| \\le 2 \\cdot 10^5$), consisting of lowercase Latin letters.\n\nAdditional constraints on the input:\n\n- the string $s$ has an even length;\n- the string $s$ can always be converted to a palindrome;\n- the sum of lengths of $s$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the minimum possible length of the substring on which the aforementioned operation must be performed in order to convert the given string $s$ into a palindrome.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\nbaba\n\ncc\n\nddaa\n\nacbacddacbca\n\n```\n\n#### Output #1\n\n```\n2\n0\n3\n2\n```\n\n### Note\n\nIn the first example, you can perform the operation as follows: baba $\\rightarrow$ baab.\n\nIn the second example, the string is already a palindrome, so we can shuffle an empty substring.\n\nIn the third example, you can perform the operation as follows: ddaa $\\rightarrow$ adda.\n\nIn the fourth example, you can perform the operation as follows: acbacddacbca $\\rightarrow$ acbcaddacbca.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n// Calculates the length of the minimal contiguous substring covering all mismatches.\nint calculate_mismatch_range(const string& s, int start, int end, const vector<char>& h_p) {\n    int len = end - start + 1;\n    if (len == 0) return 0;\n    \n    int first_mismatch = -1, last_mismatch = -1;\n    for (int i = 0; i < len; ++i) {\n        char p_char = (i < len / 2) ? h_p[i] : h_p[len - 1 - i];\n        if (s[start + i] != p_char) {\n            if (first_mismatch == -1) {\n                first_mismatch = i;\n            }\n            last_mismatch = i;\n        }\n    }\n    \n    if (first_mismatch == -1) {\n        return 0;\n    }\n    return last_mismatch - first_mismatch + 1;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int n = s.length();\n\n    int l = 0, r = n - 1;\n    while (l < r && s[l] == s[r]) {\n        l++;\n        r--;\n    }\n\n    if (l >= r) {\n        cout << 0 << \"\\n\";\n        return;\n    }\n    \n    int core_len = r - l + 1;\n    map<char, int> core_counts;\n    for (int i = l; i <= r; ++i) {\n        core_counts[s[i]]++;\n    }\n\n    map<char, int> half_counts;\n    for (auto const& [key, val] : core_counts) {\n        half_counts[key] = val / 2;\n    }\n\n    // Case 1: Maximize match with the prefix of the core string\n    int k1 = 0;\n    map<char, int> current_half_counts1;\n    for (int i = 0; i < core_len / 2; ++i) {\n        char c = s[l + i];\n        current_half_counts1[c]++;\n        if (current_half_counts1[c] > half_counts[c]) {\n            break;\n        }\n        k1++;\n    }\n\n    vector<char> h_p1(core_len / 2);\n    map<char, int> needed1 = half_counts;\n    for (int i = 0; i < k1; ++i) {\n        char c = s[l + i];\n        h_p1[i] = c;\n        needed1[c]--;\n    }\n    int fill_idx1 = k1;\n    for (auto const& [key, val] : needed1) {\n        for (int i = 0; i < val; ++i) {\n            h_p1[fill_idx1++] = key;\n        }\n    }\n    int ans1 = calculate_mismatch_range(s, l, r, h_p1);\n\n    // Case 2: Maximize match with the suffix of the core string\n    int k2 = 0;\n    map<char, int> current_half_counts2;\n    for (int i = 0; i < core_len / 2; ++i) {\n        char c = s[r - i];\n        current_half_counts2[c]++;\n        if (current_half_counts2[c] > half_counts[c]) {\n            break;\n        }\n        k2++;\n    }\n    \n    vector<char> h_p2(core_len / 2);\n    map<char, int> needed2 = half_counts;\n    for (int i = 0; i < k2; ++i) {\n        char c = s[r - i];\n        h_p2[i] = c;\n        needed2[c]--;\n    }\n    int fill_idx2 = k2;\n    for (auto const& [key, val] : needed2) {\n        for (int i = 0; i < val; ++i) {\n            h_p2[fill_idx2++] = key;\n        }\n    }\n    int ans2 = calculate_mismatch_range(s, l, r, h_p2);\n\n    cout << min(ans1, ans2) << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2069c",
      "PROBLEM_ID": "2069C",
      "PROBLEM_STATEMENT": "Let's call an integer sequence beautiful if the following conditions hold:\n\n- its length is at least $3$;\n- for every element except the first one, there is an element to the left less than it;\n- for every element except the last one, there is an element to the right larger than it;\n\nFor example, $[1, 4, 2, 4, 7]$ and $[1, 2, 4, 8]$ are beautiful, but $[1, 2]$, $[2, 2, 4]$, and $[1, 3, 5, 3]$ are not.\n\nRecall that a subsequence is a sequence that can be obtained from another sequence by removing some elements without changing the order of the remaining elements.\n\nYou are given an integer array $a$ of size $n$, where every element is from $1$ to $3$. Your task is to calculate the number of beautiful subsequences of the array $a$. Since the answer might be large, print it modulo $998244353$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 3$).\n\nAdditional constraint on the input: the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the number of beautiful subsequences of the array $a$, taken modulo $998244353$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n7\n\n3 2 1 2 2 1 3\n\n4\n\n3 1 2 2\n\n3\n\n1 2 3\n\n9\n\n1 2 3 2 1 3 2 2 3\n\n```\n\n#### Output #1\n\n```\n3\n0\n1\n22\n```\n\n### Note\n\nIn the first test case of the example, the following subsequences are beautiful:\n\n- $[a_3, a_4, a_7]$;\n- $[a_3, a_5, a_7]$;\n- $[a_3, a_4, a_5, a_7]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\n// Main function containing the solution logic\nint main() {\n    // Use faster I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Variable to store the number of test cases\n    cin >> t; // Read the number of test cases\n\n    while (t--) { // Loop over each test case\n        int n; // Variable to store the size of the array\n        cin >> n; // Read the size of the array\n        \n        vector<int> a(n); // Declare a vector to store the array elements\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i]; // Read the array elements\n        }\n\n        // Initialize DP states. Use 'long long' to prevent potential overflow issues, \n        // especially during intermediate calculations before applying the modulo.\n        \n        // dp0 represents the count of empty subsequences. It's always 1 and serves as a base case\n        // for constructing subsequences starting with [1]. While conceptually useful, it's constant 1.\n        long long dp0 = 1; \n        \n        // dp1 stores the count of subsequences of the form [1].\n        long long dp1 = 0; \n        \n        // dp2 stores the count of subsequences of the form [1, 2, ..., 2], where there is at least one 2.\n        long long dp2 = 0; \n        \n        // dp3 stores the count of subsequences of the form [1, 2, ..., 2, 3], where there is at least one 2.\n        // This matches the structure derived for beautiful subsequences. This is our final answer state.\n        long long dp3 = 0; \n        \n        // Define the modulo value as specified in the problem statement.\n        long long mod = 998244353; \n\n        // Iterate through the array elements one by one\n        for (int i = 0; i < n; ++i) {\n            int x = a[i]; // Get the current element\n            \n            if (x == 1) {\n                // If the current element is 1:\n                // A new subsequence [1] can be formed by just taking this element.\n                // This corresponds to extending the empty subsequence (which has count dp0=1).\n                // We add dp0 (which is 1) to the current count of subsequences of type [1].\n                dp1 = (dp1 + dp0) % mod; \n            } else if (x == 2) {\n                // If the current element is 2:\n                // We can potentially extend subsequences that ended previously with 1 or 2.\n                // Case 1: Append '2' to any subsequence of type [1] (total count dp1). This forms [1, 2], which matches the pattern for dp2 state.\n                // Case 2: Append '2' to any subsequence of type [1, 2, ..., 2] (total count dp2). This forms [1, 2, ..., 2, 2], which also matches the pattern for dp2 state.\n                // The number of new sequences ending with this '2' that match the dp2 pattern is (dp1 + dp2), where dp1 and dp2 are counts *before* this update.\n                // The total count for dp2 state updates by adding these new sequences.\n                // Thus, the new count dp2 becomes (current dp2 + new sequences) = dp2 + (dp1 + dp2) = 2 * dp2 + dp1.\n                // Use 2LL to ensure the multiplication is done using long long type.\n                dp2 = (dp2 * 2LL + dp1) % mod; \n            } else if (x == 3) {\n                // If the current element is 3:\n                // We can potentially extend subsequences ending in 2 to form a beautiful subsequence.\n                // Case 1: Append '3' to any subsequence of type [1, 2, ..., 2] (total count dp2). This forms [1, 2, ..., 2, 3], which is a beautiful subsequence. These contribute to dp3 state.\n                // Case 2: Append '3' to any subsequence of type [1, 2, ..., 2, 3] (total count dp3). The resulting subsequence [1, 2, ..., 2, 3, 3] is NOT beautiful because the second to last element '3' violates Condition 3 (no element to its right is larger).\n                // Therefore, we only form new beautiful subsequences by extending sequences counted by dp2.\n                // The number of new beautiful subsequences ending with this '3' is equal to dp2 (the count before this update).\n                // Update dp3 by adding these newly formed beautiful subsequences.\n                 dp3 = (dp3 + dp2) % mod;\n            }\n            // Note: dp0 remains conceptually 1 throughout the process. It represents the single empty subsequence.\n        }\n\n        // After iterating through all elements, dp3 holds the total count of beautiful subsequences found.\n        cout << dp3 << \"\\n\"; // Print the result for the current test case.\n    }\n    return 0; // Indicate successful execution of the program.\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2069a",
      "PROBLEM_ID": "2069A",
      "PROBLEM_STATEMENT": "For an array of integers $a_1, a_2, \\dots, a_n$, we define its equality characteristic as the array $b_2, b_3, \\dots, b_{n-1}$, where $b_i = 1$ if the $i$-th element of the array $a$ is equal to both of its neighbors, and $b_i = 0$ if the $i$-th element of the array $a$ is not equal to at least one of its neighbors.\n\nFor example, for the array $[1, 2, 2, 2, 3, 3, 4, 4, 4, 4]$, the equality characteristic will be $[0, 1, 0, 0, 0, 0, 1, 1]$.\n\nYou are given the array $b_2, b_3, \\dots, b_{n-1}$. Your task is to determine whether there exists such an array $a$ for which the given array is the equality characteristic.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n- the first line contains one integer $n$ ($3 \\le n \\le 100$);\n- the second line contains $n-2$ integers $b_2, b_3, \\dots, b_{n-1}$ ($0 \\le b_i \\le 1$).\n\n### Output\n\nFor each test case, output YES if the array $a$ exists, or NO if such an array does not exist. Each letter can be printed in any case.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n10\n\n0 1 0 0 0 0 1 1\n\n3\n\n1\n\n10\n\n0 1 0 1 1 0 0 1\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\n```\n\n### Note\n\nIn the first example, the array $a = [1, 2, 2, 2, 3, 3, 4, 4, 4, 4]$ is suitable.\n\nIn the second example, the array $a = [7, 7, 7]$ is suitable.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (n < 3) {\n        return true;\n    }\n    vector<int> b(n - 2);\n    for (int i = 0; i < n - 2; ++i) {\n        cin >> b[i];\n    }\n    if (n < 5) {\n        return true;\n    }\n    for (int i = 3; i <= n - 2; ++i) {\n        if (b[i - 2 - 1] == 1 && b[i - 2 + 1] == 1) {\n            if (b[i - 2] == 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        if (solve()) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2067b",
      "PROBLEM_ID": "2067B",
      "PROBLEM_STATEMENT": "You have two large bags of numbers. Initially, the first bag contains $n$ numbers: $a_1, a_2, \\ldots, a_n$, while the second bag is empty. You are allowed to perform the following operations:\n\n- Choose any number from the first bag and move it to the second bag.\n- Choose a number from the first bag that is also present in the second bag and increase it by one.\n\nYou can perform an unlimited number of operations of both types, in any order. Is it possible to make the contents of the first and second bags identical?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($2 \\le n \\le 1000$)\u00a0\u2014 the length of the array $a$. It is guaranteed that $n$ is an even number.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$).\n\nIt is guaranteed that the sum of $n^2$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, print \"YES\" if it is possible to equalize the contents of the bags. Otherwise, output \"NO\".\n\nYou can output each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\", \"yEs\" will be recognized as a positive answer).\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n2\n\n1 1\n\n2\n\n2 1\n\n4\n\n1 1 4 4\n\n4\n\n3 4 3 3\n\n4\n\n2 3 4 4\n\n6\n\n3 3 4 5 3 3\n\n6\n\n2 2 2 4 4 4\n\n8\n\n1 1 1 1 1 1 1 4\n\n10\n\n9 9 9 10 10 10 10 10 10 10\n\n```\n\n#### Output #1\n\n```\nYes\nNo\nYes\nYes\nNo\nYes\nNo\nYes\nYes\n```\n\n### Note\n\nLet's analyze the sixth test case: we will show the sequence of operations that leads to the equality of the bags. Initially, the first bag consists of the numbers $(3, 3, 4, 5, 3, 3)$, and the second bag is empty.\n\n1. In the first operation, move the number $3$ from the first bag to the second. State: $(3, 4, 5, 3, 3)$ and $(3)$.\n2. In the second operation, increase the number $3$ from the first bag by one. This operation is possible because the second bag contains the number $3$. State: $(4, 4, 5, 3, 3)$ and $(3)$.\n3. In the third operation, move the number $4$ from the first bag to the second. State: $(4, 5, 3, 3)$ and $(3, 4)$.\n4. In the fourth operation, increase the number $4$ from the first bag by one. State: $(5, 5, 3, 3)$ and $(3, 4)$.\n5. In the fifth operation, move the number $5$ from the first bag to the second. State: $(5, 3, 3)$ and $(3, 4, 5)$.\n6. In the sixth operation, increase the number $3$ from the first bag by one. State: $(5, 3, 4)$ and $(3, 4, 5)$.\n\nAs we can see, as a result of these operations, it is possible to make the contents of the bags equal, so the answer exists.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <map>\n#include <algorithm> // For std::max\n\nint main() {\n    // Use fast IO operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Number of elements in the initial array\n        std::cin >> n;\n        \n        // Use a map to store the counts of each number in the initial array `a`.\n        // This handles potentially sparse numbers efficiently.\n        std::map<int, int> counts;\n        int max_a = 0; // Track the maximum value in the initial array\n        for (int i = 0; i < n; ++i) {\n            int a;\n            std::cin >> a;\n            counts[a]++;\n            // Update the maximum value seen so far\n            if (a > max_a) {\n                max_a = a;\n            }\n        }\n\n        // Determine the maximum possible index `k` we might need to consider for counts C_0(k) or increases I_k.\n        // The initial maximum value is `max_a`. Values can increase due to operations.\n        // A value `k` can be increased to `k+1`. The largest value `k` for which we might need to perform an increase\n        // `k -> k+1` seems to be `max_a`. If $I_k > 0$, the value $k+1$ can be generated.\n        // We use `M = max_a + 2` as a safe upper bound for indices `k` we need to consider in our vectors.\n        // This covers indices up to `max_a + 1`, plus some buffer.\n        int M = max_a + 2; \n        \n        // `I[k]` will store the total number of times value `k` is increased to `k+1`. Use long long for potentially large counts.\n        std::vector<long long> I(M + 1, 0); \n        // `p[k]` stores the required parity of `I_k`. It's based on the prefix sum of parities of initial counts.\n        // Specifically, p[k] = (sum_{j=1..k} (C_0(j) mod 2)) mod 2.\n        std::vector<int> p(M + 1, 0); \n\n        // Calculate initial parities `p[k]` and set the minimal required `I[k]` values (0 or 1).\n        int current_parity_sum = 0;\n        for (int k = 1; k <= M; ++k) {\n            int count_k = 0;\n            // Safely get the count of `k` from the initial `counts` map.\n            auto it = counts.find(k);\n            if (it != counts.end()) {\n                count_k = it->second;\n            }\n            // Update the running sum of parities\n            current_parity_sum = (current_parity_sum + (count_k % 2)) % 2;\n            p[k] = current_parity_sum;\n            // The minimal non-negative `I[k]` satisfying the parity requirement `I[k] % 2 == p[k]` is simply `p[k]` itself (since p[k] is 0 or 1).\n            I[k] = p[k]; \n        }\n\n        bool possible = true; // Flag to track if a valid sequence of operations exists\n        \n        // Perform a backward pass from `k = M` down to `1`.\n        // This pass adjusts the `I[k]` values to satisfy the necessary condition derived from the operation rules.\n        // The condition is: If `I[k] > 0`, then `N_k >= I[k] + 1`, where `N_k = C_0(k) + I_{k-1}` is the total number of items with value `k` available.\n        for (int k = M; k >= 1; --k) {\n            // Retrieve C_0(k), the initial count of k, safely from the map.\n            long long current_count_k = 0;\n            auto it = counts.find(k);\n             if (it != counts.end()) {\n                current_count_k = it->second;\n            }\n            \n            // Calculate N_k = C_0(k) + I_{k-1}. This represents the total number of items of value `k`\n            // that are either initially present or generated by increases from `k-1`.\n            // Need safe access to I[k-1]. I[0] represents increases for value 0, which is impossible/not needed, so it's 0.\n            long long I_k_minus_1 = (k > 1) ? I[k-1] : 0;\n            long long Nk = current_count_k + I_k_minus_1; \n\n            // Check the condition: If we need to perform `I[k] > 0` increases `k -> k+1`, \n            // we must have enough items `k`. Specifically, `N_k` items must be sufficient to provide:\n            // - `I[k]` items to be increased (these must be in bag A).\n            // - At least 1 item to be moved to bag B to enable the increases.\n            // Total required items = `I[k] + 1`.\n            if (I[k] > 0) {\n                if (Nk < I[k] + 1) {\n                    // Condition failed: Not enough items of value `k`. We need `N_k` to be larger.\n                    // To increase `N_k`, we must increase `I_{k-1}` (number of increases `k-1 -> k`).\n                    long long deficit = (I[k] + 1) - Nk; // How many more items `k` are needed?\n                    \n                    // If k=1, we need to increase I_0. Increases $0 \\to 1$ are not possible starting with positive integers.\n                    // Thus, if the condition fails for k=1, it's impossible.\n                    if (k == 1) { \n                        possible = false;\n                        break; // Exit the loop, as we've found an impossible situation.\n                    }\n\n                    // Calculate the minimal *even* non-negative integer `increase_by` such that `Nk + increase_by >= I[k] + 1`.\n                    // This increase must be added to `I_{k-1}`. Since `I_{k-1}` must maintain its parity,\n                    // any change must be an even number. The minimal required even increase is `2 * ceil(deficit / 2.0)`.\n                    // The formula `2 * ((deficit + 1) / 2)` computes this using integer division for `deficit > 0`.\n                    long long increase_by = 2 * ((deficit + 1) / 2); \n\n                    // Apply the calculated increase to `I[k-1]`.\n                    I[k-1] += increase_by;\n                    \n                    // The updated value of `I[k-1]` will be considered when the loop processes `k-1`.\n                }\n            }\n        }\n        \n        // After the backward pass, if `possible` is still true, it means we found a consistent set of `I[k]` values.\n        // There's a small edge case where `I[0]` might become non-zero hypothetically, although the `k=1` check should prevent this.\n        // An explicit check for `I[0]` could be added for robustness, but is likely redundant.\n        // if (possible && I[0] != 0) { possible = false; } \n\n        // Output the result based on the final value of the `possible` flag.\n        if (possible) {\n            std::cout << \"Yes\\n\";\n        } else {\n            std::cout << \"No\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2067a",
      "PROBLEM_ID": "2067A",
      "PROBLEM_STATEMENT": "You are given two numbers $x, y$. You need to determine if there exists an integer $n$ such that $S(n) = x$, $S(n + 1) = y$.\n\nHere, $S(a)$ denotes the sum of the digits of the number $a$ in the decimal numeral system.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $x, y$ ($1 \\le x \\le 1000, 1 \\le y \\le 1000$).\n\n### Output\n\nFor each test case, print \"NO\" if a suitable $n$ does not exist. Otherwise, output \"YES\".\n\nYou can output each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\", \"yEs\" will be recognized as a positive answer).\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n1 2\n\n77 77\n\n997 999\n\n999 1\n\n1000 1\n\n1 11\n\n18 1\n\n```\n\n#### Output #1\n\n```\nYes\nNo\nNo\nYes\nNo\nNo\nYes\n```\n\n### Note\n\nIn the first test case, for example, $n = 100$ works. $S(100) = 1$, $S(101) = 2$.\n\nIn the second test case, it can be shown that $S(n) \\neq S(n+1)$ for all $n$; therefore, the answer is No.\n\nIn the fourth test case, $n = 10^{111}-1$ works, which is a number consisting of $111$ digits of $9$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int x, y;\n        cin >> x >> y;\n        int delta = x - y + 1;\n        if (delta >= 0 && delta % 9 == 0) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2066f",
      "PROBLEM_ID": "2066F",
      "PROBLEM_STATEMENT": "You are given two arrays of integers: $a_1, a_2, \\ldots, a_n$ and $b_1, b_2, \\ldots, b_m$.\n\nYou need to determine if it is possible to transform array $a$ into array $b$ using the following operation several (possibly, zero) times.\n\n- Among all non-empty subarrays$^{\\text{\u2217}}$ of $a$, choose any with the maximum sum, and replace this subarray with an arbitrary non-empty integer array.\n\nIf it is possible, you need to construct any possible sequence of operations. Constraint: in your answer, the sum of the lengths of the arrays used as replacements must not exceed $n + m$ across all operations. The numbers must not exceed $10^9$ in absolute value.\n\n$^{\\text{\u2217}}$An array $a$ is a subarray of an array $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 200$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n, m$ ($1 \\le n, m \\le 500$)\u00a0\u2014 the lengths of arrays $a$ and $b$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-10^6 \\le a_i \\le 10^6$)\u00a0\u2014 the elements of array $a$.\n\nThe third line of each test case contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($-10^6 \\le b_i \\le 10^6$)\u00a0\u2014 the elements of array $b$.\n\nIt is guaranteed that the sum of the values of $n$ across all test cases does not exceed $500$.\n\nIt is guaranteed that the sum of the values of $m$ across all test cases does not exceed $500$.\n\n### Output\n\nFor each test case, output $-1$ if it is impossible to transform array $a$ into array $b$.\n\nOtherwise, in the first line, output the number of operations $0 \\leq q \\leq n + m$. Then output the operations in the following format in the order they are performed.\n\nIn the first line of each operation, print three numbers $l, r, k$ ($1 \\leq l \\leq r \\leq |a|$). In the second line, print $k$ integers $c_1 \\ldots c_k$, which means replacing the segment $a_l, \\ldots, a_r$ with the array $c_1, \\ldots, c_k$.\n\nThe sum of $k$ across all $q$ operations must not exceed $n + m$. Additionally, it must hold that $-10^9 \\leq c_i \\leq 10^9$.\n\nYou do not need to minimize the number of operations.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4 3\n\n2 -3 2 0\n\n-3 -7 0\n\n2 1\n\n-2 -2\n\n2\n\n5 4\n\n-5 9 -3 5 -9\n\n-6 6 -1 -9\n\n```\n\n#### Output #1\n\n```\n4\n3 4 1\n-3\n\n1 1 1\n-3\n\n2 2 1\n-7\n\n3 3 1\n0\n\n-1\n\n3\n2 4 1\n-5\n\n1 1 1\n-6\n\n2 2 2\n6 -1\n```\n\n### Note\n\nIn the first test, the initial array is modified as follows:\n\n\n\n$$ [2, -3, 2, 0] \\to [2, -3, -3] \\to [-3, -3, -3] \\to [-3, -7, -3] \\to [-3, -7, 0] $$\n\nYou may choose to output empty lines or not. Empty lines in the example are added for convenience.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// #define int long long\ntypedef long long ll;\ntypedef long double ld;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define sum(x) accumulate(all(x), 0)\nconst int INF = 2'000'000'000;\nconst int PLACEHOLDER = INF;\n\nvector<vector<int>> cool_split(vector<int> a) {\n    if (a.empty())return {};\n    int n = (int) a.size();\n    array<int, 4> mxi = {-INF, 0, 0, 0};\n    int sumi = 0;\n    int smallest_pref = 0, prefi = 0;\n    for (int i = 0; i < n; i++) {\n        sumi += a[i];\n        mxi = max(mxi, {sumi - smallest_pref, i - prefi, prefi, i});\n        if (smallest_pref > sumi) {\n            smallest_pref = sumi;\n            prefi = i + 1;\n        }\n    }\n    auto [_, __, l, r] = mxi;\n    vector<int> al, amid, ar;\n    for (int i = 0; i < n; i++) {\n        if (i < l) {\n            al.push_back(a[i]);\n        } else if (i <= r) {\n            amid.push_back(a[i]);\n        } else {\n            ar.push_back(a[i]);\n        }\n    }\n    vector<vector<int>> X = cool_split(al), Y = cool_split(ar);\n    X.push_back(amid);\n    for (auto el: Y)X.push_back(el);\n    return X;\n}\n\nconst int N = 503;\nbool dp[N][N][2];\narray<int, 2> go[N][N][2];\nint maxsubsum[N][N];\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    vector<int> b(m), prefb(m);\n    for (int i = 0; i < m; i++) {\n        cin >> b[i];\n    }\n    prefb[0] = b[0];\n    for (int i = 1; i < m; i++) {\n        prefb[i] = b[i] + prefb[i - 1];\n    }\n\n    auto get_sum = [&](int l, int r) {\n        if (l == 0) return prefb[r];\n        return prefb[r] - prefb[l - 1];\n    };\n\n    for (int i = 0; i < m; i++) {\n        maxsubsum[i][i] = b[i];\n    }\n    for (int l = 1; l < m; l++) {\n        for (int i = 0; i + l < m; i++) {\n            int j = i + l;\n            maxsubsum[i][j] = max({maxsubsum[i + 1][j], maxsubsum[i][j - 1], get_sum(i, j)});\n        }\n    }\n\n    vector<vector<int>> spa = cool_split(a);\n    vector<array<int, 2>> order;\n    for (int i = 0; i < spa.size(); i++) {\n        order.push_back({sum(spa[i]), i});\n    }\n    sort(rall(order));\n    vector<tuple<int, int, vector<int>>> ops;\n\n    auto check = [&](int u) -> bool {\n        for (int i = 0; i <= spa.size(); i++) {\n            for (int j = 0; j <= m; j++) {\n                dp[i][j][0] = dp[i][j][1] = false;\n            }\n        }\n        dp[0][0][0] = true;\n        for (int i = 0; i < spa.size(); i++) {\n            if (spa[i] != (vector<int>) {PLACEHOLDER}) {\n                for (int j = 0; j + spa[i].size() <= m; j++) {\n                    bool ok = true;\n                    for (int k = 0; k < spa[i].size(); k++) {\n                        if (spa[i][k] != b[j + k]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if (!ok)continue;\n                    for (auto flag: {0, 1}) {\n                        if (dp[i][j][flag]) {\n                            dp[i + 1][j + spa[i].size()][flag] = true;\n                            go[i + 1][j + spa[i].size()][flag] = {j, flag};\n                        }\n                    }\n                }\n                continue;\n            }\n            int jr = 0;\n            bool brandnew = true;\n            int lastgood0 = 0, lastgood1 = 0;\n            for (int j = 0; j < m; j++) {\n                while (jr < m && (jr < j || maxsubsum[j][jr] <= u))jr++;\n                if (dp[i][j][0]) {\n                    for (int jk = max(lastgood0, j); jk < jr; jk++) {\n                        dp[i + 1][jk + 1][0] = true;\n                        go[i + 1][jk + 1][0] = {j, 0};\n                    }\n                    lastgood0 = jr;\n                    if (brandnew) {\n                        brandnew = false;\n                        for (int jk = jr; jk < m; jk++) {\n                            dp[i + 1][jk + 1][1] = true;\n                            go[i + 1][jk + 1][1] = {j, 0};\n                        }\n                    }\n                }\n                if (dp[i][j][1]) {\n                    for (int jk = max(lastgood1, j); jk < jr; jk++) {\n                        dp[i + 1][jk + 1][1] = true;\n                        go[i + 1][jk + 1][1] = {j, 1};\n                    }\n                    lastgood1 = jr;\n                }\n            }\n        }\n        for (auto flag: {0, 1}) {\n            if (dp[spa.size()][m][flag]) {\n                int i = (int) spa.size(), j = m;\n                int idx = 0;\n                for (auto ar: spa)idx += (int) ar.size();\n                pair<int, vector<int>> last_op = {-1, {}};\n                while (i > 0) {\n                    idx -= (int) spa[i - 1].size();\n                    int j2 = go[i][j][flag][0];\n                    int flag2 = go[i][j][flag][1];\n                    if (spa[i - 1] == (vector<int>) {PLACEHOLDER}) {\n                        vector<int> xar;\n                        for (int jk = j2; jk < j; jk++) {\n                            xar.push_back(b[jk]);\n                        }\n                        if (flag == 1 && flag2 == 0) {\n                            last_op = {i - 1, xar};\n                        } else {\n                            ops.push_back({idx + 1, idx + (int) spa[i - 1].size(), xar});\n                            spa[i - 1] = xar;\n                        }\n                    }\n                    i--;\n                    j = j2;\n                    flag = flag2;\n                }\n                if (last_op.first != -1) {\n                    idx = 0;\n                    int ri = last_op.first;\n                    auto xar = last_op.second;\n                    for (int jk = 0; jk < ri; jk++)idx += (int) spa[jk].size();\n                    ops.push_back({idx + 1, idx + (int) spa[ri].size(), xar});\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n\n    for (int j = 0; j < order.size(); j++) {\n        auto [u, i] = order[j];\n        int idx = 0;\n        for (int k = 0; k < i; k++) {\n            idx += (int) spa[k].size();\n        }\n        ops.push_back({idx + 1, idx + (int) spa[i].size(), {PLACEHOLDER}});\n        spa[i] = {PLACEHOLDER};\n        if (j + 1 < order.size() && order[j][0] == order[j + 1][0]) continue;\n        if (check(u)) {\n            cout << ops.size() << '\\n';\n            for (auto [l, r, xar]: ops) {\n                cout << l << ' ' << r << ' ' << xar.size() << '\\n';\n                for (auto el: xar) {\n                    if (el == PLACEHOLDER) el = u;\n                    cout << el << ' ';\n                }\n                cout << '\\n';\n            }\n            return;\n        }\n    }\n    cout << \"-1\\n\";\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2066e",
      "PROBLEM_ID": "2066E",
      "PROBLEM_STATEMENT": "You have $n$ barrels of infinite capacity. The $i$-th barrel initially contains $a_i$ kilograms of water. In this problem, we assume that all barrels weigh the same.\n\nYou know that exactly one of the barrels has a small amount of tropical poison distributed on its surface, with a total weight of $0.179$ kilograms. However, you do not know which barrel contains the poison. Your task is to identify this poisonous barrel.\n\nAll the barrels are on scales. Unfortunately, the scales do not show the exact weight of each barrel. Instead, for each pair of barrels, they show the result of a comparison between the weights of those barrels. Thus, for any two barrels, you can determine whether their weights are equal, and if not, which barrel is heavier. The poison and water are included in the weight of the barrel.\n\nThe scales are always turned on, and the information from them can be used an unlimited number of times.\n\nYou also have the ability to pour water. You can pour water from any barrel into any other barrel in any amounts.\n\nHowever, to pour water, you must physically handle the barrel from which you are pouring, so if that happens to be the poisonous barrel, you will die. This outcome must be avoided.\n\nHowever, you can pour water into the poisonous barrel without touching it.\n\nIn other words, you can choose the numbers $i, j, x$ ($i \\neq j, 1 \\leq i, j \\leq n, 0 < x \\leq a_i$, the barrel numbered $i$ is not poisonous) and execute $a_i := a_i - x$, $a_j := a_j + x$. Where $x$ is not necessarily an integer.\n\nIs it possible to guarantee the identification of which barrel contains the poison and remain alive using pouring and the information from the scales? You know that the poison is located on exactly one of the barrels.\n\nAdditionally, we ask you to process $q$ queries. In each query, either one of the existing barrels is removed, or an additional barrel with a certain amount of water is added. After each query, you need to answer whether it is possible to guarantee the identification of the poisonous barrel, given that there is exactly one.\n\n### Input\n\nThe first line contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^6$) \u2014 the volumes of water in the existing barrels.\n\nThe next $q$ lines contain queries, one per line. Each query is either of the form \\+ x or \\- x, which means, respectively, adding and removing a barrel with $x$ kilograms of water. It is guaranteed that when the query \\- x is made, one of the existing barrels has a volume of $x$, and that there is always at least one barrel remaining throughout the queries. In all queries, $1 \\leq x \\leq 10^6$.\n\n### Output\n\nOutput $q+1$ lines, the answer to the problem before all queries, and after each query. If it is possible to identify the poisonous barrel, output \"Yes\"; otherwise, output \"No\". You can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Examples\n\n#### Input #1\n\n```\n\n4 7\n\n2 2 4 11\n\n\\- 2\n\n\\+ 4\n\n\\+ 30\n\n\\+ 40\n\n\\- 4\n\n\\+ 2\n\n\\+ 2\n\n```\n\n#### Output #1\n\n```\nYes\nNo\nYes\nNo\nYes\nNo\nNo\nYes\n```\n\n#### Input #2\n\n```\n\n6 7\n\n5000 1000 400 400 100 99\n\n\\+ 1\n\n\\- 5000\n\n\\- 1\n\n\\- 400\n\n\\- 400\n\n\\- 100\n\n\\- 99\n\n```\n\n#### Output #2\n\n```\nNo\nYes\nYes\nYes\nNo\nNo\nNo\nYes\n```\n\n### Note\n\nIn the first test, before any queries, the weights of the barrels are $[2, 2, 4, 11]$. You can compare the values of the first and second barrels. If the result is not equal, you can definitively conclude that the barrel with the greater weight is poisonous. If the result is equal, both barrels are non-poisonous. Then you can pour all the contents of the first barrel into the second. After that, both the second and third barrels will contain $4$ kilograms of water. Now let's compare the values of the second and third barrels. If the result is not equal, the barrel with the greater weight is poisonous. Otherwise, both barrels are non-poisonous. The only barrel that could be poisonous is barrel 4. Thus, with this strategy, we can safely determine the poisonous barrel.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define ar(x) array<int, x>\nconst int MAXA = 1'000'009;\nconst int INF = (int) 1e18;\n\nstruct SegTreeMIN {\n    int n = 1;\n    vector<int> tree;\n\n    SegTreeMIN(int n_) {\n        while (n <= n_) n *= 2;\n        tree.assign(4 * n + 7, INF);\n    }\n\n    void upd(int v, int l, int r, int i, int x) {\n        if (l + 1 == r) {\n            tree[v] = x;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (i < mid) {\n            upd(2 * v + 1, l, mid, i, x);\n        } else {\n            upd(2 * v + 2, mid, r, i, x);\n        }\n        tree[v] = min(tree[2 * v + 1], tree[2 * v + 2]);\n    }\n\n    int get(int v, int l, int r, int lq, int rq) {\n        if (l >= rq || lq >= r) return INF;\n        if (lq <= l && r <= rq) return tree[v];\n        int mid = (l + r) / 2;\n        return min(get(2 * v + 1, l, mid, lq, rq), get(2 * v + 2, mid, r, lq, rq));\n    }\n\n    void upd(int i, int x) {\n        upd(0, 0, n, i, x);\n    }\n\n    int get(int lq, int rq) {\n        return get(0, 0, n, lq, rq);\n    }\n\n};\n\nstruct SegTreeSUM {\n    int n = 1;\n    vector<int> tree;\n\n    SegTreeSUM(int n_) {\n        while (n <= n_) n *= 2;\n        tree.assign(4 * n + 7, 0);\n    }\n\n    void upd(int v, int l, int r, int i, int x) {\n        if (l + 1 == r) {\n            tree[v] = x;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (i < mid) {\n            upd(2 * v + 1, l, mid, i, x);\n        } else {\n            upd(2 * v + 2, mid, r, i, x);\n        }\n        tree[v] = tree[2 * v + 1] + tree[2 * v + 2];\n    }\n\n    int get(int v, int l, int r, int lq, int rq) {\n        if (l >= rq || lq >= r) return 0;\n        if (lq <= l && r <= rq) return tree[v];\n        int mid = (l + r) / 2;\n        return get(2 * v + 1, l, mid, lq, rq) + get(2 * v + 2, mid, r, lq, rq);\n    }\n\n    void upd(int i, int x) {\n        upd(0, 0, n, i, x);\n    }\n\n    int get(int lq, int rq) {\n        return get(0, 0, n, lq, rq);\n    }\n\n};\n\nstruct Solver {\n    int WATER = 0; // sum of all but unique\n    map<int, int> barrels;\n    set<int> unique_barrels;\n    SegTreeMIN dist_to_next = SegTreeMIN(MAXA);\n    SegTreeSUM available_barrels = SegTreeSUM(MAXA);\n\n    int prev_unique(int x) {\n        if (*unique_barrels.begin() >= x) return -1;\n        auto it = unique_barrels.lower_bound(x);\n        it--;\n        return *it;\n    }\n\n    int next_unique(int x) {\n        if (*unique_barrels.rbegin() <= x) return -1;\n        auto it = unique_barrels.upper_bound(x);\n        return *it;\n    }\n\n    void upd_dist(int x) {\n        if (x == -1) return;\n        if (unique_barrels.find(x) == unique_barrels.end()) {\n            dist_to_next.upd(x, INF);\n            return;\n        }\n        int y = next_unique(x);\n        if (y == -1) {\n            dist_to_next.upd(x, INF);\n            return;\n        }\n        dist_to_next.upd(x, y - x);\n    }\n\n    void upd_ava(int x) {\n        if (unique_barrels.find(x) == unique_barrels.end()) {\n            available_barrels.upd(x, 0);\n        } else {\n            available_barrels.upd(x, x);\n        }\n    }\n\n    void unique_add(int x) {\n        WATER -= x;\n        unique_barrels.insert(x);\n        int y = prev_unique(x);\n        upd_dist(y);\n        upd_dist(x);\n        upd_ava(x);\n    }\n\n    void unique_erase(int x) {\n        WATER += x;\n        int y = prev_unique(x);\n        unique_barrels.erase(x);\n        upd_dist(y);\n        upd_dist(x);\n        upd_ava(x);\n    }\n\n    void add(int x) {\n        WATER += x;\n        if (barrels[x] == 1) {\n            unique_erase(x);\n        }\n        barrels[x]++;\n        if (barrels[x] == 1) {\n            unique_add(x);\n        }\n    }\n\n    void erase(int x) {\n        assert(barrels[x] >= 1);\n        WATER -= x;\n        if (barrels[x] == 1) {\n            unique_erase(x);\n        }\n        barrels[x]--;\n        if (barrels[x] == 1) {\n            unique_add(x);\n        }\n    }\n\n    int sum_water(int x) {\n        // total amount of water in u-barrels <= x\n        return available_barrels.get(0, x + 1);\n    }\n\n    bool is_special(int x) {\n        return x > WATER + sum_water(x - 1);\n    }\n\n    vector<int> find_all_special() {\n        int balance = WATER;\n        vector<int> ans;\n        while (balance < MAXA) {\n            int x = next_unique(balance);\n            if (x == -1) break;\n            if (is_special(x)) {\n                ans.push_back(x);\n            }\n            balance = WATER + sum_water(x);\n        }\n        return ans;\n    }\n\n    bool check_val(int x) {\n        // if we have all u-barrels < x, can we get another one?\n        if (unique_barrels.size() <= 1) return true;\n        int y = prev_unique(*unique_barrels.rbegin());\n        if (x > y) {\n            return true; // <=1 u-barrels left\n        }\n        int BALANCE = WATER + sum_water(x - 1);\n        y = next_unique(x - 1);\n        assert(y != -1);\n        if (BALANCE >= y) {\n            return true;\n        }\n        int min_diff = dist_to_next.get(x, dist_to_next.n);\n        if (BALANCE >= min_diff) {\n            return true;\n        }\n        return false;\n    }\n\n    bool check() {\n        if (unique_barrels.empty()) return true;\n        for (auto x: find_all_special()) {\n            if (!check_val(x)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n};\n\nvoid solve() {\n    int n, q;\n    cin >> n >> q;\n    Solver boss;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        boss.add(x);\n    }\n    if (boss.check()) {\n        cout << \"Yes\\n\";\n    } else {\n        cout << \"No\\n\";\n    }\n    for (int i = 0; i < q; i++) {\n        char c;\n        int x;\n        cin >> c >> x;\n        if (c == '+') {\n            boss.add(x);\n        } else {\n            boss.erase(x);\n        }\n        if (boss.check()) {\n            cout << \"Yes\\n\";\n        } else {\n            cout << \"No\\n\";\n        }\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2066d2",
      "PROBLEM_ID": "2066D2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, not necessary $a_i = 0$. You can hack only if you solved all versions of this problem.\n\nThere is a building with $n$ floors, numbered from $1$ to $n$ from bottom to top. There is exactly one person living on each floor.\n\nAll the residents of the building have an important goal today: to launch at least $c$ paper airplanes collectively. The residents will launch the airplanes in turn. When a person from the $i$-th floor launches an airplane, all residents on floors from $1$ to $i$ can see it as it descends to the ground. If, from the perspective of the resident on the $i$-th floor, at least $c$ airplanes have already been launched, they will no longer launch airplanes themselves. It is also known that by the end of the day, from the perspective of each resident in the building, at least $c$ airplanes have been launched, and a total of $m$ airplanes were thrown.\n\nYou have been carefully monitoring this flash mob, and for each airplane, you recorded which resident from which floor threw it. Unfortunately, the information about who exactly threw some of the airplanes has been lost. Find the number of ways to fill in the gaps so that the information could be credible. Since the answer could be quite large, output it modulo $10^9 + 7$.\n\nIt is also possible that you made a mistake in your records, and there is no possible way to restore the gaps. In that case, the answer is considered to be $0$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n, c, m$ ($1 \\le n \\le 100$, $1 \\le c \\le 100$, $c \\le m \\le n \\cdot c$)\u00a0\u2014 the number of floors in the building, the minimum required number of airplanes, and the number of airplanes actually launched.\n\nThe second line of each test case contains $m$ integers $a_1, a_2, \\ldots, a_m$ ($0 \\le a_i \\le n$)\u00a0\u2014 $a_i$ indicates the resident from which floor launched the $i$-th airplane; $a_i = 0$ indicates a gap.\n\nIt is guaranteed that the sum of the values of $m$ across all test cases does not exceed $10^4$.\n\n### Output\n\nFor each test case, output the number of ways to fill in the gaps with numbers from $1$ to $n$, so that the chronology of the airplane launches could be credible, modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n3 2 4\n\n0 0 0 0\n\n5 5 7\n\n0 0 0 0 0 0 0\n\n6 1 3\n\n2 0 0\n\n2 3 5\n\n0 0 1 0 2\n\n3 3 4\n\n3 3 3 0\n\n2 1 2\n\n0 1\n\n2 1 2\n\n0 2\n\n5 3 12\n\n0 0 1 0 2 4 0 0 0 5 0 5\n\n```\n\n#### Output #1\n\n```\n6\n190\n3\n2\n0\n0\n1\n14\n```\n\n### Note\n\nIn the first test example, all six possible ways to fill in the gaps are as follows:\n\n1. $[1, 1, 3, 3]$\n2. $[1, 2, 3, 3]$\n3. $[1, 3, 2, 3]$\n4. $[2, 1, 3, 3]$\n5. $[2, 2, 3, 3]$\n6. $[3, 1, 2, 3]$\n\nNote that the array $[2, 3, 1, 3]$ is not a valid way to fill in the gaps, as the third airplane could not have been launched by the person on the $1$st floor, since from their perspective, $c = 2$ airplanes had already been launched.\n\nAlso, the array $[1, 1, 2, 3]$ is not a valid way to fill in the gaps, as from the perspective of the person on the $3$rd floor, only $1$ airplane has been launched, while $c = 2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\n#define int long long\nusing namespace std;\nconst int N = 105;\nint fact[N * N], inv_fact[N * N];\nconst int M = (int) 1e9 + 7;\n\nint binpow(int a, int x) {\n    int ans = 1;\n    while (x) {\n        if (x % 2) {\n            ans *= a;\n            ans %= M;\n        }\n        a *= a;\n        a %= M;\n        x /= 2;\n    }\n    return ans;\n}\n\nint C(int k, int n) {\n    if (k > n || k < 0) return 0;\n    return (((fact[n] * inv_fact[k]) % M) * inv_fact[n - k] % M);\n}\n\nvoid solve() {\n    int n, c, m;\n    cin >> n >> c >> m;\n    vector<int> a(m + 1);\n    vector<int> last(n + 1), cnt(n + 1);\n    for (int i = 1; i <= m; i++) {\n        cin >> a[i];\n        if (a[i] != 0) {\n            last[a[i]] = i;\n            cnt[a[i]]++;\n        }\n    }\n    vector<vector<int>> more_on_prefix(m + 1, vector<int>(n + 1));\n    for (int i = 1; i <= m; i++) {\n        for (int el = 1; el <= n; el++) {\n            more_on_prefix[i][el] = more_on_prefix[i - 1][el] + (a[i] >= el);\n        }\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n\n    dp[0][0] = 1;\n    for (int el = 1; el <= n; el++) {\n        for (int sum = 0; sum <= m; sum++) {\n            dp[el][sum] = 0;\n            for (int x = 0; x <= c; x++) {\n                if (sum < x) {\n                    continue;\n                }\n                if (last[el] > c + sum - x) {\n                    continue;\n                }\n                if (x < cnt[el]) {\n                    continue;\n                }\n                if (c + sum - x > m) {\n                    continue;\n                }\n                int free_spots = c - more_on_prefix[c + sum - x][el];\n                int need_to_put = x - cnt[el];\n                dp[el][sum] += (dp[el - 1][sum - x] * C(need_to_put, free_spots)) % M;\n                if (dp[el][sum] >= M) {\n                    dp[el][sum] -= M;\n                }\n            }\n        }\n    }\n\n    cout << dp[n][m] << '\\n';\n\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    fact[0] = inv_fact[0] = 1;\n    for (int x = 1; x < N * N; x++) {\n        fact[x] = ((x * fact[x - 1]) % M);\n        inv_fact[x] = binpow(fact[x], M - 2);\n    }\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2066d1",
      "PROBLEM_ID": "2066D1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, all $a_i = 0$. You can hack only if you solved all versions of this problem.\n\nThere is an $n$-story building, with floors numbered from $1$ to $n$ from bottom to top. There is exactly one person living on each floor.\n\nAll the residents of the building have a very important goal today: to launch at least $c$ paper airplanes collectively. The residents will launch the airplanes in turn. When a person from the $i$-th floor launches an airplane, all residents on the floors from $1$ to $i$ can see it as it descends to the ground.\n\nIf, from the perspective of the resident on the $i$-th floor, at least $c$ airplanes have already been launched, they will not launch any more airplanes themselves. It is also known that by the end of the day, from the perspective of each resident in the building, at least $c$ airplanes have been launched, and a total of $m$ airplanes were thrown.\n\nYou carefully monitored this flash mob and recorded which resident from which floor threw each airplane. Unfortunately, the information about who exactly threw some airplanes has been lost. Find the number of ways to fill in the gaps so that the information could be credible. Since the answer can be quite large, output it modulo $10^9 + 7$.\n\nIn this version of the problem, all information has been lost, and the entire array consists of gaps.\n\nIt is also possible that you made a mistake in your records, and there is no possible way to restore the gaps. In that case, the answer is considered to be $0$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n, c, m$ ($1 \\le n \\le 100$, $1 \\le c \\le 100$, $c \\le m \\le n \\cdot c$)\u00a0\u2014 the number of floors in the building, the minimum required number of airplanes, and the number of airplanes actually launched.\n\nThe second line of each test case contains $m$ integers $a_1, a_2, \\ldots, a_m$ ($0 \\le a_i \\le n$)\u00a0\u2014 $a_i$ indicates the resident from which floor launched the $i$-th airplane; $a_i = 0$ indicates a gap.\n\nIn this version of the problem, it is guaranteed that all $a_i = 0$.\n\nIt is guaranteed that the sum of the values of $m$ across all test cases does not exceed $10^4$.\n\n### Output\n\nFor each test case, output the number of ways to fill in the gaps with numbers from $1$ to $n$, so that the chronology of the airplane launches could be credible, modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n3 2 4\n\n0 0 0 0\n\n5 5 7\n\n0 0 0 0 0 0 0\n\n```\n\n#### Output #1\n\n```\n6\n190\n```\n\n### Note\n\nIn the first test example, all six possible ways to fill in the gaps are as follows:\n\n1. $[1, 1, 3, 3]$\n2. $[1, 2, 3, 3]$\n3. $[1, 3, 2, 3]$\n4. $[2, 1, 3, 3]$\n5. $[2, 2, 3, 3]$\n6. $[3, 1, 2, 3]$\n\nNote that the array $[2, 3, 1, 3]$ is not a valid way to fill in the gaps, as the third airplane could not have been launched by the person on the $1$st floor, since from their perspective, $c = 2$ airplanes had already been launched.\n\nAlso, the array $[1, 1, 2, 3]$ is not a valid way to fill in the gaps, as from the perspective of the person on the $3$rd floor, only $1$ airplane has been launched, while $c = 2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 1000000007;\n\n// Fast exponentiation modulo MOD\nll modpow(ll a, ll e = MOD-2) {\n    ll r = 1;\n    while (e) {\n        if (e & 1) r = r * a % MOD;\n        a = a * a % MOD;\n        e >>= 1;\n    }\n    return r;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n    vector<tuple<int,int,int>> tests;\n    tests.reserve(T);\n    int maxN = 0;\n    for (int _ = 0; _ < T; _++) {\n        int n, c, m;\n        cin >> n >> c >> m;\n        // skip the next m integers (all zeros in this easy version)\n        for (int i = 0; i < m; i++) {\n            int x;\n            cin >> x;\n        }\n        tests.emplace_back(n, c, m);\n        // we'll need to compute binomial of up to (n-1)*c choose something\n        int up = (n - 1) * c;\n        if (up > maxN) maxN = up;\n    }\n\n    // precompute factorials and inverse factorials up to maxN\n    int N = maxN;\n    vector<ll> fact(N+1), ifact(N+1);\n    fact[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        fact[i] = fact[i-1] * i % MOD;\n    }\n    ifact[N] = modpow(fact[N]);\n    for (int i = N; i > 0; i--) {\n        ifact[i-1] = ifact[i] * i % MOD;\n    }\n\n    auto binom = [&](int n, int k) -> ll {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] % MOD * ifact[n-k] % MOD;\n    };\n\n    // answer each test\n    for (auto &tp : tests) {\n        int n, c, m;\n        tie(n, c, m) = tp;\n        // formula: C((n-1)*c, m-c)\n        int total_slots = (n - 1) * c;\n        int choose = m - c;\n        ll ans = binom(total_slots, choose);\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2066c",
      "PROBLEM_ID": "2066C",
      "PROBLEM_STATEMENT": "You are given an array $a_1, a_2, \\ldots, a_n$. Also, you are given three variables $P,Q,R$, initially equal to zero.\n\nYou need to process all the numbers $a_1, a_2, \\ldots, a_n$, in the order from $1$ to $n$. When processing the next $a_i$, you must perform exactly one of the three actions of your choice:\n\n1. $P := P \\oplus a_i$\n2. $Q := Q \\oplus a_i$\n3. $R := R \\oplus a_i$\n\n$\\oplus$ denotes the bitwise XOR operation.\n\nWhen performing actions, you must follow the main rule: it is necessary that after each action, all three numbers $P,Q,R$ are not pairwise distinct.\n\nThere are a total of $3^n$ ways to perform all $n$ actions. How many of them do not violate the main rule? Since the answer can be quite large, find it modulo $10^9 + 7$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of the values of $n$ for all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the number of ways to perform all $n$ actions without violating the main rule, modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3\n\n1 7 9\n\n4\n\n179 1 1 179\n\n5\n\n1 2 3 3 2\n\n12\n\n8 2 5 3 9 1 8 12 9 9 9 4\n\n1\n\n1000000000\n\n```\n\n#### Output #1\n\n```\n3\n9\n39\n123\n3\n```\n\n### Note\n\nIn the first test case, there are 3 valid sequences of operations: PPP, QQQ, RRR.\n\nIn the second test case, there are 9 valid sequences of operations: PPPP, PPPQ, PPPR, QQQP, QQQQ, QQQR, RRRP, RRRQ, RRRR.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing int64 = long long;\nconst int64 MOD = 1000000007;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int64> a(n);\n        for(int i = 0; i < n; i++){\n            cin >> a[i];\n        }\n        // Build prefix XORs\n        vector<int64> pref(n+1, 0);\n        for(int i = 1; i <= n; i++){\n            pref[i] = pref[i-1] ^ a[i-1];\n        }\n        // Coordinate-compress the prefix XOR values\n        vector<int64> xs = pref;\n        sort(xs.begin(), xs.end());\n        xs.erase(unique(xs.begin(), xs.end()), xs.end());\n        int m = xs.size();\n        vector<int> idx(n+1);\n        for(int i = 0; i <= n; i++){\n            idx[i] = int(lower_bound(xs.begin(), xs.end(), pref[i]) - xs.begin());\n        }\n        // cnt[u] = total number of DP paths in X-states at current prefix\n        // whose duplicate value = that prefix-XOR index u.\n        vector<int64> cnt(m, 0);\n\n        int64 fPrev = 1;    // f at prefix 0\n        int64 gTotal = 0;   // total X-state paths\n\n        // DP over prefixes\n        for(int i = 1; i <= n; i++){\n            int p1 = idx[i-1]; // index of S_{i-1}\n            int p2 = idx[i];   // index of S_i\n            // fCur = number of ways to be in X-state with uPrev = S_i\n            int64 fCur = cnt[p2];\n            // update total X-state count\n            // g_i = g_{i-1} + fCur + 3*fPrev\n            gTotal = (gTotal + fCur + 3 * fPrev) % MOD;\n            // update mapping at p1: new cnt[p1] = old + 2*cnt[p2] + 3*fPrev\n            int64 old_p1 = cnt[p1];\n            int64 old_p2 = fCur; // same as cnt[p2]\n            int64 new_p1 = (old_p1 + 2 * old_p2 + 3 * fPrev) % MOD;\n            cnt[p1] = new_p1;\n            // reset mapping at p2\n            cnt[p2] = 0;\n            // shift fPrev\n            fPrev = fCur;\n        }\n\n        // answer = f_n + total X-state count at n\n        int64 ans = (fPrev + gTotal) % MOD;\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2066b",
      "PROBLEM_ID": "2066B",
      "PROBLEM_STATEMENT": "We call a sequence $a_1, a_2, \\ldots, a_n$ magical if for all $1 \\leq i \\leq n-1$ it holds that: $\\operatorname{min}(a_1, \\ldots, a_i) \\geq \\operatorname{mex}(a_{i+1}, \\ldots, a_n)$. In particular, any sequence of length $1$ is considered magical.\n\nThe minimum excluded (MEX) of a collection of integers $a_1, a_2, \\ldots, a_k$ is defined as the smallest non-negative integer $t$ which does not occur in the collection $a$.\n\nYou are given a sequence $a$ of $n$ non-negative integers. Find the maximum possible length of a magical subsequence$^{\\text{\u2217}}$ of the sequence $a$.\n\n$^{\\text{\u2217}}$A sequence $a$ is a subsequence of a sequence $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) element from arbitrary positions.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the length of the sequence $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 10^9$)\u00a0\u2014 the elements of the sequence $a$.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single number\u00a0\u2014 the maximum possible length of a magical subsequence of the sequence $a$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n5\n\n4 3 2 1 0\n\n6\n\n4 3 3 2 1 0\n\n4\n\n2 0 1 2\n\n1\n\n777\n\n4\n\n1000000000 1 7 9\n\n2\n\n0 1\n\n2\n\n1 2\n\n4\n\n0 1 0 1\n\n```\n\n#### Output #1\n\n```\n5\n5\n3\n1\n4\n2\n2\n3\n```\n\n### Note\n\nIn the first test case, the sequence $[4, 3, 2, 1, 0]$ is magical, since:\n\n- $\\operatorname{min}(4) = 4, \\operatorname{mex}(3, 2, 1, 0) = 4$. $4 \\geq 4$\n- $\\operatorname{min}(4, 3) = 3, \\operatorname{mex}(2, 1, 0) = 3$. $3 \\geq 3$\n- $\\operatorname{min}(4, 3, 2) = 2, \\operatorname{mex}(1, 0) = 2$. $2 \\geq 2$\n- $\\operatorname{min}(4, 3, 2, 1) = 1, \\operatorname{mex}(0) = 1$. $1 \\geq 1$\n\nIn the second test case, the sequence $[4, 3, 3, 2, 1, 0]$ is not magical, since $\\operatorname{min}(4, 3) = 3, \\operatorname{mex}(3, 2, 1, 0) = 4$, $3 < 4$. However, the subsequence $[4, 3, 2, 1, 0]$ of this sequence is magical, so the answer is $5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool check(vector<int> a) {\n    int n = (int) a.size();\n    vector<int> suf_mex(n);\n    vector<int> used(n + 1, false);\n    int mex = 0;\n    for (int i = n - 1; i >= 1; i--) {\n        if (a[i] <= n) {\n            used[a[i]] = true;\n        }\n        while (used[mex]) mex++;\n        suf_mex[i] = mex;\n    }\n    int mini = a[0];\n    for (int i = 0; i < n - 1; i++) {\n        mini = min(mini, a[i]);\n        if (mini < suf_mex[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    bool was0 = false;\n    int cnt0 = 0;\n    vector<int> b;\n    for (int i = 0; i < n; i++) {\n        if (a[i] == 0) {\n            cnt0++;\n            if (!was0) {\n                b.push_back(a[i]);\n            }\n            was0 = true;\n        } else {\n            b.push_back(a[i]);\n        }\n    }\n    if (cnt0 > 0 && check(b)) {\n        cout << n - (cnt0 - 1) << '\\n';\n    } else {\n        cout << n - cnt0 << '\\n';\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2065h",
      "PROBLEM_ID": "2065H",
      "PROBLEM_STATEMENT": "Skibidus thinks he's Him! He proved it by solving this difficult task. Can you also prove yourself?\n\nGiven a binary string$^{\\text{\u2217}}$ $t$, $f(t)$ is defined as the minimum number of contiguous substrings, each consisting of identical characters, into which $t$ can be partitioned. For example, $f(\\texttt{00110001}) = 4$ because $t$ can be partitioned as $\\texttt{[00][11][000][1]}$ where each bracketed segment consists of identical characters.\n\nSkibidus gives you a binary string $s$ and $q$ queries. In each query, a single character of the string is flipped (i.e. $\\texttt{0}$ changes to $\\texttt{1}$ and $\\texttt{1}$ changes to $\\texttt{0}$); changes are saved after the query is processed. After each query, output the sum over all $f(b)$ where $b$ is a non-empty subsequence$^{\\text{\u2020}}$ of $s$, modulo $998\\,244\\,353$.\n\n$^{\\text{\u2217}}$A binary string consists of only characters $\\texttt{0}$ and $\\texttt{1}$.\n\n$^{\\text{\u2020}}$A subsequence of a string is a string which can be obtained by removing several (possibly zero) characters from the original string.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a binary string $s$ ($1 \\leq |s| \\leq 2 \\cdot 10^5$).\n\nThe following line of each test case contains an integer $q$ ($1 \\leq q \\leq 2 \\cdot 10^5$) \u2014 the number of queries.\n\nThe following line contains $q$ integers $v_1, v_2, \\ldots, v_q$ ($1 \\leq v_i \\leq |s|$), denoting $s_{v_i}$ is flipped for the $i$'th query.\n\nIt is guaranteed that the sum of $|s|$ and the sum of $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $q$ integers on a single line \u2014 the answer after each query modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n101\n\n2\n\n1 3\n\n10110\n\n3\n\n1 2 3\n\n101110101\n\n5\n\n7 2 4 4 1\n\n```\n\n#### Output #1\n\n```\n10 7\n61 59 67\n1495 1169 1417 1169 1396\n```\n\n### Note\n\nIn the first test case, $s$ becomes $\\texttt{001}$ after the first query. Let's calculate the answer for each subsequence:\n\n- $f(s_1) = f(\\texttt{0}) = 1$\n- $f(s_2) = f(\\texttt{0}) = 1$\n- $f(s_3) = f(\\texttt{1}) = 1$\n- $f(s_1 s_2) = f(\\texttt{00}) = 1$\n- $f(s_1 s_3) = f(\\texttt{01}) = 2$\n- $f(s_2 s_3) = f(\\texttt{01}) = 2$\n- $f(s_1 s_2 s_3) = f(\\texttt{001}) = 2$\n\nThe sum of these values is $10$, modulo $998\\,244\\,353$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\n// Define the modulo constant\nconst int MOD = 998244353;\n\n// Modular exponentiation function: computes (base^exp) % MOD efficiently\nlong long power(long long base, long long exp) {\n    long long res = 1;\n    base %= MOD; // Ensure base is within modulo range\n    while (exp > 0) {\n        // If exponent is odd, multiply result with base\n        if (exp % 2 == 1) res = (res * base) % MOD;\n        // Square the base and halve the exponent\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return res;\n}\n\n// Fenwick Tree (Binary Indexed Tree) structure for efficient prefix sums and point updates\nstruct FenwickTree {\n    vector<long long> bit; // The BIT array\n    int size; // Size of the array the BIT operates on\n\n    // Constructor initializes BIT of size n with all zeros\n    FenwickTree(int n) : size(n), bit(n + 1, 0) {}\n\n    // Adds delta to the element at index idx (1-based)\n    void add(int idx, long long delta) {\n        // Ensure delta is within [0, MOD-1] after modulo operation\n        delta %= MOD;\n        if (delta < 0) delta += MOD; // Handle negative delta by adding MOD\n        \n        // Propagate the update through the BIT structure\n        for (; idx <= size; idx += idx & -idx) { // idx & -idx gets the lowest set bit\n            bit[idx] = (bit[idx] + delta) % MOD;\n        }\n    }\n\n    // Queries the prefix sum up to index idx (1-based)\n    long long query(int idx) {\n        long long sum = 0;\n        // Accumulate values by traversing up the BIT structure\n        for (; idx > 0; idx -= idx & -idx) {\n            sum = (sum + bit[idx]) % MOD;\n        }\n        return sum;\n    }\n\n    // Queries the sum of elements in the range [L, R] (1-based)\n    long long query_range(int L, int R) {\n        if (L > R) return 0; // Handle empty range case\n        // Calculate sum(R) - sum(L-1) using prefix sums\n        long long res = query(R) - query(L - 1);\n        // Ensure the result is non-negative modulo MOD\n        if (res < 0) res += MOD;\n        return res;\n    }\n};\n\nint main() {\n    // Optimize standard I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        string s; // The input binary string\n        cin >> s;\n        int n = s.length(); // Length of the string\n        \n        // Precompute powers of 2 modulo MOD up to n, as they are used frequently\n        vector<long long> pow2(n + 1);\n        pow2[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            pow2[i] = (pow2[i - 1] * 2) % MOD;\n        }\n\n        // Initialize four Fenwick Trees. Two for prefix sums (storing 2^(j-1)) and two for suffix sums (storing 2^(n-k)),\n        // separated based on whether the character is '0' or '1'.\n        FenwickTree bit0_suffix(n); // Stores 2^(n-k) for '0's at index k\n        FenwickTree bit1_suffix(n); // Stores 2^(n-k) for '1's at index k\n        FenwickTree bit0_prefix(n); // Stores 2^(j-1) for '0's at index j\n        FenwickTree bit1_prefix(n); // Stores 2^(j-1) for '1's at index j\n\n        // Populate the initial Fenwick Trees based on the characters in the input string s\n        for (int i = 0; i < n; ++i) {\n            int idx = i + 1; // Convert 0-based string index to 1-based BIT index\n            if (s[i] == '0') {\n                // Check bounds for indices, although they should be valid for 1 <= idx <= n\n                if (n - idx >= 0) bit0_suffix.add(idx, pow2[n - idx]); // Store 2^(n-k) at index k = idx\n                if (idx - 1 >= 0) bit0_prefix.add(idx, pow2[idx - 1]); // Store 2^(j-1) at index j = idx\n            } else { // s[i] == '1'\n                 if (n - idx >= 0) bit1_suffix.add(idx, pow2[n - idx]);\n                 if (idx - 1 >= 0) bit1_prefix.add(idx, pow2[idx - 1]);\n            }\n        }\n        \n        // Compute the initial value of T = sum_{1 <= j < k <= n, s_j != s_k} 2^(n-k+j-1)\n        // This is equivalent to sum_{j=1..n} 2^(j-1) * (sum_{k=j+1..n, s_k != s_j} 2^(n-k))\n        long long current_T = 0;\n        for (int j = 1; j <= n; ++j) {\n            char c = s[j - 1]; // Character at index j (1-based)\n            char c_prime = (c == '0' ? '1' : '0'); // The character opposite to s_j\n            \n            // Calculate the inner sum: sum_{k=j+1..n, s_k != s_j} 2^(n-k)\n            // This is efficiently computed using a range query on the suffix BIT for character c_prime\n            long long S_suffix;\n            if (c_prime == '0') {\n                S_suffix = bit0_suffix.query_range(j + 1, n);\n            } else { // c_prime == '1'\n                S_suffix = bit1_suffix.query_range(j + 1, n);\n            }\n            \n            // Add the contribution for this j to current_T\n            // Check if j-1 >= 0 for pow2 index safety, although j >= 1 ensures this.\n            if (j-1 >= 0) { \n                 current_T = (current_T + (pow2[j - 1] * S_suffix) % MOD) % MOD;\n            }\n        }\n\n        int q; // Number of queries\n        cin >> q;\n        \n        vector<long long> results; // Vector to store results for printing after all queries\n        for (int k = 0; k < q; ++k) {\n            int v; // Query index (1-based), position to flip\n            cin >> v; \n            \n            char c = s[v - 1]; // Character at index v before the flip\n            char c_prime = (c == '0' ? '1' : '0'); // Character after the flip\n\n            // Calculate necessary range sums using BITs to find the change in T\n            long long Q_suffix_c, Q_suffix_c_prime; // Suffix sums for c and c_prime in range [v+1, n]\n            long long Q_prefix_c, Q_prefix_c_prime; // Prefix sums for c and c_prime in range [1, v-1]\n\n            // Query the appropriate BITs based on character c and c_prime\n            if (c == '0') {\n                Q_suffix_c = bit0_suffix.query_range(v + 1, n);\n                Q_suffix_c_prime = bit1_suffix.query_range(v + 1, n);\n                Q_prefix_c = bit0_prefix.query_range(1, v - 1);\n                Q_prefix_c_prime = bit1_prefix.query_range(1, v - 1);\n            } else { // c == '1'\n                Q_suffix_c = bit1_suffix.query_range(v + 1, n);\n                Q_suffix_c_prime = bit0_suffix.query_range(v + 1, n);\n                Q_prefix_c = bit1_prefix.query_range(1, v - 1);\n                Q_prefix_c_prime = bit0_prefix.query_range(1, v - 1);\n            }\n\n            // Calculate the change delta_T using the derived formula based on range sums\n            long long delta_T = 0;\n            // Change from pairs (v, k) where k > v\n            long long term1 = 0;\n            if(v-1 >= 0) term1 = (pow2[v - 1] * (Q_suffix_c - Q_suffix_c_prime + MOD)) % MOD;\n            // Change from pairs (j, v) where j < v\n            long long term2 = 0;\n            if (n-v >= 0) term2 = (pow2[n - v] * (Q_prefix_c - Q_prefix_c_prime + MOD)) % MOD;\n            \n            // Combine the two terms for total change delta_T\n            delta_T = (term1 + term2) % MOD;\n\n            // Update current T by adding the calculated change delta_T\n            current_T = (current_T + delta_T) % MOD;\n\n            // Update the Fenwick Trees to reflect the character flip at index v\n            // Need to remove the contribution of the old character c and add the contribution of the new character c_prime\n            long long suffix_val = 0; // Value 2^(n-k) for k=v\n            if(n-v >= 0) suffix_val = pow2[n - v]; \n            long long prefix_val = 0; // Value 2^(j-1) for j=v\n             if(v-1 >= 0) prefix_val = pow2[v - 1]; \n\n            if (c == '0') { // If flipping from '0' to '1'\n                // Remove values from '0' BITs\n                bit0_suffix.add(v, -suffix_val);\n                bit0_prefix.add(v, -prefix_val);\n                // Add values to '1' BITs\n                bit1_suffix.add(v, suffix_val);\n                bit1_prefix.add(v, prefix_val);\n            } else { // If flipping from '1' to '0'\n                 // Remove values from '1' BITs\n                bit1_suffix.add(v, -suffix_val);\n                bit1_prefix.add(v, -prefix_val);\n                 // Add values to '0' BITs\n                bit0_suffix.add(v, suffix_val);\n                bit0_prefix.add(v, prefix_val);\n            }\n\n            // Update the character in the string representation 's' itself for consistency in subsequent queries\n            s[v - 1] = c_prime; \n\n            // Calculate the final answer S = (2^n - 1) + T mod M\n            // Add MOD before taking modulo to handle potential negative result from (pow2[n] - 1) if n=0 (not possible here) or T is negative before correction\n            long long total_sum = (pow2[n] - 1 + current_T + MOD) % MOD;\n            results.push_back(total_sum);\n        }\n\n        // Print all the computed results for the current test case\n        for (int i = 0; i < q; ++i) {\n            cout << results[i] << (i == q - 1 ? \"\" : \" \");\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2065g",
      "PROBLEM_ID": "2065G",
      "PROBLEM_STATEMENT": "Skibidus was abducted by aliens of Amog! Skibidus tries to talk his way out, but the Amog aliens don't believe him. To prove that he is not totally capping, the Amog aliens asked him to solve this task:\n\nAn integer $x$ is considered a semi-prime if it can be written as $p \\cdot q$ where $p$ and $q$ are (not necessarily distinct) [prime numbers](https://en.wikipedia.org/wiki/Prime_number). For example, $9$ is a semi-prime since it can be written as $3 \\cdot 3$, and $3$ is a prime number.\n\nSkibidus was given an array $a$ containing $n$ integers. He must report the number of pairs $(i, j)$ such that $i \\\\leq j$ and $\\\\operatorname{lcm}(a\\_i, a\\_j)$$^{\\\\text{\u2217}}$ is semi-prime.\n\n$^{\\text{\u2217}}$Given two integers $x$ and $y$, $\\operatorname{lcm}(x, y)$ denotes the [least common multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of $x$ and $y$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^5$).\n\nThe following line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($2 \\leq a_i \\leq n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the number of ordered pairs of indices on a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4\n\n2 2 3 4\n\n6\n\n2 2 3 4 5 6\n\n9\n\n2 2 4 5 7 8 9 3 5\n\n```\n\n#### Output #1\n\n```\n5\n12\n18\n```\n\n### Note\n\nIn the first test case, the $5$ pairs of indices are $(1, 3)$, $(1, 4)$, $(2, 3)$, $(2, 4)$, and $(4, 4)$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <map>\n#include <cmath> // Include cmath for sqrt\n\n// Global constants and structures\nconst int MAXN = 200005; // Maximum possible value of N and array elements\nstd::vector<int> spf(MAXN); // Smallest Prime Factor array, spf[k] stores the smallest prime factor of k\nstd::vector<int> primes; // List of prime numbers up to MAXN\n// Using std::map to store frequency counts. Key is the number, value is its count.\n// Using long long for counts because counts can be up to N.\nstd::map<int, long long> cnt; \n\n// Sieve implementation using linear time algorithm to precompute SPF and primes up to N\n// This function should be called once before processing test cases.\nvoid sieve_init(int N) {\n    // Ensure sieve runs only once for the maximum required N across all test cases\n    static bool initialized = false;\n    static int max_N_processed = 0;\n    if (initialized && N <= max_N_processed) return;\n    \n    // Resize spf vector if needed, ensuring it's large enough for N\n    if (N >= spf.size()) {\n        spf.resize(N + 1);\n    } else {\n       // Reset relevant part of spf if necessary, though typically we compute up to max N once\n       spf.assign(N+1, 0); \n    }\n    primes.clear(); // Clear primes list for recomputation or first computation\n    \n    spf[0] = spf[1] = 1; // Mark 0 and 1 specially. They have no prime factors in the usual sense.\n\n    // Linear sieve algorithm\n    for (int i = 2; i <= N; ++i) {\n        if (spf[i] == 0) { // If spf[i] is 0, it means i is prime\n            spf[i] = i; // The smallest prime factor of a prime is itself\n            primes.push_back(i); // Add i to the list of primes\n        }\n        // For any number i, iterate through primes p such that p <= spf[i]\n        // The smallest prime factor of i*p will be p\n        for (int p : primes) {\n            // Optimization condition 1: Stop if p > spf[i].\n            // If p > spf[i], then the smallest prime factor of i*p is spf[i], not p.\n            // We only want to set spf[i*p] = p when p is the smallest prime factor.\n            // Optimization condition 2: Stop if i*p exceeds N.\n            if (p > spf[i] || (long long)i * p > N) {\n                 break;\n            }\n             spf[i * p] = p; // p is the smallest prime factor of i * p\n        }\n    }\n    initialized = true; // Mark sieve as initialized\n    max_N_processed = N; // Record the maximum N processed\n}\n\n// Function to check if a number k is semi-prime (k = p*q for primes p, q, possibly p=q)\n// Uses the precomputed SPF table for efficiency.\nbool checkSemiPrime(int k) {\n    if (k <= 3) return false; // Numbers 1, 2, 3 are not semi-primes.\n    // Ensure k is within the precomputed range SPF table covers.\n    // Given problem constraints a_i <= n <= 2e5, k will be within MAXN.\n    if (k >= MAXN) return false; \n    \n    // Check if SPF data is valid for k. Should be valid if k > 1.\n    if (spf[k] <= 1) return false; \n\n    int p1 = spf[k]; // Get the smallest prime factor of k\n    int remaining = k / p1; // The part of k remaining after dividing by p1\n    \n    // If remaining is 1, it means k was prime (k = p1), hence not semi-prime.\n    if (remaining == 1) return false; \n    \n    // Check if the 'remaining' part is prime. A number `x` is prime if spf[x] == x.\n    if (spf[remaining] == remaining) {\n        // If remaining is prime, let it be p2. Then k = p1 * p2.\n        // Since p1 = spf[k] is prime, and p2 = remaining is prime (because spf[remaining] == remaining),\n        // k is a product of two primes (p1 and p2, possibly p1=p2). Thus k is semi-prime.\n        return true;\n    } else {\n        // If remaining is not prime (i.e., spf[remaining] != remaining), \n        // it means k has at least three prime factors (counted with multiplicity).\n        // Example: k=12 -> p1=2, remaining=6. spf[6]=2 != 6. 12=2*2*3 has 3 prime factors.\n        // Example: k=8 -> p1=2, remaining=4. spf[4]=2 != 4. 8=2*2*2 has 3 prime factors.\n        // Such numbers are not semi-prime.\n        return false; \n    }\n}\n\nint main() {\n    // Optimize standard I/O operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // Precompute primes and SPF up to the maximum possible value of N (2e5)\n    sieve_init(200000); \n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Size of array for this test case\n        std::cin >> n;\n        cnt.clear(); // Clear frequency counts from the previous test case\n        \n        // Read input array elements for the current test case and compute their frequencies\n        for (int i = 0; i < n; ++i) {\n            int val;\n            std::cin >> val;\n            cnt[val]++; // Increment count for the value read\n        }\n\n        long long ans = 0; // Initialize total count of valid pairs (i, j) with i <= j\n\n        // The calculation is split into two parts: pairs with i < j and pairs with i = j.\n        // We first calculate the count for pairs (i, j) where i < j.\n\n        // Part 1: Calculate pairs (i, j) with i < j\n\n        // Step 1.1: Pairs where both a_i and a_j are distinct primes {p, q}. LCM = pq.\n        // Count pairs (i, j), i < j, such that {a_i, a_j} = {p, q} for distinct primes p, q.\n        // This can be calculated efficiently using sums over counts of primes present in the array.\n        long long total_primes_count = 0; // Sum of counts of all prime numbers present in the array `a`\n        long long sum_sq_prime_counts = 0; // Sum of squares of counts for each prime number present\n        for (int p : primes) {\n             // Optimization: We only need to consider primes up to n, as a_i <= n.\n             if (p > n) break; \n             // Check if prime p is present in the input array\n             if (cnt.count(p)) {\n                  long long count_p = cnt[p]; // Get the count of prime p\n                  total_primes_count += count_p; // Add to total count of primes\n                  sum_sq_prime_counts += count_p * count_p; // Add square of count to sum of squares\n             }\n        }\n        // The total number of pairs (i, j) with i < j where a_i=p, a_j=q (p!=q primes) is Sum_{p<q} cnt[p]*cnt[q].\n        // This sum equals 1/2 * ( (Sum cnt[p])^2 - Sum cnt[p]^2 ).\n        if (total_primes_count > 0) { // Check ensures we don't perform calculations if no primes are present.\n            ans += (total_primes_count * total_primes_count - sum_sq_prime_counts) / 2;\n        }\n\n        // Step 1.2: Pairs involving p^2. These result in LCM = p^2 (which is semi-prime).\n        // Consider pairs (i, j), i < j.\n        for (int p : primes) {\n             long long p_sq = (long long)p * p; // Calculate p^2\n             // Optimization: if p^2 > n, then p^2 cannot be an element in the array `a`. Also, subsequent p will yield even larger p^2.\n             if (p_sq > n) break; \n             \n             // Get counts of p and p^2, default to 0 if not present.\n             long long count_p = cnt.count(p) ? cnt[p] : 0;\n             long long count_p_sq = cnt.count(p_sq) ? cnt[p_sq] : 0;\n\n             // Case 1: Pairs {p, p^2}. Indices i < j such that {a_i, a_j} = {p, p^2}.\n             // Their LCM is lcm(p, p^2) = p^2. Count = cnt[p] * cnt[p^2].\n             if (count_p > 0 && count_p_sq > 0) {\n                 ans += count_p * count_p_sq; \n             }\n             // Case 2: Pairs {p^2, p^2}. Indices i < j such that a_i = a_j = p^2.\n             // Their LCM is lcm(p^2, p^2) = p^2. Count = cnt[p^2] * (cnt[p^2] - 1) / 2.\n             if (count_p_sq >= 2) { // Need at least two occurrences of p^2 to form such a pair.\n                 ans += count_p_sq * (count_p_sq - 1) / 2; \n             }\n        }\n        \n        // Step 1.3: Pairs involving pq where pq <= n. These result in LCM = pq (which is semi-prime).\n        // Iterate through pairs of distinct primes (p, q) such that p < q.\n        for (int pi = 0; pi < primes.size(); ++pi) {\n            long long p = primes[pi];\n             // Optimization: if p*p > n, then for any q > p, p*q > p*p > n. So p*q cannot be <= n. Stop iterating p.\n             if ((long long)p * p > n) break; \n            \n            // Iterate through primes q > p\n            for (int qi = pi + 1; qi < primes.size(); ++qi) {\n                 long long q = primes[qi];\n                 long long v = p * q; // v = pq, a potential semi-prime value\n                 // If pq > n, it cannot be an element in array `a`. Also, further q's will yield larger pq.\n                 if (v > n) break; \n\n                 // Get counts of p, q, and v=pq. Default to 0 if not present.\n                 long long count_p = cnt.count(p) ? cnt[p] : 0;\n                 long long count_q = cnt.count(q) ? cnt[q] : 0;\n                 long long count_v = cnt.count(v) ? cnt[v] : 0;\n\n                 // Case 1: Pairs {p, pq}. Indices i < j such that {a_i, a_j} = {p, pq}.\n                 // Their LCM is lcm(p, pq) = pq. Count = cnt[p] * cnt[pq].\n                 if (count_p > 0 && count_v > 0) {\n                     ans += count_p * count_v; \n                 }\n                 // Case 2: Pairs {q, pq}. Indices i < j such that {a_i, a_j} = {q, pq}.\n                 // Their LCM is lcm(q, pq) = pq. Count = cnt[q] * cnt[pq].\n                 if (count_q > 0 && count_v > 0) {\n                     ans += count_q * count_v; \n                 }\n                 // Case 3: Pairs {pq, pq}. Indices i < j such that a_i = a_j = pq.\n                 // Their LCM is lcm(pq, pq) = pq. Count = cnt[pq] * (cnt[pq] - 1) / 2.\n                 if (count_v >= 2) { // Need at least two occurrences of pq.\n                     ans += count_v * (count_v - 1) / 2; \n                 }\n            }\n        }\n\n        // Part 2: Add contributions for pairs (i, i) where a_i is semi-prime\n        // If a_i is semi-prime, then lcm(a_i, a_i) = a_i is semi-prime.\n        // Iterate through all distinct values present in the input array.\n        for(auto const& [val, count] : cnt) {\n            // Check if the value `val` is semi-prime.\n            if (checkSemiPrime(val)) {\n                 // If `val` is semi-prime, each of its `count` occurrences contributes one pair (i, i).\n                 ans += count; \n            }\n        }\n\n        // Output the final answer for the current test case\n        std::cout << ans << \"\\n\"; \n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2065f",
      "PROBLEM_ID": "2065F",
      "PROBLEM_STATEMENT": "Let's define the majority of a sequence of $k$ elements as the unique value that appears strictly more than $\\left \\lfloor {\\frac{k}{2}} \\right \\rfloor$ times. If such a value does not exist, then the sequence does not have a majority. For example, the sequence $[1,3,2,3,3]$ has a majority $3$ because it appears $3 > \\left \\lfloor {\\frac{5}{2}} \\right \\rfloor = 2$ times, but $[1,2,3,4,5]$ and $[1,3,2,3,4]$ do not have a majority.\n\nSkibidus found a tree$^{\\text{\u2217}}$ of $n$ vertices and an array $a$ of length $n$. Vertex $i$ has the value $a_i$ written on it, where $a_i$ is an integer in the range $[1, n]$.\n\nFor each $i$ from $1$ to $n$, please determine if there exists a non-trivial simple path$^{\\text{\u2020}}$ such that $i$ is the majority of the sequence of integers written on the vertices that form the path.\n\n$^{\\text{\u2217}}$A tree is a connected graph without cycles.\n\n$^{\\text{\u2020}}$A sequence of vertices $v_1, v_2, ..., v_m$ ($m \\geq 2$) forms a non-trivial simple path if $v_i$ and $v_{i+1}$ are connected by an edge for all $1 \\leq i \\leq m - 1$ and all $v_i$ are pairwise distinct. Note that the path must consist of at least $2$ vertices.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 5 \\cdot 10^5$) \u00a0\u2014 the number of vertices.\n\nThe second line of each test case contains $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le n$) \u00a0\u2014 the integers written on the vertices.\n\nEach of the next $n-1$ lines contains two integers $u_i$ and $v_i$, denoting the two vertices connected by an edge ($1 \\le u_i,v_i \\le n$, $u_i \\neq v_i$).\n\nIt is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a binary string $s$ of length $n$ on a separate line. $s_i$ should be computed as follows:\n\n- If there is a non-trivial path containing $i$ as the majority, $s_i$ is '1';\n- Otherwise, $s_i$ is '0'.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\n1 2 3\n\n1 3\n\n2 3\n\n4\n\n3 1 1 3\n\n1 2\n\n2 3\n\n4 2\n\n4\n\n2 4 4 2\n\n1 2\n\n2 3\n\n3 4\n\n13\n\n1 4 4 7 4 7 1 1 7 11 11 11 11\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n4 6\n\n2 7\n\n7 8\n\n2 9\n\n6 10\n\n5 11\n\n11 12\n\n10 13\n\n```\n\n#### Output #1\n\n```\n000\n1010\n0001\n1001001000100\n```\n\n### Note\n\nIn the first test case, there is no non-trivial path with $1$, $2$, or $3$ as a majority, so the binary string outputted is \"000\".\n\nIn the second test case, $1\\rightarrow 2\\rightarrow 4$ is a non-trivial path with $3$ as a majority.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <vector>       // For std::vector\n#include <string>       // For std::string\n#include <iostream>     // For std::cin, std::cout\n#include <vector>       // Included again, harmless\n\n// Function to solve a single test case\nvoid solve() {\n    int n;\n    std::cin >> n; // Read number of vertices\n\n    // Store values associated with vertices (1-based indexing)\n    std::vector<int> a(n + 1); \n    for (int i = 1; i <= n; ++i) {\n        std::cin >> a[i]; // Read vertex values\n    }\n\n    // Adjacency list representation of the tree\n    std::vector<std::vector<int>> adj(n + 1); \n    // Read edges and build adjacency list\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v; // Read an edge\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Boolean array to track if value i can be a majority on some non-trivial simple path.\n    // Indices correspond to values 1 to n. Initialize all to false.\n    std::vector<bool> is_majority(n + 1, false); \n\n    // Check 1: Check if any edge connects two vertices with the same value.\n    // If an edge (u, v) exists such that a[u] == a[v], then the path u-v has length 2.\n    // The value a[u] appears 2 times. Since floor(2/2) = 1, and 2 > 1,\n    // a[u] is a majority on this path.\n    // Iterate through vertices and their neighbors. Process each edge only once (e.g., when u < v)\n    // This ensures each edge is checked exactly once.\n    for (int u = 1; u <= n; ++u) {\n        for (int v : adj[u]) {\n            // To process each edge once, we only consider pairs where u < v\n            if (u < v) { \n                if (a[u] == a[v]) {\n                     // The problem statement guarantees 1 <= a[i] <= n, so a[u] is a valid index.\n                     // Mark a[u] as a possible majority value.\n                     is_majority[a[u]] = true;\n                }\n            }\n        }\n    }\n\n    // Check 2: Check if any vertex v has at least two neighbors u, w such that\n    // a[u] == a[w] == C and a[v] != C.\n    // If such v, u, w exist, the path u-v-w is simple (since it's a tree and u != w) and has length 3.\n    // The value C appears 2 times. Since floor(3/2) = 1, and 2 > 1, C is a majority on this path.\n    // We use a frequency array `freq` to count neighbor values efficiently.\n    // We need O(N) extra space for the frequency array.\n    // The total time complexity for this check across all vertices is O(N + M) = O(N) since M = N-1 for a tree.\n    std::vector<int> freq(n + 1, 0); // Frequency count array for neighbor values. Size n+1 for 1-based indexing.\n    \n    // neighbor_unique_vals stores unique values encountered among neighbors of the current vertex v.\n    // This is used to efficiently reset the frequency counts relevant to v after processing it.\n    std::vector<int> neighbor_unique_vals; \n\n    // Iterate through each vertex v from 1 to n\n    for (int v = 1; v <= n; ++v) { \n        neighbor_unique_vals.clear(); // Clear the list of unique neighbor values for the current vertex v\n        // Optional optimization: reserve space based on degree.\n        // neighbor_unique_vals.reserve(adj[v].size()); \n\n        // Iterate through neighbors of v to count frequencies of their values.\n        for (int neighbor : adj[v]) {\n            // Problem guarantees a[neighbor] is in [1, n], so it's a valid index for freq array.\n             if (freq[a[neighbor]] == 0) { // If this is the first time seeing this value among neighbors of v\n                 neighbor_unique_vals.push_back(a[neighbor]); // Add it to the list of unique values seen\n             }\n             freq[a[neighbor]]++; // Increment the frequency count for this neighbor's value\n        }\n\n        // Check the condition for each unique neighbor value C found\n        for (int C : neighbor_unique_vals) { \n            if (freq[C] >= 2) { // If value C appeared at least twice among neighbors of v\n                if (a[v] != C) { // And the vertex v itself does not have value C\n                    // C is guaranteed to be in [1, n] because it came from a neighbor's value a[neighbor].\n                    is_majority[C] = true; // Mark C as a possible majority value\n                }\n            }\n        }\n\n        // Reset the frequency counts for the values encountered among neighbors of vertex v.\n        // This is crucial for correctness for the next vertex iteration. We only reset counts that were modified.\n        for (int C : neighbor_unique_vals) {\n             // C is guaranteed to be in [1, n].\n             freq[C] = 0; // Reset count to 0\n        }\n    }\n\n    // Construct the final output string based on the `is_majority` flags.\n    std::string result = \"\";\n    for (int i = 1; i <= n; ++i) {\n        result += (is_majority[i] ? '1' : '0');\n    }\n    std::cout << result << \"\\n\"; // Print the result string for this test case\n}\n\n// Main function to handle multiple test cases\nint main() {\n    // Faster I/O operations\n    std::ios_base::sync_with_stdio(false); \n    std::cin.tie(NULL); \n\n    int t;\n    std::cin >> t; // Read the number of test cases\n    while (t--) {\n        solve(); // Solve each test case\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2065e",
      "PROBLEM_ID": "2065E",
      "PROBLEM_STATEMENT": "With the approach of Valentine's Day, Skibidus desperately needs a way to rizz up his crush! Fortunately, he knows of just the way: creating the perfect Binary String!\n\nGiven a binary string$^{\\text{\u2217}}$ $t$, let $x$ represent the number of $\\texttt{0}$ in $t$ and $y$ represent the number of $\\texttt{1}$ in $t$. Its balance-value is defined as the value of $\\max(x-y, y-x)$.\n\nSkibidus gives you three integers $n$, $m$, and $k$. He asks for your help to construct a binary string $s$ of length $n+m$ with exactly $n$ $\\texttt{0}$'s and $m$ $\\texttt{1}$'s such that the maximum balance-value among all of its substrings$^{\\text{\u2020}}$ is exactly $k$. If it is not possible, output -1.\n\n$^{\\text{\u2217}}$A binary string only consists of characters $\\texttt{0}$ and $\\texttt{1}$.\n\n$^{\\text{\u2020}}$A string $a$ is a substring of a string $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first and only line of each test case contains three integers $n$, $m$, and $k$ ($0 \\leq n, m \\leq 2\\cdot 10^5$, $1 \\leq k \\leq n + m$, $n+m\\geq 1$).\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, if it is possible to construct $s$, output it on a new line. If there are multiple possible $s$, output any. Otherwise, output -1 on a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1 2 1\n\n4 3 2\n\n2 4 3\n\n8 3 2\n\n5 0 4\n\n5 0 5\n\n```\n\n#### Output #1\n\n```\n101\n0100101\n011011\n-1\n-1\n00000\n```\n\n### Note\n\nIn the first test case, we must construct $s$ such that it contains one $\\texttt{0}$, two $\\texttt{1}$, and a maximum balance of $1$ among all of its substrings. One possible valid $s$ is $\\texttt{101}$ because:\n\n- Consider the substring bounded by indices $[1, 1]$. Its balance-value is $\\max(0 - 1, 1 - 0) = 1$.\n- Consider the substring bounded by indices $[1, 2]$. Its balance-value is $\\max(1 - 1, 1 - 1) = 0$.\n- Consider the substring bounded by indices $[1, 3]$. Its balance-value is $\\max(1 - 2, 2 - 1) = 1$.\n- Consider the substring bounded by indices $[2, 2]$. Its balance-value is $\\max(1 - 0, 0 - 1) = 1$.\n- Consider the substring bounded by indices $[2, 3]$. Its balance-value is $\\max(1 - 1, 1 - 1) = 0$.\n- Consider the substring bounded by indices $[3, 3]$. Its balance-value is $\\max(0 - 1, 1 - 0) = 1$.\n\nAmong all possible substrings, the maximum balance-value is $1$.\n\nIn the second test case, the substring with the maximum balance-value is $0100$, which has a balance of $max(3-1, 1-3)=2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring solve(int n, int m, int k) {\n    // If abs(n-m) > k, it's impossible\n    if (abs(n - m) > k) {\n        return \"-1\";\n    }\n    \n    // If k > max(n, m), the only solution is if k == n+m and one of n or m is 0\n    if (k > max(n, m)) {\n        if (k == n + m && (n == 0 || m == 0)) {\n            return (n == 0) ? string(m, '1') : string(n, '0');\n        }\n        return \"-1\";\n    }\n    \n    string result;\n    \n    // Alternating approach: we place alternating blocks of 0s and 1s\n    // Each block should have size at most k to ensure maximum balance is k\n    \n    // If n >= m, start with 0s, otherwise start with 1s\n    bool use_zeros_first = (n >= m);\n    \n    while (n > 0 || m > 0) {\n        if (use_zeros_first) {\n            if (n > 0) {\n                int to_add = min(n, k);\n                result += string(to_add, '0');\n                n -= to_add;\n            }\n            if (m > 0) {\n                int to_add = min(m, k);\n                result += string(to_add, '1');\n                m -= to_add;\n            }\n        } else {\n            if (m > 0) {\n                int to_add = min(m, k);\n                result += string(to_add, '1');\n                m -= to_add;\n            }\n            if (n > 0) {\n                int to_add = min(n, k);\n                result += string(to_add, '0');\n                n -= to_add;\n            }\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        \n        cout << solve(n, m, k) << '\\n';\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2065d",
      "PROBLEM_ID": "2065D",
      "PROBLEM_STATEMENT": "Let's denote the score of an array $b$ with $k$ elements as $\\sum_{i=1}^{k}\\left(\\sum_{j=1}^ib_j\\right)$. In other words, let $S_i$ denote the sum of the first $i$ elements of $b$. Then, the score can be denoted as $S_1+S_2+\\ldots+S_k$.\n\nSkibidus is given $n$ arrays $a_1,a_2,\\ldots,a_n$, each of which contains $m$ elements. Being the sigma that he is, he would like to concatenate them in any order to form a single array containing $n\\cdot m$ elements. Please find the maximum possible score Skibidus can achieve with his concatenated array!\n\nFormally, among all possible permutations$^{\\text{\u2217}}$ $p$ of length $n$, output the maximum score of $a_{p_1} + a_{p_2} + \\dots + a_{p_n}$, where $+$ represents concatenation$^{\\text{\u2020}}$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ contains all integers from $1$ to $n$ exactly once.\n\n$^{\\text{\u2020}}$The concatenation of two arrays $c$ and $d$ with lengths $e$ and $f$ respectively (i.e. $c + d$) is $c_1, c_2, \\ldots, c_e, d_1, d_2, \\ldots d_f$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n \\cdot m \\leq 2 \\cdot 10^5$) \u2014 the number of arrays and the length of each array.\n\nThe $i$'th of the next $n$ lines contains $m$ integers $a_{i,1}, a_{i,2}, \\ldots, a_{i,m}$ ($1 \\leq a_{i,j} \\leq 10^6$) \u2014 the elements of the $i$'th array.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the maximum score among all possible permutations $p$ on a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2\n\n4 4\n\n6 1\n\n3 4\n\n2 2 2 2\n\n3 2 1 2\n\n4 1 2 1\n\n2 3\n\n3 4 5\n\n1 1 9\n\n```\n\n#### Output #1\n\n```\n41\n162\n72\n```\n\n### Note\n\nFor the first test case, there are two possibilities for $p$:\n\n- $p = [1, 2]$. Then, $a_{p_1} + a_{p_2} = [4, 4, 6, 1]$. Its score is $4+(4+4)+(4+4+6)+(4+4+6+1)=41$.\n- $p = [2, 1]$. Then, $a_{p_1} + a_{p_2} = [6, 1, 4, 4]$. Its score is $6+(6+1)+(6+1+4)+(6+1+4+4)=39$.\n\nThe maximum possible score is $41$.\n\nIn the second test case, one optimal arrangement of the final concatenated array is $[4,1,2,1,2,2,2,2,3,2,1,2]$. We can calculate that the score is $162$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Structure to hold an array and its sum\nstruct ArrayWithSum {\n    vector<long long> arr;\n    long long sum;\n    int idx; // Optional: can be used for debugging\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int t;\n    cin >> t;\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n        vector<ArrayWithSum> arrays(n);\n        \n        // Input arrays and calculate their sums\n        for(int i = 0; i < n; ++i){\n            arrays[i].arr.resize(m);\n            arrays[i].sum = 0;\n            for(int j = 0; j < m; ++j){\n                cin >> arrays[i].arr[j];\n                arrays[i].sum += arrays[i].arr[j];\n            }\n            arrays[i].idx = i; // Optional: store index for debugging\n        }\n        \n        // Sort the arrays by their sum in descending order\n        sort(arrays.begin(), arrays.end(), [&](const ArrayWithSum &a, const ArrayWithSum &b) -> bool{\n            return a.sum > b.sum;\n        });\n        \n        // Compute the maximum score\n        long long total_sum = 0, score = 0;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                score += total_sum + arrays[i].arr[j];\n                total_sum += arrays[i].arr[j];\n            }\n        }\n        \n        // Output the score for the current test case\n        cout << score << \"\\n\";\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2065c2",
      "PROBLEM_ID": "2065C2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. In this version, $m \\leq 2\\cdot 10^5$.\n\nSkibidus has obtained two arrays $a$ and $b$, containing $n$ and $m$ elements respectively. For each integer $i$ from $1$ to $n$, he is allowed to perform the operation at most once:\n\n- Choose an integer $j$ such that $1 \\leq j \\leq m$. Set $a_i := b_j - a_i$. Note that $a_i$ may become non-positive as a result of this operation.\n\nSkibidus needs your help determining whether he can sort $a$ in non-decreasing order$^{\\text{\u2217}}$ by performing the above operation some number of times.\n\n$^{\\\\text{\u2217}}$$a$ is sorted in non-decreasing order if $a\\_1 \\\\leq a\\_2 \\\\leq \\\\ldots \\\\leq a\\_n$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n \\leq 2 \\cdot 10^5$, $1 \\leq m \\leq 2\\cdot 10^5$).\n\nThe following line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$).\n\nThe following line of each test case contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($1 \\leq b_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, if it is possible to sort $a$ in non-decreasing order, print \"YES\" on a new line. Otherwise, print \"NO\" on a new line.\n\nYou can output the answer in any case. For example, the strings \"yEs\", \"yes\", and \"Yes\" will also be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1 3\n\n5\n\n9 1 1000000000\n\n3 2\n\n1 4 3\n\n3 4\n\n4 3\n\n2 4 6 5\n\n6 1 8\n\n5 2\n\n6 4 5 4 5\n\n4 1000\n\n3 1\n\n9 8 7\n\n8\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nNO\nYES\n```\n\n### Note\n\nIn the first test case, $[5]$ is already sorted.\n\nIn the second test case, it can be shown that it is impossible.\n\nIn the third test case, we can set $a_2:=b_1-a_2=6-4=2$ and $a_3:=b_3-a_3=8-6=2$. The sequence $[2,2,2,5]$ is in nondecreasing order.\n\nIn the last case, we can apply operations on each index. The sequence becomes $[-1,0,1]$, which is in nondecreasing order.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    for (int test = 0; test < t; test++) {\n        int n, m;\n        cin >> n >> m;\n        vector<long long> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        vector<long long> b(m);\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n        sort(b.begin(), b.end());\n        long long prev = LLONG_MIN;\n        bool possible = true;\n        for (int i = 0; i < n; i++) {\n            long long ai = a[i];\n            vector<long long> possible_x;\n            if (ai >= prev) {\n                possible_x.push_back(ai);\n            }\n            long long target = prev + ai;\n            auto it = lower_bound(b.begin(), b.end(), target);\n            if (it != b.end()) {\n                long long candidate = (*it) - ai;\n                if (candidate >= prev) {\n                    possible_x.push_back(candidate);\n                }\n            }\n            if (possible_x.empty()) {\n                possible = false;\n                break;\n            }\n            long long x = *min_element(possible_x.begin(), possible_x.end());\n            prev = x;\n        }\n        if (possible) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2065b",
      "PROBLEM_ID": "2065B",
      "PROBLEM_STATEMENT": "Skibidus is given a string $s$ that consists of lowercase Latin letters. If $s$ contains more than $1$ letter, he can:\n\n- Choose an index $i$ ($1 \\leq i \\leq |s| - 1$, $|s|$ denotes the current length of $s$) such that $s_i = s_{i+1}$. Replace $s_i$ with any lowercase Latin letter of his choice. Remove $s_{i+1}$ from the string.\n\nSkibidus must determine the minimum possible length he can achieve through any number of operations.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases.\n\nThe only line of each test case contains a string $s$ ($1 \\leq |s| \\leq 100$). It is guaranteed $s$ only contains lowercase Latin letters.\n\n### Output\n\nFor each test case, output an integer on the new line, the minimum achievable length of $s$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\nbaa\n\nskibidus\n\ncc\n\nohio\n\n```\n\n#### Output #1\n\n```\n1\n8\n1\n4\n```\n\n### Note\n\nIn the first test case, Skibidus can:\n\n- Perform an operation on $i = 2$. He replaces $s_2$ with b and removes $s_3$ from the string. Then, $s$ becomes bb.\n- Perform an operation on $i = 1$. He replaces $s_1$ with b and removes $s_2$ from the string. Then, $s$ becomes b.\n- Because $s$ only contains $1$ letter, Skibidus cannot perform any more operations.\n\nTherefore, the answer is $1$ for the first test case.\n\nIn the second test case, he cannot perform an operation on any index. Therefore, the answer is still the length of the initial string, $8$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        string s;\n        cin >> s;\n        bool has_pair = false;\n        for (int i = 0; i < s.size() - 1; ++i) {\n            if (s[i] == s[i+1]) {\n                has_pair = true;\n                break;\n            }\n        }\n        if (has_pair) {\n            cout << 1 << endl;\n        } else {\n            cout << s.size() << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2065a",
      "PROBLEM_ID": "2065A",
      "PROBLEM_STATEMENT": "Skibidus lands on a foreign planet, where the local Amog tribe speaks the Amog'u language. In Amog'u, there are two forms of nouns, which are singular and plural.\n\nGiven that the root of the noun is transcribed as $S$, the two forms are transcribed as:\n\n- Singular: $S$ $+$ \"us\"\n- Plural: $S$ $+$ \"i\"\n\nHere, $+$ denotes [string concatenation](https://en.wikipedia.org/wiki/Concatenation). For example, abc $+$ def $=$ abcdef.\n\nFor example, when $S$ is transcribed as \"amog\", then the singular form is transcribed as \"amogus\", and the plural form is transcribed as \"amogi\". Do note that Amog'u nouns can have an empty root \u2014 in specific, \"us\" is the singular form of \"i\" (which, on an unrelated note, means \"imposter\" and \"imposters\" respectively).\n\nGiven a transcribed Amog'u noun in singular form, please convert it to the transcription of the corresponding plural noun.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe only line of each test case contains a string $W$, which is a transcribed Amog'u noun in singular form. It is guaranteed that $W$ consists of only lowercase English letters, has a length of at most $10$, and ends with \"us\".\n\n### Output\n\nFor each test case, output the transcription of the corresponding plural noun on a separate line.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\nus\n\nsus\n\nfungus\n\ncactus\n\nsussus\n\namogus\n\nchungus\n\nntarsus\n\nskibidus\n\n```\n\n#### Output #1\n\n```\ni\nsi\nfungi\ncacti\nsussi\namogi\nchungi\nntarsi\nskibidi\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;  // number of test cases\n    \n    while (t--) {\n        string word;\n        cin >> word;\n        \n        // Since we're guaranteed that the word ends with \"us\",\n        // we can remove the last two characters and add \"i\"\n        word.pop_back();  // remove 's'\n        word.pop_back();  // remove 'u'\n        word += \"i\";\n        \n        cout << word << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2064f",
      "PROBLEM_ID": "2064F",
      "PROBLEM_STATEMENT": "You are given an array $a$ of length $n$ and an integer $k$.\n\nCall a non-empty array $b$ of length $m$ epic if there exists an integer $i$ where $1 \\le i < m$ and $\\min(b_1,\\ldots,b_i) + \\max(b_{i + 1},\\ldots,b_m) = k$.\n\nCount the number of epic subarrays$^{\\text{\u2217}}$ of $a$.\n\n$^{\\text{\u2217}}$An array $a$ is a subarray of an array $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of testcases.\n\nThe first line of each testcase contains integers $n$ and $k$ ($2 \\le n \\le 2 \\cdot 10^5$; $n < k < 2 \\cdot n$)\u00a0\u2014 the length of the array $a$ and $k$.\n\nThe second line of each testcase contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le n$).\n\nThe sum of $n$ across all testcases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each testcase, output the number of epic contiguous subarrays of $a$.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n5 7\n\n1 2 3 4 5\n\n7 13\n\n6 6 6 6 7 7 7\n\n6 9\n\n4 5 6 6 5 1\n\n5 9\n\n5 5 4 5 5\n\n5 6\n\n3 3 3 3 3\n\n6 8\n\n4 5 4 5 4 5\n\n```\n\n#### Output #1\n\n```\n2\n12\n3\n8\n10\n4\n```\n\n### Note\n\nThese are all the epic subarrays in the first testcase:\n\n- $[2, 3, 4, 5]$, because $\\min(2, 3) + \\max(4, 5) = 2 + 5 = 7$.\n- $[3, 4]$, because $\\min(3) + \\max(4) = 3 + 4 = 7$.\n\nIn the second test case, every subarray that contains at least one $6$ and at least one $7$ is epic.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define debug(x) cout << #x << \" = \" << x << \"\\n\";\n#define vdebug(a) cout << #a << \" = \"; for(auto x: a) cout << x << \" \"; cout << \"\\n\";\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint uid(int a, int b) { return uniform_int_distribution<int>(a, b)(rng); }\nll uld(ll a, ll b) { return uniform_int_distribution<ll>(a, b)(rng); }\n\ntemplate <class T> struct SegTree{\n    vector<T> seg;\n    int n;\n    const T ID = {INT_MAX, -INT_MAX};\n    \n    T cmb(T a, T b){\n        array<int, 2> res;\n        res[0] = min(a[0], b[0]);\n        res[1] = max(a[1], b[1]);\n        return res;\n    }\n    \n    SegTree(int _n){\n        n = 1;\n        while (n < _n) n *= 2;\n        seg.assign(2 * n + 1, ID);\n    }\n    \n    void set(int pos, T val){\n        seg[pos + n] = val;\n    }\n    \n    void build(){\n        for (int i = n - 1; i >= 1; i--) seg[i] = cmb(seg[2 * i], seg[2 * i + 1]);\n    }\n    \n    void upd(int v, int tl, int tr, int pos, T val){\n        if (tl == tr){\n            seg[v] = val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm) upd(2 * v, tl, tm, pos, val);\n            else upd(2 * v + 1, tm + 1, tr, pos, val);\n            seg[v] = cmb(seg[2 * v], seg[2 * v + 1]);\n        }\n    }\n    \n    void upd(int pos, T val){\n        upd(1, 0, n - 1, pos, val);\n    }\n    \n    T query(int v, int tl, int tr, int l, int r){\n        if (l > r) return ID;\n        if (l == tl && r == tr) return seg[v];\n        int tm = (tl + tr) / 2;\n        T res = query(2 * v, tl, tm, l, min(tm, r));\n        res = cmb(res, query(2 * v + 1, tm + 1, tr, max(l, tm + 1), r));\n        return res;\n    }\n    \n    T query(int l, int r){\n        return query(1, 0, n - 1, l, r);\n    }\n};\n\nvoid solve(){\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> a(n);\n    for (int &x : a) cin >> x;\n\n    vector<vector<int>> p(n + 1);\n    for (int i = 0; i < n; i++)\n        p[a[i]].push_back(i);\n    \n    vector<array<int, 2>> stk;\n    vector<int> small_l(n, -1), small_r(n, n), big_l(n, -1), big_r(n, n);\n\n    for (int i = 0; i < n; i++){\n        while (stk.size() && a[i] <= stk.back()[0])\n            stk.pop_back();\n\n        if (stk.size())\n            small_l[i] = stk.back()[1];\n        stk.push_back({a[i], i});\n    }\n\n    stk.clear();\n    for (int i = n - 1; i >= 0; i--){\n        while (stk.size() && a[i] >= stk.back()[0])\n            stk.pop_back();\n\n        if (stk.size())\n            big_r[i] = stk.back()[1];\n        stk.push_back({a[i], i});\n    }\n\n    ll ans = 0;\n    SegTree<array<int, 2>> seg_small(n), seg_big(n);\n\n    for (int x = 1; x <= n; x++){\n        int y = k - x;\n        if (y > n){\n            for (int pos : p[x])\n                seg_small.upd(pos, {pos, pos});\n            continue;\n        }\n\n        vector<int> pre(p[y].size());\n        for (int i = 0; i < p[y].size(); i++){\n            if (i > 0)\n                pre[i] += pre[i - 1];\n\n            int r = big_r[p[y][i]] - 1;\n            if (i < p[y].size() - 1)\n                r = min(r, p[y][i + 1] - 1);\n            pre[i] += r - p[y][i] + 1;\n        }\n\n        vector<int> first(p[x].size()), last(p[y].size());\n        for (int i = 0; i < p[x].size(); i++)\n            first[i] = seg_small.query(p[x][i], n - 1)[0];\n\n        for (int i = 0; i < p[y].size(); i++)\n            last[i] = seg_big.query(0, p[y][i])[1];\n\n        int prev = -1;\n        for (int i = 0; i < p[x].size(); i++){\n            int l = p[x][i];\n            int l_min = small_l[l] + 1;\n            l_min = max(l_min, prev + 1);\n            prev = l;\n\n            int nxt = upper_bound(p[y].begin(), p[y].end(), l) - p[y].begin();\n            if (nxt == p[y].size())\n                continue;\n       \n            int lo = nxt, hi = p[y].size();\n            while (lo < hi){\n                int mid = (lo + hi) / 2;\n\n                int pos = p[y][mid];\n                if (first[i] <= last[mid])\n                    hi = mid;\n                else\n                    lo = mid + 1;\n            }\n\n            lo--;\n            if (lo < nxt)\n                continue;\n\n            int res = pre[lo];\n            if (nxt > 0)\n                res -= pre[nxt - 1];\n\n            ans += 1LL * (l - l_min + 1) * res;\n        }\n\n        for (int pos : p[x])\n            seg_small.upd(pos, {pos, pos});\n        for (int pos : p[y])\n            seg_big.upd(pos, {pos, pos});\n    }\n\n    cout << ans << \"\\n\";\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    \n    int t;\n    cin >> t;\n    while (t--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2064e",
      "PROBLEM_ID": "2064E",
      "PROBLEM_STATEMENT": "Steve has a permutation$^{\\text{\u2217}}$ $p$ and an array $c$, both of length $n$. Steve wishes to sort the permutation $p$.\n\nSteve has an infinite supply of coloured sand blocks, and using them he discovered a physics-based way to sort an array of numbers called gravity sort. Namely, to perform gravity sort on $p$, Steve will do the following:\n\n- For all $i$ such that $1 \\le i \\le n$, place a sand block of color $c_i$ in position $(i, j)$ for all $j$ where $1 \\le j \\le p_i$. Here, position $(x, y)$ denotes a cell in the $x$-th row from the top and $y$-th column from the left.\n- Apply downwards gravity to the array, so that all sand blocks fall as long as they can fall.\n\n![](https://espresso.codeforces.com/bc9da7db75c1cd76ae4b448579a882a11a989364.png)An example of gravity sort for the third testcase. $p = [4, 2, 3, 1, 5]$, $c = [2, 1, 4, 1, 5]$\n\nAlex looks at Steve's sand blocks after performing gravity sort and wonders how many pairs of arrays $(p',c')$ where $p'$ is a permutation would have resulted in the same layout of sand. Note that the original pair of arrays $(p, c)$ will always be counted.\n\nPlease calculate this for Alex. As this number could be large, output it modulo $998\\,244\\,353$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is a $4$ in the array).\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each testcase contains an integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the lengths of the arrays.\n\nThe second line of each testcase contains $n$ distinct integers $p_1,p_2,\\ldots,p_n$ ($1 \\le p_i \\le n$)\u00a0\u2014 the elements of $p$.\n\nThe following line contains $n$ integers $c_1,c_2,\\ldots,c_n$ ($1 \\le c_i \\le n$)\u00a0\u2014 the elements of $c$.\n\nThe sum of $n$ across all testcases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each testcase, output the number of pairs of arrays $(p', c')$ Steve could have started with, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n1\n\n1\n\n5\n\n5 3 4 1 2\n\n1 1 1 1 1\n\n5\n\n4 2 3 1 5\n\n2 1 4 1 5\n\n40\n\n29 15 20 35 37 31 27 1 32 36 38 25 22 8 16 7 3 28 11 12 23 4 14 9 39 13 10 30 6 2 24 17 19 5 34 18 33 26 40 21\n\n3 1 2 2 1 2 3 1 1 1 1 2 1 3 1 1 3 1 1 1 2 2 1 3 3 3 2 3 2 2 2 2 1 3 2 1 1 2 2 2\n\n```\n\n#### Output #1\n\n```\n1\n120\n1\n143654893\n```\n\n### Note\n\nThe second test case is shown below.\n\n![](https://espresso.codeforces.com/0be3e1a1e38f8485a0af76fd4cafe659e8413522.png)Gravity sort of the second testcase.\n\nIt can be shown that permutations of $p$ will yield the same result, and that $c$ must equal $[1,1,1,1,1]$ (since all sand must be the same color), so the answer is $5! = 120$.\n\nThe third test case is shown in the statement above. It can be proven that no other arrays $p$ and $c$ will produce the same final result, so the answer is $1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define debug(x) cout << #x << \" = \" << x << \"\\n\";\n#define vdebug(a) cout << #a << \" = \"; for(auto x: a) cout << x << \" \"; cout << \"\\n\";\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint uid(int a, int b) { return uniform_int_distribution<int>(a, b)(rng); }\nll uld(ll a, ll b) { return uniform_int_distribution<ll>(a, b)(rng); }\n\nconst int MOD = 998244353;\n\ntemplate<ll mod> // template was not stolen from https://codeforces.com/profile/SharpEdged\nstruct modnum {\n    static constexpr bool is_big_mod = mod > numeric_limits<int>::max();\n\n    using S = conditional_t<is_big_mod, ll, int>;\n    using L = conditional_t<is_big_mod, __int128, ll>;\n\n    S x;\n\n    modnum() : x(0) {}\n    modnum(ll _x) {\n        _x %= static_cast<ll>(mod);\n        if (_x < 0) { _x += mod; }\n        x = _x;\n    }\n\n    modnum pow(ll n) const {\n        modnum res = 1;\n        modnum cur = *this;\n        while (n > 0) {\n            if (n & 1) res *= cur;\n            cur *= cur;\n            n /= 2;\n        }\n        return res;\n    }\n    modnum inv() const { return (*this).pow(mod-2); }\n    \n    modnum& operator+=(const modnum& a){\n        x += a.x;\n        if (x >= mod) x -= mod;\n        return *this;\n    }\n    modnum& operator-=(const modnum& a){\n        if (x < a.x) x += mod;\n        x -= a.x;\n        return *this;\n    }\n    modnum& operator*=(const modnum& a){\n        x = static_cast<L>(x) * a.x % mod;\n        return *this;\n    }\n    modnum& operator/=(const modnum& a){ return *this *= a.inv(); }\n    \n    friend modnum operator+(const modnum& a, const modnum& b){ return modnum(a) += b; }\n    friend modnum operator-(const modnum& a, const modnum& b){ return modnum(a) -= b; }\n    friend modnum operator*(const modnum& a, const modnum& b){ return modnum(a) *= b; }\n    friend modnum operator/(const modnum& a, const modnum& b){ return modnum(a) /= b; }\n    \n    friend bool operator==(const modnum& a, const modnum& b){ return a.x == b.x; }\n    friend bool operator!=(const modnum& a, const modnum& b){ return a.x != b.x; }\n    friend bool operator<(const modnum& a, const modnum& b){ return a.x < b.x; }\n\n    friend ostream& operator<<(ostream& os, const modnum& a){ os << a.x; return os; }\n    friend istream& operator>>(istream& is, modnum& a) { ll x; is >> x; a = modnum(x); return is; }\n};\n\nusing mint = modnum<MOD>;\n\ntemplate <class T> struct SegTree{\n    vector<T> seg;\n    int n;\n    const T ID = 0;\n    \n    T cmb(T a, T b){\n        return max(a, b);\n    }\n    \n    SegTree(int _n){\n        n = 1;\n        while (n < _n) n *= 2;\n        seg.assign(2 * n + 1, ID);\n    }\n    \n    void set(int pos, T val){\n        seg[pos + n] = val;\n    }\n    \n    void build(){\n        for (int i = n - 1; i >= 1; i--) seg[i] = cmb(seg[2 * i], seg[2 * i + 1]);\n    }\n    \n    void upd(int v, int tl, int tr, int pos, T val){\n        if (tl == tr){\n            seg[v] = val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm) upd(2 * v, tl, tm, pos, val);\n            else upd(2 * v + 1, tm + 1, tr, pos, val);\n            seg[v] = cmb(seg[2 * v], seg[2 * v + 1]);\n        }\n    }\n    \n    void upd(int pos, T val){\n        upd(1, 0, n - 1, pos, val);\n    }\n    \n    T query(int v, int tl, int tr, int l, int r){\n        if (l > r) return ID;\n        if (l == tl && r == tr) return seg[v];\n        int tm = (tl + tr) / 2;\n        T res = query(2 * v, tl, tm, l, min(tm, r));\n        res = cmb(res, query(2 * v + 1, tm + 1, tr, max(l, tm + 1), r));\n        return res;\n    }\n    \n    T query(int l, int r){\n        return query(1, 0, n - 1, l, r);\n    }\n};\n\nstruct DSU{\n    vector<int> p, sz, used, mn, mx;\n    \n    DSU(int n){\n        p.assign(n, 0);\n        sz.assign(n, 1);\n        used.assign(n, 0);\n        mx.assign(n, 0);\n        mn.assign(n, 0);\n\n        for (int i = 0; i < n; i++) p[i] = i;\n    }\n    \n    int find(int u){\n        if (p[u] == u) return u;\n        p[u] = find(p[u]);\n        return p[u];\n    }\n    \n    void unite(int u, int v){\n        u = find(u);\n        v = find(v);\n        if (u == v) return;\n        \n        if (sz[u] < sz[v]) swap(u, v);\n        p[v] = u;\n        sz[u] += sz[v];\n        used[u] += used[v];\n        mn[u] = min(mn[u], mn[v]);\n        mx[u] = max(mx[u], mx[v]);\n    }\n    \n    bool same(int u, int v){\n        return find(u) == find(v);\n    }\n    \n    int size(int u){\n        u = find(u);\n        return sz[u];\n    }\n};\n\nvoid solve(){\n    int n;\n    cin >> n;\n\n    vector<int> a(n), b(n);\n    for (int &x : a) cin >> x;\n    for (int &x : b) cin >> x;\n\n    vector<vector<int>> col(n + 1);\n    for (int i = 0; i < n; i++){\n        col[b[i]].push_back(i);\n    }\n\n    vector<vector<int>> ord(n + 1);\n\n    for (int i = 0; i <= n; i++){\n        ord[i] = col[i];\n        sort(ord[i].begin(), ord[i].end(), [&](int x, int y) -> bool{\n            return a[x] < a[y];\n        });\n    }\n\n    SegTree<int> seg(n);\n    for (int i = 0; i < n; i++){\n        seg.set(i, a[i]);\n    } seg.build();\n\n    mint ans = 1;\n    DSU dsu(n);\n    for (int i = 0; i <= n; i++){\n        for (int j = 0; j < col[i].size(); j++){\n            dsu.mn[col[i][j]] = j;\n            dsu.mx[col[i][j]] = j;\n        }\n    }\n\n    for (int i = 0; i <= n; i++){\n        for (int x : ord[i]) seg.upd(x, 0);\n\n        for (int x : ord[i]){\n            int idx = lower_bound(col[i].begin(), col[i].end(), x) - col[i].begin();\n            for (int j = idx + 1; j < col[i].size(); j++){\n                if (seg.query(x, col[i][j]) >= a[x]) break;\n\n                dsu.unite(x, col[i][j]);\n                j = dsu.mx[dsu.find(x)];\n            }\n\n            for (int j = idx - 1; j >= 0; j--){\n                if (seg.query(col[i][j], x) >= a[x]) break;\n\n                dsu.unite(x, col[i][j]);\n                j = dsu.mn[dsu.find(x)];\n            }\n\n            int u = dsu.find(x);\n            ans *= dsu.size(u) - dsu.used[u];\n            dsu.used[u]++;\n        }\n\n        for (int x : ord[i]) seg.upd(x, a[x]);\n    }\n\n    cout << ans << \"\\n\";\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    \n    int t;\n    cin >> t;\n    while (t--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2064d",
      "PROBLEM_ID": "2064D",
      "PROBLEM_STATEMENT": "There are $n$ slimes on a line, the $i$-th of which has weight $w\\_i$. Slime $i$ is able to eat another slime $j$ if $w\\_i \\\\geq w\\_j$; afterwards, slime $j$ disappears and the weight of slime $i$ becomes $w\\_i \\\\oplus w\\_j$$^{\\\\text{\u2217}}$.\n\nThe King of Slimes wants to run an experiment with parameter $x$ as follows:\n\n- Add a new slime with weight $x$ to the right end of the line (after the $n$-th slime).\n- This new slime eats the slime to its left if it is able to, and then takes its place (moves one place to the left). It will continue to do this until there is either no slime to its left or the weight of the slime to its left is greater than its own weight. (No other slimes are eaten during this process.)\n- The score of this experiment is the total number of slimes eaten.\n\nThe King of Slimes is going to ask you $q$ queries. In each query, you will be given an integer $x$, and you need to determine the score of the experiment with parameter $x$.\n\nNote that the King does not want you to actually perform each experiment; his slimes would die, which is not ideal. He is only asking what the hypothetical score is; in other words, the queries are not persistent.\n\n$^{\\text{\u2217}}$Here $\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of slimes and the number of queries, respectively.\n\nThe following line contains $n$ integers $w_1,w_2,\\ldots,w_n$ ($1 \\le w_i < 2^{30}$)\u00a0\u2014 the weights of the slimes.\n\nThe following $q$ lines contain a single integer $x$ ($ 1 \\le x < 2^{30}$)\u00a0\u2014 the parameter for the experiment.\n\nThe sum of $n$ does not exceed $2 \\cdot 10^5$ and the sum of $q$ does not exceed $2 \\cdot 10^5$ across all test cases.\n\n### Output\n\nFor each query, output a single integer\u00a0\u2014 the score of the experiment.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n1 1\n\n5\n\n6\n\n4 4\n\n1 5 4 11\n\n8\n\n13\n\n16\n\n15\n\n10 9\n\n10 4 3 9 7 4 6 1 9 4\n\n2\n\n6\n\n5\n\n6\n\n9\n\n8\n\n6\n\n2\n\n7\n\n```\n\n#### Output #1\n\n```\n1\n0 2 4 2\n0 1 1 1 3 3 1 0 1\n```\n\n### Note\n\nFor the first query of the second testcase:\n\n- A slime of weight $8$ would be added to the end, so $w = [1, 5, 4, 11, \\color{red}8]$.\n- The added slime has smaller weight than the slime to its left so it cannot eat it, and thus ends the process after eating no slimes with score $0$.\n\nFor the second query of the second testcase:\n\n- A slime of weight $13$ would be added to the end, so $w = [1, 5, 4, 11, \\color{red}{13}]$.\n- The added slime has bigger weight than the slime to its left, and so it will eat it. Its weight will become $13 \\oplus 11 = 6$. Now $w = [1, 5, 4, \\color{red}{6}]$.\n- The added slime will now eat the slime to its left, and its weight becomes $6 \\oplus 4 = 2$. Now $w = [1, 5, \\color{red}{2}]$.\n- The added slime is no longer able to eat the slime to its left, so it ends the process with a score of $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Node for the binary trie. \n// ch[0], ch[1]: child pointers for bit 0/1.\n// head: head of linked list of query indices (for leaves).\nstruct Node {\n    int ch[2];\n    int head;\n    Node() {\n        ch[0] = ch[1] = 0;\n        head = -1;\n    }\n};\n\nstatic const int BIT_MAX = 29;\n\nvector<Node> nodes;\nvector<int> nextArr;\nvector<int> ans;\nlong long alive;\nint curr_ans_i;\n\n// Collect and remove all query indices in the subtree rooted at u.\n// Assign ans[id] = curr_ans_i for each collected id.\n// Decrement 'alive' accordingly. Prune the subtree edges.\nvoid collect_ids(int u) {\n    if (!u) return;\n    // First, process any query ids at this node.\n    if (nodes[u].head != -1) {\n        int id = nodes[u].head;\n        nodes[u].head = -1;\n        while (id != -1) {\n            ans[id] = curr_ans_i;\n            alive--;\n            int nxt = nextArr[id];\n            id = nxt;\n        }\n    }\n    // Recurse on children and cut them off.\n    int c0 = nodes[u].ch[0];\n    if (c0) {\n        collect_ids(c0);\n        nodes[u].ch[0] = 0;\n    }\n    int c1 = nodes[u].ch[1];\n    if (c1) {\n        collect_ids(c1);\n        nodes[u].ch[1] = 0;\n    }\n}\n\n// Remove from the trie all x such that (x XOR S_prev) < Ai.\n// We walk the trie, using the classic XOR-trie < bound logic.\n// Whenever a whole subtree satisfies the condition, we collect it.\nvoid remove_x(int u, int bit, int S_prev, int Ai) {\n    if (!u || bit < 0) return;\n    int Cbit = (S_prev >> bit) & 1;\n    int Abit = (Ai    >> bit) & 1;\n    // Capture children now, because we may modify nodes[u].ch[]\n    int c0 = nodes[u].ch[0];\n    int c1 = nodes[u].ch[1];\n    // Handle child 0\n    if (c0) {\n        int b = 0;\n        int yb = b ^ Cbit; // (x_bit XOR Cbit) at this position\n        if (Abit == 1 && yb == 0) {\n            // y_bit < A_bit, so whole subtree c0 has y < A => remove all\n            collect_ids(c0);\n            nodes[u].ch[0] = 0;\n        } else if ((Abit == 1 && yb == 1) || (Abit == 0 && yb == 0)) {\n            // y_bit == A_bit, must continue checking deeper\n            remove_x(c0, bit - 1, S_prev, Ai);\n        }\n        // else (Abit==0 && yb==1) => y_bit > A_bit, no x in this subtree can satisfy y<A\n    }\n    // Handle child 1\n    if (c1) {\n        int b = 1;\n        int yb = b ^ Cbit;\n        if (Abit == 1 && yb == 0) {\n            collect_ids(c1);\n            nodes[u].ch[1] = 0;\n        } else if ((Abit == 1 && yb == 1) || (Abit == 0 && yb == 0)) {\n            remove_x(c1, bit - 1, S_prev, Ai);\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, q;\n        cin >> n >> q;\n        vector<int> w(n);\n        for (int i = 0; i < n; i++) {\n            cin >> w[i];\n        }\n        // Build A and prefix-XOR S for the reversed weights.\n        // A[1] = w[n-1], A[2] = w[n-2], ..., A[n] = w[0]\n        vector<int> A(n+1), S(n+1);\n        S[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            A[i] = w[n - i];\n            S[i] = S[i-1] ^ A[i];\n        }\n        vector<int> xs(q);\n        for (int i = 0; i < q; i++) {\n            cin >> xs[i];\n        }\n\n        // Initialize the trie and auxiliary arrays.\n        nodes.clear();\n        // Reserve enough nodes: each query can add up to BIT_MAX+1 nodes.\n        nodes.reserve((size_t)(q + 5) * (BIT_MAX + 1));\n        // node 0 unused, node 1 is the root\n        nodes.emplace_back();\n        nodes.emplace_back();\n        int root = 1;\n\n        ans.assign(q, -1);\n        nextArr.assign(q, -1);\n        alive = q;\n\n        // Insert all queries x into the trie; at each leaf store the list of query indices.\n        for (int i = 0; i < q; i++) {\n            int x = xs[i];\n            int u = root;\n            for (int bit = BIT_MAX; bit >= 0; bit--) {\n                int b = (x >> bit) & 1;\n                if (!nodes[u].ch[b]) {\n                    nodes[u].ch[b] = (int)nodes.size();\n                    nodes.emplace_back();\n                }\n                u = nodes[u].ch[b];\n            }\n            // Push query index i onto the leaf's linked list\n            nextArr[i] = nodes[u].head;\n            nodes[u].head = i;\n        }\n\n        // Sweep positions i = 1..n. At step i we check the condition for A[i].\n        // Queries that fail at this step get ans = i-1 and are removed from the trie.\n        for (int i = 1; i <= n && alive > 0; i++) {\n            curr_ans_i = i - 1;\n            remove_x(root, BIT_MAX, S[i-1], A[i]);\n        }\n        // Remaining queries never failed => they eat all n slimes.\n        for (int i = 0; i < q; i++) {\n            if (ans[i] < 0) ans[i] = n;\n        }\n        // Output answers in the original query order.\n        for (int i = 0; i < q; i++) {\n            cout << ans[i] << (i+1<q ? ' ' : '\\n');\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2064c",
      "PROBLEM_ID": "2064C",
      "PROBLEM_STATEMENT": "You have an array $a$ of length $n$ consisting of non-zero integers. Initially, you have $0$ coins, and you will do the following until $a$ is empty:\n\n- Let $m$ be the current size of $a$. Select an integer $i$ where $1 \\\\le i \\\\le m$, gain $\\|a\\_i\\|$$^{\\\\text{\u2217}}$ coins, and then:\n  - if $a_i < 0$, then replace $a$ with $[a_1,a_2,\\ldots,a_{i - 1}]$ (that is, delete the suffix beginning with $a_i$);\n  - otherwise, replace $a$ with $[a_{i + 1},a_{i + 2},\\ldots,a_m]$ (that is, delete the prefix ending with $a_i$).\n\nFind the maximum number of coins you can have at the end of the process.\n\n$^{\\text{\u2217}}$Here $|a_i|$ represents the absolute value of $a_i$: it equals $a_i$ when $a_i > 0$ and $-a_i$ when $a_i < 0$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of testcases.\n\nThe first line of each testcase contains an integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of $a$.\n\nThe second line of each testcase contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($-10^9 \\le a_i \\le 10^9$, $a_i \\ne 0$).\n\nThe sum of $n$ across all testcases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the maximum number of coins you can have at the end of the process.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n6\n\n3 1 4 -1 -5 -9\n\n6\n\n-10 -3 -17 1 19 20\n\n1\n\n1\n\n```\n\n#### Output #1\n\n```\n23\n40\n1\n```\n\n### Note\n\nAn example of how to get $23$ coins in the first testcase is as follows:\n\n- $a = [3, 1, 4, -1, -5, \\color{red}{-9}] \\xrightarrow{i = 6} a = [3, 1, 4, -1, -5] $, and get $9$ coins.\n- $a = [\\color{red}{3}, 1, 4, -1, -5] \\xrightarrow{i = 1} a = [1, 4, -1, -5] $, and get $3$ coins.\n- $a = [\\color{red}{1}, 4, -1, -5] \\xrightarrow{i = 1} a = [4, -1, -5] $, and get $1$ coin.\n- $a = [4, -1, \\color{red}{-5}] \\xrightarrow{i = 3} a = [4, -1] $, and get $5$ coins.\n- $a = [4, \\color{red}{-1}] \\xrightarrow{i = 2} a = [4] $, and get $1$ coin.\n- $a = [\\color{red}{4}] \\xrightarrow{i = 1} a = [] $, and get $4$ coins.\n\nAfter all the operations, you have $23$ coins.\n\nAn example of how to get $40$ coins in the second testcase is as follows:\n\n- $a = [-10, -3, -17, \\color{red}{1}, 19, 20] \\xrightarrow{i = 4} a = [19, 20] $, and get $1$ coin.\n- $a = [\\color{red}{19}, 20] \\xrightarrow{i = 1} a = [20] $, and get $19$ coins.\n- $a = [\\color{red}{20}] \\xrightarrow{i = 1} a = [] $, and get $20$ coins.\n\nAfter all the operations, you have $40$ coins.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<long long> a(n);\n        for(int i = 0; i < n; i++){\n            cin >> a[i];\n        }\n        \n        // pref[i] will be the sum of positives in a[0] to a[i-1]\n        vector<long long> pref(n+1, 0);\n        for (int i = 0; i < n; i++){\n            pref[i+1] = pref[i] + (a[i] > 0 ? a[i] : 0);\n        }\n        \n        // suf[i] will be the sum of absolute values of negatives in a[i] to a[n-1]\n        // for index n, we define suf[n] = 0.\n        vector<long long> suf(n+1, 0);\n        suf[n] = 0;\n        for (int i = n-1; i >= 0; i--){\n            suf[i] = suf[i+1] + (a[i] < 0 ? -a[i] : 0);\n        }\n \n        long long ans = 0;\n        // We try every split x (0 <= x <= n):\n        // In other words, take positives from indices [0, x-1] and negatives from indices [x, n-1]\n        for (int x = 0; x <= n; x++){\n            long long candidate = pref[x] + suf[x];\n            ans = max(ans, candidate);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2064b",
      "PROBLEM_ID": "2064B",
      "PROBLEM_STATEMENT": "Define the score of an arbitrary array $b$ to be the length of $b$ minus the number of distinct elements in $b$. For example:\n\n- The score of $[1, 2, 2, 4]$ is $1$, as it has length $4$ and only $3$ distinct elements ($1$, $2$, $4$).\n- The score of $[1, 1, 1]$ is $2$, as it has length $3$ and only $1$ distinct element ($1$).\n- The empty array has a score of $0$.\n\nYou have an array $a$. You need to remove some non-empty contiguous subarray from $a$ at most once.\n\nMore formally, you can do the following at most once:\n\n- pick two integers $l$, $r$ where $1 \\le l \\le r \\le n$, and\n- delete the contiguous subarray $[a_l,\\ldots,a_r]$ from $a$ (that is, replace $a$ with $[a_1,\\ldots,a_{l - 1},a_{r + 1},\\ldots,a_n]$).\n\nOutput an operation such that the score of $a$ is maximum; if there are multiple answers, output one that minimises the final length of $a$ after the operation. If there are still multiple answers, you may output any of them.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of testcases.\n\nThe first line of each testcase contains an integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of the array $a$.\n\nThe second line of each testcase contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le n$).\n\nThe sum of $n$ across all testcases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each testcase, if you wish to not make a move, output $0$.\n\nOtherwise, output two integers $l$ and $r$ ($1 \\le l \\le r \\le n$), representing the left and right bound of the removed subarray.\n\nThe removed subarray should be chosen such that the score is maximized, and over all such answers choose any of them that minimises the final length of the array.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n1\n\n1\n\n5\n\n1 1 1 1 1\n\n4\n\n2 1 3 2\n\n```\n\n#### Output #1\n\n```\n1 1\n0\n2 3\n```\n\n### Note\n\nIn the first testcase, we have two options:\n\n- do nothing: the score of $[1]$ is $1-1=0$.\n- remove the subarray with $l=1$, $r=1$: we remove the only element, and we get an empty array with score $0$.\n\nTherefore, the maximum score possible is $0$. However, since we need to additionally minimise the final length of the array, we must output the second option with $l=r=1$. Note that the first option of doing nothing is incorrect, since it has a longer final length.\n\nIn the second testcase, no subarray is selected, so after which $a$ is still $[1, 1, 1, 1, 1]$. This has length $5$ and $1$ distinct element, so it has a score of $5 - 1 = 4$. This can be proven to be a shortest array which maximises the score.\n\nIn the third testcase, the subarray selected is $[2, \\color{red}1, \\color{red}3, 2]$, after which $a$ becomes $[2, 2]$. This has length $2$ and $1$ distinct element, so it has a score of $2 - 1 = 1$. This can be proven to be a shortest array which maximises the score.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvoid process_test_case() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    unordered_map<int, int> min_pos;\n    unordered_map<int, int> max_pos;\n\n    for (int i = 0; i < n; ++i) {\n        if (min_pos.find(a[i]) == min_pos.end()) {\n            min_pos[a[i]] = i;\n        }\n        max_pos[a[i]] = i;\n    }\n\n    vector<bool> is_single(n, false);\n    for (int i = 0; i < n; ++i) {\n        int x = a[i];\n        if (min_pos[x] == max_pos[x]) {\n            is_single[i] = true;\n        }\n    }\n\n    int max_len = 0;\n    int start = -1;\n    int end = -1;\n    int current_len = 0;\n    int current_start = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (is_single[i]) {\n            current_len++;\n            if (current_len > max_len) {\n                max_len = current_len;\n                start = current_start;\n                end = i;\n            }\n        } else {\n            current_len = 0;\n            current_start = i + 1;\n        }\n    }\n\n    if (max_len > 0) {\n        cout << (start + 1) << \" \" << (end + 1) << endl;\n    } else {\n        cout << 0 << endl;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; ++i) {\n        process_test_case();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2064a",
      "PROBLEM_ID": "2064A",
      "PROBLEM_STATEMENT": "One day after waking up, your friend challenged you to a brogramming contest. In a brogramming contest, you are given a binary string$^{\\text{\u2217}}$ $s$ of length $n$ and an initially empty binary string $t$. During a brogramming contest, you can make either of the following moves any number of times:\n\n- remove some suffix$^{\\text{\u2020}}$ from $s$ and place it at the end of $t$, or\n- remove some suffix from $t$ and place it at the end of $s$.\n\nTo win the brogramming contest, you must make the minimum number of moves required to make $s$ contain only the character $\\texttt{0}$ and $t$ contain only the character $\\texttt{1}$. Find the minimum number of moves required.\n\n$^{\\text{\u2217}}$A binary string is a string consisting of characters $\\texttt{0}$ and $\\texttt{1}$.\n\n$^{\\text{\u2020}}$A string $a$ is a suffix of a string $b$ if $a$ can be obtained from deletion of several (possibly, zero or all) elements from the beginning of $b$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case is an integer $n$ ($1 \\le n \\le 1000$)\u00a0\u2014 the length of the string $s$.\n\nThe second line of each test case contains the binary string $s$.\n\nThe sum of $n$ across all test cases does not exceed $1000$.\n\n### Output\n\nFor each testcase, output the minimum number of moves required.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n5\n\n00110\n\n4\n\n1111\n\n3\n\n001\n\n5\n\n00000\n\n3\n\n101\n\n```\n\n#### Output #1\n\n```\n2\n1\n1\n0\n3\n```\n\n### Note\n\nAn optimal solution to the first test case is as follows:\n\n- $s = \\texttt{00}\\color{red}{\\texttt{110}}$, $t =$ empty string.\n- $s = \\texttt{00}$, $t = \\texttt{11}\\color{red}{\\texttt{0}}$.\n- $s = \\texttt{000}$, $t = \\texttt{11}$.\n\nIt can be proven that there is no solution using less than $2$ moves.\n\nIn the second test case, you have to move the whole string from $s$ to $t$ in one move.\n\nIn the fourth test case, you don't have to do any moves.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint solve() {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n\n    if (n == 0) {\n        return 0;\n    }\n\n    bool all_zeros = true;\n    for (char c : s) {\n        if (c == '1') {\n            all_zeros = false;\n            break;\n        }\n    }\n    if (all_zeros) {\n        return 0;\n    }\n\n    int transitions = 0;\n    for (int i = 0; i < n - 1; ++i) {\n        if (s[i] != s[i + 1]) {\n            transitions++;\n        }\n    }\n\n    if (s[0] == '1') {\n        return transitions + 1;\n    } else {\n        return transitions;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        cout << solve() << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2063f2",
      "PROBLEM_ID": "2063F2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, the limits on $t$ and $n$ are bigger. You can hack only if you solved all versions of this problem.\n\nNow Little John is rich, and so he finally buys a house big enough to fit himself and his favorite bracket sequence. But somehow, he ended up with a lot of brackets! Frustrated, he penetrates through the ceiling with the \"buddha palm\".\n\nA bracket sequence is called balanced if it can be constructed by the following formal grammar.\n\n1. The empty sequence $\\varnothing$ is balanced.\n2. If the bracket sequence $A$ is balanced, then $\\mathtt{(}A\\mathtt{)}$ is also balanced.\n3. If the bracket sequences $A$ and $B$ are balanced, then the concatenated sequence $A B$ is also balanced.\n\nFor example, the sequences \"(())()\", \"()\", \"(()(()))\", and the empty sequence are balanced, while \"(()\" and \"(()))(\" are not.\n\nGiven a balanced bracket sequence $s$, a pair of indices $(i,j)$ ($i<j$) is called a good pair if $s_i$ is '(', $s_j$ is ')', and the two brackets are added simultaneously with respect to Rule 2 while constructing the sequence $s$. For example, the sequence \"(())()\" has three different good pairs, which are $(1,4)$, $(2,3)$, and $(5,6)$. One can show that any balanced bracket sequence of $2n$ brackets contains exactly $n$ different good pairs, and using any order of rules to construct the same bracket sequence will yield the same set of good pairs.\n\nEmily will play a bracket guessing game with John. The game is played as follows.\n\nInitially, John has a balanced bracket sequence $s$ containing $n$ different good pairs, which is not known to Emily. John tells Emily the value of $n$ and asks Emily to guess the sequence.\n\nThroughout $n$ turns, John gives Emily the following kind of clue on each turn.\n\n- $l\\;r$: The sequence $s$ contains a good pair $(l,r)$.\n\nThe clues that John gives Emily are pairwise distinct and do not contradict each other.\n\nAt a certain point, Emily can be certain that the balanced bracket sequence satisfying the clues given so far is unique. For example, assume Emily knows that $s$ has $3$ good pairs, and it contains the good pair $(2,5)$. Out of $5$ balanced bracket sequences with $3$ good pairs, there exists only one such sequence \"((()))\" with the good pair $(2,5)$. Therefore, one can see that Emily does not always need $n$ turns to guess $s$.\n\nTo find out the content of $s$ as early as possible, Emily wants to know the number of different balanced bracket sequences that match the clues after each turn. Surely, this is not an easy job for Emily, especially when she is given so many good pairs. Now it is your turn to help Emily. Given the clues, you must find the answer before and after each turn. As the answers may be huge, you need to find them modulo $998\\,244\\,353$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($2 \\le n \\le 3 \\cdot 10^5$)\u00a0\u2014 the number of good pairs.\n\nThen, each of the $n$ following lines contains two integers $l_i$ and $r_i$ representing the $i$-th clue ($1 \\le l_i < r_i \\le 2n$).\n\nThe clues in one test case are pairwise distinct and do not contradict each other.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n+1$ integers on a separate line:\n\n- The first integer is the answer before all clues, modulo $998\\,244\\,353$.\n- For all $i \\ge 1$, the $i+1$-th integer is the answer after the $i$-th clue, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n2 5\n\n1 6\n\n3 4\n\n4\n\n1 6\n\n7 8\n\n2 3\n\n4 5\n\n6\n\n2 3\n\n1 6\n\n7 8\n\n9 12\n\n10 11\n\n4 5\n\n```\n\n#### Output #1\n\n```\n5 1 1 1\n14 2 2 1 1\n132 42 5 2 1 1 1\n```\n\n### Note\n\nThe first test case of the example is explained in the problem description.\n\nThe third test case of the example is explained as follows. It can be shown that there are $132$ balanced bracket sequences with $6$ good pairs. The answers after each clue are given as follows:\n\n1. You are given the good pair $(2,3)$. There are $42$ balanced bracket sequences having the good pair $(2,3)$.\n2. You are given the good pair $(1,6)$. There are $5$ balanced bracket sequences having good pairs $(2,3)$, $(1,6)$.\n3. You are given the good pair $(7,8)$. There are $2$ balanced bracket sequences having the three good pairs. The strings are \"(()())()(())\" and \"(()())()()()\", respectively.\n4. You are given the good pair $(9,12)$. There is only one balanced bracket sequence having the four good pairs. The content of $s$ is therefore the only string, which is \"(()())()(())\".\n\nThen, the number of bracket sequences after the fifth and the sixth clue are both $1$ as you already know the content of $s$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nconst ll nil=-1;\nconst ll md=998244353;\n \nll pw(ll a,ll b)\n{\n    ll c=1;\n    while(b>0)\n    {\n        if(b&1)c=c*a%md;\n        a=a*a%md;\n        b>>=1;\n    }\n    return c;\n}\n \nint main()\n{\n    cin.tie(0)->sync_with_stdio(0);\n    vector<ll>fac(1010101,1),ctl(505050);\n    for(int i=1;i<1010101;i++)fac[i]=fac[i-1]*i%md;\n    for(int i=0;i<505050;i++)\n    {\n        ctl[i]=fac[i*2]*pw(fac[i]*fac[i+1]%md,md-2)%md;\n    }\n    ll t;cin>>t;\n    while(t--)\n    {\n        ll n;cin>>n;\n        vector<ll>L(n*2,nil),R(n*2,nil),P(n*2,nil),S(n*2);\n        auto update=[&](ll x)\n        {\n            S[x]=1;\n            if(L[x]!=nil)S[x]+=S[L[x]];\n            if(R[x]!=nil)S[x]+=S[R[x]];\n        };\n        auto rotate=[&](ll x)\n        {\n            ll dummy;\n            ll p=P[x];\n            ll b=nil;\n            if(p==nil)return;\n            if(x==L[p])\n            {\n                L[p]=b=R[x];\n                R[x]=p;\n            }\n            else\n            {\n                R[p]=b=L[x];\n                L[x]=p;\n            }\n            P[x]=P[p];P[p]=x;\n            if(b!=nil)P[b]=p;\n            (P[x]!=nil?p==L[P[x]]?L[P[x]]:R[P[x]]:dummy)=x;\n            update(p);update(x);\n        };\n        auto splay=[&](ll x)\n        {\n            while(P[x]!=nil)\n            {\n                ll p=P[x];\n                ll g=P[p];\n                if(g!=nil)\n                {\n                    if((x==L[p])==(p==L[g]))rotate(p);\n                    else rotate(x);\n                }\n                rotate(x);\n            }\n        };\n        update(0);\n        for(int i=1;i<n*2;i++)\n        {\n            L[i]=i-1;\n            P[i-1]=i;\n            update(i);\n        }\n        splay(0);\n        ll ans=ctl[n];\n        cout<<ans<<\" \";\n        for(int i=0;i<n;i++)\n        {\n            ll li,ri;cin>>li>>ri;\n            //li=(li+ans%(2*n))%(2*n);\n            //ri=(ri+ans%(2*n))%(2*n);\n            li--;ri--;\n            splay(li);\n            ans=ans*pw(ctl[S[li]/2],md-2)%md;\n            ll lli=L[li];\n            if(L[li]!=nil)P[L[li]]=nil;\n            if(R[li]!=nil)P[R[li]]=nil;\n            L[li]=nil;\n            R[li]=nil;\n            update(li);\n            // now L[li] separated from tree\n            // should not be affected in splay ri\n            splay(ri);\n            ll lri=L[ri];\n            ll rri=R[ri];\n            if(L[ri]!=nil)P[L[ri]]=nil;\n            if(R[ri]!=nil)P[R[ri]]=nil;\n            L[ri]=nil;\n            R[ri]=nil;\n            update(ri);\n            if(lri!=nil)\n            {\n                splay(lri);\n                ans=ans*ctl[S[lri]/2]%md;\n            }\n            if(lli!=nil&&rri!=nil)\n            {\n                while(L[rri]!=nil)rri=L[rri];\n                splay(lli);\n                splay(rri);\n                P[lli]=rri;\n                L[rri]=lli;\n                update(rri);\n                ans=ans*ctl[S[rri]/2]%md;\n            }\n            else if(lli!=nil||rri!=nil)\n            {\n                if(lli!=nil)\n                {\n                    splay(lli);\n                    ans=ans*ctl[S[lli]/2]%md;\n                }\n                else\n                {\n                    splay(rri);\n                    ans=ans*ctl[S[rri]/2]%md;\n                }\n            }\n            L[ri]=li;\n            P[li]=ri;\n            update(ri);\n            // make dummy tree (for invariant maintaining)\n            cout<<ans<<\" \\n\"[i+1==n];\n        }\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2063f1",
      "PROBLEM_ID": "2063F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, the limits on $t$ and $n$ are smaller. You can hack only if you solved all versions of this problem.\n\nNow Little John is rich, and so he finally buys a house big enough to fit himself and his favorite bracket sequence. But somehow, he ended up with a lot of brackets! Frustrated, he penetrates through the ceiling with the \"buddha palm\".\n\nA bracket sequence is called balanced if it can be constructed by the following formal grammar.\n\n1. The empty sequence $\\varnothing$ is balanced.\n2. If the bracket sequence $A$ is balanced, then $\\mathtt{(}A\\mathtt{)}$ is also balanced.\n3. If the bracket sequences $A$ and $B$ are balanced, then the concatenated sequence $A B$ is also balanced.\n\nFor example, the sequences \"(())()\", \"()\", \"(()(()))\", and the empty sequence are balanced, while \"(()\" and \"(()))(\" are not.\n\nGiven a balanced bracket sequence $s$, a pair of indices $(i,j)$ ($i<j$) is called a good pair if $s_i$ is '(', $s_j$ is ')', and the two brackets are added simultaneously with respect to Rule 2 while constructing the sequence $s$. For example, the sequence \"(())()\" has three different good pairs, which are $(1,4)$, $(2,3)$, and $(5,6)$. One can show that any balanced bracket sequence of $2n$ brackets contains exactly $n$ different good pairs, and using any order of rules to construct the same bracket sequence will yield the same set of good pairs.\n\nEmily will play a bracket guessing game with John. The game is played as follows.\n\nInitially, John has a balanced bracket sequence $s$ containing $n$ different good pairs, which is not known to Emily. John tells Emily the value of $n$ and asks Emily to guess the sequence.\n\nThroughout $n$ turns, John gives Emily the following kind of clue on each turn.\n\n- $l\\;r$: The sequence $s$ contains a good pair $(l,r)$.\n\nThe clues that John gives Emily are pairwise distinct and do not contradict each other.\n\nAt a certain point, Emily can be certain that the balanced bracket sequence satisfying the clues given so far is unique. For example, assume Emily knows that $s$ has $3$ good pairs, and it contains the good pair $(2,5)$. Out of $5$ balanced bracket sequences with $3$ good pairs, there exists only one such sequence \"((()))\" with the good pair $(2,5)$. Therefore, one can see that Emily does not always need $n$ turns to guess $s$.\n\nTo find out the content of $s$ as early as possible, Emily wants to know the number of different balanced bracket sequences that match the clues after each turn. Surely, this is not an easy job for Emily, especially when she is given so many good pairs. Now it is your turn to help Emily. Given the clues, you must find the answer before and after each turn. As the answers may be huge, you need to find them modulo $998\\,244\\,353$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($2 \\le n \\le 5000$)\u00a0\u2014 the number of good pairs.\n\nThen, each of the $n$ following lines contains two integers $l_i$ and $r_i$ representing the $i$-th clue ($1 \\le l_i < r_i \\le 2n$).\n\nThe clues in one test case are pairwise distinct and do not contradict each other.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, output $n+1$ integers on a separate line:\n\n- The first integer is the answer before all clues, modulo $998\\,244\\,353$.\n- For all $i \\ge 1$, the $i+1$-th integer is the answer after the $i$-th clue, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n2 5\n\n1 6\n\n3 4\n\n4\n\n1 6\n\n7 8\n\n2 3\n\n4 5\n\n6\n\n2 3\n\n1 6\n\n7 8\n\n9 12\n\n10 11\n\n4 5\n\n```\n\n#### Output #1\n\n```\n5 1 1 1\n14 2 2 1 1\n132 42 5 2 1 1 1\n```\n\n### Note\n\nThe first test case of the example is explained in the problem description.\n\nThe third test case of the example is explained as follows. It can be shown that there are $132$ balanced bracket sequences with $6$ good pairs. The answers after each clue are given as follows:\n\n1. You are given the good pair $(2,3)$. There are $42$ balanced bracket sequences having the good pair $(2,3)$.\n2. You are given the good pair $(1,6)$. There are $5$ balanced bracket sequences having good pairs $(2,3)$, $(1,6)$.\n3. You are given the good pair $(7,8)$. There are $2$ balanced bracket sequences having the three good pairs. The strings are \"(()())()(())\" and \"(()())()()()\", respectively.\n4. You are given the good pair $(9,12)$. There is only one balanced bracket sequence having the four good pairs. The content of $s$ is therefore the only string, which is \"(()())()(())\".\n\nThen, the number of bracket sequences after the fifth and the sixth clue are both $1$ as you already know the content of $s$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing int64 = long long;\nconst int MOD = 998244353;\nconst int MAXN = 5000;\nconst int MAX2N = 2 * MAXN;\n\nint add_mod(int a, int b) { a += b; if (a >= MOD) a -= MOD; return a; }\nint mul_mod(int64 a, int64 b) { return int(a * b % MOD); }\nint pow_mod(int a, int64 p) {\n    int64 res = 1, x = a;\n    while (p) {\n        if (p & 1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        p >>= 1;\n    }\n    return int(res);\n}\n\nint invArr[MAXN + 5];\nint fact[2 * MAXN + 5], ifact[2 * MAXN + 5];\nint catalan[MAXN + 5];\n\n// Precomputed arrays for counting\nstatic int mark[2 * MAXN + 5];\nstatic int f_cnt[MAXN + 5];\nstatic int starr[MAXN + 5];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    // Precompute inverses up to MAXN+1\n    invArr[1] = 1;\n    for(int i = 2; i <= MAXN + 1; i++){\n        // MOD is prime\n        invArr[i] = MOD - int( (MOD / i) * 1LL * invArr[MOD % i] % MOD );\n    }\n    // Precompute factorials and inverse factorials up to 2*MAXN\n    fact[0] = 1;\n    for(int i = 1; i <= 2*MAXN; i++){\n        fact[i] = mul_mod(fact[i-1], i);\n    }\n    ifact[2*MAXN] = pow_mod(fact[2*MAXN], MOD - 2);\n    for(int i = 2*MAXN; i >= 1; i--){\n        ifact[i-1] = mul_mod(ifact[i], i);\n    }\n    // Precompute Catalan numbers up to MAXN\n    catalan[0] = 1;\n    for(int n = 1; n <= MAXN; n++){\n        // C(2n, n) / (n+1)\n        int64 c = fact[2*n];\n        c = c * ifact[n] % MOD * ifact[n] % MOD;\n        c = c * invArr[n+1] % MOD;\n        catalan[n] = int(c);\n    }\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<pair<int,int>> c(n);\n        for(int i = 0; i < n; i++){\n            int l, r;\n            cin >> l >> r;\n            c[i].first = l;\n            c[i].second = r;\n        }\n        // Answers: ans[0] before any clue, ans[1] after first, ..., ans[n] after nth\n        vector<int> ans(n+1);\n        // Initial count: Catalan(n)\n        ans[0] = catalan[n];\n        // We'll maintain arcs sorted by left endpoint\n        vector<pair<int,int>> arcs;\n        arcs.reserve(n);\n\n        bool foundUnique = false;\n        int breakIdx = -1; // index i (0-based for clues) when ans becomes 1 at ans[i+1]\n\n        // Process clues in input order, but maintain arcs sorted by l\n        for(int i = 0; i < n; i++){\n            // Insert c[i] into arcs keeping arcs sorted by .first (l)\n            {\n                auto it = lower_bound(arcs.begin(), arcs.end(), c[i],\n                    [](const pair<int,int> &a, const pair<int,int> &b){\n                        return a.first < b.first;\n                    });\n                arcs.insert(it, c[i]);\n            }\n            int k = int(arcs.size()); // number of forced arcs\n            // Prepare mark[] for events\n            int two_n = 2 * n;\n            // Clear mark for 1..2n\n            // Using fill as it's efficient\n            fill(mark + 1, mark + two_n + 1, 0);\n            // Place arc events: start and end\n            for(int id = 0; id < k; id++){\n                int l = arcs[id].first;\n                int r = arcs[id].second;\n                mark[l] = id + 1;    // positive => start of arc id\n                mark[r] = -(id + 1); // negative => end of arc id\n            }\n            // Clear face free-counts\n            fill(f_cnt, f_cnt + (k + 1), 0);\n\n            // Traverse positions, maintain stack of open arcs\n            int stsz = 0;\n            for(int pos = 1; pos <= two_n; pos++){\n                int m = mark[pos];\n                if(m > 0){\n                    // start of arc (m-1)\n                    starr[stsz++] = m - 1;\n                } else if(m < 0){\n                    // end of arc abs(m)-1\n                    stsz--;\n                } else {\n                    // free vertex\n                    int face_id = (stsz == 0 ? k : starr[stsz - 1]);\n                    f_cnt[face_id]++;\n                }\n            }\n            // Compute product of Catalan counts for each face\n            int64 ways = 1;\n            for(int u = 0; u <= k; u++){\n                int cnt = f_cnt[u];\n                if(cnt & 1){\n                    ways = 0;\n                    break;\n                }\n                int pairs = cnt >> 1;\n                // multiply by Catalan[pairs]\n                ways = ways * catalan[pairs] % MOD;\n            }\n            ans[i+1] = int(ways);\n            if(!foundUnique && ans[i+1] == 1){\n                foundUnique = true;\n                breakIdx = i; // ans index is i+1\n            }\n        }\n        // If we found a unique (count==1) at ans[breakIdx+1], fill rest with 1\n        if(foundUnique){\n            for(int j = breakIdx + 2; j <= n; j++){\n                ans[j] = 1;\n            }\n        }\n\n        // Output answers\n        for(int i = 0; i <= n; i++){\n            cout << ans[i] << (i == n ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2063d",
      "PROBLEM_ID": "2063D",
      "PROBLEM_STATEMENT": "Even Little John needs money to buy a house. But he recently lost his job; how will he earn money now? Of course, by playing a game that gives him money as a reward! Oh well, maybe not those kinds of games you are thinking about.\n\nThere are $n+m$ distinct points $(a_1,0), (a_2,0), \\ldots, (a_{n},0), (b_1,2), (b_2,2), \\ldots, (b_{m},2)$ on the plane. Initially, your score is $0$. To increase your score, you can perform the following operation:\n\n- Choose three distinct points which are not [collinear](https://en.wikipedia.org/wiki/Collinearity);\n- Increase your score by the area of the triangle formed by these three points;\n- Then, erase the three points from the plane.\n\n![](https://espresso.codeforces.com/5f6a73286fffbc2708f1d388ed58ca5bc0d69d23.png)An instance of the game, where the operation is performed twice.\n\nLet $k_{\\max}$ be the maximum number of operations that can be performed. For example, if it is impossible to perform any operation, $k_\\max$ is $0$. Additionally, define $f(k)$ as the maximum possible score achievable by performing the operation exactly $k$ times. Here, $f(k)$ is defined for all integers $k$ such that $0 \\le k \\le k_{\\max}$.\n\nFind the value of $k_{\\max}$, and find the values of $f(x)$ for all integers $x=1,2,\\ldots,k_{\\max}$ independently.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le {3 \\cdot 10^4}$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n,m \\le 2 \\cdot 10^5$).\n\nThe second line of each test case contains $n$ pairwise distinct integers $a_1,a_2,\\ldots,a_{n}$\u00a0\u2014 the points on $y=0$ ($-10^9 \\le a_i \\le 10^9$).\n\nThe third line of each test case contains $m$ pairwise distinct integers $b_1,b_2,\\ldots,b_{m}$\u00a0\u2014 the points on $y=2$ ($-10^9 \\le b_i \\le 10^9$).\n\nIt is guaranteed that both the sum of $n$ and the sum of $m$ over all test cases do not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, given that the maximum number of operations is $k_{\\max}$, you must output at most two lines:\n\n- The first line contains the value of $k_{\\max}$;\n- The second line contains $k_{\\max}$ integers denoting $f(1),f(2),\\ldots,f(k_{\\max})$. You are allowed to omit this line if $k_{\\max}$ is $0$.\n\nNote that under the constraints of this problem, it can be shown that all values of $f(x)$ are integers no greater than $10^{16}$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1 3\n\n0\n\n0 1 -1\n\n2 4\n\n0 100\n\n-100 -50 0 50\n\n2 4\n\n0 1000\n\n-100 -50 0 50\n\n6 6\n\n20 1 27 100 43 42\n\n100 84 1 24 22 77\n\n8 2\n\n564040265 -509489796 469913620 198872582 -400714529 553177666 131159391 -20796763\n\n-1000000000 1000000000\n\n```\n\n#### Output #1\n\n```\n1\n2\n2\n150 200\n2\n1000 200\n4\n99 198 260 283\n2\n2000000000 2027422256\n```\n\n### Note\n\nOn the first test case, there are $1+3=4$ points $(0,0),(0,2),(1,2),(-1,2)$.\n\nIt can be shown that you cannot perform two or more operations. The value of $k_{\\max}$ is $1$, and you are only asked for the value of $f(1)$.\n\nYou can choose $(0,0)$, $(-1,2)$, and $(1,2)$ as the three vertices of the triangle. After that, your score is increased by the area of the triangle, which is $2$. Then, the three points are erased from the plane. It can be shown that the maximum value of your score after performing one operation is $2$. Therefore, the value of $f(1)$ is $2$.\n\nOn the fifth test case, there are $8+2=10$ points.\n\nIt can be shown that you cannot perform three or more operations. The value of $k_{\\max}$ is $2$, and you are asked for the values $f(1)$ and $f(2)$.\n\nTo maximize the score with only one operation, you can choose three points $(198\\,872\\,582,0)$, $(-1\\,000\\,000\\,000,2)$, and $(1\\,000\\,000\\,000,2)$. Then, the three points are erased from the plane. It can be shown that the maximum value of your score after performing one operation is $2\\,000\\,000\\,000$. Therefore, the value of $f(1)$ is $2\\,000\\,000\\,000$.\n\nTo maximize the score with exactly two operations, you can choose the following sequence of operations.\n\n- Choose three points $(-509\\,489\\,796,0)$, $(553\\,177\\,666,0)$, and $(-1\\,000\\,000\\,000,2)$. The three points are erased.\n- Choose three points $(-400\\,714\\,529,0)$, $(564\\,040\\,265,0)$, and $(1\\,000\\,000\\,000,2)$. The three points are erased.\n\nThen, the score after two operations becomes $2\\,027\\,422\\,256$. It can be shown that the maximum value of your score after performing exactly two operations is $2\\,027\\,422\\,256$. Therefore, the value of $f(2)$ is $2\\,027\\,422\\,256$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric> // Potentially needed for std::min with initializer list on some compilers\n\n// Helper function to query prefix sum array safely.\n// Assumes pref is 1-based and has size N+1. Indices are 1 to N.\nlong long query_pref(const std::vector<long long>& pref, int idx) {\n    // If requested index is out of valid range [1, N], return 0.\n    if (idx <= 0) return 0;\n    // If idx exceeds size-1 (max valid index N), clamp to N.\n    if (idx >= pref.size()) idx = pref.size() - 1; \n    return pref[idx];\n}\n\n// Helper function to query suffix sum array safely.\n// Assumes suff is 1-based and has size N+2. Indices are 1 to N+1.\n// suff[i] stores sum from index i to N.\nlong long query_suff(const std::vector<long long>& suff, int idx, int total_len) {\n     // If requesting suffix starting after the last element, sum is 0.\n     if (idx > total_len) return 0;\n     // If requesting suffix starting before the first element, clamp to index 1.\n     if (idx < 1) idx = 1; \n    // Ensure index does not exceed N+1 (max valid index for suff array)\n    if (idx >= suff.size()) idx = suff.size() - 1;\n    return suff[idx];\n}\n\nint main() {\n    // Fast I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Number of points on y=0\n        long long m_ll; // Number of points on y=2, use long long temporarily for calculation safety\n        std::cin >> n >> m_ll;\n        int m = (int)m_ll; // Convert m back to int; constraints suggest it fits\n\n        // Read coordinates for points on y=0\n        std::vector<long long> a_coords(n);\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a_coords[i];\n        }\n        // Read coordinates for points on y=2\n        std::vector<long long> b_coords(m);\n        for (int i = 0; i < m; ++i) {\n            std::cin >> b_coords[i];\n        }\n\n        // Sort coordinates to easily find points with min/max coordinates\n        std::sort(a_coords.begin(), a_coords.end());\n        std::sort(b_coords.begin(), b_coords.end());\n\n        // Create 1-based indexed vectors A and B for easier calculation using formulas\n        std::vector<long long> A(n + 1);\n        for (int i = 0; i < n; ++i) A[i + 1] = a_coords[i];\n        std::vector<long long> B(m + 1);\n        for (int i = 0; i < m; ++i) B[i + 1] = b_coords[i];\n\n        // Compute prefix sums for A and B\n        std::vector<long long> pref_A(n + 1, 0);\n        for (int i = 1; i <= n; ++i) pref_A[i] = pref_A[i - 1] + A[i];\n        \n        // Compute suffix sums for A and B\n        // Suffix sum array needs size N+2 to access index N+1 safely (suff[N+1]=0)\n        std::vector<long long> suff_A(n + 2, 0); \n        for (int i = n; i >= 1; --i) suff_A[i] = suff_A[i + 1] + A[i];\n\n        std::vector<long long> pref_B(m + 1, 0);\n        for (int i = 1; i <= m; ++i) pref_B[i] = pref_B[i - 1] + B[i];\n\n        std::vector<long long> suff_B(m + 2, 0); \n        for (int i = m; i >= 1; --i) suff_B[i] = suff_B[i + 1] + B[i];\n\n        // Function to calculate the maximum possible score sum from k3 pairs chosen optimally from A points\n        // This strategy picks k3 smallest and k3 largest points and pairs them up.\n        auto calculate_SA = [&](int k3) -> long long {\n            if (k3 <= 0) return 0LL;\n            // Index check: n-k3+1 must be at least 1. k3 must be at least 1.\n            // These are implicitly handled by constraints k3 <= k <= n, k3 >= 0.\n            // Calculate sum of (A[n-t+1] - A[t]) for t = 1 to k3\n             return query_suff(suff_A, n - k3 + 1, n) - query_pref(pref_A, k3);\n        };\n\n        // Function to calculate the maximum possible score sum from k4 pairs chosen optimally from B points\n        auto calculate_SB = [&](int k4) -> long long {\n            if (k4 <= 0) return 0LL;\n            // Index check similar to SA\n             return query_suff(suff_B, m - k4 + 1, m) - query_pref(pref_B, k4);\n        };\n\n        // Calculate the maximum number of operations possible\n        int k_max = std::min({n, m, (n + m) / 3});\n\n        // Output k_max\n        std::cout << k_max << \"\\n\";\n\n        // If k_max > 0, calculate and output f(1), f(2), ..., f(k_max)\n        if (k_max > 0) {\n            std::vector<long long> f_values; // Stores the results f(k)\n            for (int k = 1; k <= k_max; ++k) {\n                long long max_score_k = 0; // Max score for exactly k operations\n                \n                // Determine the valid range [k3_min, k3_max] for k3 given k\n                // k3 + k4 = k\n                // 2k3 + k4 <= n  => k3 + k <= n => k3 <= n - k\n                // k3 + 2k4 <= m  => k3 + 2(k - k3) <= m => k3 + 2k - 2k3 <= m => 2k - k3 <= m => k3 >= 2k - m\n                int k3_min = std::max(0, (int)(2LL * k - m)); // Use m, potentially large k can cause overflow\n                int k3_max = std::min(k, n - k);\n\n                // If the range is valid (non-empty)\n                 if (k3_min <= k3_max) {\n                    // The function G(k3) = SA(k3) + SB(k-k3) is concave.\n                    // We can use ternary search to find the maximum value of G(k3) in the range [k3_min, k3_max].\n                    int low = k3_min, high = k3_max;\n                    \n                    // Standard ternary search loop condition: terminates when range size < 3\n                    while (high - low >= 3) {\n                        int mid1 = low + (high - low) / 3;\n                        int mid2 = high - (high - low) / 3;\n                        \n                        // Evaluate the function at midpoints\n                        long long score1 = calculate_SA(mid1) + calculate_SB(k - mid1);\n                        long long score2 = calculate_SA(mid2) + calculate_SB(k - mid2);\n\n                        // Narrow down the search range based on comparison\n                        if (score1 < score2) {\n                            // Maximum is likely in [mid1, high], potentially at mid2 or higher\n                            low = mid1; \n                        } else {\n                            // Maximum is likely in [low, mid2], potentially at mid1 or lower\n                            high = mid2; \n                        }\n                    }\n\n                    // After ternary search loop, the maximum is within the small range [low, high]\n                    // Check all values in this range to find the true maximum\n                    max_score_k = 0; // Initialize max_score_k for the final check\n                    for (int cur_k3 = low; cur_k3 <= high; ++cur_k3) {\n                         max_score_k = std::max(max_score_k, calculate_SA(cur_k3) + calculate_SB(k - cur_k3));\n                    }\n                 } else {\n                    // If the range [k3_min, k3_max] is empty, max_score_k remains 0.\n                    // This case should not happen for k <= k_max based on the derivation of k_max.\n                 }\n\n                f_values.push_back(max_score_k); // Store the calculated f(k)\n            }\n\n            // Output the calculated values f(1)...f(k_max)\n            for (int k = 0; k < k_max; ++k) {\n                std::cout << f_values[k] << (k == k_max - 1 ? \"\" : \" \");\n            }\n            std::cout << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2063b",
      "PROBLEM_ID": "2063B",
      "PROBLEM_STATEMENT": "After Little John borrowed expansion screws from auntie a few hundred times, eventually she decided to come and take back the unused ones.\nBut as they are a crucial part of home design, Little John decides to hide some in the most unreachable places\u00a0\u2014 under the eco-friendly wood veneers.\n\nYou are given an integer sequence $a_1, a_2, \\ldots, a_n$, and a segment $[l,r]$ ($1 \\le l \\le r \\le n$).\n\nYou must perform the following operation on the sequence exactly once.\n\n- Choose any subsequence$^{\\text{\u2217}}$ of the sequence $a$, and reverse it. Note that the subsequence does not have to be contiguous.\n\nFormally, choose any number of indices $i_1,i_2,\\ldots,i_k$ such that $1 \\le i_1 < i_2 < \\ldots < i_k \\le n$. Then, change the $i_x$-th element to the original value of the $i_{k-x+1}$-th element simultaneously for all $1 \\le x \\le k$.\n\nFind the minimum value of $a_l+a_{l+1}+\\ldots+a_{r-1}+a_r$ after performing the operation.\n\n$^{\\text{\u2217}}$A sequence $b$ is a subsequence of a sequence $a$ if $b$ can be obtained from $a$ by the deletion of several (possibly, zero or all) element from arbitrary positions.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $l$, $r$ ($1 \\le l \\le r \\le n \\le 10^5$)\u00a0\u2014 the length of $a$, and the segment $[l,r]$.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_{i} \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output the minimum value of $a_l+a_{l+1}+\\ldots+a_{r-1}+a_r$ on a separate line.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n2 1 1\n\n2 1\n\n3 2 3\n\n1 2 3\n\n3 1 3\n\n3 1 2\n\n4 2 3\n\n1 2 2 2\n\n5 2 5\n\n3 3 2 3 5\n\n6 1 3\n\n3 6 6 4 3 2\n\n```\n\n#### Output #1\n\n```\n1\n3\n6\n3\n11\n8\n```\n\n### Note\n\nOn the second test case, the array is $a=[1,2,3]$ and the segment is $[2,3]$.\n\nAfter choosing the subsequence $a_1,a_3$ and reversing it, the sequence becomes $[3,2,1]$. Then, the sum $a_2+a_3$ becomes $3$. It can be shown that the minimum possible value of the sum is $3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, l, r;\n        cin >> n >> l >> r;\n        vector<ll> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n\n        // Compute original sum of the segment [l, r]\n        ll origSum = 0;\n        for (int i = l - 1; i < r; i++) {\n            origSum += a[i];\n        }\n\n        // Build left, middle (segment), and right value lists\n        vector<ll> leftVals, midVals, rightVals;\n        leftVals.reserve(l - 1);\n        midVals.reserve(r - l + 1);\n        rightVals.reserve(n - r);\n        for (int i = 0; i < l - 1; i++) {\n            leftVals.push_back(a[i]);\n        }\n        for (int i = l - 1; i < r; i++) {\n            midVals.push_back(a[i]);\n        }\n        for (int i = r; i < n; i++) {\n            rightVals.push_back(a[i]);\n        }\n\n        // Sort for prefix/suffix sums\n        // leftVals and rightVals ascending (we want their smallest sums)\n        sort(leftVals.begin(), leftVals.end());\n        sort(rightVals.begin(), rightVals.end());\n        // midVals descending (we want the sum of its largest values)\n        sort(midVals.begin(), midVals.end(), greater<ll>());\n\n        // Prefix sums\n        int L = (int)leftVals.size();\n        int M = (int)midVals.size();\n        int R = (int)rightVals.size();\n\n        vector<ll> prefL(L + 1, 0), prefM(M + 1, 0), prefR(R + 1, 0);\n        for (int i = 0; i < L; i++) {\n            prefL[i + 1] = prefL[i] + leftVals[i];\n        }\n        for (int i = 0; i < M; i++) {\n            prefM[i + 1] = prefM[i] + midVals[i];\n        }\n        for (int i = 0; i < R; i++) {\n            prefR[i + 1] = prefR[i] + rightVals[i];\n        }\n\n        // Try swapping with left side\n        ll bestDelta = 0;  // we only care about negative deltas (sum reduction)\n        int maxSwapL = min(L, M);\n        for (int s = 1; s <= maxSwapL; s++) {\n            // delta = sum of s smallest leftVals - sum of s largest midVals\n            ll delta = prefL[s] - prefM[s];\n            if (delta < bestDelta) {\n                bestDelta = delta;\n            }\n        }\n\n        // Try swapping with right side\n        int maxSwapR = min(R, M);\n        for (int s = 1; s <= maxSwapR; s++) {\n            // delta = sum of s smallest rightVals - sum of s largest midVals\n            ll delta = prefR[s] - prefM[s];\n            if (delta < bestDelta) {\n                bestDelta = delta;\n            }\n        }\n\n        // The answer is the original sum plus the best (most negative) delta\n        ll answer = origSum + bestDelta;\n        cout << answer << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2063a",
      "PROBLEM_ID": "2063A",
      "PROBLEM_STATEMENT": "Today, Little John used all his savings to buy a segment. He wants to build a house on this segment.\n\nA segment of positive integers $[l,r]$ is called coprime if $l$ and $r$ are coprime$^{\\text{\u2217}}$.\n\nA coprime segment $[l,r]$ is called minimal coprime if it does not contain$^{\\text{\u2020}}$ any coprime segment not equal to itself. To better understand this statement, you can refer to the notes.\n\nGiven $[l,r]$, a segment of positive integers, find the number of minimal coprime segments contained in $[l,r]$.\n\n$^{\\text{\u2217}}$Two integers $a$ and $b$ are coprime if they share only one positive common divisor. For example, the numbers $2$ and $4$ are not coprime because they are both divided by $2$ and $1$, but the numbers $7$ and $9$ are coprime because their only positive common divisor is $1$.\n\n$^{\\text{\u2020}}$A segment $[l',r']$ is contained in the segment $[l,r]$ if and only if $l \\le l' \\le r' \\le r$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe only line of each test case consists of two integers $l$ and $r$ ($1 \\le l \\le r \\le 10^9$).\n\n### Output\n\nFor each test case, output the number of minimal coprime segments contained in $[l,r]$, on a separate line.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1 2\n\n1 10\n\n49 49\n\n69 420\n\n1 1\n\n9982 44353\n\n```\n\n#### Output #1\n\n```\n1\n9\n0\n351\n1\n34371\n```\n\n### Note\n\nOn the first test case, the given segment is $[1,2]$. The segments contained in $[1,2]$ are as follows.\n\n- $[1,1]$: This segment is coprime, since the numbers $1$ and $1$ are coprime, and this segment does not contain any other segment inside. Thus, $[1,1]$ is minimal coprime.\n- $[1,2]$: This segment is coprime. However, as it contains $[1,1]$, which is also coprime, $[1,2]$ is not minimal coprime.\n- $[2,2]$: This segment is not coprime because $2$ and $2$ share $2$ positive common divisors: $1$ and $2$.\n\nTherefore, the segment $[1,2]$ contains $1$ minimal coprime segment.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\nbool is_coprime(long long l, long long r) {\n    return gcd(l, r) == 1;\n}\n\nbool is_minimal_coprime(long long l, long long r) {\n    if (!is_coprime(l, r)) {\n        return false;\n    }\n    if (l == r) {\n        return true;\n    }\n    for (long long l_prime = l; l_prime <= r; ++l_prime) {\n        for (long long r_prime = l_prime; r_prime <= r; ++r_prime) {\n            if (l_prime == l && r_prime == r) continue;\n            if (is_coprime(l_prime, r_prime)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint solve() {\n    int l, r;\n    cin >> l >> r;\n    if (l == 1) {\n        return 1 + max(0, r - 2);\n    } else {\n        return max(0, r - l);\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        cout << solve() << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2062h",
      "PROBLEM_ID": "2062H",
      "PROBLEM_STATEMENT": "In a two-dimensional universe, a star can be represented by a point $(x,y)$ on a two-dimensional plane. Two stars are directly connected if and only if their $x$ or $y$ coordinates are the same, and there are no other stars on the line segment between them. Define a galaxy as a connected component composed of stars connected directly or indirectly (through other stars).\n\nFor a set of stars, its value is defined as the minimum number of galaxies that can be obtained after performing the following operation for any (possibly, zero) times: in each operation, you can select a point $(x,y)$ without stars. If a star can be directly connected to at least $3$ stars after creating it here, then you create a star here.\n\nYou are given a $n\\times n$ matrix $a$ consisting of $0$ and $1$ describing a set $S$ of stars. There is a star at $(x,y)$ if and only if $a_{x,y}=1$. Calculate the sum, modulo $10^9 + 7$, of the values of all non-empty subsets of $S$.\n\n### Input\n\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases.\n\nFor each test case, the first line contains a single integer $n$ ($1 \\leq n \\leq 14$) \u2014 the size of matrix $a$.\n\nThen $n$ lines follow; the $i$-th line contains a string $a_i$ of length $n$ \u2014 the $i$-th row of matrix $a$.\n\nIt is guaranteed that the sum of $2^n$ over all test cases does not exceed $2^{14}$.\n\n### Output\n\nFor each test case, output the sum, modulo $10^9 + 7$, of the values of all non-empty subsets of $S$.\n\n### Example\n\n#### Input #1\n\n```\n8\n1\n0\n2\n01\n10\n3\n010\n000\n101\n4\n0110\n1001\n1001\n0110\n11\n11111110111\n10000010010\n10111010011\n10111010011\n10111010001\n10000010000\n11111110101\n00000000111\n11011010011\n10010101100\n11101010100\n11\n11011111110\n10010000010\n00010111010\n10010111010\n01010111010\n11010000010\n01011111110\n11000000000\n01010000010\n01000111100\n00000001010\n11\n11010101001\n11001010100\n00000000110\n11111110010\n10000010010\n10111010110\n10111010111\n10111010010\n10000010110\n11111110100\n00000000000\n3\n111\n100\n111\n```\n\n#### Output #1\n\n```\n0\n4\n9\n355\n593092633\n438667113\n922743932\n155\n```\n\n### Note\n\nIn the first test case, $S$ is empty. $S$ has no non-empty subsets. So the answer is $0$.\n\nIn the second test case, $S = \\{(1,2),(2,1)\\}$. $S$ has $3$ non-empty subsets.\n\n- $\\{(1,2)\\}$ and $\\{(2,1)\\}$ \u2014 there is only one star in the set, forming $1$ galaxy.\n- $\\{(1,2),(2,1)\\}$ \u2014 two stars in the set are not connected, forming $2$ galaxies.\n\nSo the answer is $1+1+2=4$.\n\nIn the third test case, $S = \\{(1,2),(3,1),(3,3)\\}$. $S$ has $7$ non-empty subsets.\n\n- $\\{(1,2)\\}$, $\\{(3,1)\\}$, and $\\{(3,3)\\}$ \u2014 there is only one star in the set, forming $1$ galaxy.\n- $\\{(1,2),(3,1)\\}$ and $\\{(1,2),(3,3)\\}$ \u2014 two stars in the set are not connected, forming $2$ galaxies.\n- $\\{(3,1),(3,3)\\}$ \u2014 two stars in the set are connected, forming $1$ galaxy.\n- $\\{(1,2),(3,1),(3,3)\\}$ \u2014 initially, star $(1,2)$ is not in the galaxy formed by $(3,1)$ and $(3,3)$. You can make an operation creating a star at $(3,2)$ connecting to these three stars, forming $1$ galaxy.\n\nSo the answer is $1+1+1+2+2+1+1=9$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=1000000007;\nstring s;\nlong long dp[15][15][1<<14],vl[200],sgvl[15][15][15][15];\nlong long dp2[15][1<<14],dpvl2[15][1<<14];\nint psum[15][15];\nlong long getvl(long long l,long long r,long long x,long long y){\n\tif(l>=r||x>=y)return 0;\n\treturn vl[psum[r][y]-psum[l][y]-psum[r][x]+psum[l][x]];\n}\nlong long f(long long l,long long r,long long x,long long y){\n\tlong long ans=0,i,c,tl,tr,tx,ty;\n\tfor(i=0;i<16;i++)\n\t{\n\t\tc=0;\n\t\ttl=l;\n\t\ttr=r;\n\t\ttx=x;\n\t\tty=y;\n\t\tif(i&1)\n\t\t{\n\t\t\tc^=1;\n\t\t\ttl++;\n\t\t}\n\t\tif(i&2)\n\t\t{\n\t\t\tc^=1;\n\t\t\ttr--;\n\t\t}\n\t\tif(i&4)\n\t\t{\n\t\t\tc^=1;\n\t\t\ttx++;\n\t\t}\n\t\tif(i&8)\n\t\t{\n\t\t\tc^=1;\n\t\t\tty--;\n\t\t}\n\t\tif(c)ans=(ans+mod-getvl(tl,tr,tx,ty))%mod;\n\t\telse ans=(ans+getvl(tl,tr,tx,ty))%mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tios::sync_with_stdio(false),cin.tie(0);\n\tint T,n,i,j,t,p,l,r,len,cmsk;\n\tlong long ans;\n\tfor(cin>>T;T>0;T--)\n\t{\n\t\tcin>>n;\n\t\tvl[0]=0;\n\t\tfor(i=1;i<=n*n;i++)vl[i]=(vl[i-1]*2+1)%mod;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)psum[i][j]=0;\n\t\t}\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>s;\n\t\t\tfor(j=0;j<n;j++)psum[i+1][j+1]=s[j]-'0';\n\t\t}\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)psum[i+1][j]+=psum[i][j];\n\t\t}\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(j=0;j<n;j++)psum[i][j+1]+=psum[i][j];\n\t\t}\n\t\tfor(l=0;l<=n;l++)\n\t\t{\n\t\t\tfor(r=l+1;r<=n;r++)\n\t\t\t{\n\t\t\t\tfor(i=0;i<=n;i++)\n\t\t\t\t{\n\t\t\t\t\tfor(j=i+1;j<=n;j++)sgvl[l][r][i][j]=f(l,r,i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tfor(t=0;t<(1<<n);t++)dp[i][j][t]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=n;i++)dp[i][i][0]=1;\n\t\tfor(len=1;len<=n;len++)\n\t\t{\n\t\t\tfor(l=0;l+len<=n;l++)\n\t\t\t{\n\t\t\t\tr=l+len;\n\t\t\t\tfor(i=l+1;i<r;i++)\n\t\t\t\t{\n\t\t\t\t\tfor(j=1;j<(1<<n);j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(t=0;t<n;t++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcmsk=j;\n\t\t\t\t\t\t\tfor(p=t;p<n&&(j>>p&1^1);p++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcmsk|=(1<<p);\n\t\t\t\t\t\t\t\tdp[l][r][cmsk]=(dp[l][r][cmsk]+dp[l][i][j]*sgvl[i][r][t][p+1])%mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(j=1;j<(1<<n);j++)\n\t\t\t\t{\n\t\t\t\t\tfor(i=0;(j>>i&1^1);i++);\n\t\t\t\t\tfor(t=n-1;(j>>t&1^1);t--);\n\t\t\t\t\tsgvl[l][r][i][t+1]=(sgvl[l][r][i][t+1]+mod-dp[l][r][j])%mod;\n\t\t\t\t}\n\t\t\t\tfor(i=0;i<n;i++)\n\t\t\t\t{\n\t\t\t\t\tcmsk=0;\n\t\t\t\t\tfor(t=i;t<n;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcmsk|=(1<<t);\n\t\t\t\t\t\tdp[l][r][cmsk]=(dp[l][r][cmsk]+sgvl[l][r][i][t+1])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(len==1)continue;\n\t\t\t\tfor(j=0;j<(1<<n);j++)dp[l][r][j]=(dp[l][r-1][j]+dp[l][r][j])%mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(j=0;j<(1<<n);j++)\n\t\t\t{\n\t\t\t\tdp2[i][j]=0;\n\t\t\t\tdpvl2[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp2[0][0]=1;\n\t\tfor(l=0;l<n;l++)\n\t\t{\n\t\t\tfor(j=0;j<(1<<n);j++)\n\t\t\t{\n\t\t\t\tdp2[l+1][j]=(dp2[l+1][j]+dp2[l][j])%mod;\n\t\t\t\tdpvl2[l+1][j]=(dpvl2[l+1][j]+dpvl2[l][j])%mod;\n\t\t\t}\n\t\t\tfor(r=l+1;r<=n;r++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<(1<<n);j++)\n\t\t\t\t{\n\t\t\t\t\tfor(i=0;i<n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcmsk=j;\n\t\t\t\t\t\tfor(t=i;t<n&&(j>>t&1^1);t++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcmsk|=(1<<t);\n\t\t\t\t\t\t\tdp2[r][cmsk]=(dp2[r][cmsk]+dp2[l][j]*sgvl[l][r][i][t+1])%mod;\n\t\t\t\t\t\t\tdpvl2[r][cmsk]=(dpvl2[r][cmsk]+(dp2[l][j]+dpvl2[l][j])*sgvl[l][r][i][t+1])%mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tfor(j=1;j<(1<<n);j++)ans=(ans+dpvl2[n][j])%mod;\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2062g",
      "PROBLEM_ID": "2062G",
      "PROBLEM_STATEMENT": "You are given two permutations $p_1,p_2,\\ldots,p_n$ and $q_1,q_2,\\ldots,q_n$ of length $n$. In one operation, you can select two integers $1\\leq i,j\\leq n,i\\neq j$ and swap $p_i$ and $p_j$. The cost of the operation is $\\min (|i-j|,|p_i-p_j|)$.\n\nFind the minimum cost to make $p_i = q_i$ hold for all $1\\leq i\\leq n$ and output a sequence of operations to achieve the minimum cost.\n\nA permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of input test cases.\n\nThe first line of each test case contains one integer $n$ ($2 \\le n \\le 100$) \u2014 the length of permutations $p$ and $q$.\n\nThe second line contains $n$ integers $p_1,p_2,\\ldots,p_n$ ($1\\leq p_i\\leq n$) \u2014 the permutation $p$. It is guaranteed that $p_1,p_2,\\ldots,p_n$ is a permutation of $1,2,\\ldots,n$.\n\nThe third line contains $n$ integers $q_1,q_2,\\ldots,q_n$ ($1\\leq q_i\\leq n$) \u2014 the permutation $q$. It is guaranteed that $q_1,q_2,\\ldots,q_n$ is a permutation of $1,2,\\ldots,n$.\n\nIt is guaranteed that the sum of $n^3$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output the total number of operations $k$ ($0\\le k\\le n^2$) on the first line. Then output $k$ lines, each containing two integers $i,j$ ($1\\le i,j\\le n$, $i\\neq j$) representing an operation to swap $p_i$ and $p_j$ in order.\n\nIt can be shown that no optimal operation sequence has a length greater than $n^2$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n2 1\n\n2 1\n\n3\n\n1 2 3\n\n3 2 1\n\n4\n\n2 1 4 3\n\n4 2 3 1\n\n5\n\n1 4 3 2 5\n\n5 2 3 4 1\n\n```\n\n#### Output #1\n\n```\n0\n1\n1 3\n3\n1 4\n2 4\n1 3\n4\n1 2\n4 5\n2 5\n1 4\n```\n\n### Note\n\nIn the second test case, you can swap $p_1,p_3$ costing $\\min(|1-3|,|1-3|)=2$. Then $p$ equals $q$ with a cost of $2$.\n\nIn the third test case, you can perform the following operations:\n\nInitially, $p=[2,1,4,3]$.\n\n1. Swap $p_1,p_4$ costing $\\min(|1-4|,|2-3|)=1$, resulting in $p=[3,1,4,2]$.\n2. Swap $p_2,p_4$ costing $\\min(|2-4|,|1-2|)=1$, resulting in $p=[3,2,4,1]$.\n3. Swap $p_1,p_3$ costing $\\min(|1-3|,|3-4|)=1$. Then $p$ equals $q$ with a cost of $3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nstruct linex{\n\tint v;\n\tint w;\n\tint nxt;\n\tint c;\n};\nint head[210],cnt,cpos[210],vis[210],qvis[210],totc,dis[210],inf=1000000000;\nlinex l[21000];\nqueue<int>que;\nvoid add(int u,int v,int w,int c){\n\tl[cnt].nxt=head[u];\n\thead[u]=cnt;\n\tl[cnt].v=v;\n\tl[cnt].w=w;\n\tl[cnt].c=c;\n\tcnt++;\n\tl[cnt].nxt=head[v];\n\thead[v]=cnt;\n\tl[cnt].v=u;\n\tl[cnt].w=0;\n\tl[cnt].c=-c;\n\tcnt++;\n}\nint spfa(int st,int en,int n){\n\tint i,j,t;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tvis[i]=0;\n\t\tdis[i]=inf;\n\t\tcpos[i]=head[i];\n\t}\n\tque.push(st);\n\tdis[st]=0;\n\tvis[st]=1;\n\tqvis[st]=1;\n\twhile(!que.empty())\n\t{\n\t\tt=que.front();\n\t\tque.pop();\n\t\tqvis[t]=0;\n\t\tfor(j=head[t];j!=-1;j=l[j].nxt)\n\t\t{\n\t\t\tif(l[j].w>0&&dis[l[j].v]>dis[t]+l[j].c)\n\t\t\t{\n\t\t\t\tdis[l[j].v]=dis[t]+l[j].c;\n\t\t\t\tvis[l[j].v]=1;\n\t\t\t\tif(!qvis[l[j].v])\n\t\t\t\t{\n\t\t\t\t\tque.push(l[j].v);\n\t\t\t\t\tqvis[l[j].v]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn vis[en];\n}\nlong long dfs(int p,int en,int curr){\n\tint x,j,flow=0;\n\tif(p==en)return curr;\n\tfor(j=cpos[p];j!=-1&&flow<curr;j=l[j].nxt)\n\t{\n\t\tcpos[p]=j;\n\t\tqvis[p]=1;\n\t\tif(l[j].w>0&&dis[l[j].v]==dis[p]+l[j].c&&!qvis[l[j].v])\n\t\t{\n\t\t\tx=dfs(l[j].v,en,min(curr-flow,l[j].w));\n\t\t\tflow+=x;\n\t\t\tl[j].w-=x;\n\t\t\tl[j^1].w+=x;\n\t\t\ttotc+=l[j].c*x;\n\t\t}\n\t\tqvis[p]=0;\n\t}\n\treturn flow;\n}\nint p[100],q[100],id[100][100];\nint cabs(int x){\n\tif(x<0)x=-x;\n\treturn x;\n}\nstruct point{\n\tint x;\n\tint y;\n\tint tx;\n\tint ty;\n}pc[100];\nvector<int>ansv[2];\nint main(){\n\tios::sync_with_stdio(false),cin.tie(0);\n\tsrand(time(0));\n\tint T,n,i,j,flow,flag;\n\tfor(cin>>T;T>0;T--)\n\t{\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>p[i];\n\t\t\tp[i]--;\n\t\t}\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>q[i];\n\t\t\tq[i]--;\n\t\t}\n\t\tfor(i=0;i<n*2+2;i++)head[i]=-1;\n\t\tcnt=0;\n\t\ttotc=0;\n\t\tflow=0;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tadd(n*2,i,1,0);\n\t\t\tadd(i+n,n*2+1,1,0);\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tid[i][j]=cnt;\n\t\t\t\tadd(i,j+n,1,cabs(i-j)+cabs(p[i]-q[j]));\n\t\t\t}\n\t\t}\n\t\twhile(spfa(n*2,n*2+1,n*2+2))flow+=dfs(n*2,n*2+1,inf);\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tpc[i].x=i;\n\t\t\tpc[i].y=p[i];\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(l[id[i][j]].w==0)\n\t\t\t\t{\n\t\t\t\t\tpc[i].tx=j;\n\t\t\t\t\tpc[i].ty=q[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1)\n\t\t{\n\t\t\tflag=0;\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(pc[j].tx<=pc[i].x&&pc[i].x<pc[j].x&&pc[j].x<=pc[i].tx)\n\t\t\t\t\t{\n\t\t\t\t\t\tansv[0].push_back(pc[i].x);\n\t\t\t\t\t\tansv[1].push_back(pc[j].x);\n\t\t\t\t\t\tswap(pc[i].x,pc[j].x);\n\t\t\t\t\t\tflag=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)break;\n\t\t}\n\t\twhile(1)\n\t\t{\n\t\t\tflag=0;\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(pc[j].ty<=pc[i].y&&pc[i].y<pc[j].y&&pc[j].y<=pc[i].ty)\n\t\t\t\t\t{\n\t\t\t\t\t\tansv[0].push_back(pc[i].x);\n\t\t\t\t\t\tansv[1].push_back(pc[j].x);\n\t\t\t\t\t\tswap(pc[i].y,pc[j].y);\n\t\t\t\t\t\tflag=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)break;\n\t\t}\n\t\tcout<<ansv[0].size()<<'\\n';\n\t\tfor(i=0;i<ansv[0].size();i++)cout<<ansv[0][i]+1<<' '<<ansv[1][i]+1<<'\\n';\n\t\tansv[0].clear();\n\t\tansv[1].clear();\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2062f",
      "PROBLEM_ID": "2062F",
      "PROBLEM_STATEMENT": "You are a cat selling fun algorithm problems. Today, you want to recommend your fun algorithm problems to $k$ cities.\n\nThere are a total of $n$ cities, each with two parameters $a_i$ and $b_i$. Between any two cities $i,j$ ($i\\ne j$), there is a bidirectional road with a length of $\\max(a_i + b_j , b_i + a_j)$. The cost of a path is defined as the total length of roads between every two adjacent cities along the path.\n\nFor $k=2,3,\\ldots,n$, find the minimum cost among all simple paths containing exactly $k$ distinct cities.\n\n### Input\n\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 1500$) \u2014 the number of test cases.\n\nFor each test case, the first line contains a single integer $n$ ($2 \\leq n \\leq 3\\cdot 10^3$) \u2014 the number of cities.\n\nThen $n$ lines follow, the $i$-th line contains two integers $a_i,b_i$ ($0 \\leq a_i,b_i \\leq 10^9$) \u2014 the parameters of city $i$.\n\nIt is guaranteed that the sum of $n^2$ over all test cases does not exceed $9\\cdot 10^6$.\n\n### Output\n\nFor each test case, print $n-1$ integers in one line. The $i$-th integer represents the minimum cost when $k=i+1$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n0 2\n\n2 1\n\n3 3\n\n5\n\n2 7\n\n7 5\n\n6 3\n\n1 8\n\n7 5\n\n8\n\n899167687 609615846\n\n851467150 45726720\n\n931502759 23784096\n\n918190644 196992738\n\n142090421 475722765\n\n409556751 726971942\n\n513558832 998277529\n\n294328304 434714258\n\n```\n\n#### Output #1\n\n```\n4 9\n10 22 34 46\n770051069 1655330585 2931719265 3918741472 5033924854 6425541981 7934325514\n```\n\n### Note\n\nIn the first test case:\n\n- For $k=2$, the optimal path is $1\\to 2$ with a cost of $\\max(0+1,2+2)=4$.\n- For $k=3$, the optimal path is $2\\to 1\\to 3$ with a cost of $\\max(0+1,2+2)+\\max(0+3,3+2)=4+5=9$.\n\nIn the second test case:\n\n- For $k=2$, the optimal path is $1\\to 4$.\n- For $k=3$, the optimal path is $2\\to 3\\to 5$.\n- For $k=4$, the optimal path is $4\\to 1\\to 3\\to 5$.\n- For $k=5$, the optimal path is $5\\to 2\\to 3\\to 1\\to 4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nstruct apos{\n\tlong long a;\n\tlong long b;\n\tfriend bool operator<(apos a,apos b){\n\t\treturn a.b-a.a<b.b-b.a;\n\t}\n}ap[3000];\nlong long dp[3001][3],tdp[3001][3],ans[3001],inf=1000000000000000000LL;\nint main(){\n\tios::sync_with_stdio(false),cin.tie(0);\n\tint T,n,i,j,t;\n\tfor(cin>>T;T>0;T--)\n\t{\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++)cin>>ap[i].a>>ap[i].b;\n\t\tsort(ap,ap+n);\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tdp[i][j]=inf;\n\t\t\t\ttdp[i][j]=inf;\n\t\t\t}\n\t\t\tans[i]=inf;\n\t\t}\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\ttdp[1][0]=min(tdp[1][0],ap[i].a*2);\n\t\t\ttdp[1][1]=min(tdp[1][1],ap[i].a);\n\t\t\tfor(j=1;j<n;j++)\n\t\t\t{\n\t\t\t\tfor(t=0;t<3;t++)tdp[j+1][t]=min(tdp[j+1][t],dp[j][t]+ap[i].a+ap[i].b);\n\t\t\t\ttdp[j+1][1]=min(tdp[j+1][1],dp[j][0]+ap[i].b);\n\t\t\t\ttdp[j+1][2]=min(tdp[j+1][2],dp[j][1]+ap[i].a);\n\t\t\t\tans[j+1]=min(ans[j+1],dp[j][1]+ap[i].b);\n\t\t\t\tans[j+1]=min(ans[j+1],dp[j][2]+ap[i].b*2);\n\t\t\t}\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tfor(t=0;t<3;t++)\n\t\t\t\t{\n\t\t\t\t\tdp[j][t]=min(dp[j][t],tdp[j][t]);\n\t\t\t\t\ttdp[j][t]=inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=2;i<=n;i++)cout<<ans[i]<<' ';\n\t\tcout<<'\\n';\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2062d",
      "PROBLEM_ID": "2062D",
      "PROBLEM_STATEMENT": "You are given a tree$^{\\text{\u2217}}$ with $n$ nodes and values $l_i, r_i$ for each node. You can choose an initial value $a_i$ satisfying $l_i\\le a_i\\le r_i$ for the $i$-th node. A tree is balanced if all node values are equal, and the value of a balanced tree is defined as the value of any node.\n\nIn one operation, you can choose two nodes $u$ and $v$, and increase the values of all nodes in the subtree$^{\\text{\u2020}}$ of node $v$ by $1$ while considering $u$ as the root of the entire tree. Note that $u$ may be equal to $v$.\n\nYour goal is to perform a series of operations so that the tree becomes balanced. Find the minimum possible value of the tree after performing these operations. Note that you don't need to minimize the number of operations.\n\n$^{\\text{\u2217}}$A tree is a connected graph without cycles.\n\n$^{\\text{\u2020}}$Node $w$ is considered in the subtree of node $v$ if any path from root $u$ to $w$ must go through $v$.\n\n### Input\n\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 10^5$) \u2014 the number of input test cases.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2\\cdot 10^5$) \u2014 the number of nodes in the tree.\n\nThen $n$ lines follow. The $i$-th line contains two integers $l_i,r_i$ ($0\\le l_i \\le r_i\\le 10^9$) \u2014 the constraint of the value of the $i$-th node.\n\nThe next $n-1$ lines contain the edges of the tree. The $i$-th line contains two integers $u_i,v_i$ ($1\\le u_i,v_i \\le n$, $u_i \\neq v_i$) \u2014 an edge connecting $u_i$ and $v_i$. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the minimum possible value that all $a_i$ can be made equal to after performing the operations. It can be shown that the answer always exists.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n4\n\n0 11\n\n6 6\n\n0 0\n\n5 5\n\n2 1\n\n3 1\n\n4 3\n\n7\n\n1 1\n\n0 5\n\n0 5\n\n2 2\n\n2 2\n\n2 2\n\n2 2\n\n1 2\n\n1 3\n\n2 4\n\n2 5\n\n3 6\n\n3 7\n\n4\n\n1 1\n\n1 1\n\n1 1\n\n0 0\n\n1 4\n\n2 4\n\n3 4\n\n7\n\n0 20\n\n0 20\n\n0 20\n\n0 20\n\n3 3\n\n4 4\n\n5 5\n\n1 2\n\n1 3\n\n1 4\n\n2 5\n\n3 6\n\n4 7\n\n5\n\n1000000000 1000000000\n\n0 0\n\n1000000000 1000000000\n\n0 0\n\n1000000000 1000000000\n\n3 2\n\n2 1\n\n1 4\n\n4 5\n\n6\n\n21 88\n\n57 81\n\n98 99\n\n61 76\n\n15 50\n\n23 67\n\n2 1\n\n3 2\n\n4 3\n\n5 3\n\n6 4\n\n```\n\n#### Output #1\n\n```\n11\n3\n3\n5\n3000000000\n98\n```\n\n### Note\n\nIn the first test case, you can choose $a=[6,6,0,5]$.\n\nYou can perform the following operations to make all $a_i$ equal:\n\n1. Choose $u=4$, $v=3$ and perform the operation $5$ times.\n2. Choose $u=1$, $v=3$ and perform the operation $6$ times.\n\nThe complete process is shown as follows (where the numbers inside the parentheses are elements of $a$):\n\n![](https://espresso.codeforces.com/7f1aa785ea78225224c7c60aeb85b5c2197683c0.png)\n\nIt can be proven that this is the optimal solution.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll INF = (ll)9e18;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    // We'll reuse storage across test cases up to total n <= 2e5\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<ll> l(n+1), r(n+1);\n        for (int i = 1; i <= n; i++) {\n            cin >> l[i] >> r[i];\n        }\n        vector<vector<int>> adj(n+1);\n        for (int i = 0; i < n-1; i++) {\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        // Root the tree at 1 (arbitrary)\n        int root = 1;\n        vector<int> parent(n+1, 0);\n        vector<int> order;\n        order.reserve(n);\n        // children list\n        vector<vector<int>> children(n+1);\n        // BFS to get parent[] and order[]\n        {\n            queue<int> q;\n            q.push(root);\n            parent[root] = 0;\n            while (!q.empty()) {\n                int u = q.front(); q.pop();\n                order.push_back(u);\n                for (int v: adj[u]) {\n                    if (v == parent[u]) continue;\n                    parent[v] = u;\n                    children[u].push_back(v);\n                    q.push(v);\n                }\n            }\n        }\n        // Pre-compute sum of r, and max of l\n        ll sumR = 0;\n        ll maxL = 0;\n        for (int i = 1; i <= n; i++) {\n            sumR += r[i];\n            maxL = max(maxL, l[i]);\n        }\n        // Binary search on X\n        ll low = maxL, high = sumR;\n        ll answer = sumR;\n        // Prepare dp arrays\n        vector<ll> L(n+1), U(n+1), d(n+1), qv(n+1);\n        // Check function\n        auto check = [&](ll X) {\n            // Compute L_i and U_i and validate\n            for (int i = 1; i <= n; i++) {\n                // minimal b_i = max(0, X - r_i)\n                ll Li = X - r[i];\n                if (Li < 0) Li = 0;\n                ll Ui = X - l[i];\n                // if Li > Ui => no feasible b_i\n                if (Li > Ui) return false;\n                L[i] = Li;\n                U[i] = Ui;\n            }\n            // Bottom-up dp in reverse BFS order\n            for (int idx = n-1; idx >= 0; idx--) {\n                int u = order[idx];\n                // process node u\n                ll d_base = 0;\n                ll mnq = INF;\n                // sum up children's d and find min q among children\n                for (int v: children[u]) {\n                    // Assuming children[v] processed already\n                    // if child infeasible, its q < d would have been caught then\n                    d_base += d[v];\n                    if (qv[v] < mnq) mnq = qv[v];\n                }\n                if (children[u].empty()) {\n                    mnq = INF; // no children\n                }\n                // choose q[u] in [L[u], U[u]] that minimizes D and maximizes q\n                ll qi;\n                if (L[u] <= mnq) {\n                    // can achieve minimal D (no penalty) by q <= mnq\n                    // pick as large as possible: min(mnq, U[u])\n                    qi = mnq < U[u] ? mnq : U[u];\n                } else {\n                    // domain entirely above mnq, minimal at q = L[u]\n                    qi = L[u];\n                }\n                // qi now in [L[u], U[u]]\n                // compute penalty sum over children\n                ll pen = 0;\n                for (int v: children[u]) {\n                    if (qi > qv[v]) {\n                        pen += (qi - qv[v]);\n                        // potential small overflow, but sums <= n*maxU ~2e5*2e14 ~4e19 > INF\n                        // but INF set ~9e18, though sumR <=2e14 so penalty sum <=2e14\n                        // safe\n                    }\n                }\n                ll di = d_base + pen;\n                // must satisfy di <= qi\n                if (di > qi) {\n                    return false;\n                }\n                d[u] = di;\n                qv[u] = qi;\n            }\n            // after dp, root is feasible\n            // root check di <= qi done in loop for u=root\n            return true;\n        };\n\n        // Binary search minimal X\n        while (low <= high) {\n            ll mid = (low + high) >> 1;\n            if (check(mid)) {\n                answer = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        cout << answer << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2062c",
      "PROBLEM_ID": "2062C",
      "PROBLEM_STATEMENT": "Cirno has a sequence $a$ of length $n$. She can perform either of the following two operations for any (possibly, zero) times unless the current length of $a$ is $1$:\n\n- Reverse the sequence. Formally, $[a_1,a_2,\\ldots,a_n]$ becomes $[a_n,a_{n-1},\\ldots,a_1]$ after the operation.\n- Replace the sequence with its difference sequence. Formally, $[a_1,a_2,\\ldots,a_n]$ becomes $[a_2-a_1,a_3-a_2,\\ldots,a_n-a_{n-1}]$ after the operation.\n\nFind the maximum possible sum of elements of $a$ after all operations.\n\n### Input\n\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 100$) \u2014 the number of input test cases.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 50$) \u2014 the length of sequence $a$.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($|a_i|\\le 1000$) \u2014 the sequence $a$.\n\n### Output\n\nFor each test case, print an integer representing the maximum possible sum.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n-1000\n\n2\n\n5 -3\n\n2\n\n1000 1\n\n9\n\n9 7 9 -9 9 -8 7 -8 9\n\n11\n\n678 201 340 444 453 922 128 987 127 752 0\n\n```\n\n#### Output #1\n\n```\n-1000\n8\n1001\n2056\n269891\n```\n\n### Note\n\nIn the first test case, Cirno can not perform any operation, so the answer is $-1000$.\n\nIn the second test case, Cirno firstly reverses the sequence, then replaces the sequence with its difference sequence: $[5,-3]\\to[-3,5]\\to[8]$. It can be proven that this maximizes the sum, so the answer is $8$.\n\nIn the third test case, Cirno can choose not to operate, so the answer is $1001$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// Function to reverse the vector\nvector<ll> reverse(vector<ll> a) {\n    vector<ll> res = a;\n    std::reverse(res.begin(), res.end());\n    return res;\n}\n\n// Function to get difference sequence \nvector<ll> diff(vector<ll> a) {\n    vector<ll> res;\n    for(int i = 1; i < a.size(); i++) {\n        res.push_back(a[i] - a[i-1]);\n    }\n    return res;\n}\n\n// Function to get sum of vector\nll getSum(vector<ll>& a) {\n    ll sum = 0;\n    for(ll x : a) sum += x;\n    return sum;\n}\n\n// Function to solve each test case\nll solve(vector<ll> a) {\n    int n = a.size();\n    if(n == 1) return a[0];\n    \n    // Set to keep track of all sequences we've seen\n    set<vector<ll>> seen;\n    // Queue for BFS\n    queue<vector<ll>> q;\n    \n    q.push(a);\n    seen.insert(a);\n    ll maxSum = getSum(a);\n    \n    while(!q.empty()) {\n        vector<ll> curr = q.front();\n        q.pop();\n        \n        // Try reversing\n        vector<ll> rev = reverse(curr);\n        if(seen.find(rev) == seen.end()) {\n            maxSum = max(maxSum, getSum(rev));\n            seen.insert(rev);\n            q.push(rev);\n        }\n        \n        // Try difference sequence\n        if(curr.size() > 1) {\n            vector<ll> d = diff(curr);\n            if(seen.find(d) == seen.end()) {\n                maxSum = max(maxSum, getSum(d));\n                seen.insert(d);\n                q.push(d);\n            }\n        }\n    }\n    \n    return maxSum;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while(t--) {\n        int n;\n        cin >> n;\n        vector<ll> a(n);\n        for(int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        cout << solve(a) << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2062b",
      "PROBLEM_ID": "2062B",
      "PROBLEM_STATEMENT": "You have a sequence of $n$ time clocks arranged in a line, where the initial time on the $i$-th clock is $a_i$. In each second, the following happens in order:\n\n- Each clock's time decreases by $1$. If any clock's time reaches $0$, you lose immediately.\n- You can choose to move to an adjacent clock or stay at the clock you are currently on.\n- You can reset the time of the clock you are on back to its initial value $a_i$.\n\nNote that the above events happen in order. If the time of a clock reaches $0$ in a certain second, even if you can move to this clock and reset its time during that second, you will still lose.\n\nYou can start from any clock. Determine if it is possible to continue this process indefinitely without losing.\n\n### Input\n\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nFor each test case, the first line contains a single integer $n$ ($2 \\leq n \\leq 5 \\cdot 10^5$) \u2014 the number of time clocks.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the initial times set on the clocks.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5\\cdot 10^5$.\n\n### Output\n\nFor each test case, print \"YES\" (without quotes) if it is possible to continue this process indefinitely, or \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\" and \"Yes\" will be recognized as a positive response).\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n4 10\n\n2\n\n2 2\n\n3\n\n4 10 5\n\n3\n\n5 3 5\n\n5\n\n12 13 25 17 30\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nNO\nYES\nYES\n```\n\n### Note\n\nIn the first test case, you can move back and forth between the two clocks, resetting them repeatedly.\n\nIn the third test case, assuming that you start from clock $1$ and follow the strategy below:\n\nInitially, $a=[4,10,5]$.\n\n1. $a$ becomes $[3, 9, 4]$. You move to clock $2$ and reset its time, resulting in $a=[3, 10, 4]$.\n2. $a$ becomes $[2, 9, 3]$. You move to clock $3$ and reset its time, resulting in $a=[2, 9, 5]$.\n3. $a$ becomes $[1, 8, 4]$. You move to clock $2$ and reset its time, resulting in $a=[1, 10, 4]$.\n4. $a$ becomes $[0, 9, 3]$. You move to clock $1$, but you lose because $a_1$ reaches $0$.\n\nIt can be proven that no other strategy allows you to continue this process indefinitely.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm> // Required for std::max\n\n// Using std::max should be fine as long as arguments are cast properly or are already long long.\n// Explicitly define a max function for long long to ensure type correctness and potentially avoid subtle issues.\nlong long max_ll(long long a, long long b) {\n    return a > b ? a : b;\n}\n\nint main() {\n    // Faster I/O operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Number of clocks\n        std::cin >> n;\n        std::vector<long long> a(n); // Initial times on clocks\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n        }\n        \n        // According to the problem statement, n >= 2.\n\n        bool possible = true; // Flag to track if survival is possible\n\n        // The core idea is to check if a specific strategy allows survival indefinitely.\n        // The strategy considered is moving back and forth between clock 1 and clock n:\n        // Path: 1 -> 2 -> ... -> n -> n-1 -> ... -> 1 -> ... (repeats)\n        // This cycle takes T = 2 * (n-1) seconds total.\n        // During this cycle, each clock i must be reset periodically.\n        // Let T_i be the maximum time interval between consecutive resets of clock i.\n        // For the process to be sustainable, after clock i is reset to a_i,\n        // it must not reach 0 before its next reset T_i seconds later.\n        // The time decreases by 1 each second. After T_i seconds, the time will have decreased by T_i.\n        // Just before the reset at time t+T_i, the clock time is a_i - T_i (if reset at t).\n        // The problem states that if a clock reaches 0 after the decrease step, you lose.\n        // This means after decreasing, the time must be >= 1.\n        // So, at the time of reset (just before the decrease step), the time must be >= 2.\n        // But the logic based on examples and the Note suggests the check is right after decrease.\n        // A clock with time 1 becomes 0 and you lose. Thus, after decrease, time must be >= 1.\n        // So, just before the decrease step (at the start of the second), the time must be >= 2.\n        // If a clock is reset to a_i, and the next reset is T_i seconds later,\n        // at the start of the second when it's reset again, its time is a_i - (T_i - 1).\n        // In that second, it decreases to a_i - T_i. This must be >= 1.\n        // So, the condition is a_i >= T_i + 1.\n\n        // For the endpoint clocks 1 and n:\n        // They are reset once per cycle. The time interval is T = 2 * (n-1).\n        // Required condition: a[0] >= T + 1 = 2*(n-1) + 1 = 2n - 1.\n        // Required condition: a[n-1] >= T + 1 = 2*(n-1) + 1 = 2n - 1.\n        \n        // Check condition for clock 1 (index 0)\n        if (a[0] < (long long)2 * n - 1) {\n            possible = false;\n        }\n        \n        // Check condition for clock n (index n-1)\n        if (possible) { // Only check if still considered possible\n            if (a[n - 1] < (long long)2 * n - 1) {\n                 possible = false;\n            }\n        }\n        \n        // For intermediate clocks k (where 1 < k < n):\n        // Clock k is reset twice per cycle:\n        // 1. When moving 1 -> n, arriving at k from k-1. Reset time t = k-1.\n        // 2. When moving n -> 1, arriving at k from k+1. Reset time t = (n-1) + (n-k).\n        // The time interval between reset 1 and reset 2 is T_k1 = (n-1 + n-k) - (k-1) = 2n - 2k = 2*(n-k).\n        // The time interval between reset 2 and the next reset 1 (in the next cycle) is T_k2 = (2*(n-1) + k-1) - (n-1 + n-k) = 2k - 2 = 2*(k-1).\n        // The maximum time interval for clock k is max(T_k1, T_k2).\n        // Required condition: a[k-1] >= max(T_k1, T_k2) + 1.\n        \n        // Check conditions for intermediate clocks k where 1 < k < n (indices 1 to n-2 in 0-based)\n        // This loop only runs if n >= 3.\n        if (possible) {\n            // Loop variable i is the 0-based index. It corresponds to clock k=i+1 (1-based).\n            for (int i = 1; i < n - 1; ++i) { \n                long long k = i + 1; // k is the 1-based clock index (from 2 to n-1)\n                \n                // Calculate the maximum time interval between consecutive resets for clock k\n                // using the back-and-forth strategy 1 <-> n.\n                long long interval1 = 2LL * (n - k); // Duration between resets on path segment k...n...k\n                long long interval2 = 2LL * (k - 1); // Duration between resets on path segment k...1...k\n                long long max_interval = std::max(interval1, interval2); // Use std::max with long long args\n                \n                // Required minimum initial value for clock k (a[i])\n                // Must be at least max_interval + 1 to survive the decrease step just before reset.\n                long long required = max_interval + 1;\n                \n                if (a[i] < required) {\n                    possible = false;\n                    break; // If one clock fails, this strategy fails. We assume this implies impossibility.\n                }\n            }\n        }\n        \n        // Note: The conditions derived above automatically ensure a[i] >= 2.\n        // For n=2, endpoints require a[i] >= 2*2 - 1 = 3.\n        // For n>=3, endpoints require a[i] >= 2n-1 >= 5.\n        // Intermediate clocks require a[i] >= max(2*(n-k), 2*(k-1)) + 1.\n        // The minimum value of max(n-k, k-1) for k in [2, n-1] is floor((n-1)/2).\n        // So minimum required is 2*floor((n-1)/2) + 1. This is n if n is odd, n-1 if n is even.\n        // Since n>=3, this minimum is at least 3-1=2? No, for n=3, min req is 3. For n=4, min req is 3.\n        // The minimum required value over all clocks is min(2n-1, 2*floor((n-1)/2)+1). For n=3, min(5,3)=3. For n=4, min(7,3)=3? Check n=4 calc again.\n        // n=4, k=2: req=max(2*(4-2), 2*(2-1))+1 = max(4,2)+1 = 5. k=3: req=max(2*(4-3), 2*(3-1))+1 = max(2,4)+1=5. Min req is 5.\n        // So required values are always >= 3 for n>=2. This covers the basic a[i] >= 2 necessity.\n        \n        if (possible) {\n            std::cout << \"YES\\n\";\n        } else {\n            std::cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2062a",
      "PROBLEM_ID": "2062A",
      "PROBLEM_STATEMENT": "You are given a string $s$ of length $n$ consisting of $\\mathtt{0}$ and/or $\\mathtt{1}$. In one operation, you can select a non-empty subsequence $t$ from $s$ such that any two adjacent characters in $t$ are different. Then, you flip each character of $t$ ($\\mathtt{0}$ becomes $\\mathtt{1}$ and $\\mathtt{1}$ becomes $\\mathtt{0}$). For example, if $s=\\mathtt{\\underline{0}0\\underline{101}}$ and $t=s_1s_3s_4s_5=\\mathtt{0101}$, after the operation, $s$ becomes $\\mathtt{\\underline{1}0\\underline{010}}$.\n\nCalculate the minimum number of operations required to change all characters in $s$ to $\\mathtt{0}$.\n\nRecall that for a string $s = s_1s_2\\ldots s_n$, any string $t=s_{i_1}s_{i_2}\\ldots s_{i_k}$ ($k\\ge 1$) where $1\\leq i_1 < i_2 < \\ldots <i_k\\leq n$ is a subsequence of $s$.\n\n### Input\n\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of input test cases.\n\nThe only line of each test case contains the string $s$ ($1\\le |s|\\le 50$), where $|s|$ represents the length of $s$.\n\n### Output\n\nFor each test case, output the minimum number of operations required to change all characters in $s$ to $\\mathtt{0}$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n000\n\n1001\n\n10101\n\n01100101011101\n\n```\n\n#### Output #1\n\n```\n1\n0\n2\n3\n8\n```\n\n### Note\n\nIn the first test case, you can flip $s_1$. Then $s$ becomes $\\mathtt{0}$, so the answer is $1$.\n\nIn the fourth test case, you can perform the following three operations in order:\n\n1. Flip $s_1s_2s_3s_4s_5$. Then $s$ becomes $\\mathtt{\\underline{01010}}$.\n2. Flip $s_2s_3s_4$. Then $s$ becomes $\\mathtt{0\\underline{010}0}$.\n3. Flip $s_3$. Then $s$ becomes $\\mathtt{00\\underline{0}00}$.\n\nIt can be shown that you can not change all characters in $s$ to $\\mathtt{0}$ in less than three operations, so the answer is $3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        string s;\n        cin >> s;\n        int count = 0;\n        for (char c : s) {\n            if (c == '1') {\n                count++;\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2061i",
      "PROBLEM_ID": "2061I",
      "PROBLEM_STATEMENT": "Kevin and Nivek are competing for the title of \"The Best Kevin\". They aim to determine the winner through $n$ matches.\n\nThe $i$-th match can be one of two types:\n\n- Type 1: Kevin needs to spend $a_i$ time to defeat Nivek and win the match. If Kevin doesn't spend $a_i$ time on it, Nivek will win the match.\n- Type 2: The outcome of this match depends on their historical records. If Kevin's number of wins is greater than or equal to Nivek's up to this match, then Kevin wins. Otherwise, Nivek wins.\n\nKevin wants to know the minimum amount of time he needs to spend to ensure he wins at least $k$ matches.\n\nOutput the answers for $k = 0, 1, \\ldots, n$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$)\u00a0\u2014 the number of matches.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-1 \\leq a_i \\leq 10^9$).\n\nIf $a_i = -1$, the $i$-th match is of Type 2. Otherwise, the $i$-th match is of Type 1, and $a_i$ represents the amount of time Kevin needs to spend to win this match.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n + 1$ integers. The $i$-th integer represents the minimum amount of time to win at least $i-1$ matches.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5\n\n-1 -1 -1 -1 -1\n\n5\n\n3 2 5 4 1\n\n5\n\n100 -1 -1 -1 1\n\n```\n\n#### Output #1\n\n```\n0 0 0 0 0 0\n0 1 3 6 10 15\n0 1 100 100 100 101\n```\n\n### Note\n\nIn the first test case, all matches are of Type 2. Kevin can automatically win all matches.\n\nIn the second test case, all matches are of Type 1. Kevin can choose matches in increasing order of $a_i$.\n\nIn the third test case:\n\n- If Kevin spends $a_1$ time on match $1$, he can win matches $1, 2, 3, 4$.\n- If Kevin spends $a_5$ time on match $5$, he can win match $5$.\n- If Kevin spends $a_1$ time on match $1$ and $a_5$ time on match $5$, he can win all matches.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define N 300005\n#define V vector<long long >\nusing namespace std;\nconst long long inf=1e18;\nint n,a[N];\nlong long s[N],g[N],h[N];\nvoid calc(int ql,int qr,int l,int r,int k){\n\tif(ql>qr||l==r){\n\t\tfor(int i=ql;i<=qr;i++) h[i]=g[l]+s[i-l];\n\t\treturn;\n\t}\n\tint mid=(ql+qr)/2,pos=0;h[mid]=inf;\n\tfor(int i=max(l,mid-k);i<=r&&i<=mid;i++)\n\t\tif(h[mid]>g[i]+s[mid-i]) h[mid]=g[i]+s[mid-i],pos=i;\n\tcalc(ql,mid-1,l,pos,k);\n\tcalc(mid+1,qr,pos,r,k);\n}\nV fz(int l,int r,int d,int u,V f){\n\tV ret;for(int i=d;i<=u+(r-l);i++) ret.push_back(inf);\n\tif(r-l==1){\n\t\tfor(int i=d;i<=u;i++){\n\t\t\tif(a[r]==-1){\n\t\t\t\tif(i*2>=l) ret[i+1-d]=min(ret[i+1-d],f[i-d]);\n\t\t\t\telse ret[i-d]=min(ret[i-d],f[i-d]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret[i+1-d]=min(ret[i+1-d],f[i-d]+a[r]);\n\t\t\t\tret[i-d]=min(ret[i-d],f[i-d]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=u-d+(r-l)-1;i>=0;i--) ret[i]=min(ret[i],ret[i+1]);\n\t\treturn ret;\n\t}\n\tint limd=min(u,(2*l-r)/2-1),limu=max(d,r/2+1);\n\tint tot=0,cnt=0;\n\tfor(int i=l+1;i<=r;i++){\n\t\tif(a[i]==-1) cnt++;\n\t\telse s[++tot]=a[i];\n\t}\n\tsort(s+1,s+tot+1);s[0]=0;\n\tfor(int i=2;i<=tot;i++) s[i]+=s[i-1];\n\tif(d<=limd){\n\t\tfor(int i=d;i<=limd;i++) g[i-d]=f[i-d];\n\t\tcalc(0,limd-d+tot,0,limd-d,tot);\n\t\tfor(int i=d;i<=limd+tot;i++) ret[i-d]=h[i-d];\n\t}\n\tif(limu<=u){\n\t\tfor(int i=limu;i<=u;i++) g[i-limu]=f[i-d];\n\t\tcalc(0,u-limu+tot,0,u-limu,tot);\n\t\tfor(int i=limu;i<=u+tot;i++) ret[i+cnt-d]=min(ret[i+cnt-d],h[i-limu]);\n\t}\n\tint mid=(l+r)/2,xd=max(d,limd+1),xu=min(u,limu-1);\n\tV go;for(int i=xd;i<=xu;i++) go.push_back(f[i-d]);\n\tV r0=fz(l,mid,xd,xu,go);\n\tV r1=fz(mid,r,xd,xu+(mid-l),r0);\n\tfor(int i=xd;i<=xu+(r-l);i++) ret[i-d]=min(ret[i-d],r1[i-xd]);\n\tfor(int i=u-d+(r-l)-1;i>=0;i--) ret[i]=min(ret[i],ret[i+1]);\n\treturn ret;\n}\nvoid solve(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tV st;st.push_back(0ll);\n\tV ans=fz(0,n,0,0,st);\n\tfor(int i=0;i<=n;i++) printf(\"%lld \",ans[i]);\n\tprintf(\"\\n\");\n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2061h2",
      "PROBLEM_ID": "2061H2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, you need to output a valid sequence of operations if one exists. You can hack only if you solved all versions of this problem.\n\nKevin has an undirected graph with $n$ vertices and $m$ edges. Initially, some vertices contain stones, which Kevin wants to move to new positions.\n\nKevin can perform the following operation:\n\n- For each stone at $u_i$, select a neighboring vertex $v_i$. Simultaneously move each stone from $u_i$ to its corresponding $v_i$.\n\nAt any time, each vertex can contain at most one stone.\n\nDetermine whether a valid sequence of operations exists that moves the stones from the initial state to the target state. Output a valid sequence of operations with no more than $2n$ moves if one exists. It can be proven that if a valid sequence exists, a valid sequence with no more than $2n$ moves exists.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1\\leq n \\leq 2000$, $0\\leq m \\leq \\min(\\frac{n(n-1)}{2}, 10^4)$)\u00a0\u2014 the number of vertices and edges in the graph.\n\nThe second line contains a binary string $s$ consisting of '0' and '1'. The $i$-th bit of $s$ indicates the number of stones on the $i$-th vertex in the initial state.\n\nThe third line contains a binary string $t$ consisting of '0' and '1'. The $i$-th bit of $t$ indicates the number of stones on the $i$-th vertex in the target state.\n\nEach of the next $m$ lines contains two integers $u$ and $v$ ($1\\leq u, v \\leq n$)\u00a0\u2014 an undirected edge between the $u$-th vertex and the $v$-th vertex.\n\nIt is guaranteed that the graph is simple. There are no self-loops and parallel edges in the graph.\n\nIt is guaranteed that the numbers of '1' in $s$ and $t$ are the same.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.\n\nIt is guaranteed that the sum of $m$ over all test cases does not exceed $10^4$.\n\n### Output\n\nFor each test case, on the first line, output \"Yes\" or \"No\" to indicate whether a valid sequence of operations exists.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nIf a valid sequence of operations exists, output a single integer $k$ ($0 \\leq k \\leq 2n$) on the second line, representing the number of operations. Suppose there are $c$ stones in the initial state. The next $k + 1$ lines should each contain distinct $c$ integers, representing the positions of the stones before the operations and after each operation. These positions should satisfy the following:\n\n- The positions of the stones in the first line match the initial state from the input, in any order.\n- The positions of the stones in the last line match the target state from the input, in any order.\n- For all $i$ ($1\\leq i\\leq k$) and $j$ ($1\\leq j\\leq c$), ensure that the $j$-th integer in the $i$-th line and the $j$-th integer in the $(i+1)$-th line correspond to adjacent vertices in the graph. In other words, the stone is moved from its previous position to the next.\n\nIf there are multiple solutions, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 1\n\n10\n\n01\n\n1 2\n\n11 11\n\n11011001010\n\n01101011100\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n5 6\n\n6 7\n\n7 8\n\n8 9\n\n9 10\n\n10 11\n\n11 1\n\n3 2\n\n110\n\n101\n\n1 2\n\n2 3\n\n3 2\n\n111\n\n111\n\n1 2\n\n2 3\n\n```\n\n#### Output #1\n\n```\nYes\n1\n1\n2\nYes\n6\n1 2 4 5 8 10\n2 3 5 6 9 11\n3 2 6 7 10 1\n4 3 7 8 11 2\n5 2 8 9 1 3\n6 3 7 8 2 4\n7 2 8 9 3 5\nNo\nYes\n0\n1 2 3\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<cstdio>\n#include<queue>\n#define TY int\n#define MAXN 4002\n#define MAXM 40002\n#define FOR(i,a,b)for(TY i=(a);i<=(b);i=-~i)\n#define fOR(i,a,b)for(TY i=(a);i<(b);i=-~i)\n#define ROF(i,a,b)for(TY i=(a);i>=(b);i=~-i)\n#define rOF(i,a,b)for(TY i=(a);i>(b);i=~-i)\n#define EDG(i,u)for(TY i=hed[u];i;i=nxt[i])\nusing namespace std;\ntypedef long long ll;\nconst TY M=998244353;\ntypedef unsigned long long ull;\nTY _abs(TY a){return a<0?-a:a;}\nTY maxn(TY a,TY b){return a>b?a:b;}\nTY minn(TY a,TY b){return a<b?a:b;}\ninline void updmx(TY &x,TY y){if(x<y)x=y;}\ninline void updmn(TY &x,TY y){if(x>y)x=y;}\ninline void add(TY &x,TY y){if((x+=y)>=M)x-=M;}\nTY gcd(TY a,TY b){return b?gcd(b,a%b):a;}\nTY qp(TY a,TY b){TY ans=1;do{if(1&b)ans=ans*a%M;a=a*a%M;}while(b>>=1);return ans;}\nchar getc(){char ch=getchar();while(ch==' '||ch=='\\n'||ch=='\\r')ch=getchar();return ch;}\nTY qr(){\n\tchar ch=getchar();TY s=0,x=1;\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')x=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())s=s*10+ch-'0';return x*s;\n}void qw(TY a){if(a>9)qw(a/10);putchar(a%10+'0');}\nvoid qw(TY a,char ch){\n\tif(a<0){a=-a;putchar('-');}\n\tif(a>9)qw(a/10);putchar(a%10+'0');if(ch)putchar(ch);\n}TY T=qr(),n,m,u,v,edg,hed[MAXN],nxt[MAXM],to[MAXM],mch[MAXN],mct[MAXN],fa[MAXN],l,r;\nchar s[MAXN],t[MAXN];bool vs[MAXN],fl,us[MAXM];TY ans[MAXN][MAXN],ar[MAXN],ct;queue<TY>q;\nTY getfa(TY u){return fa[u]!=u?fa[u]=getfa(fa[u]):u;}\nvoid addedge(TY u,TY v){\n\tnxt[++edg]=hed[u];to[hed[u]=edg]=v;\n\tnxt[++edg]=hed[v];to[hed[v]=edg]=u;\n}void dfs(TY u){\n\tif(u<=n&&s[u]=='1')++v;\n\tif(u<=n&&t[u]=='1')--v;vs[u]=true;\n\tEDG(i,u)if(!vs[to[i]])dfs(to[i]);\n}bool findmch(TY u){\n\tif(vs[u])return false;vs[u]=true;\n\tEDG(i,u)if(us[i>>1])if(!mch[to[i]-n]||findmch(mch[to[i]-n]))\n\t\t{mch[to[i]-n]=u;return true;}return false;\n}void bfs(TY x){\n\tFOR(i,1,n<<1)fa[i]=0;v=ar[x];\n\twhile(q.size())q.pop();q.push(x);\n\twhile(q.size()){\n\t\tu=q.front();q.pop();\n\t\tif(u<=n&&t[u]=='1'){\n\t\t\trOF(i,n-1<<1,r){\n\t\t\t\tif(1&i)ans[i][v]=mct[u]-n;\n\t\t\t\telse ans[i][v]=u;\n\t\t\t}t[u]=s[x]='0';ROF(i,r,1){\n\t\t\t\tans[i][v]=u;if(1&i)ans[i][v]-=n;\n\t\t\t\tif(u==x)u=mch[x];\n\t\t\t\telse if(u==mch[x])u=x;\n\t\t\t\telse u=fa[u];\n\t\t\t}r-=2;return;\n\t\t}EDG(i,u)if(!fa[to[i]]&&us[i>>1]){\n\t\t\tfa[to[i]]=u;q.push(to[i]);\n\t\t\tif(to[i]<=n&&t[to[i]]=='1'&&mct[to[i]]==u){\n\t\t\t\tTY val=to[i];\n\t\t\t\tu=to[i];rOF(i,n-1<<1,r){\n\t\t\t\t\tif(1&i)ans[i][v]=mct[u]-n;\n\t\t\t\t\telse ans[i][v]=u;\n\t\t\t\t}t[u]=s[x]='0';ROF(i,r,1){\n\t\t\t\t\tans[i][v]=u;if(1&i)ans[i][v]-=n;\n\t\t\t\t\tif(u==x)u=mch[x];\n\t\t\t\t\telse if(u==mch[x])u=x;\n\t\t\t\t\telse u=fa[u];\n\t\t\t\t}r-=2;return;\n\t\t\t}\n\t\t}\n\t}\n}void bfs2(TY x){\n\tFOR(i,1,n<<1)fa[i]=0;\n\twhile(q.size())q.pop();q.push(x);\n\twhile(q.size()){\n\t\tu=q.front();q.pop();\n\t\tif(u<=n&&s[u]=='1'){\n\t\t\tv=ar[u];fOR(i,1,l){\n\t\t\t\tif(1&i)ans[i][v]=mch[u]-n;\n\t\t\t\telse ans[i][v]=u;\n\t\t\t}s[u]=t[x]='0';FOR(i,l,n-1<<1){\n\t\t\t\tif(u==x)u=mct[x];\n\t\t\t\telse if(u==mct[x])u=x;\n\t\t\t\telse u=fa[u];\n\t\t\t\tans[i][v]=u;if(1&i)ans[i][v]-=n;\n\t\t\t}l+=2;return;\n\t\t}EDG(i,u)if(!fa[to[i]]&&us[i>>1]){\n\t\t\tfa[to[i]]=u;q.push(to[i]);\n\t\t\tif(to[i]<=n&&s[to[i]]=='1'&&u==mch[to[i]]){\n\t\t\t\tv=ar[u=to[i]];fOR(i,1,l){\n\t\t\t\t\tif(1&i)ans[i][v]=mch[u]-n;\n\t\t\t\t\telse ans[i][v]=u;\n\t\t\t\t}s[u]=t[x]='0';FOR(i,l,n-1<<1){\n\t\t\t\t\tif(u==x)u=mct[x];\n\t\t\t\t\telse if(u==mct[x])u=x;else u=fa[u];\n\t\t\t\t\tans[i][v]=u;if(1&i)ans[i][v]-=n;\n\t\t\t\t}l+=2;return;\n\t\t\t}\n\t\t}\n\t}\n}void dfs(TY u,TY fa){\n\tvs[u]=true;TY p=-1,q=-1;\n\tEDG(i,u)if(to[i]!=fa&&us[i>>1]){\n\t\tdfs(to[i],u);if(to[i]<=n&&s[to[i]]=='1'&&mch[to[i]]==u)p=to[i];\n\t\tif(to[i]<=n&&t[to[i]]=='1'&&mct[to[i]]==u)q=to[i];\n\t}if(~p&&s[p]=='1')bfs(p);if(~q&&t[q]=='1')bfs2(q);\n\tif(u<=n&&s[u]=='1'&&mch[u]!=fa)bfs(u);\n\tif(u<=n&&t[u]=='1'&&mct[u]!=fa)bfs2(u);\n}void findans(){\n\tFOR(i,1,m<<1)us[i]=false;FOR(i,1,n<<1)fa[i]=i;\n\tFOR(i,1,n)mch[i]=ar[i];FOR(i,1,n)ar[mct[i]]=i+n;FOR(i,1,n)mct[i]=ar[i];\n\tFOR(i,1,n)if(t[i]=='1')EDG(j,i)if(mct[i]==to[j])\n\t\t{us[j>>1]=true;fa[getfa(i)]=getfa(to[j]);}\n\tFOR(i,1,n)if(s[i]=='1'){\n\t\tif(getfa(i)==getfa(mch[i]))continue;\n\t\tEDG(j,i)if(mch[i]==to[j])\n\t\t\t{us[j>>1]=true;fa[getfa(i)]=getfa(to[j]);}\n\t}FOR(i,1,m<<1)if(!us[i]){\n\t\tu=to[i<<1];v=to[i<<1|1];\n\t\tif(getfa(u)==getfa(v))continue;\n\t\tus[i]=true;fa[getfa(u)]=v;\n\t}FOR(i,1,n)mch[i]=0;FOR(i,1,n)if(s[i]=='1')\n\t\t{FOR(j,1,n)vs[j]=false;findmch(i);}\n\tFOR(i,1,n)ar[mch[i]]=i+n;FOR(i,1,n)mch[i]=ar[i];\n\tct=0;FOR(i,1,n)if(s[i]=='1'){qw(i,' ');ar[i]=++ct;}putchar('\\n');\n\tl=1;r=n-1<<1;FOR(i,1,n<<1)vs[i]=false;FOR(i,1,n<<1)if(!vs[i])dfs(i,0);\n\tFOR(i,1,n-1<<1){FOR(j,1,ct)qw(ans[i][j],' ');putchar('\\n');}\n}int main(){\n\twhile(T--){\n\t\tn=qr();m=qr();edg=fl=1;\n\t\tFOR(i,1,n<<1)hed[i]=0;\n\t\tscanf(\"%s%s\",s+1,t+1);\n\t\tFOR(i,1,m){\n\t\t\tu=qr();v=qr();\n\t\t\taddedge(u,v+n);addedge(u+n,v);\n\t\t}FOR(i,1,n)if(s[i]!=t[i])fl=false;\n\t\tif(fl){\n\t\t\tprintf(\"Yes\\n0\\n\");\n\t\t\tFOR(i,1,n)if(s[i]=='1')qw(i,' ');\n\t\t\tputchar('\\n');continue;\n\t\t}FOR(i,1,n)mch[i]=ar[i]=0;\n\t\tFOR(i,1,m<<1)us[i]=true;\n\t\tFOR(i,1,n)if(t[i]=='1'){\n\t\t\tFOR(j,1,n)vs[j]=false;\n\t\t\tif(!findmch(i)){fl=true;break;}\n\t\t}FOR(i,1,n){mct[i]=mch[i];mch[i]=0;}\n\t\tFOR(i,1,n)if(s[i]=='1'){\n\t\t\tFOR(j,1,n)vs[j]=false;\n\t\t\tif(!findmch(i)){fl=true;break;}\n\t\t}if(fl){printf(\"No\\n\");continue;}\n\t\tFOR(i,1,n<<1)vs[i]=false;\n\t\tFOR(i,1,n<<1)if(!vs[i]){\n\t\t\tv=0;dfs(i);if(v)fl=true;\n\t\t}if(!fl){\n\t\t\tprintf(\"Yes\\n\");qw(n-1<<1,'\\n');\n\t\t\tFOR(i,1,n)ar[mch[i]]=i+n;findans();continue;\n\t\t}FOR(i,1,n){\n\t\t\ts[i]='0'+(!!mch[i]);ar[mch[i]]=i;\n\t\t}FOR(i,1,n)mch[i]=ar[i];\n\t\tFOR(i,1,n<<1)vs[i]=false;fl=false;\n\t\tFOR(i,1,n<<1)if(!vs[i]){\n\t\t\tv=0;dfs(i);if(v)fl=true;\n\t\t}if(fl){printf(\"No\\n\");continue;}\n\t\tprintf(\"Yes\\n\");qw((n<<1)-1,'\\n');\n\t\tFOR(i,1,n)ar[mch[i]]=i+n;\n\t\tFOR(i,1,n)if(s[i]=='1')qw(ar[i]-n,' ');\n\t\tputchar('\\n');findans();\n\t}return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2061h1",
      "PROBLEM_ID": "2061H1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, you only need to determine whether a valid sequence of operations exists. You can hack only if you solved all versions of this problem.\n\nKevin has an undirected graph with $n$ vertices and $m$ edges. Initially, some vertices contain stones, which Kevin wants to move to new positions.\n\nKevin can perform the following operation:\n\n- For each stone at $u_i$, select a neighboring vertex $v_i$. Simultaneously move each stone from $u_i$ to its corresponding $v_i$.\n\nAt any time, each vertex can contain at most one stone.\n\nDetermine whether a valid sequence of operations exists that moves the stones from the initial state to the target state.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1\\leq n \\leq 2000$, $0\\leq m \\leq \\min(\\frac{n(n-1)}{2}, 10^4)$)\u00a0\u2014 the number of vertices and edges in the graph.\n\nThe second line contains a binary string $s$ consisting of '0' and '1'. The $i$-th bit of $s$ indicates the number of stones on the $i$-th vertex in the initial state.\n\nThe third line contains a binary string $t$ consisting of '0' and '1'. The $i$-th bit of $t$ indicates the number of stones on the $i$-th vertex in the target state.\n\nEach of the next $m$ lines contains two integers $u$ and $v$ ($1\\leq u, v \\leq n$)\u00a0\u2014 an undirected edge between the $u$-th vertex and the $v$-th vertex.\n\nIt is guaranteed that the graph is simple. There are no self-loops and parallel edges in the graph.\n\nIt is guaranteed that the numbers of '1' in $s$ and $t$ are the same.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.\n\nIt is guaranteed that the sum of $m$ over all test cases does not exceed $10^4$.\n\n### Output\n\nFor each test case, on the first line, output \"Yes\" or \"No\" to indicate whether a valid sequence of operations exists.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 1\n\n10\n\n01\n\n1 2\n\n11 11\n\n11011001010\n\n01101011100\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n5 6\n\n6 7\n\n7 8\n\n8 9\n\n9 10\n\n10 11\n\n11 1\n\n3 2\n\n110\n\n101\n\n1 2\n\n2 3\n\n3 2\n\n111\n\n111\n\n1 2\n\n2 3\n\n```\n\n#### Output #1\n\n```\nYes\nYes\nNo\nYes\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst ll mod=998244353;\nconst int N=2e6+5;\nll n,m;\nint s[N],t[N];\nvector<int>adj[N];\n\nbool vis[N];\nint col[N];\nint mat[N];\nbool dfs(int id){\n\tvis[id]=true;\n\tfor(auto c:adj[id]){\n\t\tif(mat[n+c]==0){\n\t\t\tmat[id]=n+c;\n\t\t\tmat[n+c]=id;\n\t\t\treturn true;\n\t\t}\n\t\telse if(!vis[mat[n+c]]){\n\t\t\tbool res=dfs(mat[n+c]);\n\t\t\tif(res){\n\t\t\t\tmat[id]=n+c;\n\t\t\t\tmat[n+c]=id;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool aespa(){\n\tfor(int i=1; i<=2*n ;i++) mat[i]=0;\n\tfor(int i=1; i<=n ;i++){\n\t\tif(s[i]==0) continue;\n\t\tfor(int j=1; j<=n ;j++) vis[j]=false;\n\t\tif(!dfs(i)) return false;\n\t}\n\treturn true;\n} \nbool bi;\nint sx[2],sy[2];\nvoid bdfs(int id){\n\tvis[id]=true;\n\tif(s[id]) sx[col[id]]++;\n\tif(t[id]) sy[col[id]]++;\n\tfor(auto c:adj[id]){\n\t\tif(vis[c]){\n\t\t\tif(col[c]+col[id]!=1) bi=false;\n\t\t}\n\t\telse{\n\t\t\tcol[c]=1-col[id];\n\t\t\tbdfs(c);\n\t\t}\n\t}\n}\nbool solve(){\n\tcin >> n >> m;\n\tfor(int i=1; i<=n ;i++){\n\t\tadj[i].clear();\n\t\tmat[i]=0;\n\t}\n\tfor(int i=1; i<=n ;i++){\n\t\tchar c;cin >> c;\n\t\ts[i]=c-48;\n\t}\n\tfor(int i=1; i<=n ;i++){\n\t\tchar c;cin >> c;\n\t\tt[i]=c-48;\n\t}\n\tbool same=true;\n\tfor(int i=1; i<=n ;i++) if(s[i]!=t[i]) same=false;\n\tfor(int i=1; i<=m ;i++){\n\t\tint u,v;cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tif(same) return true;\n\tif(!aespa()) return false;\n\tfor(int i=1; i<=n ;i++) swap(s[i],t[i]);\n\tif(!aespa()) return false;\n\tint bal=0;\n\tfor(int i=1; i<=n ;i++) vis[i]=false;\n\tbool can[2];\n\tcan[0]=can[1]=true;\n\tfor(int i=1; i<=n ;i++){\n\t\tif(vis[i]) continue;\n\t\tbi=true;\n\t\tsx[0]=sx[1]=sy[0]=sy[1]=0;\n\t\tcol[i]=0;\n\t\tbdfs(i);\n\t\tif(bi){\n\t\t\tif(sx[0]==sy[0] && sx[1]==sy[1]);\n\t\t\telse can[0]=false;\n\t\t}\n\t\tif(bi){\n\t\t\tif(sx[0]==sy[1] && sx[1]==sy[0]);\n\t\t\telse can[1]=false;\n\t\t}\n\t\tif(sx[0]+sx[1]!=sy[0]+sy[1]){\n\t\t\tcan[0]=can[1]=false;\n\t\t}\n\t}\n\tif(can[0] || can[1]) return true;\n\telse return false;\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\tint t;cin >> t;while(t--){\n\t\tint res=solve();\n\t\tif(res) cout << \"Yes\\n\";\n\t\telse cout << \"No\\n\";\n\t}\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2061f2",
      "PROBLEM_ID": "2061F2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, string $t$ consists of '0', '1' and '?'. You can hack only if you solved all versions of this problem.\n\nKevin has a binary string $s$ of length $n$. Kevin can perform the following operation:\n\n- Choose two adjacent blocks of $s$ and swap them.\n\nA block is a maximal substring$^{\\text{\u2217}}$ of identical characters. Formally, denote $s[l,r]$ as the substring $s_l s_{l+1} \\ldots s_r$. A block is $s[l,r]$ satisfying:\n\n- $l=1$ or $s_l\\not=s_{l-1}$.\n- $s_l=s_{l+1} = \\ldots = s_{r}$.\n- $r=n$ or $s_r\\not=s_{r+1}$.\n\nAdjacent blocks are two blocks $s[l_1,r_1]$ and $s[l_2,r_2]$ satisfying $r_1+1=l_2$.\n\nFor example, if $s=\\mathtt{000}\\,\\mathbf{11}\\,\\mathbf{00}\\,\\mathtt{111}$, Kevin can choose the two blocks $s[4,5]$ and $s[6,7]$ and swap them, transforming $s$ into $\\mathtt{000}\\,\\mathbf{00}\\,\\mathbf{11}\\,\\mathtt{111}$.\n\nGiven a string $t$ of length $n$ consisting of '0', '1' and '?', Kevin wants to determine the minimum number of operations required to perform such that for any index $i$ ($1\\le i\\le n$), if $t_i\\not=$ '?' then $s_i=t_i$. If it is impossible, output $-1$.\n\n$^{\\text{\u2217}}$A string $a$ is a substring of a string $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a string $s$ consisting of '0' and '1'.\n\nThe second line of each test case contains a string $t$ consisting of '0', '1' and '?'.\n\nIt is guaranteed that the lengths of $s$ and $t$ are the same.\n\nIt is guaranteed that the sum of the length of $s$ over all test cases will not exceed $4\\cdot 10^5$.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the minimum number of operations required. If it is impossible, output $-1$.\n\n### Examples\n\n#### Input #1\n\n```\n\n6\n\n0001100111\n\n0000011111\n\n010101\n\n111000\n\n0101\n\n0110\n\n0101\n\n1010\n\n011001\n\n001110\n\n0\n\n1\n\n```\n\n#### Output #1\n\n```\n1\n3\n1\n-1\n-1\n-1\n```\n\n#### Input #2\n\n```\n\n6\n\n010101\n\n?0?0??\n\n0101\n\n?0?0\n\n11100101\n\n????????\n\n11100101\n\n???11?1?\n\n1000100011\n\n?11?000?0?\n\n10101\n\n?1011\n\n```\n\n#### Output #2\n\n```\n2\n-1\n0\n2\n2\n-1\n```\n\n### Note\n\nIn the first test case of the first example, the possible way is shown in the statement.\n\nIn the second test case of the first example, one possible way could be:\n\n- Swap blocks $[2, 2], [3, 3]$, $s$ will become $\\mathtt{001101}$.\n- Swap blocks $[3, 4], [5, 5]$, $s$ will become $\\mathtt{000111}$.\n- Swap blocks $[1, 3], [4, 6]$, $s$ will become $\\mathtt{111000}$.\n\nIn the first test case of the second example, one possible way could be:\n\n- Swap blocks $[1, 1], [2, 2]$, $s$ will become $\\mathtt{100101}$.\n- Swap blocks $[4, 4], [5, 5]$, $s$ will become $\\mathtt{100011}$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;typedef long long ll;typedef pair<int,int> pii;const int N=4e5+10,inf=1e8;int n,m,l[N],r[N],c[N],s[2][N],f[N];char a[N],b[N];struct node{int l,r,mn0,mn1;}tr[N<<2];inline void pushup(int u){tr[u].mn0=min(tr[u<<1].mn0,tr[u<<1|1].mn0);tr[u].mn1=min(tr[u<<1].mn1,tr[u<<1|1].mn1);}inline void build(int u,int l,int r){tr[u]={l,r,inf,inf};if(l==r) return ;int mid=l+r>>1;build(u<<1,l,mid),build(u<<1|1,mid+1,r);}inline void mdf(int u,int x,int v){if(tr[u].l==tr[u].r) return (x&1?tr[u].mn1:tr[u].mn0)=v,void();int mid=tr[u].l+tr[u].r>>1;mdf(u<<1|(x>mid),x,v);pushup(u);}inline int query(int u,int l,int r,int tp){if(l>r) return inf;if(l<=tr[u].l&&tr[u].r<=r) return tp?tr[u].mn1:tr[u].mn0;int mid=tr[u].l+tr[u].r>>1;if(r<=mid) return query(u<<1,l,r,tp);if(l>mid) return query(u<<1|1,l,r,tp);return min(query(u<<1,l,r,tp),query(u<<1|1,l,r,tp));}inline void solve(){scanf(\"%s%s\",a+2,b+2);a[1]=b[1]=a[2]^1;n=strlen(a+1),m=0;a[n+1]=b[n+1]=a[n]^1,++n;int la[2]={0,0};for(int i=1;i<=n;++i){if(b[i]!='?') la[b[i]^48]=i;if(a[i]!=a[i+1]||i==n){c[++m]=i;l[m]=la[a[i]^48^1];}}la[0]=la[1]=n+1;for(int i=n,j=m;i;--i){if(b[i]!='?') la[b[i]^48]=i;if(a[i]!=a[i-1]||i==1){r[j--]=la[a[i]^48^1];}}vector<pii>G[2];for(int i=1;i<=m;++i){s[0][i]=s[0][i-1],s[1][i]=s[1][i-1];int v=a[c[i]]^48;s[v][i]+=c[i]-c[i-1];G[v].push_back({s[v][i]+r[i]-c[i]-1,i});}sort(G[0].begin(),G[0].end());sort(G[1].begin(),G[1].end());la[0]=la[1]=0;build(1,1,m);mdf(1,1,-1);for(int i=2;i<=m;++i){int v=a[c[i]]^48;while(la[v]<G[v].size()&&s[v][i]>G[v][la[v]].first){mdf(1,G[v][la[v]].second,inf);++la[v];}int p=lower_bound(s[v]+1,s[v]+1+i,s[v][i]-c[i]+l[i])-s[v],tmp=query(1,p,i-1,i&1^1);f[i]=tmp<inf?(tmp+i-1)/2:inf;mdf(1,i,f[i]*2-i);}printf(\"%d\\n\",f[m]<inf?f[m]:-1);}int main(){int T;scanf(\"%d\",&T);while(T--) solve();return 0;}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2061f1",
      "PROBLEM_ID": "2061F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, string $t$ consists of only '0' and '1'. You can hack only if you solved all versions of this problem.\n\nKevin has a binary string $s$ of length $n$. Kevin can perform the following operation:\n\n- Choose two adjacent blocks of $s$ and swap them.\n\nA block is a maximal substring$^{\\text{\u2217}}$ of identical characters. Formally, denote $s[l,r]$ as the substring $s_l s_{l+1} \\ldots s_r$. A block is $s[l,r]$ satisfying:\n\n- $l=1$ or $s_l\\not=s_{l-1}$.\n- $s_l=s_{l+1} = \\ldots = s_{r}$.\n- $r=n$ or $s_r\\not=s_{r+1}$.\n\nAdjacent blocks are two blocks $s[l_1,r_1]$ and $s[l_2,r_2]$ satisfying $r_1+1=l_2$.\n\nFor example, if $s=\\mathtt{000}\\,\\mathbf{11}\\,\\mathbf{00}\\,\\mathtt{111}$, Kevin can choose the two blocks $s[4,5]$ and $s[6,7]$ and swap them, transforming $s$ into $\\mathtt{000}\\,\\mathbf{00}\\,\\mathbf{11}\\,\\mathtt{111}$.\n\nGiven a string $t$ of length $n$ consisting of '0', '1' and '?', Kevin wants to determine the minimum number of operations required to perform such that for any index $i$ ($1\\le i\\le n$), if $t_i\\not=$ '?' then $s_i=t_i$. If it is impossible, output $-1$.\n\n$^{\\text{\u2217}}$A string $a$ is a substring of a string $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a string $s$ consisting of '0' and '1'.\n\nThe second line of each test case contains a string $t$ consisting of '0' and '1'.\n\nIt is guaranteed that the lengths of $s$ and $t$ are the same.\n\nIt is guaranteed that the sum of the length of $s$ over all test cases will not exceed $4\\cdot 10^5$.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the minimum number of operations required. If it is impossible, output $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n0001100111\n\n0000011111\n\n010101\n\n111000\n\n0101\n\n0110\n\n0101\n\n1010\n\n011001\n\n001110\n\n0\n\n1\n\n```\n\n#### Output #1\n\n```\n1\n3\n1\n-1\n-1\n-1\n```\n\n### Note\n\nIn the first test case, the possible way is shown in the statement.\n\nIn the second test case, one possible way could be:\n\n- Swap blocks $[2, 2], [3, 3]$, $s$ will become $\\mathtt{001101}$.\n- Swap blocks $[3, 4], [5, 5]$, $s$ will become $\\mathtt{000111}$.\n- Swap blocks $[1, 3], [4, 6]$, $s$ will become $\\mathtt{111000}$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Block\n{\n    char ch;            // '0' or '1'\n    int  len;           // its length\n};\n\nusing ll = long long;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    if (!(cin >> T)) return 0;\n    while (T--)\n    {\n        string s, t;\n        cin >> s >> t;\n        /* 1. build block lists of s and t */\n        list<Block> a;                  // blocks of s\n        for (int i = 0, n = s.size(); i < n; )\n        {\n            int j = i;\n            while (j < n && s[j] == s[i]) ++j;\n            a.push_back({s[i], j - i});\n            i = j;\n        }\n        vector<Block> need;             // blocks of t, kept in a vector\n        for (int i = 0, n = t.size(); i < n; )\n        {\n            int j = i;\n            while (j < n && t[j] == t[i]) ++j;\n            need.push_back({t[i], j - i});\n            i = j;\n        }\n\n        ll ops = 0;\n        bool ok = true;\n\n        for (const Block &want : need)\n        {\n            int still = want.len;           // characters of this block still needed\n            while (still > 0)\n            {\n                if (a.empty()) { ok = false; break; }\n\n                auto it0 = a.begin();\n                if (it0->ch != want.ch)     // wrong character in front -> swap needed\n                {\n                    auto it1 = next(it0);\n                    if (it1 == a.end()) { ok = false; break; }\n\n                    /* swap first two blocks : move it1 before it0 */\n                    a.splice(it0, a, it1);  // constant time\n                    ++ops;\n\n                    /* possible merge of the new second and third block */\n                    auto itSecond = next(a.begin());\n                    auto itThird  = next(itSecond);\n                    if (itThird != a.end() && itSecond->ch == itThird->ch)\n                    {\n                        itSecond->len += itThird->len;\n                        a.erase(itThird);\n                    }\n                    continue;               // check character again\n                }\n                /* correct character in front */\n                if (it0->len > still) { ok = false; break; }   // cannot split\n                still -= it0->len;\n                a.pop_front();\n            }\n            if (!ok) break;\n        }\n        if (ok && !a.empty()) ok = false;   // t finished but s not\n\n        cout << (ok ? ops : -1) << '\\n';\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2061e",
      "PROBLEM_ID": "2061E",
      "PROBLEM_STATEMENT": "Kevin has an integer sequence $a$ of length $n$. At the same time, Kevin has $m$ types of magic, where the $i$-th type of magic can be represented by an integer $b_i$.\n\nKevin can perform at most $k$ (possibly zero) magic operations. In each operation, Kevin can do the following:\n\n- Choose two indices $i$ ($1\\leq i\\leq n$) and $j$ ($1\\leq j\\leq m$), and then update $a_i$ to $a_i\\ \\&\\ b_j$. Here, $\\&$ denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND).\n\nFind the minimum possible sum of all numbers in the sequence $a$ after performing at most $k$ operations.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n, m, k$ ($1\\leq n \\leq 10^5$, $1\\leq m \\leq 10$, $0\\leq k\\leq nm$)\u00a0\u2014 the length of $a$, the number of types of magic, and the maximum number of operations.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0\\leq a_i < 2^{30}$).\n\nThe third line contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($0\\leq b_i < 2^{30}$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the minimum possible sum of all numbers in the sequence $a$ after performing at most $k$ operations.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1 3 2\n\n7\n\n5 6 3\n\n2 3 2\n\n5 6\n\n5 6 3\n\n10 2 5\n\n3 1 4 1 5 9 2 6 5 3\n\n7 8\n\n5 1 0\n\n1073741823 1073741823 1073741823 1073741823 1073741823\n\n1073741823\n\n1 1 0\n\n0\n\n0\n\n```\n\n#### Output #1\n\n```\n1\n3\n11\n5368709115\n0\n```\n\n### Note\n\nIn the first test case, one possible way could be:\n\n- Update $a_1$ to $a_1\\ \\&\\ b_1$. The sequence will become $[5]$.\n- Update $a_1$ to $a_1\\ \\&\\ b_3$. The sequence will become $[1]$.\n\nIn the second test case, one possible way could be:\n\n- Update $a_1$ to $a_1\\ \\&\\ b_3$. The sequence will become $[1, 6]$.\n- Update $a_2$ to $a_2\\ \\&\\ b_3$. The sequence will become $[1, 2]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int profit;\n    int id;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        long long k;\n        cin >> n >> m >> k;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        vector<uint32_t> b(m);\n        for (int j = 0; j < m; j++) {\n            cin >> b[j];\n        }\n\n        // Enumerate all non-empty subsets of {0..m-1} to get all possible AND-masks\n        int total_masks = 1 << m;\n        vector<pair<uint32_t,int>> vb;\n        vb.reserve(total_masks - 1);\n        for (int mask = 1; mask < total_masks; ++mask) {\n            uint32_t Bmask = ~0u;\n            int pc = __builtin_popcount(mask);\n            int mm = mask;\n            // fast iterate bits of mask\n            for (int j = 0; mm; ++j, mm >>= 1) {\n                if (mm & 1) {\n                    Bmask &= b[j];\n                }\n            }\n            vb.emplace_back(Bmask, pc);\n        }\n        // Sort by mask, then by popcount => to keep minimal popcount per mask\n        sort(vb.begin(), vb.end(),\n             [](auto &l, auto &r) {\n                 if (l.first != r.first) return l.first < r.first;\n                 return l.second < r.second;\n             });\n        // Unique-ify to get minimal s_B for each distinct Bmask\n        vector<pair<uint32_t,int>> ub;\n        ub.reserve(vb.size());\n        for (auto &p : vb) {\n            if (ub.empty() || p.first != ub.back().first) {\n                ub.push_back(p);\n            }\n        }\n\n        // Sum of original a[i]\n        long long sumAi = 0;\n        for (int x : a) sumAi += x;\n\n        // Collect all positive marginal profits\n        vector<Node> profits;\n        // Reserve up to n*m entries (worst-case), to avoid repeated reallocations\n        if (n > 0 && m > 0) {\n            long long cap = (long long)n * (long long)m;\n            profits.reserve((size_t)cap);\n        }\n\n        // Temporary array for best profits per number of operations s = 1..m\n        vector<int> best_profit(m+1, 0);\n\n        // For each a[i], compute the concave profit function f_i(s) and its marginals\n        for (int i = 0; i < n; i++) {\n            int ai = a[i];\n            // reset best_profit\n            for (int s = 1; s <= m; s++) {\n                best_profit[s] = 0;\n            }\n            // For each unique mask Bmask with minimal cost sb, compute profit\n            for (auto &p : ub) {\n                uint32_t Bmask = p.first;\n                int sb = p.second;\n                int prof = ai - int(ai & Bmask);\n                if (prof > best_profit[sb]) {\n                    best_profit[sb] = prof;\n                }\n            }\n            // Build marginals: dp_i[s] = f_i(s) - f_i(s-1)\n            int prev = 0;\n            for (int s = 1; s <= m; s++) {\n                int cur = best_profit[s];\n                if (cur < prev) cur = prev;\n                int marg = cur - prev;\n                if (marg > 0) {\n                    // encode id so that for same i, smaller s has smaller id\n                    int id = (i << 4) | s;\n                    profits.push_back({marg, id});\n                }\n                prev = cur;\n            }\n        }\n\n        // Greedy: take the k largest marginals (respecting tie-breaks by id)\n        sort(profits.begin(), profits.end(),\n             [](const Node &l, const Node &r) {\n                 if (l.profit != r.profit) return l.profit > r.profit;\n                 return l.id < r.id;\n             });\n        long long sumProfits = 0;\n        long long take = min((long long)profits.size(), k);\n        for (long long i = 0; i < take; i++) {\n            sumProfits += profits[i].profit;\n        }\n\n        // Resulting minimal sum\n        long long ans = sumAi - sumProfits;\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2061c",
      "PROBLEM_ID": "2061C",
      "PROBLEM_STATEMENT": "Kevin enjoys logic puzzles.\n\nHe played a game with $n$ classmates who stand in a line. The $i$-th person from the left says that there are $a_i$ liars to their left (not including themselves).\n\nEach classmate is either honest or a liar, with the restriction that no two liars can stand next to each other. Honest classmates always say the truth. Liars can say either the truth or lies, meaning their statements are considered unreliable.\n\nKevin wants to determine the number of distinct possible game configurations modulo $998\\,244\\,353$. Two configurations are considered different if at least one classmate is honest in one configuration and a liar in the other.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1\\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the number of classmates.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0\\leq a_i \\leq n$)\u00a0\u2014 the number of liars to the left of the $i$-th person they claimed.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the number of distinct game configurations modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n3\n\n0 1 2\n\n5\n\n0 0 0 0 0\n\n5\n\n0 0 1 1 2\n\n5\n\n0 1 2 3 4\n\n5\n\n0 0 1 1 1\n\n5\n\n5 1 5 2 5\n\n1\n\n0\n\n4\n\n2 3 1 1\n\n```\n\n#### Output #1\n\n```\n1\n2\n3\n0\n4\n1\n2\n0\n```\n\n### Note\n\nWe will use $\\color{red}{\\text{red}}$ to mark liars and $\\color{blue}{\\text{blue}}$ to mark honest people.\n\nIn the first test case, the only possible way is $(\\color{red}{0},\\color{blue}{1},\\color{red}{2})$.\n\nIn the second test case, two possible ways are $(\\color{blue}{0},\\color{blue}{0},\\color{blue}{0},\\color{blue}{0},\\color{blue}{0})$ and $(\\color{blue}{0},\\color{blue}{0},\\color{blue}{0},\\color{blue}{0},\\color{red}{0})$.\n\nIn the third test case, three possible ways are $(\\color{blue}{0},\\color{blue}{0},\\color{red}{1},\\color{blue}{1},\\color{red}{2})$, $(\\color{blue}{0},\\color{red}{0},\\color{blue}{1},\\color{red}{1},\\color{blue}{2})$, $(\\color{blue}{0},\\color{red}{0},\\color{blue}{1},\\color{blue}{1},\\color{red}{2})$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    if (n == 0) {\n        cout << 0 << endl;\n        return;\n    }\n    vector<int> dpH(n, 0);\n    vector<int> dpL(n, 0);\n    \n    // Base case for the first person (i=0)\n    dpH[0] = (a[0] == 0) ? 1 : 0;\n    dpL[0] = 1;\n    \n    for (int i = 1; i < n; ++i) {\n        // Compute dpH[i]\n        dpH[i] = 0;\n        // Contribution from previous H\n        if (a[i-1] == a[i]) {\n            dpH[i] += dpH[i-1];\n            dpH[i] %= MOD;\n        }\n        // Contribution from previous L\n        bool condition = false;\n        if (i-1 == 0) {\n            condition = (a[i] == 1);\n        } else if (i-1 >= 1) {\n            condition = (a[i-2] + 1 == a[i]);\n        }\n        if (condition) {\n            dpH[i] += dpL[i-1];\n            dpH[i] %= MOD;\n        }\n        // Compute dpL[i]\n        dpL[i] = dpH[i-1] % MOD;\n    }\n    \n    int ans = (dpH[n-1] + dpL[n-1]) % MOD;\n    cout << ans << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2060g",
      "PROBLEM_ID": "2060G",
      "PROBLEM_STATEMENT": "Today, Alice has given Bob arrays for him to sort in increasing order again! At this point, no one really knows how many times she has done this.\n\nBob is given two sequences $a$ and $b$, both of length $n$. All integers in the range from $1$ to $2n$ appear exactly once in either $a$ or $b$. In other words, the concatenated$^{\\text{\u2217}}$ sequence $a+b$ is a permutation$^{\\text{\u2020}}$ of length $2n$.\n\nBob must sort both sequences in increasing order at the same time using Alice's swap function. Alice's swap function is implemented as follows:\n\n- Given two indices $i$ and $j$ ($i \\neq j$), it swaps $a_i$ with $b_j$, and swaps $b_i$ with $a_j$.\n\nGiven sequences $a$ and $b$, please determine if both sequences can be sorted in increasing order simultaneously after using Alice's swap function any number of times.\n\n$^{\\text{\u2217}}$The concatenated sequence $a+b$ denotes the sequence $[a_1, a_2, a_3, \\ldots , b_1, b_2, b_3, \\ldots]$.\n\n$^{\\text{\u2020}}$A permutation of length $m$ contains all integers from $1$ to $m$ in some order.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line of each test case contains $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le 2n$).\n\nThe third line of each test case contains $b_1,b_2,\\ldots,b_n$ ($1 \\le b_i \\le 2n$).\n\nIt is guaranteed that all integers in the range $[1,2n]$ appear exactly once in either $a$ or $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nIf it is possible to sort both sequences simultaneously, print \"YES\" on a new line. Otherwise, print \"NO\" on a new line.\n\nYou can output the answer in any case. For example, the strings \"yEs\", \"yes\", and \"Yes\" will also be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3\n\n2 1 3\n\n4 6 5\n\n3\n\n2 1 5\n\n4 3 6\n\n4\n\n1 6 4 3\n\n5 2 8 7\n\n4\n\n5 3 7 1\n\n8 6 4 2\n\n7\n\n5 1 9 12 3 13 7\n\n2 4 11 14 6 10 8\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nNO\nYES\nYES\n```\n\n### Note\n\nIn the first test case, it can be shown that it is impossible.\n\nIn the second test case, Bob can perform one operation with indices $i=1$ and $j=2$. The arrays become $[3,4,5]$ and $[1,2,6]$ respectively. Both arrays are now sorted.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\nusing ll = long long;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> A(n), B(n);\n        for(int i = 0; i < n; i++){\n            cin >> A[i];\n        }\n        for(int i = 0; i < n; i++){\n            cin >> B[i];\n        }\n        // Compute initial parity of orientation bits\n        int parity = 0;\n        // Build vector of (l, r, s) where s = 1 if A_i>B_i initially\n        vector< array<int,3> > v;\n        v.reserve(n);\n        for(int i = 0; i < n; i++){\n            int a = A[i], b = B[i];\n            int s = (a > b) ? 1 : 0;\n            parity ^= s;\n            int l = min(a,b);\n            int r = max(a,b);\n            v.push_back({l, r, s});\n        }\n        // Sort pairs by their l ascending\n        sort(v.begin(), v.end(),\n             [](auto &p1, auto &p2){\n                 return p1[0] < p2[0];\n             });\n        // Check that r is strictly increasing\n        bool ok = true;\n        for(int i = 0; i + 1 < n; i++){\n            if(v[i][1] >= v[i+1][1]){\n                ok = false;\n                break;\n            }\n        }\n        if(!ok){\n            cout << \"NO\\n\";\n            continue;\n        }\n        // Compute breakpoints: between i and i+1 if r_i < l_{i+1}\n        // Build blocks of indices forced to have same orientation bit\n        vector<int> blocks;\n        blocks.reserve(n);\n        int cur_sz = 1;\n        for(int i = 0; i + 1 < n; i++){\n            int r_i = v[i][1];\n            int l_j = v[i+1][0];\n            // if r_i < l_{i+1}, no constraint => break here\n            if(r_i < l_j){\n                blocks.push_back(cur_sz);\n                cur_sz = 1;\n            } else {\n                // r_i >= l_{i+1} => s_i == s_{i+1}, stay in same block\n                cur_sz++;\n            }\n        }\n        blocks.push_back(cur_sz);\n\n        // If any block has odd size, we can always adjust parity\n        bool allEven = true;\n        for(int sz : blocks){\n            if(sz % 2 == 1){\n                allEven = false;\n                break;\n            }\n        }\n        // If all blocks are even, then sum(s_i) mod2 = 0 always\n        // So we need parity == 0 to succeed. Otherwise fail.\n        if(allEven && parity == 1){\n            cout << \"NO\\n\";\n        } else {\n            cout << \"YES\\n\";\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2060f",
      "PROBLEM_ID": "2060F",
      "PROBLEM_STATEMENT": "You're given integers $k$ and $n$. For each integer $x$ from $1$ to $k$, count the number of integer arrays $a$ such that all of the following are satisfied:\n\n- $1 \\leq |a| \\leq n$ where $|a|$ represents the length of $a$.\n- $1 \\leq a_i \\leq k$ for all $1 \\leq i \\leq |a|$.\n- $a_1 \\times a_2 \\times \\dots \\times a_{|a|}=x$ (i.e., the product of all elements is $x$).\n\nNote that two arrays $b$ and $c$ are different if either their lengths are different, or if there exists an index $1 \\leq i \\leq |b|$ such that $b_i\\neq c_i$.\n\nOutput the answer modulo $998\\,244\\,353$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t\\leq 10^3$) \u2014 the number of independent test cases.\n\nThe only line of each test case contains two integers $k$ and $n$ ($1 \\leq k \\leq 10^5, 1\\leq n \\leq 9\\cdot 10^8$).\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output $k$ space-separated integers on a new line: the number of arrays for $x=1,2,\\ldots,k$, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2\n\n4 3\n\n10 6969420\n\n```\n\n#### Output #1\n\n```\n2 3\n3 6 6 10\n6969420 124188773 124188773 729965558 124188773 337497990 124188773 50981194 729965558 337497990\n```\n\n### Note\n\nIn the first test case, there are $2$ arrays $a$ with $|a|\\leq 2$ and the product of elements equal to $1$:\n\n- $[1]$\n- $[1,1]$\n\nThere are $3$ arrays $a$ with $|a|\\leq 2$ and the product of elements equal to $2$:\n\n- $[2]$\n- $[1,2]$\n- $[2,1]$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MAX_FACT = 1e5 + 10;\n\nvector<int> spf;\nvector<long long> fact, inv_fact;\n\nlong long mod_pow(long long base, long long exp) {\n    long long res = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            res = res * base % MOD;\n        base = base * base % MOD;\n        exp /= 2;\n    }\n    return res;\n}\n\nvoid precompute_spf() {\n    spf.resize(MAX_FACT);\n    iota(spf.begin(), spf.end(), 0);\n    for (int i = 2; i * i < MAX_FACT; i++) {\n        if (spf[i] == i) {\n            for (int j = i * i; j < MAX_FACT; j += i) {\n                if (spf[j] == j) {\n                    spf[j] = i;\n                }\n            }\n        }\n    }\n}\n\nvoid precompute_factorials() {\n    fact.resize(MAX_FACT);\n    fact[0] = 1;\n    for (int i = 1; i < MAX_FACT; i++)\n        fact[i] = fact[i - 1] * i % MOD;\n    \n    inv_fact.resize(MAX_FACT);\n    inv_fact[MAX_FACT - 1] = mod_pow(fact[MAX_FACT - 1], MOD - 2);\n    for (int i = MAX_FACT - 2; i >= 0; i--)\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n}\n\nvector<pair<int, int>> factorize(int x) {\n    map<int, int> factors;\n    if (x == 1) {\n        return {};\n    }\n    while (x > 1) {\n        factors[spf[x]]++;\n        x /= spf[x];\n    }\n    return vector<pair<int, int>>(factors.begin(), factors.end());\n}\n\nvector<int> get_poly(int e) {\n    if (e == 0) {\n        return {1};\n    }\n    vector<int> poly = {1};\n    for (int i = 0; i < e; i++) {\n        vector<int> new_poly(poly.size() + 1, 0);\n        for (int j = 0; j < (int)poly.size(); j++) {\n            new_poly[j + 1] = (new_poly[j + 1] + poly[j]) % MOD;\n            new_poly[j] = (new_poly[j] + 1LL * poly[j] * i % MOD) % MOD;\n        }\n        poly = new_poly;\n    }\n    long long inv = inv_fact[e];\n    for (int &coeff : poly) {\n        coeff = coeff * inv % MOD;\n    }\n    return poly;\n}\n\nvector<int> multiply(const vector<int> &a, const vector<int> &b) {\n    vector<int> res(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int)a.size(); ++i) {\n        for (int j = 0; j < (int)b.size(); ++j) {\n            res[i + j] = (res[i + j] + 1LL * a[i] * b[j]) % MOD;\n        }\n    }\n    return res;\n}\n\nlong long sum_powers(long long n, int k) {\n    vector<long long> dp(k + 2, 0);\n    for (int m = 1; m <= k + 1; ++m) {\n        dp[m] = (dp[m - 1] + mod_pow(m, k)) % MOD;\n    }\n    if (n <= k + 1) {\n        return dp[n];\n    }\n    k++;\n    vector<long long> factorial(k + 1, 1), inv_fact(k + 1, 1);\n    for (int i = 1; i <= k; ++i) {\n        factorial[i] = factorial[i - 1] * i % MOD;\n        inv_fact[i] = mod_pow(factorial[i], MOD - 2);\n    }\n    \n    vector<long long> numerator(k + 1, 1);\n    for (int i = 0; i <= k; ++i) {\n        numerator[i] = 1;\n        for (int j = 0; j <= k; ++j) {\n            if (j != i) {\n                numerator[i] = numerator[i] * (n - j) % MOD;\n            }\n        }\n    }\n    \n    long long res = 0;\n    for (int i = 0; i <= k; ++i) {\n        long denom = inv_fact[i] * inv_fact[k - i] % MOD;\n        if ((k - i) % 2 == 1) {\n            denom = (MOD - denom) % MOD;\n        }\n        res = (res + numerator[i] * dp[i] % MOD * denom % MOD) % MOD;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    precompute_spf();\n    precompute_factorials();\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        int k, n;\n        cin >> k >> n;\n        \n        vector<long long> res(k + 1, 0);\n        for (int x = 1; x <= k; x++) {\n            if (x == 1) {\n                res[x] = n % MOD;\n                continue;\n            }\n            auto factors = factorize(x);\n            if (factors.empty()) {\n                res[x] = 0;\n                continue;\n            }\n            vector<int> poly = {1};\n            for (auto [p, e] : factors) {\n                vector<int> p_poly = get_poly(e);\n                poly = multiply(poly, p_poly);\n            }\n            \n            long long ans = 0;\n            for (int d = 0; d < (int)poly.size(); d++) {\n                if (poly[d] == 0) continue;\n                long long term = sum_powers(n, d);\n                ans = (ans + 1LL * poly[d] * term) % MOD;\n            }\n            res[x] = ans % MOD;\n        }\n        \n        for (int x = 1; x <= k; x++) {\n            cout << res[x] << (x == k ? \"\\n\" : \" \");\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2060d",
      "PROBLEM_ID": "2060D",
      "PROBLEM_STATEMENT": "You are given a sequence $a$ consisting of $n$ positive integers.\n\nYou can perform the following operation any number of times.\n\n- Select an index $i$ ($1 \\le i < n$), and subtract $\\min(a_i,a_{i+1})$ from both $a_i$ and $a_{i+1}$.\n\nDetermine if it is possible to make the sequence non-decreasing by using the operation any number of times.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line of each test case contains $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nIf it is possible to make the sequence non-decreasing, print \"YES\" on a new line. Otherwise, print \"NO\" on a new line.\n\nYou can output the answer in any case. For example, the strings \"yEs\", \"yes\", and \"Yes\" will also be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n5\n\n1 2 3 4 5\n\n4\n\n4 3 2 1\n\n4\n\n4 5 2 3\n\n8\n\n4 5 4 5 4 5 4 5\n\n9\n\n9 9 8 2 4 4 3 5 3\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nYES\nNO\n```\n\n### Note\n\nIn the first test case, the array is already sorted.\n\nIn the second test case, we can show that it is impossible.\n\nIn the third test case, after performing an operation on $i=1$, the array becomes $[0,1,2,3]$, which is now in nondecreasing order.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    bool possible = true;\n    for (int i = n-2; i >= 0; --i) {\n        if (a[i] > a[i+1]) {\n            long long required = a[i] - a[i+1];\n            if (i == 0) {\n                possible = false;\n                break;\n            }\n            long long available = min(a[i-1], a[i]);\n            if (required > available) {\n                possible = false;\n                break;\n            }\n            a[i-1] -= required;\n            a[i] -= required;\n            if (a[i-1] < 0 || a[i] < 0) {\n                possible = false;\n                break;\n            }\n        }\n    }\n    if (possible) {\n        for (int i = 0; i < n-1; ++i) {\n            if (a[i] > a[i+1]) {\n                possible = false;\n                break;\n            }\n        }\n    }\n    cout << (possible ? \"YES\" : \"NO\") << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2060b",
      "PROBLEM_ID": "2060B",
      "PROBLEM_STATEMENT": "Farmer John's $n$ cows are playing a card game! Farmer John has a deck of $n \\cdot m$ cards numbered from $0$ to $n \\cdot m-1$. He distributes $m$ cards to each of his $n$ cows.\n\nFarmer John wants the game to be fair, so each cow should only be able to play $1$ card per round. He decides to determine a turn order, determined by a permutation$^{\\text{\u2217}}$ $p$ of length $n$, such that the $p_i$'th cow will be the $i$'th cow to place a card on top of the center pile in a round.\n\nIn other words, the following events happen in order in each round:\n\n- The $p_1$'th cow places any card from their deck on top of the center pile.\n- The $p_2$'th cow places any card from their deck on top of the center pile.\n- ...\n- The $p_n$'th cow places any card from their deck on top of the center pile.\n\nThere is a catch. Initially, the center pile contains a card numbered $-1$. In order to place a card, the number of the card must be greater than the number of the card on top of the center pile. Then, the newly placed card becomes the top card of the center pile. If a cow cannot place any card in their deck, the game is considered to be lost.\n\nFarmer John wonders: does there exist $p$ such that it is possible for all of his cows to empty their deck after playing all $m$ rounds of the game? If so, output any valid $p$. Otherwise, output $-1$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ contains each integer from $1$ to $n$ exactly once\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 400$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n \\cdot m \\leq 2\\,000$) \u2014 the number of cows and the number of cards each cow receives.\n\nThe following $n$ lines contain $m$ integers each\u00a0\u2013 the cards received by each cow. It is guaranteed all given numbers (across all $n$ lines) are distinct and in the range from $0$ to $n \\cdot m - 1$, inclusive.\n\nIt is guaranteed the sum of $n \\cdot m$ over all test cases does not exceed $2\\,000$.\n\n### Output\n\nFor each test case, output the following on a new line:\n\n- If $p$ exists, output $n$ space-separated integers $p_1, p_2, \\ldots, p_n$.\n- Otherwise, output $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 3\n\n0 4 2\n\n1 5 3\n\n1 1\n\n0\n\n2 2\n\n1 2\n\n0 3\n\n4 1\n\n1\n\n2\n\n0\n\n3\n\n```\n\n#### Output #1\n\n```\n1 2\n1\n-1\n3 1 2 4\n```\n\n### Note\n\nIn the first test case, one turn order that allows all cards to be played is by having the first cow go before the second cow. The cards played will be $0\\rightarrow1\\rightarrow2\\rightarrow3\\rightarrow4\\rightarrow5$.\n\nIn the second test case, there is only one cow, so having the cow play all of her cards in increasing order will empty the deck.\n\nIn the third test case, it can be shown there is no valid turn order that allows all cards to be played.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Cow {\n    vector<int> cards;\n    int index;\n\n    Cow(const vector<int>& c, int i) : cards(c), index(i) {}\n};\n\nbool compare(const Cow& a, const Cow& b) {\n    return a.cards[0] < b.cards[0];\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        vector<Cow> cows;\n        for (int i = 0; i < n; i++) {\n            vector<int> cards(m);\n            for (int j = 0; j < m; j++) {\n                cin >> cards[j];\n            }\n            sort(cards.begin(), cards.end());\n            cows.emplace_back(cards, i + 1);\n        }\n\n        bool possible = true;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const auto& a = cows[i].cards;\n                const auto& b = cows[j].cards;\n                bool a_less = true;\n                for (int k = 0; k < m; k++) {\n                    if (a[k] >= b[k]) {\n                        a_less = false;\n                        break;\n                    }\n                }\n                if (a_less) continue;\n                bool b_less = true;\n                for (int k = 0; k < m; k++) {\n                    if (b[k] >= a[k]) {\n                        b_less = false;\n                        break;\n                    }\n                }\n                if (b_less) continue;\n                possible = false;\n                goto end_check;\n            }\n        }\n\n    end_check:\n        if (!possible) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        sort(cows.begin(), cows.end(), compare);\n\n        bool ok = true;\n        for (int i = 0; i < m - 1; i++) {\n            int last = cows.back().cards[i];\n            int first_next = cows[0].cards[i + 1];\n            if (last >= first_next) {\n                ok = false;\n                break;\n            }\n        }\n\n        if (!ok) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (i > 0) cout << ' ';\n            cout << cows[i].index;\n        }\n        cout << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2060a",
      "PROBLEM_ID": "2060A",
      "PROBLEM_STATEMENT": "There is an array of $5$ integers. Initially, you only know $a_1,a_2,a_4,a_5$. You may set $a_3$ to any positive integer, negative integer, or zero. The Fibonacciness of the array is the number of integers $i$ ($1 \\leq i \\leq 3$) such that $a_{i+2}=a_i+a_{i+1}$. Find the maximum Fibonacciness over all integer values of $a_3$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 500$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains four integers $a_1, a_2, a_4, a_5$ ($1 \\leq a_i \\leq 100$).\n\n### Output\n\nFor each test case, output the maximum Fibonacciness on a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1 1 3 5\n\n1 3 2 1\n\n8 10 28 100\n\n100 1 100 1\n\n1 100 1 100\n\n100 100 100 100\n\n```\n\n#### Output #1\n\n```\n3\n2\n2\n1\n1\n2\n```\n\n### Note\n\nIn the first test case, we can set $a_3$ to $2$ to achieve the maximal Fibonacciness of $3$.\n\nIn the third test case, it can be shown that $2$ is the maximum Fibonacciness that can be achieved. This can be done by setting $a_3$ to $18$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int a1, a2, a4, a5;\n        cin >> a1 >> a2 >> a4 >> a5;\n        \n        // Check for Fibonacciness 3\n        bool three = (a4 == a1 + 2 * a2) && (a5 == 2 * a1 + 3 * a2);\n        if (three) {\n            cout << 3 << endl;\n            continue;\n        }\n        \n        // Check for Fibonacciness 2\n        bool two = false;\n        two |= (a4 == a1 + 2 * a2);\n        two |= (a5 == a1 + a2 + a4);\n        two |= (a5 == 2 * a4 - a2);\n        \n        if (two) {\n            cout << 2 << endl;\n            continue;\n        }\n        \n        // Otherwise, it's at least 1\n        cout << 1 << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2059e2",
      "PROBLEM_ID": "2059E2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version you need to output all the operations that need to be performed. You can hack only if you solved all versions of this problem.\n\nYou are given $n$ arrays, each of which has a length of $m$. Let the $j$-th element of the $i$-th array be denoted as $a_{i, j}$. It is guaranteed that all $a_{i, j}$ are pairwise distinct. In one operation, you can do the following:\n\n- Choose some integer $i$ ($1 \\le i \\le n$) and an integer $x$ ($1 \\le x \\le 2 \\cdot n \\cdot m$).\n- For all integers $k$ from $i$ to $n$ in increasing order, do the following:\n1. Add the element $x$ to the beginning of the $k$-th array.\n\n2. Assign $x$ the value of the last element in the $k$-th array.\n\n3. Remove the last element from the $k$-th array.\n\nIn other words, you can insert an element at the beginning of any array, after which all elements in this and all following arrays are shifted by one to the right. The last element of the last array is removed.\n\nYou are also given a description of the arrays that need to be obtained after all operations. That is, after performing the operations, the $j$-th element of the $i$-th array should be equal to $b_{i, j}$. It is guaranteed that all $b_{i, j}$ are pairwise distinct.\n\nDetermine the minimum number of operations that need to be performed to obtain the desired arrays, and also output the sequence of all operations itself.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 3 \\cdot 10^5$)\u00a0\u2014 the number of arrays and the number of elements in each array.\n\nThe $i$-th of the following $n$ lines contains $m$ integers $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, m}$ ($1 \\le a_{i, j} \\le 2 \\cdot n \\cdot m$)\u00a0\u2014 the elements of the $i$-th original array. It is guaranteed that all $a_{i, j}$ are pairwise distinct.\n\nThe $i$-th of the following $n$ lines contains $m$ integers $b_{i, 1}, b_{i, 2}, \\ldots, b_{i, m}$ ($1 \\le b_{i, j} \\le 2 \\cdot n \\cdot m$)\u00a0\u2014 the elements of the $i$-th final array. It is guaranteed that all $b_{i, j}$ are pairwise distinct.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations that need to be performed.\n\nNext, for each operation output two integers $i$ and $x$ ($1 \\le i \\le n$, $1 \\le x \\le 2 \\cdot n \\cdot m$) \u2014 the index of the array where the element is inserted and the value of the element, respectively.\n\nIf there are multiple possible sequences with the minimum number of operations, output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 2\n\n2 6\n\n3 4\n\n1 2\n\n7 8\n\n1 5\n\n5 4 1 2 3\n\n5 4 3 2 1\n\n3 3\n\n1 2 3\n\n4 5 6\n\n7 8 9\n\n11 1 2\n\n12 3 4\n\n13 5 6\n\n4 4\n\n1 2 3 4\n\n5 6 7 8\n\n9 10 11 12\n\n13 14 15 16\n\n17 1 2 3\n\n4 18 5 6\n\n7 19 8 20\n\n9 21 22 10\n\n```\n\n#### Output #1\n\n```\n3\n1 1\n2 8\n2 7\n5\n1 1\n1 2\n1 3\n1 4\n1 5\n3\n1 11\n2 12\n3 13\n6\n3 20\n2 18\n3 19\n4 22\n4 21\n1 17\n```\n\n### Note\n\nIn the first test case, the following sequence of $3$ operations is suitable:\n\n- Apply the operation to the first array with $x = 1$. Then the element $1$ will be added to the beginning of the first array, and the value of $x$ will become $6$. The last element will be removed, and the first array will look like $[1, 2]$. Next, the element $x$ is added to the beginning of the second array, and the value of $x$ becomes $4$. The last element of the second array is removed, and both arrays look like $[1, 2]$ and $[6, 3]$ respectively after the first operation.\n- Apply the operation to the second array with $x = 8$. Then the first array remains unchanged, and both arrays will look like $[1, 2]$ and $[8, 6]$ respectively.\n- Apply the operation to the second array with $x = 7$, then both arrays will have the required appearance $[1, 2]$ and $[7, 8]$ respectively.\n\nIn the second test case, the desired array can only be achieved in $5$ operations.\n\nIn the third test case, the following sequence of $3$ operations is suitable:\n\n- Apply the operation with $x = 11$ to the first array.\n- Apply the operation with $x = 12$ to the second array.\n- Apply the operation with $x = 13$ to the third array.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define eb emplace_back\n#define int long long\n#define all(x) x.begin(), x.end()\n#define fi first\n#define se second\n\nconst int INF = 1e9 + 1000;\n \nstruct segtree {\n    vector<pair<int, int>> tree;\n    vector<int> ass;\n    int size = 1;\n \n    void init(vector<int> &a) {\n        while (a.size() >= size) {\n            size <<= 1;\n        }\n        tree.assign(2 * size, {});\n        ass.assign(2 * size, 0);\n        build(0, 0, size, a);\n    }\n \n    void build(int x, int lx, int rx, vector<int> &a) {\n        if (rx - lx == 1) {\n            tree[x].se = lx;\n            if (lx < a.size()) {\n                tree[x].fi = a[lx];\n            } else {\n                tree[x].fi = INF;\n            }\n            return;\n        }\n        int m = (lx + rx) / 2;\n        build(2 * x + 1, lx, m, a);\n        build(2 * x + 2, m, rx, a);\n        tree[x] = min(tree[2 * x + 1], tree[2 * x + 2]);\n    }\n \n    void push(int x, int lx, int rx) {\n        tree[x].fi += ass[x];\n        if (rx - lx == 1) {\n            ass[x] = 0;\n            return;\n        }\n        ass[2 * x + 1] += ass[x];\n        ass[2 * x + 2] += ass[x];\n        ass[x] = 0;\n    }\n \n    void update(int l, int r, int val, int x, int lx, int rx) {\n        push(x, lx,  rx);\n        if (l <= lx && rx <= r) {\n            ass[x] += val;\n            push(x, lx, rx);\n            return;\n        }\n        if (rx <= l || r <= lx) {\n            return;\n        }\n        int m = (lx + rx) / 2;\n        update(l, r, val, 2 * x + 1, lx, m);\n        update(l, r, val, 2 * x + 2, m, rx);\n        tree[x] = min(tree[2 * x + 1], tree[2 * x + 2]);\n    }\n \n    void update(int l, int r, int val) {\n        update(l, r + 1, val, 0, 0, size);\n    }\n \n    int req(int x, int lx, int rx) {\n        push(x, lx, rx);\n        if (rx - lx == 1) {\n            return tree[x].se;\n        }\n        int m = (lx + rx) / 2;\n        push(2 * x + 1, lx, m);\n        push(2 * x + 2, m, rx);\n        if (tree[2 * x + 2].fi == 0) {\n            return req(2 * x + 2, m, rx);\n        } else {\n            return req(2 * x + 1, lx, m);\n        }\n    }\n \n    int req() {\n        return req(0, 0, size);\n    }\n};\n \nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n * m + 1), b(n * m + 1);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < m; j++) {\n            int ind = j + 1 + (i - 1) * m;\n            cin >> a[ind];\n        }\n    }\n    for (int i = 1; i <= n * m; i++)\n        cin >> b[i];\n    map<int, int> mp;\n    for (int i = 1; i <= n * m; i++)\n        mp[b[i]] = i;\n    vector<int> s(n * m + 1), pos(n * m + 1, -1);\n    for (int i = 1; i <= n * m; i++) {\n        if (mp.find(a[i]) != mp.end())\n            pos[i] = mp[a[i]];\n        else\n            break;\n    }\n    pos[0] = 0;\n    int skipped = 0, pref = 0;\n    bool prev = true;\n    for (int i = 1; i <= n * m; i++) {\n        if (pos[i - 1] > pos[i])\n            break;\n        int d = pos[i] - pos[i - 1] - 1;\n        if (prev)\n            skipped += d;\n        else if (d > 0)\n            break;\n        if (skipped >= m - 1)\n            prev = true;\n        else if ((i - 1) % m > (i + skipped - 1) % m || (i + skipped) % m == 0)\n            prev = true;\n        else\n            prev = false;\n        if (prev)\n            pref = i;\n    }\n    for (int i = 1; i <= pref; i++) {\n        s[i - 1] = pos[i] - pos[i - 1] - 1;\n    }\n    s[pref] = n * m - pos[pref];\n \n    vector<pair<int, int>> ans;\n \n    int res = 0;\n    for (int i = 0; i <= n * m; i++) {\n        res += s[i];\n    }\n    vector<int> ost(pref + 1);\n    for (int i = 1; i <= pref; i++) {\n        ost[i] = (m - i % m) % m;\n    }\n    for (int i = 0; i <= pref; i++) {\n        if (s[i] == 0) {\n            ost[i] = INF;\n        }\n    }\n    vector<int> gol(pref + 1);\n    gol[0] = 1;\n    for (int i = 1; i <= pref; i++) {\n        gol[i] = (i + m - 1) / m + 1;\n    }\n \n    segtree tree;\n \n    tree.init(ost);\n \n    for (int step = 0; step < res; step++) {\n        int chel = tree.req();\n        ans.eb(gol[chel], b[pos[chel] + s[chel]]);\n        tree.update(chel + 1, pref, -1);\n        s[chel]--;\n        if (s[chel] == 0) {\n            tree.update(chel, chel, INF);\n        }\n    }\n \n    cout << ans.size() << '\\n';\n    for (auto [i, col] : ans) {\n        cout << i << \" \" << col << '\\n';\n    }\n}\n \nsigned main() {\n    //cout << fixed << setprecision(5);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1;\n    cin >> T;\n    //cin >> G;\n    while (T--)\n        solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2059e1",
      "PROBLEM_ID": "2059E1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version you only need to find the minimum number of operations. You can hack only if you solved all versions of this problem.\n\nYou are given $n$ arrays, each of which has a length of $m$. Let the $j$-th element of the $i$-th array be denoted as $a_{i, j}$. It is guaranteed that all $a_{i, j}$ are pairwise distinct. In one operation, you can do the following:\n\n- Choose some integer $i$ ($1 \\le i \\le n$) and an integer $x$ ($1 \\le x \\le 2 \\cdot n \\cdot m$).\n- For all integers $k$ from $i$ to $n$ in increasing order, do the following:\n1. Add the element $x$ to the beginning of the $k$-th array.\n\n2. Assign $x$ the value of the last element in the $k$-th array.\n\n3. Remove the last element from the $k$-th array.\n\nIn other words, you can insert an element at the beginning of any array, after which all elements in this and all following arrays are shifted by one to the right. The last element of the last array is removed.\n\nYou are also given a description of the arrays that need to be obtained after all operations. That is, after performing the operations, the $j$-th element of the $i$-th array should be equal to $b_{i, j}$. It is guaranteed that all $b_{i, j}$ are pairwise distinct.\n\nDetermine the minimum number of operations that need to be performed to obtain the desired arrays.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 3 \\cdot 10^5$)\u00a0\u2014 the number of arrays and the number of elements in each array.\n\nThe $i$-th of the following $n$ lines contains $m$ integers $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, m}$ ($1 \\le a_{i, j} \\le 2 \\cdot n \\cdot m$)\u00a0\u2014 the elements of the $i$-th original array. It is guaranteed that all $a_{i, j}$ are pairwise distinct.\n\nThe $i$-th of the following $n$ lines contains $m$ integers $b_{i, 1}, b_{i, 2}, \\ldots, b_{i, m}$ ($1 \\le b_{i, j} \\le 2 \\cdot n \\cdot m$)\u00a0\u2014 the elements of the $i$-th final array. It is guaranteed that all $b_{i, j}$ are pairwise distinct.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations that need to be performed.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 2\n\n2 6\n\n3 4\n\n1 2\n\n7 8\n\n1 5\n\n5 4 1 2 3\n\n5 4 3 2 1\n\n3 3\n\n1 2 3\n\n4 5 6\n\n7 8 9\n\n11 1 2\n\n12 3 4\n\n13 5 6\n\n4 4\n\n1 2 3 4\n\n5 6 7 8\n\n9 10 11 12\n\n13 14 15 16\n\n17 1 2 3\n\n4 18 5 6\n\n7 19 8 20\n\n9 21 22 10\n\n```\n\n#### Output #1\n\n```\n3\n5\n3\n6\n```\n\n### Note\n\nIn the first test case, the following sequence of $3$ operations is suitable:\n\n- Apply the operation to the first array with $x = 1$. Then the element $1$ will be added to the beginning of the first array, and the value of $x$ will become $6$. The last element will be removed, and the first array will look like $[1, 2]$. Next, the element $x$ is added to the beginning of the second array, and the value of $x$ becomes $4$. The last element of the second array is removed, and both arrays look like $[1, 2]$ and $[6, 3]$ respectively after the first operation.\n- Apply the operation to the second array with $x = 8$. Then the first array remains unchanged, and both arrays will look like $[1, 2]$ and $[8, 6]$ respectively.\n- Apply the operation to the second array with $x = 7$, then both arrays will have the required appearance $[1, 2]$ and $[7, 8]$ respectively.\n\nIn the second test case, the desired array can only be achieved in $5$ operations.\n\nIn the third test case, the following sequence of $3$ operations is suitable:\n\n- Apply the operation with $x = 11$ to the first array.\n- Apply the operation with $x = 12$ to the second array.\n- Apply the operation with $x = 13$ to the third array.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include \"bits/stdc++.h\"\nusing namespace std;\n \nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n * m + 1), b(n * m + 1);\n    vector<deque<int>> mat(n + 1, deque<int> (m));\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < m; j++) {\n            int ind = j + 1 + (i - 1) * m;\n            mat[i][j] = ind;\n            cin >> a[ind];\n        }\n    }\n    for (int i = 1; i <= n * m; i++)\n        cin >> b[i];\n    map<int, int> mp;\n    for (int i = 1; i <= n * m; i++)\n        mp[b[i]] = i;\n    vector<int> s(n * m + 1), pos(n * m + 1, -1);\n    for (int i = 1; i <= n * m; i++) {\n        if (mp.find(a[i]) != mp.end())\n            pos[i] = mp[a[i]];\n        else\n            break;\n    }\n    pos[0] = 0;\n    int skipped = 0, pref = 0;\n    bool prev = true;\n    for (int i = 1; i <= n * m; i++) {\n        if (pos[i - 1] > pos[i])\n            break;\n        int d = pos[i] - pos[i - 1] - 1;\n        if (prev)\n            skipped += d;\n        else if (d > 0)\n            break;\n        if (skipped >= m - 1)\n            prev = true;\n        else if ((i - 1) % m > (i + skipped - 1) % m || (i + skipped) % m == 0)\n            prev = true;\n        else\n            prev = false;\n        if (prev)\n            pref = i;\n    }\n    cout << n * m - pref << '\\n';\n}\n \nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2059d",
      "PROBLEM_ID": "2059D",
      "PROBLEM_STATEMENT": "You are given two connected undirected graphs with the same number of vertices. In both graphs, there is a token located at some vertex. In the first graph, the token is initially at vertex $s_1$, and in the second graph, the token is initially at vertex $s_2$. The following operation is repeated an infinite number of times:\n\n- Let the token currently be at vertex $v_1$ in the first graph and at vertex $v_2$ in the second graph.\n- A vertex $u_1$, adjacent to $v_1$, is chosen in the first graph.\n- A vertex $u_2$, adjacent to $v_2$, is chosen in the second graph.\n- The tokens are moved to the chosen vertices: in the first graph, the token moves from $v_1$ to $u_1$, and in the second graph, from $v_2$ to $u_2$.\n- The cost of such an operation is equal to $|u_1 - u_2|$.\n\nDetermine the minimum possible total cost of all operations or report that this value will be infinitely large.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains one integer $t$ ($1 \\le t \\le 500$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $s_1$, and $s_2$ ($2 \\le n \\le 1000$, $1 \\le s_1, s_2 \\le n$)\u00a0\u2014 the number of vertices in each graph, the number of the vertex in the first graph where the token is initially located, and the number of the vertex in the second graph where the token is initially located.\n\nThe second line of each test case contains one integer $m_1$ ($1 \\le m_1 \\le 1000$)\u00a0\u2014 the number of edges in the first graph.\n\nThe $i$-th of the following $m_1$ lines contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le n$, $a_i \\ne b_i$)\u00a0\u2014 the numbers of the endpoints of the $i$-th edge in the first graph.\n\nThe next line of each test case contains one integer $m_2$ ($1 \\le m_2 \\le 1000$)\u00a0\u2014 the number of edges in the second graph.\n\nThe $j$-th of the following $m_2$ lines contains two integers $c_j$ and $d_j$ ($1 \\le c_j, d_j \\le n$, $c_j \\ne d_j$)\u00a0\u2014 the numbers of the endpoints of the $j$-th edge in the second graph.\n\nIt is guaranteed that the sum of $n$, the sum of $m_1$, and the sum of $m_2$ over all test cases do not exceed $1000$.\n\nIt is guaranteed that both graphs are connected.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the minimum total cost of all operations or $-1$, if this value will be infinitely large.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4 1 1\n\n4\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n4\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n4 1 2\n\n4\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n4\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n7 7 2\n\n7\n\n1 6\n\n2 1\n\n3 2\n\n3 4\n\n5 1\n\n7 3\n\n7 5\n\n6\n\n5 1\n\n5 6\n\n5 7\n\n6 3\n\n7 2\n\n7 4\n\n```\n\n#### Output #1\n\n```\n0\n-1\n7\n```\n\n### Note\n\nIn the first test case, an infinite sequence of transitions can be constructed to the vertices $2, 3, 4, 1, 2, 3, 4, 1, \\ldots$, along which the token can move in both the first and the second graphs.\n\nIn the second test case, it can be proven that the cost of any operation will be greater than $0$; therefore, the total cost of all operations will be infinitely large.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, s1, s2;\n        cin >> n >> s1 >> s2;\n\n        vector<vector<int>> adj1(n + 1), adj2(n + 1);\n\n        int m1;\n        cin >> m1;\n        for (int i = 0; i < m1; ++i) {\n            int a, b;\n            cin >> a >> b;\n            adj1[a].push_back(b);\n            adj1[b].push_back(a);\n        }\n\n        int m2;\n        cin >> m2;\n        for (int i = 0; i < m2; ++i) {\n            int c, d;\n            cin >> c >> d;\n            adj2[c].push_back(d);\n            adj2[d].push_back(c);\n        }\n\n        vector<bool> has_common(n + 1, false);\n        for (int x = 1; x <= n; ++x) {\n            unordered_set<int> s(adj1[x].begin(), adj1[x].end());\n            for (int y : adj2[x]) {\n                if (s.count(y)) {\n                    has_common[x] = true;\n                    break;\n                }\n            }\n        }\n\n        vector<vector<int>> dist(n + 1, vector<int>(n + 1, INF));\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n\n        dist[s1][s2] = 0;\n        pq.emplace(0, s1, s2);\n\n        int answer = -1;\n        while (!pq.empty()) {\n            auto [cost, a, b] = pq.top();\n            pq.pop();\n\n            if (a == b && has_common[a]) {\n                answer = cost;\n                break;\n            }\n\n            if (cost > dist[a][b]) continue;\n\n            for (int a_prime : adj1[a]) {\n                for (int b_prime : adj2[b]) {\n                    int new_cost = cost + abs(a_prime - b_prime);\n                    if (new_cost < dist[a_prime][b_prime]) {\n                        dist[a_prime][b_prime] = new_cost;\n                        pq.emplace(new_cost, a_prime, b_prime);\n                    }\n                }\n            }\n        }\n\n        cout << answer << '\\n';\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2059c",
      "PROBLEM_ID": "2059C",
      "PROBLEM_STATEMENT": "Nikyr has started working as a queue manager at the company \"Black Contour.\" He needs to choose the order of servicing customers. There are a total of $n$ queues, each initially containing $0$ people. In each of the next $n$ moments of time, there are two sequential events:\n\n1. New customers arrive in all queues. More formally, at the $j$-th moment of time, the number of people in the $i$-th queue increases by a positive integer $a_{i,j}$.\n2. Nikyr chooses exactly one of the $n$ queues to be served at that moment in time. The number of customers in this queue becomes $0$.\n\nLet the number of people in the $i$-th queue after all events be $x_i$. Nikyr wants MEX$^{\\dagger}$ of the collection $x_1, x_2, \\ldots, x_n$ to be as large as possible. Help him determine the maximum value he can achieve with an optimal order of servicing the queues.\n\n$^{\\dagger}$The minimum excluded (MEX) of a collection of integers $c_1, c_2, \\ldots, c_k$ is defined as the smallest non-negative integer $y$ which does not occur in the collection $c$.\n\nFor example:\n\n- $\\operatorname{MEX}([2,2,1])= 0$, since $0$ does not belong to the array.\n- $\\operatorname{MEX}([3,1,0,1]) = 2$, since $0$ and $1$ belong to the array, but $2$ does not.\n- $\\operatorname{MEX}([0,3,1,2]) = 4$, since $0$, $1$, $2$, and $3$ belong to the array, but $4$ does not.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 2 \\cdot 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 300$) \u2014 the number of queues and moments of time.\n\nThe $i$-th of the next $n$ lines contains $n$ integers $a_{i,1}, a_{i,2}, \\ldots, a_{i,n}$ ($1 \\le a_{i,j} \\le 10^9$) \u2014 the number of new customers in the $i$-th queue at each moment of time.\n\nIt is guaranteed that the sum of $n^2$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the maximum value of $\\operatorname{MEX}([x_1, x_2, \\ldots, x_n])$ that can be achieved.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n1 2\n\n2 1\n\n2\n\n10 10\n\n10 10\n\n3\n\n2 3 3\n\n4 4 1\n\n2 1 1\n\n4\n\n4 2 2 17\n\n1 9 3 1\n\n5 5 5 11\n\n1 2 1 1\n\n```\n\n#### Output #1\n\n```\n2\n1\n3\n3\n```\n\n### Note\n\nIn the first test case, the second queue can be served at time $1$, and the first queue at time $2$. There will be $x_1 = 0$ people left in the first queue and $x_2 = 1$ person left in the second queue. Therefore, the answer is $\\operatorname{MEX}([0, 1]) = 2$.\n\nIn the second test case, the first queue can be served both times. There will be $x_1 = 0$ people left in the first queue and $x_2 = 20$ people left in the second queue. Therefore, the answer is $\\operatorname{MEX}([0, 20]) = 1$.\n\nIn the third test case, the third queue can be served at time $1$, the second queue at time $2$, and the first queue at time $3$. There will be $x_1 = 0$ people left in the first queue, $x_2 = 1$ person left in the second queue, and $x_3 = 2$ people left in the third queue. Therefore, the answer is $\\operatorname{MEX}([0, 1, 2]) = 3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        vector<vector<long long>> a(n, vector<long long>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                cin >> a[i][j];\n            }\n        }\n\n        // Compute suffix sums:\n        // suffix[i][j] = sum of a[i][j+1] + a[i][j+2] + ... + a[i][n-1]\n        vector<vector<long long>> suffix(n, vector<long long>(n));\n        for (int i = 0; i < n; i++) {\n            suffix[i][n-1] = 0;\n            for (int j = n - 2; j >= 0; j--) {\n                suffix[i][j] = suffix[i][j+1] + a[i][j+1];\n            }\n        }\n\n        // Build adjacency for bipartite matching:\n        // Left side: y = 0..n-1\n        // Right side: rows i = 0..n-1\n        // There is an edge (y, i) iff suffix[i][n-y-1] == y\n        vector<vector<int>> adj(n);\n        for (int y = 0; y < n; y++) {\n            int j = n - y - 1;\n            for (int i = 0; i < n; i++) {\n                if (suffix[i][j] == y) {\n                    adj[y].push_back(i);\n                }\n            }\n        }\n\n        // We'll do an incremental bipartite matching, trying to match y = 0,1,2,...\n        vector<int> matchedRow(n, -1);\n        int mex = 0;\n        vector<char> visited(n);\n\n        // DFS to find augmenting path for a given y\n        function<bool(int)> dfs = [&](int y) {\n            for (int i : adj[y]) {\n                if (!visited[i]) {\n                    visited[i] = 1;\n                    // If row i is free or we can re-match the y' that is currently using i\n                    if (matchedRow[i] == -1 || dfs(matchedRow[i])) {\n                        matchedRow[i] = y;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n\n        for (int y = 0; y < n; y++) {\n            fill(visited.begin(), visited.end(), 0);\n            if (dfs(y)) {\n                // Successfully matched label y\n                mex++;\n            } else {\n                // Cannot match y, stop here\n                break;\n            }\n        }\n\n        cout << mex << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2059b",
      "PROBLEM_ID": "2059B",
      "PROBLEM_STATEMENT": "You are given an array $a$ of length $n$ and an even integer $k$ ($2 \\le k \\le n$). You need to split the array $a$ into exactly $k$ non-empty subarrays$^{\\dagger}$ such that each element of the array $a$ belongs to exactly one subarray.\n\nNext, all subarrays with even indices (second, fourth, $\\ldots$, $k$-th) are concatenated into a single array $b$. After that, $0$ is added to the end of the array $b$.\n\nThe cost of the array $b$ is defined as the minimum index $i$ such that $b_i \\neq i$. For example, the cost of the array $b = [1, 2, 4, 5, 0]$ is $3$, since $b_1 = 1$, $b_2 = 2$, and $b_3 \\neq 3$. Determine the minimum cost of the array $b$ that can be obtained with an optimal partitioning of the array $a$ into subarrays.\n\n$^{\\dagger}$An array $x$ is a subarray of an array $y$ if $x$ can be obtained from $y$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2 \\le k \\le n \\le 2 \\cdot 10^5$, $k$ is even)\u00a0\u2014 the length of the array $a$ and the number of subarrays.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum cost of the array $b$ that can be obtained.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 2\n\n1 1 1\n\n8 8\n\n1 1 2 2 3 3 4 4\n\n5 4\n\n1 1 1 2 2\n\n5 4\n\n1 1 1000000000 2 2\n\n```\n\n#### Output #1\n\n```\n2\n5\n2\n1\n```\n\n### Note\n\nIn the first test case, there are only two possible partitionings: $[[1], [1, 1]]$ and $[[1, 1], [1]]$. In either case, $b_1 = 1$, and $b_2 \\ne 2$, so the cost is $2$.\n\nIn the second test case, there is only one possible partitioning, where $b = [1, 2, 3, 4, 0]$, so the cost is $5$ ($b_5 = 0 \\ne 5$).\n\nIn the third test case, the following partitioning works: $[[1], [1, 1], [2], [2]]$. Then $b = [1, 1, 2, 0]$, and the cost is $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    if(!(cin >> t)) return 0;\n    while(t--){\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n+1);\n        for(int i = 1; i <= n; i++){\n            cin >> a[i];\n        }\n        // Build position lists for values 1..n\n        vector<vector<int>> posList(n+2);\n        for(int i = 1; i <= n; i++){\n            int v = a[i];\n            if(v >= 1 && v <= n){\n                posList[v].push_back(i);\n            }\n        }\n        int halfK = k / 2;\n        // posPrev = last pick position, transPrev = number of transitions so far minus 1 (initial -1)\n        int posPrev = 0;\n        int transPrev = -1;\n        bool done = false;\n\n        // --- Stage i = 1: special handling for first pick/mismatch ---\n        {\n            int i = 1;\n            // possible mismatch positions p1 in [2.. n-k+2]\n            int lo = 2;\n            int hi = n - k + 2;\n            if(lo <= hi){\n                // count how many are equal to 1 in that interval\n                int have1 = 0;\n                if(i <= n){\n                    auto &P = posList[i];\n                    auto itl = lower_bound(P.begin(), P.end(), lo);\n                    auto itu = upper_bound(P.begin(), P.end(), hi);\n                    have1 = int(itu - itl);\n                }\n                int total = hi - lo + 1;\n                if(total > have1){\n                    // there is some a[p]!=1 -> mismatch at i=1\n                    cout << 1 << \"\\n\";\n                    continue;\n                }\n            }\n            // mapping match for i=1\n            {\n                int lo_map = 2;\n                int hi_map = n - k + 2;\n                // find minimal position of value 1 in [lo_map..hi_map]\n                int p1 = -1;\n                if(1 <= n){\n                    auto &P = posList[1];\n                    auto it = lower_bound(P.begin(), P.end(), lo_map);\n                    if(it != P.end() && *it <= hi_map){\n                        p1 = *it;\n                    }\n                }\n                if(p1 < 0){\n                    // cannot map even the first match, so mismatch forced at 1\n                    cout << 1 << \"\\n\";\n                    continue;\n                }\n                posPrev = p1;\n                transPrev = 0;\n            }\n        }\n\n        // Now for i >= 2\n        for(int i = 2; ; i++){\n            // 1) Attempt mismatch at i\n            // 1a) contiguous pick for mismatch\n            int p1 = posPrev + 1;\n            if(p1 <= n){\n                int trans1 = transPrev; \n                if(trans1 <= halfK - 1){\n                    // leftover segments after using segStarted = 2*(trans1+1)\n                    int leftover = k - 2*(trans1 + 1);\n                    if(leftover < 0) leftover = 0;\n                    if(n - p1 >= leftover){\n                        // we can take a[p1] as b_i\n                        if(a[p1] != i){\n                            cout << i << \"\\n\";\n                            done = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if(done) break;\n\n            // 1b) skip pick for mismatch\n            if(transPrev + 1 <= halfK - 1){\n                int trans2 = transPrev + 1;\n                int leftover = k - 2*(trans2 + 1);\n                if(leftover < 0) leftover = 0;\n                int lo2 = posPrev + 2;\n                int hi2 = n - leftover;\n                if(lo2 <= hi2){\n                    int total = hi2 - lo2 + 1;\n                    int cntSame = 0;\n                    if(i <= n){\n                        auto &P = posList[i];\n                        auto itl = lower_bound(P.begin(), P.end(), lo2);\n                        auto itu = upper_bound(P.begin(), P.end(), hi2);\n                        cntSame = int(itu - itl);\n                    }\n                    if(total > cntSame){\n                        // found some p in [lo2..hi2] with a[p] != i\n                        cout << i << \"\\n\";\n                        done = true;\n                        break;\n                    }\n                }\n            }\n            if(done) break;\n\n            // 2) No mismatch possible at i, now we must match value i\n            bool mapped = false;\n            // 2a) try contiguous mapping\n            if(p1 <= n){\n                int trans1 = transPrev;\n                if(trans1 <= halfK - 1){\n                    int leftover = k - 2*(trans1 + 1);\n                    if(leftover < 0) leftover = 0;\n                    if(n - p1 >= leftover && a[p1] == i){\n                        // match by contiguous pick\n                        posPrev = p1;\n                        transPrev = trans1;\n                        mapped = true;\n                    }\n                }\n            }\n            if(mapped) continue;\n\n            // 2b) try skip mapping (transition)\n            if(transPrev + 1 <= halfK - 1){\n                int trans2 = transPrev + 1;\n                int leftover = k - 2*(trans2 + 1);\n                if(leftover < 0) leftover = 0;\n                int lo2 = posPrev + 2;\n                int hi2 = n - leftover;\n                if(lo2 <= hi2 && i <= n){\n                    auto &P = posList[i];\n                    auto it = lower_bound(P.begin(), P.end(), lo2);\n                    if(it != P.end() && *it <= hi2){\n                        posPrev = *it;\n                        transPrev = trans2;\n                        mapped = true;\n                    }\n                }\n            }\n            if(mapped) continue;\n\n            // 2c) mapping fails -> forced mismatch at i\n            cout << i << \"\\n\";\n            done = true;\n            break;\n        }\n        // end for i\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2059a",
      "PROBLEM_ID": "2059A",
      "PROBLEM_STATEMENT": "An array is called good if for any element $x$ that appears in this array, it holds that $x$ appears at least twice in this array. For example, the arrays $[1, 2, 1, 1, 2]$, $[3, 3]$, and $[1, 2, 4, 1, 2, 4]$ are good, while the arrays $[1]$, $[1, 2, 1]$, and $[2, 3, 4, 4]$ are not good.\n\nMilya has two good arrays $a$ and $b$ of length $n$. She can rearrange the elements in array $a$ in any way. After that, she obtains an array $c$ of length $n$, where $c_i = a_i + b_i$ ($1 \\le i \\le n$).\n\nDetermine whether Milya can rearrange the elements in array $a$ such that there are at least $3$ distinct elements in array $c$.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 50$)\u00a0\u2014 the length of the arrays $a$ and $b$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the elements of the array $a$.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le 10^9$)\u00a0\u2014 the elements of the array $b$.\n\n### Output\n\nFor each test case, output $\u00ab$YES$\u00bb$ (without quotes) if it is possible to obtain at least $3$ distinct elements in array $c$, and $\u00ab$NO$\u00bb$ otherwise.\n\nYou can output each letter in any case (for example, $\u00ab$YES$\u00bb$, $\u00ab$Yes$\u00bb$, $\u00ab$yes$\u00bb$, $\u00ab$yEs$\u00bb$ will be recognized as a positive answer).\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4\n\n1 2 1 2\n\n1 2 1 2\n\n6\n\n1 2 3 3 2 1\n\n1 1 1 1 1 1\n\n3\n\n1 1 1\n\n1 1 1\n\n6\n\n1 52 52 3 1 3\n\n59 4 3 59 3 4\n\n4\n\n100 1 100 1\n\n2 2 2 2\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\nYES\nNO\n```\n\n### Note\n\nIn the first test case, you can swap the second and third elements. Then the array $a = [1, 1, 2, 2]$, $b = [1, 2, 1, 2]$, and then $c = [2, 3, 3, 4]$.\n\nIn the second test case, you can leave the elements unchanged. Then $c = [2, 3, 4, 4, 3, 2]$.\n\nIn the third test case, the array $a$ will not change from rearranging the elements in it. Then $c = [2, 2, 2]$, so the answer is $\u00ab$NO$\u00bb$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n), b(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        for (int i = 0; i < n; ++i) {\n            cin >> b[i];\n        }\n        unordered_set<int> sums;\n        for (int x : a) {\n            for (int y : b) {\n                sums.insert(x + y);\n            }\n        }\n        cout << (sums.size() >= 3 ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2057h",
      "PROBLEM_ID": "2057H",
      "PROBLEM_STATEMENT": "There are very long classes in the T-Generation. In one day, you need to have time to analyze the training and thematic contests, give a lecture with new material, and, if possible, also hold a mini-seminar. Therefore, there is a break where students can go to drink coffee and chat with each other.\n\nThere are a total of $n+2$ coffee machines located in sequentially arranged rooms along a long corridor. The coffee machines are numbered from $0$ to $n+1$, and immediately after the break starts, there are $a_i$ students gathered around the $i$-th coffee machine.\n\nThe students are talking too loudly among themselves, and the teachers need to make a very important announcement. Therefore, they want to gather the maximum number of students around some single coffee machine. The teachers are too lazy to run around the corridors and gather the students, so they came up with a more sophisticated way to manipulate them:\n\n- At any moment, the teachers can choose room $i$ ($1 \\le i \\le n$) and turn off the lights there;\n- If there were $x$ students in that room, then after turning off the lights, $\\lfloor \\frac12 x \\rfloor$ students will go to room $(i-1)$, and $\\lfloor \\frac12 x \\rfloor$ other students will go to room $(i+1)$.\n- If $x$ was odd, then one student remains in the same room.\n- After that, the lights in room $i$ are turned back on.\n\nThe teachers have not yet decided where they will gather the students, so for each $i$ from $1$ to $n$, you should determine what is the maximum number of students that can be gathered around the $i$-th coffee machine.\n\nThe teachers can turn off the lights in any rooms at their discretion, in any order, possibly turning off the lights in the same room multiple times.\n\nNote that the values of $a_0$ and $a_{n+1}$ do not affect the answer to the problem, so their values will not be given to you.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10\\,000$)\u00a0\u2014 the number of test cases.\n\nIn the first line of each test case, there is an integer $n$ ($1 \\le n \\le 10^6$).\n\nIn the second line of each test case, there are integers $a_1, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$)\u00a0\u2014 the number of students around coffee machines numbered $1, 2, \\ldots, n$.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output $n$ integers $b_1, \\ldots, b_n$, where $b_i$ is the maximum number of students that can be around coffee machines number $i$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2\n\n8 0\n\n5\n\n2 2 2 2 2\n\n5\n\n0 0 9 0 0\n\n```\n\n#### Output #1\n\n```\n8 4\n4 5 4 5 4\n4 6 9 6 4\n```\n\n### Note\n\nLet's analyze the first test case:\n\n- To maximize the number of students at the $1$-st coffee machine, all that needs to be done is nothing.\n- To maximize the number of students at the $2$-nd coffee machine, it is sufficient to turn off the lights in the $1$-st room once.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing vi = vector<int>;\nusing ll = long long;\n\nvector<ll> a, lhs, rhs;\nvector<int> st;\n\nvector<ll> get_right_out(const vector<ll>& a, vector<ll>& res) {\n    const int n = a.size();\n    st.clear();\n    res.assign(n+1, 0);\n\n    for (int i = 0; i < n; ++i) {\n        ll x = a[i] + res[i];\n        st.push_back(i);\n\n        while (x != 0) {\n            if (st.empty()) {\n                const int len = i + 1;\n                const ll cnt = x / (len + 1);\n                res[i+1] += cnt * len;\n                x -= cnt * (len + 1);\n\n                if (x != 0) {\n                    res[i+1] += x;\n                    st.push_back(x-1);\n                    x = 0;\n                }\n            } else {\n                const int j = st.back();\n                if (x > i - j) {\n                    res[i+1] += i - j;\n                    st.pop_back();\n                    x -= i - j + 1;\n                } else {\n                    res[i+1] += x;\n                    st.back() += x;\n                    x = 0;\n                }\n            }\n        }\n    }\n\n    return res;\n}\n\nvector<ll> get_left_out(vector<ll>& a, vector<ll>& b) {\n    reverse(a.begin(), a.end());\n    get_right_out(a, b);\n    reverse(b.begin(), b.end());\n    reverse(a.begin(), a.end());\n    return b;\n}\n\nvoid solve() {\n    int n; cin >> n;\n    \n    a.resize(n);\n    for (ll& x : a) cin >> x;\n\n    get_right_out(a, lhs);\n    get_left_out(a, rhs);\n\n    ll ans = 0;\n    for (int i = 0; i < n; ++i)\n        cout << lhs[i] + a[i] + rhs[i+1] << ' ';\n    cout << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(0); cin.tie(0);\n\n    int t = 1;\n    cin >> t;\n    while (t--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2057f",
      "PROBLEM_ID": "2057F",
      "PROBLEM_STATEMENT": "One day, the teachers of \"T-generation\" decided to instill discipline in the pupils, so they lined them up and made them calculate in order. There are a total of $n$ pupils, the height of the $i$-th pupil in line is $a_i$.\n\nThe line is comfortable, if for each $i$ from $1$ to $n - 1$, the following condition holds: $a_i \\cdot 2 \\ge a_{i + 1}$. Initially, the line is comfortable.\n\nThe teachers do not like that the maximum height in the line is too small, so they want to feed the pupils pizza. You know that when a pupil eats one pizza, their height increases by $1$. One pizza can only be eaten by only one pupil, but each pupil can eat an unlimited number of pizzas. It is important that after all the pupils have eaten their pizzas, the line is comfortable.\n\nThe teachers have $q$ options for how many pizzas they will order. For each option $k_i$, answer the question: what is the maximum height $\\max(a_1, a_2, \\ldots, a_n)$ that can be achieved if the pupils eat at most $k_i$ pizzas.\n\n### Input\n\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each set of test case contains two integers $n$ and $q$ ($1 \\le n, q \\le 5 \\cdot 10^4$)\u00a0\u2014 the number of pupils and the number of options for how many pizzas the teachers will order.\n\nThe second line of each set of test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the heights of the pupils.It is guaranteed that initially, the line is comfortable.\n\nEach of the following $q$ lines of each set of input data contains one integer $k_i$ ($1 \\le k_i \\le 10^9$)\u00a0\u2014 the next limit for how many pizzas the pupils can eat.\n\nIt is guaranteed that the sum of the values of $n$ across all sets of input data does not exceed $5 \\cdot 10^4$.\n\nIt is guaranteed that the sum of the values of $q$ across all sets of input data does not exceed $5 \\cdot 10^4$.\n\n### Output\n\nFor each test case, for each limit for how many pizzas the pupils can eat, output the maximum value $\\max(a_1, a_2, \\ldots, a_n)$ that can be achieved while ensuring that the line is comfortable.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 1\n\n10 20\n\n10\n\n6 7\n\n3 1 2 4 5 6\n\n1\n\n2\n\n4\n\n8\n\n16\n\n32\n\n64\n\n10 4\n\n1 2 4 8 16 32 64 128 256 512\n\n10\n\n100\n\n1000\n\n10000\n\n```\n\n#### Output #1\n\n```\n26\n7 8 10 12 19 35 67\n513 560 1011 10001\n```\n\n### Note\n\nIn the first query of the first set of input data, you can first give $3$ pizzas to the first pupil, and then give $6$ pizzas to the second pupil, making the final array $[13, 26]$ (the line is comfortable since $13 \\cdot 2 \\ge 26$), and the maximum element in it is $26$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n \nusing i64 = long long;\n \nvoid solve() {\n    int n, q;\n    std::cin >> n >> q;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    constexpr int LG = 30;\n    std::vector<std::array<i64, 4>> events;\n    for (int i = 0; i < n; i++) {\n        i64 pow = 1, sum = 0;\n        i64 dop = 0;\n        for (int j = 0; j < LG; j++) {\n            if (i - j < 0) {\n                break;\n            }\n            sum += a[i - j];\n            i64 L = dop, R;\n            if (i - j == 0) {\n                R = 2E18;\n            } else {\n                i64 x = (pow * 4 - 2) * a[i - j - 1] - sum;\n                R = x;\n                dop = x;\n            }\n            pow *= 2;\n            events.push_back({L, -1, j, sum});\n            events.push_back({R, 1, j, sum});\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int x;\n        std::cin >> x;\n        events.push_back({x, 0, i, 0});\n    }\n    std::sort(events.begin(), events.end());\n    std::vector<int> ans(q); \n    std::vector<std::multiset<i64>> st(LG);\n    for (auto item : events) {\n        int h = item[0];\n        int o = item[1];\n        if (o == -1) {\n            int j = item[2];\n            i64 sum = item[3];\n            st[j].insert(sum);\n        } else if (o == 1) {\n            int j = item[2];\n            i64 sum = item[3];\n            st[j].erase(st[j].find(sum));\n        } else {\n            int i = item[2];\n            int low = 0, high = 2E9 + 1;\n            while (high - low > 1) {\n                int mid = (0LL + low + high) / 2;\n                int cur = mid;\n                i64 pos = 0;\n                bool ok = false;\n                for (int cnt = 0; cnt < LG; cnt++) {\n                    if (st[cnt].empty()) {\n                        continue;\n                    }\n                    i64 neg = *st[cnt].rbegin();\n                    pos += cur;\n                    cur = (cur + 1) / 2;\n                    if (pos - neg <= h) {\n                        ok = true;\n                        break;\n                    }\n                }\n                if (ok) {\n                    low = mid;\n                } else {\n                    high = mid;\n                }\n            }\n            ans[i] = low;\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        std::cout << ans[i] << \" \\n\"[i == q - 1];\n    }\n}\n \nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n \n    int t = 1;\n    std::cin >> t;\n \n    while (t--) {\n        solve();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2057e2",
      "PROBLEM_ID": "2057E2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, there is no additional constraint on $m$. You can hack only if you solved all versions of this problem.\n\nRecently, the instructors of \"T-generation\" needed to create a training contest. They were missing one problem, and there was not a single problem on graphs in the contest, so they came up with the following problem.\n\nYou are given a connected weighted undirected graph with $n$ vertices and $m$ edges, which does not contain self-loops or multiple edges.\n\nThere are $q$ queries of the form $(a, b, k)$: among all paths from vertex $a$ to vertex $b$, find the smallest $k$-th maximum weight of edges on the path$^{\\dagger}$.\n\nThe instructors thought that the problem sounded very interesting, but there is one catch. They do not know how to solve it. Help them and solve the problem, as there are only a few hours left until the contest starts.\n\n$^{\\dagger}$ Let $w_1 \\ge w_2 \\ge \\ldots \\ge w_{h}$ be the weights of all edges in a path, in non-increasing order. The $k$-th maximum weight of the edges on this path is $w_{k}$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each set of test case contains three integers $n, m$ and $q$ ($2 \\le n \\le 400$, $n - 1 \\le m \\le \\frac{n \\cdot (n - 1)}{2}$, $1 \\le q \\le 3 \\cdot 10^5$)\u00a0\u2014 the number of vertices, the number of edges, and the number of questions, respectively.\n\nEach of the following $m$ lines of each set of test case contains three integers $v, u$ and $w$ ($1 \\le v, u \\le n$, $1 \\le w \\le 10^9$)\u00a0\u2014 the ends of the next edge of the graph and its weight, respectively. It is guaranteed that the graph does not contain self-loops and multiple edges.\n\nEach of the following $q$ lines of each set of test case contains three integers $a, b$ and $k$ ($1 \\le a, b \\le n$, $k \\ge 1$)\u00a0\u2014 the next question. It is guaranteed that any path from vertex $a$ to vertex $b$ contains at least $k$ edges.\n\nIt is guaranteed that the sum of the values of $n$ across all sets of test cases does not exceed $400$.\n\nIt is guaranteed that the sum of the values of $q$ across all sets of test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each set of test case, output the answers to all questions.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4 4 2\n\n1 2 2\n\n2 4 2\n\n1 3 4\n\n3 4 1\n\n1 4 2\n\n2 3 1\n\n6 7 3\n\n1 2 10\n\n2 3 3\n\n3 4 9\n\n4 5 2\n\n5 6 1\n\n2 4 10\n\n4 6 10\n\n1 6 3\n\n1 6 2\n\n2 4 1\n\n11 17 10\n\n1 4 5\n\n1 3 19\n\n1 2 10\n\n3 2 13\n\n4 5 1\n\n4 6 11\n\n3 5 9\n\n3 6 18\n\n2 7 17\n\n5 8 15\n\n5 10 8\n\n6 9 4\n\n7 10 20\n\n7 8 16\n\n8 11 3\n\n9 11 6\n\n10 11 14\n\n3 11 1\n\n3 11 3\n\n1 11 1\n\n1 11 4\n\n1 11 3\n\n8 2 2\n\n10 4 1\n\n3 9 2\n\n3 9 1\n\n6 7 3\n\n```\n\n#### Output #1\n\n```\n1 2\n2 9 9\n11 3 11 1 3 10 8 4 11 4\n```\n\n### Note\n\nIn the first set of test cases, one of the optimal paths in the first query is the path $1 \\rightarrow 3 \\rightarrow 4$; the $2$-nd maximum weight of the edges on this path is $1$. In the second query, one of the optimal paths is $2 \\rightarrow 4 \\rightarrow 3$; $1$-st maximum weight of the edges is $2$.\n\nIn the second set of input data, one of the optimal paths in the first query is the path $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$; the $3$-rd maximum weight of the edges on this path is $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct DSU {\n    std::vector<int> p, sz, h;\n    \n    DSU(int n = 0) : p(n), sz(n, 1), h(n) { \n        std::iota(p.begin(), p.end(), 0); \n    }\n\n    int leader(int x) {\n        if (x == p[x]) {\n            return x;\n        }\n        return leader(p[x]);\n    }\n\n    bool same(int x, int y) {\n        return leader(x) == leader(y);\n    }\n\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        if (h[x] < h[y]) {\n            std::swap(x, y);\n        }\n        if (h[x] == h[y]) {\n            ++h[x];\n        }\n        sz[x] += sz[y];\n        p[y] = x;\n        return true;\n    }\n\n    int size(int x) { \n        return sz[leader(x)]; \n    }\n};\n\nvoid solve() {\n    int n, m, q;\n    std::cin >> n >> m >> q;\n    std::vector<std::array<int, 3>> edges(m);\n    for (int i = 0; i < m; i++) {\n        int v, u, w;\n        std::cin >> v >> u >> w;\n        v--, u--;\n        edges[i] = {v, u, w};\n    }\n    std::sort(edges.begin(), edges.end(), [&](const std::array<int, 3> &a, const std::array<int, 3> &b) {\n        return a[2] < b[2];\n    });\n    constexpr int INF = 1e9;\n    std::vector<int> value(n);\n    std::vector<std::vector<std::vector<int>>> dis(n, std::vector<std::vector<int>>(n, std::vector<int>(n, INF)));\n    for (int i = 0; i < n; i++) {\n        dis[0][i][i] = 0;\n    }\n    for (auto edge : edges) {\n        int v = edge[0], u = edge[1];\n        dis[0][v][u] = dis[0][u][v] = 1;\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dis[0][i][j] = std::min(dis[0][i][j], dis[0][i][k] + dis[0][k][j]);\n            }\n        }\n    }\n    int p = 1;\n    DSU dsu(n);\n    for (auto edge : edges) {\n        int v = edge[0], u = edge[1], w = edge[2];\n        if (dsu.merge(v, u)) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    dis[p][i][j] = std::min({dis[p - 1][i][j], dis[p - 1][i][v] + dis[p - 1][u][j], dis[p - 1][i][u] + dis[p - 1][v][j]});\n                }\n            }\n            value[p++] = w;\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int v, u, k;\n        std::cin >> v >> u >> k;\n        v--, u--;\n        int low = 0, high = n - 1;\n        while (high - low > 1) {\n            int mid = (low + high) / 2;\n            if (dis[mid][v][u] < k) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        std::cout << value[high] << \" \\n\"[i == q - 1];\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int t = 1;\n    std::cin >> t;\n\n    while (t--) {\n        solve();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2057d",
      "PROBLEM_ID": "2057D",
      "PROBLEM_STATEMENT": "\"T-Generation\" has decided to purchase gifts for various needs; thus, they have $n$ different sweaters numbered from $1$ to $n$. The $i$-th sweater has a size of $a_i$. Now they need to send some subsegment of sweaters to an olympiad. It is necessary that the sweaters fit as many people as possible, but without having to take too many of them.\n\nThey need to choose two indices $l$ and $r$ ($1 \\le l \\le r \\le n$) to maximize the convenience equal to \n\n$$\\operatorname{max} (a_l, a_{l + 1}, \\ldots, a_r) - \\operatorname{min} (a_l, a_{l + 1}, \\ldots, a_r) - (r - l),$$\n\nthat is, the range of sizes minus the number of sweaters.\n\nSometimes the sizes of the sweaters change; it is known that there have been $q$ changes, in each change, the size of the $p$-th sweater becomes $x$.\n\nHelp the \"T-Generation\" team and determine the maximum convenience among all possible pairs $(l, r)$ initially, as well as after each size change.\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of sweaters and the number of size changes.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the sizes of the sweaters.\n\nEach of the following $q$ lines of each test case contains two integers $p$ and $x$ ($1 \\le p \\le n$, $1 \\le x \\le 10^9$)\u00a0\u2014 the next size change.\n\nIt is guaranteed that the sum of the values of $n$ and the sum of the values of $q$ across all test cases do not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the maximum value of convenience among all possible pairs $(l, r)$ before any actions, as well as after each size change.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2\n\n1 10\n\n1 10\n\n2 2\n\n5 3\n\n1 2 3 4 5\n\n3 7\n\n1 4\n\n5 2\n\n8 5\n\n7 4 2 4 8 2 1 4\n\n5 4\n\n1 10\n\n3 2\n\n8 11\n\n7 7\n\n```\n\n#### Output #1\n\n```\n8\n0\n7\n0\n4\n4\n4\n5\n3\n6\n6\n9\n7\n```\n\n### Note\n\nConsider the first test case.\n\n- Before any changes, you can take all the sweaters; then the convenience is equal to $\\operatorname{max} (a_1, a_2) - \\operatorname{min} (a_1, a_2) - (2 - 1) = 10 - 1 - 1 = 8$.\n- After the first query, the sizes of both sweaters will be equal to $10$, you can only take the first sweater and the convenience is equal to $10 - 10 - 0 = 0$.\n- After the second query, the size of the first sweater will be $10$, and the second $2$, you can take all the sweaters and the convenience is equal to $\\operatorname{max} (a_1, a_2) - \\operatorname{min} (a_1, a_2) - (2 - 1) = 10 - 2 - 1 = 7$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct NodeCase1 {\n    int max_val;\n    int min_val;\n    int max_diff;\n    NodeCase1() : max_val(0), min_val(0), max_diff(0) {}\n    NodeCase1(int val) : max_val(val), min_val(val), max_diff(INT_MIN) {}\n};\n\nNodeCase1 mergeCase1(const NodeCase1& left, const NodeCase1& right) {\n    NodeCase1 res;\n    res.max_val = max(left.max_val, right.max_val);\n    res.min_val = min(left.min_val, right.min_val);\n    res.max_diff = max({left.max_diff, right.max_diff, left.max_val - right.min_val});\n    return res;\n}\n\nstruct SegTreeCase1 {\n    vector<NodeCase1> tree;\n    int n;\n\n    SegTreeCase1(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(0, 0, n-1, arr);\n    }\n\n    void build(int node, int l, int r, const vector<int>& arr) {\n        if (l == r) {\n            tree[node] = NodeCase1(arr[l]);\n            return;\n        }\n        int mid = (l + r) / 2;\n        build(2*node+1, l, mid, arr);\n        build(2*node+2, mid+1, r, arr);\n        tree[node] = mergeCase1(tree[2*node+1], tree[2*node+2]);\n    }\n\n    void update(int node, int l, int r, int idx, int val) {\n        if (l == r) {\n            tree[node] = NodeCase1(val);\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (idx <= mid) {\n            update(2*node+1, l, mid, idx, val);\n        } else {\n            update(2*node+2, mid+1, r, idx, val);\n        }\n        tree[node] = mergeCase1(tree[2*node+1], tree[2*node+2]);\n    }\n\n    NodeCase1 query() {\n        return tree[0];\n    }\n};\n\nstruct NodeCase2 {\n    int max_array2;\n    int max_array3;\n    int max_sum;\n    NodeCase2() : max_array2(0), max_array3(0), max_sum(0) {}\n    NodeCase2(int a2, int a3) : max_array2(a2), max_array3(a3), max_sum(INT_MIN) {}\n};\n\nNodeCase2 mergeCase2(const NodeCase2& left, const NodeCase2& right) {\n    NodeCase2 res;\n    res.max_array2 = max(left.max_array2, right.max_array2);\n    res.max_array3 = max(left.max_array3, right.max_array3);\n    res.max_sum = max({left.max_sum, right.max_sum, left.max_array2 + right.max_array3});\n    return res;\n}\n\nstruct SegTreeCase2 {\n    vector<NodeCase2> tree;\n    int n;\n\n    SegTreeCase2(const vector<int>& arr2, const vector<int>& arr3) {\n        n = arr2.size();\n        tree.resize(4 * n);\n        build(0, 0, n-1, arr2, arr3);\n    }\n\n    void build(int node, int l, int r, const vector<int>& arr2, const vector<int>& arr3) {\n        if (l == r) {\n            tree[node] = NodeCase2(arr2[l], arr3[l]);\n            return;\n        }\n        int mid = (l + r) / 2;\n        build(2*node+1, l, mid, arr2, arr3);\n        build(2*node+2, mid+1, r, arr2, arr3);\n        tree[node] = mergeCase2(tree[2*node+1], tree[2*node+2]);\n    }\n\n    void update(int node, int l, int r, int idx, int a2, int a3) {\n        if (l == r) {\n            tree[node] = NodeCase2(a2, a3);\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (idx <= mid) {\n            update(2*node+1, l, mid, idx, a2, a3);\n        } else {\n            update(2*node+2, mid+1, r, idx, a2, a3);\n        }\n        tree[node] = mergeCase2(tree[2*node+1], tree[2*node+2]);\n    }\n\n    NodeCase2 query() {\n        return tree[0];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, q;\n        cin >> n >> q;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n\n        vector<int> array1(n), array2(n), array3(n);\n        for (int i = 0; i < n; i++) {\n            array1[i] = a[i] + (i+1);\n            array2[i] = (i+1) - a[i];\n            array3[i] = a[i] - (i+1);\n        }\n\n        SegTreeCase1 st1(array1);\n        SegTreeCase2 st2(array2, array3);\n\n        auto getAns = [&]() {\n            int case1 = st1.query().max_diff;\n            int case2 = st2.query().max_sum;\n            return max({0, case1, case2});\n        };\n\n        cout << getAns() << '\\n';\n\n        while (q--) {\n            int p, x;\n            cin >> p >> x;\n            p--;\n\n            a[p] = x;\n            array1[p] = x + (p+1);\n            array2[p] = (p+1) - x;\n            array3[p] = x - (p+1);\n\n            st1.update(0, 0, n-1, p, array1[p]);\n            st2.update(0, 0, n-1, p, array2[p], array3[p]);\n\n            cout << getAns() << '\\n';\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2057c",
      "PROBLEM_ID": "2057C",
      "PROBLEM_STATEMENT": "In the upcoming year, there will be many team olympiads, so the teachers of \"T-generation\" need to assemble a team of three pupils to participate in them. Any three pupils will show a worthy result in any team olympiad. But winning the olympiad is only half the battle; first, you need to get there...\n\nEach pupil has an independence level, expressed as an integer. In \"T-generation\", there is exactly one student with each independence levels from $l$ to $r$, inclusive. For a team of three pupils with independence levels $a$, $b$, and $c$, the value of their team independence is equal to $(a \\oplus b) + (b \\oplus c) + (a \\oplus c)$, where $\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nYour task is to choose any trio of students with the maximum possible team independence.\n\n### Input\n\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case set contains two integers $l$ and $r$ ($0 \\le l, r < 2^{30}$, $r - l > 1$)\u00a0\u2014 the minimum and maximum independence levels of the students.\n\n### Output\n\nFor each test case set, output three pairwise distinct integers $a, b$, and $c$, such that $l \\le a, b, c \\le r$ and the value of the expression $(a \\oplus b) + (b \\oplus c) + (a \\oplus c)$ is maximized. If there are multiple triples with the maximum value, any of them can be output.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n0 2\n\n0 8\n\n1 3\n\n6 22\n\n128 137\n\n69 98\n\n115 127\n\n0 1073741823\n\n```\n\n#### Output #1\n\n```\n1 2 0\n8 7 1\n2 1 3\n7 16 11\n134 132 137\n98 85 76\n123 121 118\n965321865 375544086 12551794\n```\n\n### Note\n\nIn the first test case, the only suitable triplet of numbers ($a, b, c$) (up to permutation) is ($0, 1, 2$).\n\nIn the second test case, one of the suitable triplets is ($8, 7, 1$), where $(8 \\oplus 7) + (7 \\oplus 1) + (8 \\oplus 1) = 15 + 6 + 9 = 30$. It can be shown that $30$ is the maximum possible value of $(a \\oplus b) + (b \\oplus c) + (a \\oplus c)$ for $0 \\le a, b, c \\le 8$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        ll l, r;\n        cin >> l >> r;\n\n        // Find the highest differing bit between l and r\n        ll x = l ^ r;\n        int d = 63 - __builtin_clzll(x);  // position of the most significant set bit in x\n\n        // Build the base (common high bits above d)\n        ll D = 1LL << d;\n        ll prefix = l >> (d + 1);\n        ll base = prefix << (d + 1);\n\n        // Choose a, b, c as described\n        ll a = base + D;        // has bit d = 1, all lower bits = 0\n        ll b = base + (D - 1);  // has bit d = 0, lower bits all = 1\n        ll c;\n        // If l coincides with b, pick c = r, otherwise c = l\n        if (l != b) c = l;\n        else        c = r;\n\n        // Output any order; here we output a, b, c\n        cout << a << \" \" << b << \" \" << c << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2057a",
      "PROBLEM_ID": "2057A",
      "PROBLEM_STATEMENT": "One day, the schoolboy Mark misbehaved, so the teacher Sasha called him to the whiteboard.\n\nSasha gave Mark a table with $n$ rows and $m$ columns. His task is to arrange the numbers $0, 1, \\\\ldots, n \\\\cdot m - 1$ in the table (each number must be used exactly once) in such a way as to maximize the sum of MEX$^{\\\\text{\u2217}}$ across all rows and columns. More formally, he needs to maximize \n\n$$\\sum\\limits_{i = 1}^{n} \\operatorname{mex}(\\{a_{i,1}, a_{i,2}, \\ldots, a_{i,m}\\}) + \\sum\\limits_{j = 1}^{m} \\operatorname{mex}(\\{a_{1,j}, a_{2,j}, \\ldots, a_{n,j}\\}),$$\n\nwhere $a_{i,j}$ is the number in the $i$-th row and $j$-th column.\n\nSasha is not interested in how Mark arranges the numbers, so he only asks him to state one number\u00a0\u2014 the maximum sum of MEX across all rows and columns that can be achieved.\n\n$^{\\text{\u2217}}$The minimum excluded (MEX) of a collection of integers $c_1, c_2, \\ldots, c_k$ is defined as the smallest non-negative integer $x$ which does not occur in the collection $c$.\n\nFor example:\n\n- $\\operatorname{mex}([2,2,1])= 0$, since $0$ does not belong to the array.\n- $\\operatorname{mex}([3,1,0,1]) = 2$, since $0$ and $1$ belong to the array, but $2$ does not.\n- $\\operatorname{mex}([0,3,1,2]) = 4$, since $0$, $1$, $2$, and $3$ belong to the array, but $4$ does not.\n\n### Input\n\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^9$)\u00a0\u2014 the number of rows and columns in the table, respectively.\n\n### Output\n\nFor each test case, output the maximum possible sum of $\\operatorname{mex}$ across all rows and columns.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n1 1\n\n2 2\n\n3 5\n\n```\n\n#### Output #1\n\n```\n2\n3\n6\n```\n\n### Note\n\nIn the first test case, the only element is $0$, and the sum of the $\\operatorname{mex}$ of the numbers in the first row and the $\\operatorname{mex}$ of the numbers in the first column is $\\operatorname{mex}(\\{0\\}) + \\operatorname{mex}(\\{0\\}) = 1 + 1 = 2$.\n\nIn the second test case, the optimal table may look as follows:\n\n$3\n\n$$0$$\n\n2$$1$\n\nThen $\\sum\\limits_{i = 1}^{n} \\operatorname{mex}(\\{a_{i,1}, a_{i,2}, \\ldots, a_{i,m}\\}) + \\sum\\limits_{j = 1}^{m} \\operatorname{mex}(\\{a_{1,j}, a_{2,j}, \\ldots, a_{n,j}\\}) = \\operatorname{mex}(\\{3, 0\\}) + \\operatorname{mex}(\\{2, 1\\})$ $+ \\operatorname{mex}(\\{3, 2\\}) + \\operatorname{mex}(\\{0, 1\\}) = 1 + 0 + 0 + 2 = 3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n, m;\n        cin >> n >> m;\n        cout << max(n, m) + 1 << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2056f2",
      "PROBLEM_ID": "2056F2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, the constraints on $t$, $k$, and $m$ are higher. You can hack only if you solved all versions of this problem.\n\nA sequence $a$ of $n$ integers is called good if the following condition holds:\n\n- Let $\\text{cnt}_x$ be the number of occurrences of $x$ in sequence $a$. For all pairs $0 \\le i < j < m$, at least one of the following has to be true: $\\text{cnt}_i = 0$, $\\text{cnt}_j = 0$, or $\\text{cnt}_i \\le \\text{cnt}_j$. In other words, if both $i$ and $j$ are present in sequence $a$, then the number of occurrences of $i$ in $a$ is less than or equal to the number of occurrences of $j$ in $a$.\n\nYou are given integers $n$ and $m$. Calculate the value of the bitwise XOR of the median$^{\\text{\u2217}}$ of all good sequences $a$ of length $n$ with $0\\le a_i < m$.\n\nNote that the value of $n$ can be very large, so you are given its binary representation instead.\n\n$^{\\text{\u2217}}$The median of a sequence $a$ of length $n$ is defined as the $\\left\\lfloor\\frac{n + 1}{2}\\right\\rfloor$-th smallest value in the sequence.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $k$ and $m$ ($1 \\le k \\le 2 \\cdot 10^5$, $1 \\le m \\le 10^9$)\u00a0\u2014 the number of bits in $n$ and the upper bound on the elements in sequence $a$.\n\nThe second line of each test case contains a binary string of length $k$\u00a0\u2014 the binary representation of $n$ with no leading zeros.\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer representing the bitwise XOR of the median of all good sequences $a$ of length $n$ where $0\\le a_i < m$.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n2 3\n\n10\n\n2 3\n\n11\n\n5 1\n\n11101\n\n7 9\n\n1101011\n\n17 34\n\n11001010001010010\n\n1 1000000000\n\n1\n\n```\n\n#### Output #1\n\n```\n3\n2\n0\n8\n32\n0\n```\n\n### Note\n\nIn the first example, $n = 10_2 = 2$ and $m = 3$. All possible sequences with elements less than $m$ are: $[0, 0]$, $[0, 1]$, $[0, 2]$, $[1, 0]$, $[1, 1]$, $[1, 2]$, $[2, 0]$, $[2, 1]$, $[2, 2]$. All of them are good, so the answer is: $0 \\oplus 0 \\oplus 0 \\oplus 0 \\oplus 1 \\oplus 1 \\oplus 0 \\oplus 1 \\oplus 2 = 3$.\n\nIn the second example, $n = 11_2 = 3$ and $m = 3$. Some good sequences are $[2, 2, 2]$, $[1, 0, 1]$, and $[2, 0, 1]$. However, a sequence $[2, 0, 0]$ is not good, because $\\text{cnt}_0 = 2$, $\\text{cnt}_2 = 1$. Therefore, if we set $i = 0$ and $j = 2$, $i < j$ holds, but $\\text{cnt}_i \\le \\text{cnt}_j$ does not.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint S(int n, int k) {\n    return !(n - k & (k - 1 >> 1));\n}\n\nint get(int n, int m) {\n    int L = __lg(n) + 1;\n    int up = 1 << L;\n    vector<int> dp(up);\n    for(int i = 0; i < n; i++) dp[i] = S(n, i + 1);\n    for(int j = 0; j < L; j++) {\n        for(int i = 0; i < up; i++) {\n            if(i >> j & 1) dp[i] ^= dp[i ^ (1 << j)];\n        }\n    }\n    int ans = 0;\n    for(int lst = 0; lst < up && lst < m; lst++) {\n        if(!dp[lst]) continue;\n        int cnt = m - 1 - lst >> L;\n        if(cnt & 1 ^ 1) ans ^= lst;\n        if(cnt % 4 == 0) ans ^= cnt << L;\n        else if(cnt % 4 == 1) ans ^= 1ll << L;\n        else if(cnt % 4 == 2) ans ^= cnt + 1 << L;\n        else ans ^= 0;\n    }\n    return ans;\n}\n\nvoid solve() {\n    int k, m;\n    string s;\n    cin >> k >> m >> s;\n    int n = 0;\n    for(auto &i : s) n += i & 1;\n    int ans = get(n, m);\n    cout << ans << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int ttt = 1;\n    cin >> ttt;\n    while(ttt--) {\n        solve();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2056f1",
      "PROBLEM_ID": "2056F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, the constraints on $t$, $k$, and $m$ are lower. You can hack only if you solved all versions of this problem.\n\nA sequence $a$ of $n$ integers is called good if the following condition holds:\n\n- Let $\\text{cnt}_x$ be the number of occurrences of $x$ in sequence $a$. For all pairs $0 \\le i < j < m$, at least one of the following has to be true: $\\text{cnt}_i = 0$, $\\text{cnt}_j = 0$, or $\\text{cnt}_i \\le \\text{cnt}_j$. In other words, if both $i$ and $j$ are present in sequence $a$, then the number of occurrences of $i$ in $a$ is less than or equal to the number of occurrences of $j$ in $a$.\n\nYou are given integers $n$ and $m$. Calculate the value of the bitwise XOR of the median$^{\\text{\u2217}}$ of all good sequences $a$ of length $n$ with $0\\le a_i < m$.\n\nNote that the value of $n$ can be very large, so you are given its binary representation instead.\n\n$^{\\text{\u2217}}$The median of a sequence $a$ of length $n$ is defined as the $\\left\\lfloor\\frac{n + 1}{2}\\right\\rfloor$-th smallest value in the sequence.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 50$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $k$ and $m$ ($1 \\le k \\le 200$, $1 \\le m \\le 500$)\u00a0\u2014 the number of bits in $n$ and the upper bound on the elements in sequence $a$.\n\nThe second line of each test case contains a binary string of length $k$\u00a0\u2014 the binary representation of $n$ with no leading zeros.\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $200$.\n\n### Output\n\nFor each test case, output a single integer representing the bitwise XOR of the median of all good sequences $a$ of length $n$ where $0\\le a_i < m$.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n2 3\n\n10\n\n2 3\n\n11\n\n5 1\n\n11101\n\n7 9\n\n1101011\n\n17 34\n\n11001010001010010\n\n1 500\n\n1\n\n```\n\n#### Output #1\n\n```\n3\n2\n0\n8\n32\n0\n```\n\n### Note\n\nIn the first example, $n = 10_2 = 2$ and $m = 3$. All possible sequences with elements less than $m$ are: $[0, 0]$, $[0, 1]$, $[0, 2]$, $[1, 0]$, $[1, 1]$, $[1, 2]$, $[2, 0]$, $[2, 1]$, $[2, 2]$. All of them are good, so the answer is: $0 \\oplus 0 \\oplus 0 \\oplus 0 \\oplus 1 \\oplus 1 \\oplus 0 \\oplus 1 \\oplus 2 = 3$.\n\nIn the second example, $n = 11_2 = 3$ and $m = 3$. Some good sequences are $[2, 2, 2]$, $[1, 0, 1]$, and $[2, 0, 1]$. However, a sequence $[2, 0, 0]$ is not good, because $\\text{cnt}_0 = 2$, $\\text{cnt}_2 = 1$. Therefore, if we set $i = 0$ and $j = 2$, $i < j$ holds, but $\\text{cnt}_i \\le \\text{cnt}_j$ does not.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    vector<int> ms(t);\n    vector<int> pops(t);\n    vector<string> nbin(t);\n    int max_m = 0;\n    int max_pop = 0;\n    for (int i = 0; i < t; i++) {\n        int k, m;\n        cin >> k >> m;\n        ms[i] = m;\n        max_m = max(max_m, m);\n        string s;\n        cin >> s;\n        nbin[i] = s;\n        int pc = 0;\n        for (char c : s) if (c == '1') pc++;\n        pops[i] = pc;\n        max_pop = max(max_pop, pc);\n    }\n    // We need DP up to KMAX = max_pop - 1 (but at least up to 0) and bmax = max_m\n    int KMAX = max(1, max_pop) + 1; // safe up to popcount+1\n    if (KMAX < 1) KMAX = 1;\n    KMAX = max(KMAX, 200);\n    int BM = max_m;\n    if (BM < 1) BM = 1;\n    BM = max(BM, 500);\n\n    // But we only use up to popcount <=200, and b <= max_m <=500\n    const int kMax = 200;\n    const int bMax = 500;\n\n    static int C[kMax+1][kMax+1];\n    static int A[kMax+1][bMax+1];\n    static int S[kMax+1][bMax+1];\n\n    // Compute binomial coefficients mod2\n    for (int n = 0; n <= kMax; n++) {\n        for (int k = 0; k <= n; k++) {\n            if (k == 0 || k == n) C[n][k] = 1;\n            else C[n][k] = (C[n-1][k-1] ^ C[n-1][k]);\n        }\n        for (int k = n+1; k <= kMax; k++) {\n            C[n][k] = 0;\n        }\n    }\n    // DP for A and S\n    // A[0][b] = 1 for all b\n    for (int b = 0; b <= bMax; b++) {\n        A[0][b] = 1;\n    }\n    // S[0][b] = sum_{v=0..b-1} A[0][v]\n    S[0][0] = 0;\n    for (int b = 1; b <= bMax; b++) {\n        S[0][b] = S[0][b-1] ^ A[0][b-1];\n    }\n    // For k from 1..kMax\n    for (int k = 1; k <= kMax; k++) {\n        for (int b = 0; b <= bMax; b++) {\n            int v = 0;\n            // A[k][b] = sum_{k'=0..k-1} C[k-1][k'] * S[k'][b] mod2\n            int nC = k - 1;\n            // loop k'\n            // unroll or simple\n            for (int kp = 0; kp < k; kp++) {\n                if (C[nC][kp]) {\n                    v ^= S[kp][b];\n                }\n            }\n            A[k][b] = v;\n        }\n        // compute S[k]\n        S[k][0] = 0;\n        for (int b = 1; b <= bMax; b++) {\n            S[k][b] = S[k][b-1] ^ A[k][b-1];\n        }\n    }\n\n    // Process each test\n    for (int ti = 0; ti < t; ti++) {\n        int m = ms[ti];\n        int P = pops[ti];\n        // K = P-1\n        int K = P - 1;\n        int ans = 0;\n        // For each v in [0..m-1], compute parity g[K][v]\n        // g[K][v] = sum_{k'=0..K} C[K][k'] * A[k'][v] mod2\n        if (K < 0) K = 0; // but P>=1 so K>=0\n        for (int v = 0; v < m; v++) {\n            int g = 0;\n            for (int kp = 0; kp <= K; kp++) {\n                if (C[K][kp] && A[kp][v]) {\n                    g ^= 1;\n                }\n            }\n            if (g) ans ^= v;\n        }\n        cout << ans;\n        if (ti+1 < t) cout << '\\n';\n    }\n    cout << '\\n';\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2056e",
      "PROBLEM_ID": "2056E",
      "PROBLEM_STATEMENT": "A set $A$ consisting of pairwise distinct segments $[l, r]$ with integer endpoints is called good if $1\\le l\\le r\\le n$, and for any pair of distinct segments $[l_i, r_i], [l_j, r_j]$ in $A$, exactly one of the following conditions holds:\n\n- $r_i < l_j$ or $r_j < l_i$ (the segments do not intersect)\n- $l_i \\le l_j \\le r_j \\le r_i$ or $l_j \\le l_i \\le r_i \\le r_j$ (one segment is fully contained within the other)\n\nYou are given a good set $S$ consisting of $m$ pairwise distinct segments $[l_i, r_i]$ with integer endpoints. You want to add as many additional segments to the set $S$ as possible while ensuring that set $S$ remains good.\n\nSince this task is too easy, you need to determine the number of different ways to add the maximum number of additional segments to $S$, ensuring that the set remains good. Two ways are considered different if there exists a segment that is being added in one of the ways, but not in the other.\n\nFormally, you need to find the number of good sets $T$ of distinct segments, such that $S$ is a subset of $T$ and $T$ has the maximum possible size. Since the result might be very large, compute the answer modulo $998\\,244\\,353$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le m \\le 2 \\cdot 10^5$)\u00a0\u2014 the maximum right endpoint of the segments, and the size of $S$.\n\nThe $i$-th of the next $m$ lines contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$)\u00a0\u2014 the boundaries of the segments in set $S$.\n\nIt is guaranteed that the given set $S$ is good, and the segments in set $S$ are pairwise distinct.\n\nIt is guaranteed that both the sum of $n$ and the sum of $m$ over all test cases do not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer representing the number of different ways, modulo $998\\,244\\,353$, that you can add the maximum number of additional segments to set $S$ while ensuring that set $S$ remains good.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1 0\n\n2 3\n\n1 1\n\n2 2\n\n1 2\n\n5 2\n\n1 3\n\n2 3\n\n4 1\n\n1 1\n\n6 2\n\n1 3\n\n4 6\n\n2300 0\n\n```\n\n#### Output #1\n\n```\n1\n1\n2\n5\n4\n187997613\n```\n\n### Note\n\nIn the first example, the only possible segment is $[1, 1]$, so $T = \\{[1, 1]\\}$ has the maximum size, and it is the only solution.\n\nIn the second example, it is not possible to add any additional segments to set $S$. Hence, the only way to add segments to $S$ is adding nothing.\n\nIn the third example, it is possible to add $7$ additional segments to $S$ while ensuring that the set remains good. It can be proven that adding more than $7$ additional segments to $S$ is not possible. There are exactly $2$ different ways to add these $7$ segments to $S$, and their respective sets $T$ are shown below:\n\n- $\\{[1, 1], [1, 3], [1, 4], [1, 5], [2, 2], [2, 3], [3, 3], [4, 4], [5, 5]\\}$\n- $\\{[1, 1], [1, 3], [1, 5], [2, 2], [2, 3], [3, 3], [4, 4], [4, 5], [5, 5]\\}$.\n\nIn the fourth example, there are exactly $5$ different ways to add a maximum of $6$ additional segments to $S$, and their respective sets $T$ are shown below:\n\n- $\\{[1, 1], [1, 2], [1, 3], [1, 4], [2, 2], [3, 3], [4, 4]\\}$\n- $\\{[1, 1], [1, 2], [1, 4], [2, 2], [3, 3], [3, 4], [4, 4]\\}$\n- $\\{[1, 1], [1, 3], [1, 4], [2, 2], [2, 3], [3, 3], [4, 4]\\}$\n- $\\{[1, 1], [1, 4], [2, 2], [2, 3], [2, 4], [3, 3], [4, 4]\\}$\n- $\\{[1, 1], [1, 4], [2, 2], [2, 4], [3, 3], [3, 4], [4, 4]\\}$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 998244353;\n\n// Maximum n across all test cases.\nconst int MAXN = 200000;\n// For factorials up to 2*MAXN.\nconst int MAXF = 2 * MAXN + 5;\n\n// Precomputed factorials, inverse factorials, and inverses.\nstatic ll fact[MAXF], invfact[MAXF], invnum[MAXF];\n// Precomputed Catalan numbers: catalan[i] = C(2*i, i)/(i+1) mod.\nstatic ll catalan[MAXN + 5];\n\n// Arrays for each test case up to m segments + dummy.\nstatic int L_arr[MAXN + 5], R_arr[MAXN + 5];\n// Adjacency lists for the laminar tree.\nstatic vector<int> children[MAXN + 5];\n// DP value: number of ways for subtree rooted at u.\nstatic ll f_dp[MAXN + 5];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    // 1) Precompute factorials.\n    fact[0] = 1;\n    for (int i = 1; i < MAXF; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    // 2) Precompute modular inverses 1..MAXF-1.\n    invnum[1] = 1;\n    for (int i = 2; i < MAXF; i++) {\n        // Fermat's little theorem style inverse in O(1) per i.\n        invnum[i] = (MOD - (MOD / i) * invnum[MOD % i] % MOD) % MOD;\n    }\n    // 3) Precompute inverse factorials.\n    invfact[0] = 1;\n    for (int i = 1; i < MAXF; i++) {\n        invfact[i] = invfact[i - 1] * invnum[i] % MOD;\n    }\n    // 4) Precompute Catalan numbers up to MAXN.\n    //    Catalan[i] = C(2*i, i)/(i+1).\n    catalan[0] = 1;\n    for (int i = 1; i <= MAXN; i++) {\n        // C(2i, i) = fact[2*i] * invfact[i] * invfact[i]\n        ll c = fact[2 * i];\n        c = (c * invfact[i]) % MOD;\n        c = (c * invfact[i]) % MOD;\n        // divide by (i+1)\n        c = (c * invnum[i + 1]) % MOD;\n        catalan[i] = c;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        // Clear children lists for nodes 0..m\n        for (int i = 0; i <= m; i++) {\n            children[i].clear();\n        }\n        // Dummy root at index 0 covering [1, n].\n        L_arr[0] = 1;\n        R_arr[0] = n;\n\n        // Read the m initial segments, indices 1..m.\n        vector<int> ids;\n        ids.reserve(m);\n        for (int i = 1; i <= m; i++) {\n            cin >> L_arr[i] >> R_arr[i];\n            ids.push_back(i);\n        }\n        // Sort segments by left endpoint ascending, right descending.\n        sort(ids.begin(), ids.end(), [&](int a, int b) {\n            if (L_arr[a] != L_arr[b])\n                return L_arr[a] < L_arr[b];\n            return R_arr[a] > R_arr[b];\n        });\n\n        // Build the laminar tree using a stack (with dummy = 0).\n        vector<int> st;\n        st.reserve(m + 2);\n        st.push_back(0);\n        for (int id : ids) {\n            // Pop until top contains this segment.\n            while (true) {\n                int top = st.back();\n                if (L_arr[top] <= L_arr[id] && R_arr[id] <= R_arr[top]) {\n                    // id is inside top\n                    children[top].push_back(id);\n                    st.push_back(id);\n                    break;\n                }\n                st.pop_back();\n            }\n        }\n\n        // We need a post-order of the tree rooted at 0.\n        // We'll do a manual DFS to collect nodes in post-order.\n        vector<int> order;\n        order.reserve(m + 1);\n        // pair = (node, stage 0=enter,1=exit)\n        vector<pair<int,int>> dfs_stack;\n        dfs_stack.reserve(m + 1);\n        dfs_stack.emplace_back(0, 0);\n        while (!dfs_stack.empty()) {\n            auto [u, stage] = dfs_stack.back();\n            dfs_stack.pop_back();\n            if (stage == 0) {\n                // Entering u\n                dfs_stack.emplace_back(u, 1);\n                // Push children in reverse so that we process them in original order\n                for (int i = (int)children[u].size() - 1; i >= 0; i--) {\n                    dfs_stack.emplace_back(children[u][i], 0);\n                }\n            } else {\n                // Exiting u: record in post-order\n                order.push_back(u);\n            }\n        }\n\n        // DP: process nodes in post-order.\n        for (int u : order) {\n            // 1) Multiply ways from child subtrees\n            ll ways = 1;\n            for (int v : children[u]) {\n                ways = (ways * f_dp[v]) % MOD;\n            }\n            // 2) Count leaves at u-level: M = (#children) + sum of gap positions\n            int C = (int)children[u].size();\n            int M_leaves = C;\n            int pos = L_arr[u];\n            for (int v : children[u]) {\n                // gap before this child\n                int gap = L_arr[v] - pos;\n                if (gap > 0) {\n                    M_leaves += gap;\n                }\n                // skip the child's covered region\n                pos = R_arr[v] + 1;\n            }\n            // gap after last child\n            int last_gap = R_arr[u] - pos + 1;\n            if (last_gap > 0) {\n                M_leaves += last_gap;\n            }\n            // 3) Multiply by Catalan[M_leaves - 1]\n            //    (full binary trees on M_leaves leaves)\n            ways = (ways * catalan[M_leaves - 1]) % MOD;\n            f_dp[u] = ways;\n        }\n\n        // The answer is the DP at the dummy root = f_dp[0].\n        cout << f_dp[0] << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2056d",
      "PROBLEM_ID": "2056D",
      "PROBLEM_STATEMENT": "An array $b$ of $m$ integers is called good if, when it is sorted, $b_{\\left\\lfloor \\frac{m + 1}{2} \\right\\rfloor} = b_{\\left\\lceil \\frac{m + 1}{2} \\right\\rceil}$. In other words, $b$ is good if both of its medians are equal. In particular, $\\left\\lfloor \\frac{m + 1}{2} \\right\\rfloor = \\left\\lceil \\frac{m + 1}{2} \\right\\rceil$ when $m$ is odd, so $b$ is guaranteed to be good if it has an odd length.\n\nYou are given an array $a$ of $n$ integers. Calculate the number of good subarrays$^{\\text{\u2217}}$ in $a$.\n\n$^{\\text{\u2217}}$An array $x$ is a subarray of an array $y$ if $x$ can be obtained from $y$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$)\u00a0\u2014 the length of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le \\color{red}{\\textbf{10}}$)\u00a0\u2014 the given array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single integer representing the number of good subarrays in $a$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4\n\n1 1 1 1\n\n5\n\n1 10 2 3 3\n\n10\n\n6 3 2 3 5 3 4 2 3 5\n\n```\n\n#### Output #1\n\n```\n10\n11\n42\n```\n\n### Note\n\nIn the first case, every subarray is good since all its elements are equal to $1$.\n\nIn the second case, an example of a good subarray is $b = [10, 2, 3, 3]$. When it is sorted, $b = [2, 3, 3, 10]$, so $b_{\\left\\lfloor \\frac{4 + 1}{2} \\right\\rfloor} = b_{\\left\\lceil \\frac{4 + 1}{2} \\right\\rceil} = b_2 = b_3 = 3$. Another example would be $b = [1, 10, 2]$. On the other hand, $b = [1, 10]$ is not good as its two medians are $1$ and $10$, which are not equal.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct BIT2D {\n    int n;\n    vector<vector<int>> ys, bit;\n    BIT2D(int _n = 0): n(_n), ys(_n+1), bit(_n+1) {}\n    // collect point (x,y) for building\n    void fake_add(int x, int y) {\n        for(int i = x; i <= n; i += i & -i)\n            ys[i].push_back(y);\n    }\n    // finalize building: sort & unique ys, alloc bit arrays\n    void init() {\n        for(int i = 1; i <= n; i++) {\n            auto &v = ys[i];\n            if(!v.empty()) {\n                sort(v.begin(), v.end());\n                v.erase(unique(v.begin(), v.end()), v.end());\n                bit[i].assign(v.size() + 1, 0);\n            }\n        }\n    }\n    // point update: add delta at (x,y)\n    void update(int x, int y, int delta) {\n        for(int i = x; i <= n; i += i & -i) {\n            auto &v = ys[i];\n            // find position of y in v\n            int pos = int(lower_bound(v.begin(), v.end(), y) - v.begin()) + 1;\n            auto &b = bit[i];\n            for(int j = pos; j < (int)b.size(); j += j & -j) {\n                b[j] += delta;\n            }\n        }\n    }\n    // query sum of points (u,v) with u<=x, v<=y\n    int query(int x, int y) {\n        int s = 0;\n        for(int i = x; i > 0; i -= i & -i) {\n            auto &v = ys[i];\n            // count how many v[] <= y\n            int pos = int(upper_bound(v.begin(), v.end(), y) - v.begin());\n            auto &b = bit[i];\n            for(int j = pos; j > 0; j -= j & -j) {\n                s += b[j];\n            }\n        }\n        return s;\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n+1);\n        for(int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        // count odd-length good subarrays\n        // positions 1..n, odd parity positions count = (n+1)/2, even parity count = n/2\n        ll cntOdd = (n + 1) / 2;\n        ll cntEven = n / 2;\n        ll oddCount = cntOdd * (cntOdd + 1) / 2 + cntEven * (cntEven + 1) / 2;\n        ll totalGood = oddCount;\n\n        // Precompute prefix parity groups (prefix indices 0..n)\n        vector<int> idxs[2];\n        idxs[0].reserve((n+2)/2);\n        idxs[1].reserve((n+1)/2);\n        for(int i = 0; i <= n; i++) {\n            idxs[i & 1].push_back(i);\n        }\n\n        // pre-count freq of each value\n        int freq[11] = {0};\n        for(int i = 1; i <= n; i++) freq[a[i]]++;\n\n        // prefix arrays (size n+1)\n        vector<int> P1(n+1), P2(n+1);\n        // mapping arrays\n        vector<int> P1_map(n+1), P2_map(n+1);\n\n        // process each v = median candidate for even-length\n        for(int v = 1; v <= 10; v++) {\n            if(freq[v] < 2) continue;\n            // build prefix sums P1 and P2\n            // P1: (#<=v) - (#>v)\n            // P2: (#>=v) - (#<v)\n            P1[0] = 0;\n            P2[0] = 0;\n            for(int i = 1; i <= n; i++) {\n                P1[i] = P1[i-1] + (a[i] <= v ? 1 : -1);\n                P2[i] = P2[i-1] + (a[i] >= v ? 1 : -1);\n            }\n            // for each parity, do 2D counting\n            for(int p = 0; p < 2; p++) {\n                auto &group = idxs[p];\n                int m = (int)group.size();\n                if(m < 1) continue;\n                // collect values for compression\n                static vector<int> comp1, comp2;\n                comp1.clear();\n                comp2.clear();\n                comp1.reserve(m);\n                comp2.reserve(m);\n                for(int idx: group) {\n                    comp1.push_back(P1[idx]);\n                    comp2.push_back(P2[idx]);\n                }\n                sort(comp1.begin(), comp1.end());\n                comp1.erase(unique(comp1.begin(), comp1.end()), comp1.end());\n                sort(comp2.begin(), comp2.end());\n                comp2.erase(unique(comp2.begin(), comp2.end()), comp2.end());\n                int M = (int)comp1.size();\n                // build BIT2D on P1 dimension [1..M]\n                BIT2D ds(M);\n                // map each prefix in group to compressed coords, and fake_add\n                for(int idx: group) {\n                    int x = int(lower_bound(comp1.begin(), comp1.end(), P1[idx]) - comp1.begin()) + 1;\n                    int y = int(lower_bound(comp2.begin(), comp2.end(), P2[idx]) - comp2.begin()) + 1;\n                    P1_map[idx] = x;\n                    P2_map[idx] = y;\n                    ds.fake_add(x, y);\n                }\n                // finalize\n                ds.init();\n                // sweep in increasing prefix index order, ds initially empty\n                ll ans_v = 0;\n                for(int idx: group) {\n                    // query for r = idx: count l<r with P1[l] <= P1[idx]-2 and P2[l] <= P2[idx]-2\n                    int v1 = P1[idx] - 2;\n                    int v2 = P2[idx] - 2;\n                    if(v1 >= comp1.front() && v2 >= comp2.front()) {\n                        int c1 = int(upper_bound(comp1.begin(), comp1.end(), v1) - comp1.begin());\n                        int c2 = int(upper_bound(comp2.begin(), comp2.end(), v2) - comp2.begin());\n                        if(c1 > 0 && c2 > 0) {\n                            ans_v += ds.query(c1, c2);\n                        }\n                    }\n                    // update ds with this prefix as l for future\n                    ds.update(P1_map[idx], P2_map[idx], 1);\n                }\n                totalGood += ans_v;\n            }\n        }\n\n        // output result\n        cout << totalGood << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2056c",
      "PROBLEM_ID": "2056C",
      "PROBLEM_STATEMENT": "For an integer sequence $a = [a_1, a_2, \\ldots, a_n]$, we define $f(a)$ as the length of the longest subsequence$^{\\text{\u2217}}$ of $a$ that is a palindrome$^{\\text{\u2020}}$.\n\nLet $g(a)$ represent the number of subsequences of length $f(a)$ that are palindromes. In other words, $g(a)$ counts the number of palindromic subsequences in $a$ that have the maximum length.\n\nGiven an integer $n$, your task is to find any sequence $a$ of $n$ integers that satisfies the following conditions:\n\n- $1 \\le a_i \\le n$ for all $1 \\le i \\le n$.\n- $g(a) > n$\n\nIt can be proven that such a sequence always exists under the given constraints.\n\n$^{\\text{\u2217}}$A sequence $x$ is a subsequence of a sequence $y$ if $x$ can be obtained from $y$ by the deletion of several (possibly, zero or all) element from arbitrary positions.\n\n$^{\\text{\u2020}}$A palindrome is a sequence that reads the same from left to right as from right to left. For example, $[1, 2, 1, 3, 1, 2, 1]$, $[5, 5, 5, 5]$, and $[4, 3, 3, 4]$ are palindromes, while $[1, 2]$ and $[2, 3, 3, 3, 3]$ are not.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($\\color{red}{6} \\le n \\le 100$)\u00a0\u2014 the length of the sequence.\n\nNote that there are no constraints on the sum of $n$ over all test cases.\n\n### Output\n\nFor each test case, output $n$ integers $a_1, a_2, \\ldots, a_n$, representing an array that satisfies the conditions.\n\nIf there are multiple solutions, you may output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n6\n\n9\n\n15\n\n```\n\n#### Output #1\n\n```\n1 1 2 3 1 2\n7 3 3 7 5 3 7 7 3\n15 8 8 8 15 5 8 1 15 5 8 15 15 15 8\n```\n\n### Note\n\nIn the first example, one possible solution is $a = [1, 1, 2, 3, 1, 2]$. In this case, $f(a) = 3$ as the longest palindromic subsequence has length $3$. There are $7$ ways to choose a subsequence of length $3$ that is a palindrome, as shown below:\n\n1. $[a_1, a_2, a_5] = [1, 1, 1]$\n2. $[a_1, a_3, a_5] = [1, 2, 1]$\n3. $[a_1, a_4, a_5] = [1, 3, 1]$\n4. $[a_2, a_3, a_5] = [1, 2, 1]$\n5. $[a_2, a_4, a_5] = [1, 3, 1]$\n6. $[a_3, a_4, a_6] = [2, 3, 2]$\n7. $[a_3, a_5, a_6] = [2, 1, 2]$\n\nTherefore, $g(a) = 7$, which is greater than $n = 6$. Hence, $a = [1, 1, 2, 3, 1, 2]$ is a valid solution.\n\nIn the second example, one possible solution is $a = [7, 3, 3, 7, 5, 3, 7, 7, 3]$. In this case, $f(a) = 5$. There are $24$ ways to choose a subsequence of length $5$ that is a palindrome. Some examples are $[a_2, a_4, a_5, a_8, a_9] = [3, 7, 5, 7, 3]$ and $[a_1, a_4, a_6, a_7, a_8] = [7, 7, 3, 7, 7]$. Therefore, $g(a) = 24$, which is greater than $n = 9$. Hence, $a = [7, 3, 3, 7, 5, 3, 7, 7, 3]$ is a valid solution.\n\nIn the third example, $f(a) = 7$ and $g(a) = 190$, which is greater than $n = 15$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        a[0] = 1;\n        a[1] = 1;\n        a[n-1] = 1;\n        for (int i = 2; i < n-1; ++i) {\n            a[i] = i; // Values from 2 to n-2, inclusive\n        }\n        for (int num : a) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2056b",
      "PROBLEM_ID": "2056B",
      "PROBLEM_STATEMENT": "You\u00a0are\u00a0given\u00a0an\u00a0undirected\u00a0graph\u00a0with\u00a0$n$\u00a0vertices,\u00a0labeled\u00a0from\u00a0$1$\u00a0to\u00a0$n$. This graph encodes a hidden permutation$^{\\text{\u2217}}$ $p$ of size $n$.\u00a0The\u00a0graph\u00a0is\u00a0constructed as follows:\n\n- For every pair of integers $1 \\le i < j \\le n$, an undirected edge is added between vertex $p_i$ and vertex $p_j$ if and only if $p_i < p_j$. Note that the edge is not added between vertices $i$ and $j$, but between the vertices of their respective elements. Refer to the notes section for better understanding.\n\nYour task is to reconstruct and output the permutation $p$. It can be proven that permutation $p$ can be uniquely determined.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 1000$).\n\nThe $i$-th of the next $n$ lines contains a string of $n$ characters $g_{i, 1}g_{i, 2}\\ldots g_{i, n}$ ($g_{i, j} = \\mathtt{0}$ or $g_{i, j} = \\mathtt{1}$)\u00a0\u2014 the adjacency matrix. $g_{i, j} = \\mathtt{1}$ if and only if there is an edge between vertex $i$ and vertex $j$.\n\nIt is guaranteed that there exists a permutation $p$ which generates the given graph. It is also guaranteed that the graph is undirected and has no self-loops, meaning $g_{i, j} = g_{j, i}$ and $g_{i, i} = \\mathtt{0}$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $1000$.\n\n### Output\n\nFor each test case, output $n$ integers $p_1, p_2, \\ldots, p_n$ representing the reconstructed permutation.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n1\n\n0\n\n5\n\n00101\n\n00101\n\n11001\n\n00001\n\n11110\n\n6\n\n000000\n\n000000\n\n000000\n\n000000\n\n000000\n\n000000\n\n```\n\n#### Output #1\n\n```\n1\n4 2 1 3 5\n6 5 4 3 2 1\n```\n\n### Note\n\nIn the first case $p = [1]$. Since there are no pairs $1 \\le i < j \\le n$, there are no edges in the graph.\n\nThe graph in the second case is shown below. For example, when we choose $i = 3$ and $j = 4$, we add an edge between vertices $p_i = 1$ and $p_j = 3$, because $p_i < p_j$. However, when we choose $i = 2$ and $j = 3$, $p_i = 2$ and $p_j = 1$, so $p_i < p_j$ doesn't hold. Therefore, we don't add an edge between $2$ and $1$.\n\n![](https://espresso.codeforces.com/73c807a602602d5ad6dd697dfea7a886d23aec16.png)\n\nIn the third case, there are no edges in the graph, so there are no pairs of integers $1 \\le i < j \\le n$ such that $p_i < p_j$. Therefore, $p = [6, 5, 4, 3, 2, 1]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<string> g(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> g[i];\n        }\n\n        vector<vector<int>> adj(n + 1);\n        vector<int> in_degree(n + 1, 0);\n\n        for (int x = 1; x <= n; ++x) {\n            for (int y = x + 1; y <= n; ++y) {\n                if (g[x-1][y-1] == '1') {\n                    adj[x].push_back(y);\n                    in_degree[y]++;\n                } else {\n                    adj[y].push_back(x);\n                    in_degree[x]++;\n                }\n            }\n        }\n\n        queue<int> q;\n        for (int i = 1; i <= n; ++i) {\n            if (in_degree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        vector<int> order;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            order.push_back(u);\n            for (int v : adj[u]) {\n                if (--in_degree[v] == 0) {\n                    q.push(v);\n                }\n            }\n        }\n\n        for (int x : order) {\n            cout << x << ' ';\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2056a",
      "PROBLEM_ID": "2056A",
      "PROBLEM_STATEMENT": "There is an $m$ by $m$ square stamp on an infinite piece of paper. Initially, the bottom-left corner of the square stamp is aligned with the bottom-left corner of the paper. You are given two integer sequences $x$ and $y$, each of length $n$. For each step $i$ from $1$ to $n$, the following happens:\n\n- Move the stamp $x_i$ units to the right and $y_i$ units upwards.\n- Press the stamp onto the paper, leaving an $m$ by $m$ colored square at its current position.\n\nNote that the elements of sequences $x$ and $y$ have a special constraint: $1\\le x_i, y_i\\le m - 1$.\n\nNote that you do not press the stamp at the bottom-left corner of the paper. Refer to the notes section for better understanding.\n\nIt can be proven that after all the operations, the colored shape on the paper formed by the stamp is a single connected region. Find the perimeter of this colored shape.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 100$, $2 \\le m \\le 100$)\u00a0\u2014 the number of operations performed and the side length of the square stamp.\n\nThe $i$-th of the next $n$ lines contains two integers $x_i$ and $y_i$ ($1 \\le x_i, y_i \\le m - 1$)\u00a0\u2014 the distance that the stamp will be moved right and up during the $i$-th operation, respectively.\n\nNote that there are no constraints on the sum of $n$ over all test cases.\n\n### Output\n\nFor each test case, output a single integer representing the perimeter of the colored shape on the paper.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4 3\n\n1 1\n\n2 2\n\n2 1\n\n1 2\n\n1 2\n\n1 1\n\n6 7\n\n3 6\n\n1 1\n\n3 1\n\n6 6\n\n5 4\n\n6 1\n\n```\n\n#### Output #1\n\n```\n32\n8\n96\n```\n\n### Note\n\nIn the first example, the stamp has a side length of $3$ and is pressed $4$ times at coordinates $(1, 1)$, $(3, 3)$, $(5, 4)$, and $(6, 6)$. The piece of paper looks like that afterwards:\n\n![](https://espresso.codeforces.com/9fc3f24b6fa5d2b61c12e4b03034cf4461356a4e.png)\n\nHere, the square formed by the first press is colored blue, the second red, the third green, and the fourth purple. The combined shape, whose perimeter we need to calculate, looks like that:\n\n![](https://espresso.codeforces.com/d3769976097a17e12f245e090e7d4b21ac6d0111.png)\n\nFrom the diagram, it can be seen that this shape has a perimeter of $32$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        vector<int> x(n), y(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> x[i] >> y[i];\n        }\n        int sum_x = accumulate(x.begin(), x.end(), 0);\n        int sum_y = accumulate(y.begin(), y.end(), 0);\n        int first_x = x[0], first_y = y[0];\n        int width = (sum_x - first_x) + m;\n        int height = (sum_y - first_y) + m;\n        int perimeter = 2 * (width + height);\n        cout << perimeter << endl;\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2055f",
      "PROBLEM_ID": "2055F",
      "PROBLEM_STATEMENT": "With the artifact in hand, the fabric of reality gives way to its true master \u2014 Florida Man.\n\nA polyomino is a connected$^{\\text{\u2217}}$ figure constructed by joining one or more equal $1 \\times 1$ unit squares edge to edge. A polyomino is convex if, for any two squares in the polyomino that share the same row or the same column, all squares between them are also part of the polyomino. Below are four polyominoes, only the first and second of which are convex.\n\n![](https://espresso.codeforces.com/8724689d0b36a88fea4585d8abc9730b8c0d960d.png)\n\nYou are given a convex polyomino with $n$ rows and an even area. For each row $i$ from $1$ to $n$, the unit squares from column $l_i$ to column $r_i$ are part of the polyomino. In other words, there are $r_i - l_i + 1$ unit squares that are part of the polyomino in the $i$-th row: $(i, l_i), (i, l_i + 1), \\ldots, (i, r_i-1), (i, r_i)$.\n\nTwo polyominoes are congruent if and only if you can make them fit exactly on top of each other by translating the polyominoes. Note that you are not allowed to rotate or reflect the polyominoes. Determine whether it is possible to partition the given convex polyomino into two disjoint connected polyominoes that are congruent to each other. The following examples illustrate a valid partition of each of the two convex polyominoes shown above:\n\n![](https://espresso.codeforces.com/97de3cd15bf04caabb5cdf47250f4e27c68bed36.png)\n\nThe partitioned polyominoes do not need to be convex, and each unit square should belong to exactly one of the two partitioned polyominoes.\n\n$^{\\text{\u2217}}$A polyomino is connected if and only if for every two unit squares $u \\neq v$ that are part of the polyomino, there exists a sequence of distinct squares $s_1, s_2, \\ldots, s_k$, such that $s_1 = u$, $s_k = v$, $s_i$ are all part of the polyomino, and $s_i, s_{i+1}$ share an edge for each $1 \\le i \\le k - 1$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 2\\cdot 10^5$)\u00a0\u2014 the number of rows of the polyomino.\n\nThe $i$-th of the next $n$ lines contains two integers $l_i$ and $r_i$ ($1\\le l_i\\le r_i\\le 10^9$)\u00a0\u2014 the range of columns that are part of the polyomino in the $i$-th row.\n\nIt is guaranteed that the area of the polyomino is even. In other words, $\\sum_{i=1}^n r_i - l_i + 1\\equiv 0\\pmod{2}$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single line containing either \"YES\" or \"NO\", representing whether or not the polyomino can be partitioned as described in the problem.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n2\n\n1 2\n\n2 3\n\n4\n\n4 4\n\n2 4\n\n1 4\n\n1 2\n\n3\n\n1 2\n\n1 2\n\n2 3\n\n2\n\n1 3\n\n3 3\n\n2\n\n1 3\n\n2 2\n\n3\n\n1 2\n\n1 3\n\n1 3\n\n4\n\n8 9\n\n6 8\n\n6 8\n\n5 6\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\nNO\nNO\nNO\nYES\n```\n\n### Note\n\nThe first and second test cases are the polyominoes depicted in the problem statement and can be partitioned as shown.\n\nThe polyomino in the third test case, shown below, can be shown to be impossible to partition. None of the following partitions are valid:\n\n![](https://espresso.codeforces.com/0a986911d905df1d700e5c6e0a7823b6baa1714b.png)\n\nThe partition on the left does not use polyominoes that are translations of each other, and the partition on the right does not use connected polyominoes.\n\nThe polyomino in the fourth test case, shown below, can be shown to be impossible to partition.\n\n![](https://espresso.codeforces.com/5f032563bda214bb7c65076b4882bda7d0a17e46.png)\n\nNote that while you can partition it into two $1 \\times 2$ rectangles, these rectangles are not translations of each other.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\n#define f first\n#define s second\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nvoid print_set(vector<int> x) {\n    for (auto i : x) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\nvoid print_set(vector<ll> x) {\n    for (auto i : x) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\nbool connected(vector<ll> &U, vector<ll> &D) {\n    if (U[0] > D[0]) return 0;\n    for (int i = 1; i < U.size(); i++) {\n        if (U[i] > D[i]) return 0;\n        if (D[i] < U[i-1]) return 0;\n        if (U[i] > D[i-1]) return 0;\n    }\n    return 1;\n}\n\nbool compare(vector<ll> &U1, vector<ll> &D1, vector<ll> &U2, vector<ll> &D2) {\n    if (U1.size() != U2.size()) return 0;\n    if (!connected(U1, D1)) return 0;\n    for (int i = 0; i < U1.size(); i++) {\n        if (U1[i] - D1[i] != U2[i] - D2[i]) return 0;\n        if (U1[i] - U1[0] != U2[i] - U2[0]) return 0;\n    }\n    return 1;\n}\n\nbool horizontal_check(vector<ll>& U, vector<ll>& D) {\n    if (U.size() % 2) return 0;\n    int N = U.size() / 2;\n    auto U1 = vector<ll>(U.begin(), U.begin() + N);\n    auto D1 = vector<ll>(D.begin(), D.begin() + N);\n    auto U2 = vector<ll>(U.begin() + N, U.end());\n    auto D2 = vector<ll>(D.begin() + N, D.end());\n    return compare(U1, D1, U2, D2);\n}\n\nbool vertical_check(vector<ll>& U, vector<ll>& D) {\n    vector<ll> M1, M2;\n    for (int i = 0; i < U.size(); i++) {\n        if ((U[i] + D[i]) % 2 == 0) return 0;\n        M1.push_back((U[i] + D[i]) / 2);\n        M2.push_back((U[i] + D[i]) / 2 + 1);\n    }\n    return compare(U, M1, M2, D);\n}\n\nll base = 2;\nll inv = 1000000006;\nll mod = 2000000011;\n\nvector<ll> base_pows;\nvector<ll> inv_pows;\nvoid precompute_powers() {\n    base_pows.push_back(1);\n    inv_pows.push_back(1);\n    for (int i = 1; i <= 300000; i++) {\n        base_pows.push_back(base_pows.back() * base % mod);\n        inv_pows.push_back(inv_pows.back() * inv % mod);\n    }\n}\n\nll sub(vector<ll> &hash_prefix, int a1, int b1) {\n    return ((mod + hash_prefix[b1] - hash_prefix[a1]) * inv_pows[a1]) % mod;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    precompute_powers();\n\n    int T; cin >> T;\n    while (T--) {\n        int N; cin >> N;\n        vector<ll> U(N), D(N), H(N);\n        vector<pii> col_UL(N), col_DR(N+1);\n        vector<ll> hash_prefix_U(N), hash_prefix_D(N);\n        for (int i = 0; i < N; i++) {\n            cin >> U[i] >> D[i];\n            H[i] = D[i] - U[i] + 1;\n            col_UL[i] = {i,U[i]};\n            col_DR[i] = {i+1,D[i]+1};\n        }\n\n        // hashing\n        for (int i = 1; i < N; i++) {\n            hash_prefix_U[i] = (((mod + U[i] - U[i-1]) * base_pows[i-1])\n                                + hash_prefix_U[i-1]) % mod;\n        }\n\n        for (int i = 1; i < N; i++) {\n            hash_prefix_D[i] = (((mod + D[i] - D[i-1]) * base_pows[i-1])\n                                + hash_prefix_D[i-1]) % mod;\n        }\n\n        // horizontal split\n        if (horizontal_check(U, D)) {\n            cout << \"YES\" << endl;\n            goto next;\n        }\n\n        // vertical split\n        if (vertical_check(U, D)) {\n            cout << \"YES\" << endl;\n            goto next;\n        }\n\n        for (int _ = 0; _ < 2; _++) {\n            // down-right split\n            for (int c = 1; c <= N/2; c++) {\n                // check upper portion\n                if (sub(hash_prefix_U, 0, c-1) != sub(hash_prefix_U, c, 2*c-1)) continue;\n                if (H[0] - U[2*c] + U[2*c-1] != U[c-1] - U[c]) continue;\n\n                // check lower portion\n                if (sub(hash_prefix_D, N-c, N-1) != sub(hash_prefix_D, N-2*c, N-c-1)) continue;\n                if (H[N-1] + D[N-2*c-1] - D[N-2*c] != D[N-c-1] - D[N-c]) continue;\n\n                // check main portion\n                if (sub(hash_prefix_U, 2*c, N-1) != sub(hash_prefix_D, 0, N-2*c-1)) continue;\n\n                // brute force section\n                // polynomial division\n                bool ok = 1;\n                vector<ll> H_copy(H.begin(), H.end());\n                vector<ll> quotient(N);\n\n                // calculate quotient\n                for (int i = 0; i < N-c; i++) {\n                    quotient[i] = H_copy[i];\n                    H_copy[i+c] -= H_copy[i];\n                    if (quotient[i] < 0) ok = 0;\n                }\n\n                // check for no remainder\n                for (int i = N-c; i < N; i++) if (H_copy[i]) ok = 0;\n                if (!ok) continue;\n\n                // construct subdivision\n                vector<ll> U1, D1, U2, D2;\n                for (int i = c; i < N; i++) {\n                    int ref_height = quotient[i-c];\n                    U1.push_back(D[i-c] - ref_height + 1);\n                    D1.push_back(D[i-c]);\n                    U2.push_back(U[i]);\n                    D2.push_back(U[i] + ref_height - 1);\n                }\n\n                if (compare(U1, D1, U2, D2)) {\n                    cout << \"YES\" << endl;\n                    goto next;\n                }\n            }\n\n            // flip and go again!\n            swap(hash_prefix_U, hash_prefix_D);\n            swap(U, D);\n            for (int i = 0; i < N; i++) {\n                U[i] = -U[i];\n                D[i] = -D[i];\n            }\n        }\n        cout << \"NO\" << endl;\n        next:;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2055e",
      "PROBLEM_ID": "2055E",
      "PROBLEM_STATEMENT": "On the next new moon, the universe will reset, beginning with Florida. It's up to Florida Man to stop it, but he first needs to find an important item.\n\nThere are $n$ haystacks labelled from $1$ to $n$, where haystack $i$ contains $a_i$ haybales. One of the haystacks has a needle hidden beneath it, but you do not know which one. Your task is to move the haybales so that each haystack is emptied at least once, allowing you to check if the needle is hidden under that particular haystack.\n\nHowever, the process is not that simple. Once a haystack $i$ is emptied for the first time, it will be assigned a height limit and can no longer contain more than $b_i$ haybales. More formally, a move is described as follows:\n\n- Choose two haystacks $i$ and $j$. If haystack $i$ has not been emptied before, or haystack $i$ contains strictly less than $b_i$ haybales, you may move exactly $1$ haybale from haystack $j$ to haystack $i$.\n\nNote: Before a haystack is emptied, it has no height limit, and you can move as many haybales as you want onto that haystack.\n\nCompute the minimum number of moves required to ensure that each haystack is emptied at least once, or report that it is impossible.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2\\le n\\le 5\\cdot 10^5$)\u00a0\u2014 the number of haystacks.\n\nThe $i$-th of the next $n$ lines contains two integers $a_i$ and $b_i$ ($1\\le a_i, b_i\\le 10^9$)\u00a0\u2014 the initial number of haybales in the $i$-th haystack, and the height limit that it is assigned after it is emptied for the first time.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the minimum number of moves required to ensure that each haystack is emptied at least once. If it is not possible to empty each haystack at least once, output -1.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n2\n\n3 5\n\n2 4\n\n2\n\n10 1\n\n1 10\n\n3\n\n1 3\n\n4 3\n\n1 1\n\n3\n\n5 4\n\n2 4\n\n1 10\n\n6\n\n2 1\n\n3 3\n\n5 4\n\n1 5\n\n1 6\n\n1 8\n\n5\n\n3 2\n\n1 2\n\n1 1\n\n1 3\n\n6 5\n\n2\n\n5 10\n\n7 12\n\n```\n\n#### Output #1\n\n```\n8\n-1\n8\n9\n14\n15\n19\n```\n\n### Note\n\nIn the first test case, we can do the following sequence of moves:\n\n- Move $3$ haybales from haystack $1$ to haystack $2$. Haystack $1$ is now emptied, and is assigned a height limit of $5$.\n- Move $5$ haybales from haystack $2$ to haystack $1$. Haystack $2$ is now emptied, and is assigned a height limit of $4$.\n\nThe above sequence requires $3 + 5 = 8$ moves. It is not possible to use less than $8$ moves as the following sequence of moves is invalid:\n\n- Move $2$ haybales from haystack $2$ to haystack $1$. Haystack $2$ is now emptied, and is assigned a height limit of $4$.\n- Move $4$ haybales from haystack $1$ to haystack $2$. Haystack $1$ now has $1$ haybale, while haystack $2$ has $4$ haybales.\n- Haystack $1$ cannot be emptied as haystack $2$ is already at its height limit of $4$, so no more haybales can be moved from haystack $1$ to haystack $2$.\n\nIn the second test case, the task is impossible. This is because the height limits of both haystacks are too small that once one of the haystacks is emptied, the other haystack cannot be emptied due to the small height limits.\n\nIn the third test case, the following sequence of moves can be shown to be optimal:\n\n- Move $1$ haybale from haystack $1$ to haystack $3$. Haystack $1$ is now emptied, and is assigned a height limit of $3$.\n- Move $3$ haybales from haystack $2$ to haystack $1$.\n- Move $1$ haybale from haystack $2$ to haystack $3$. Haystack $2$ is now emptied and is assigned a height limit of $3$.\n- Move $3$ haybales from haystack $3$ to haystack $2$. Haystack $3$ is now emptied, and is assigned a height limit of $1$.\n\nThe above sequence requires $1 + 3 + 1 + 3 = 8$ moves.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\n#define f first\n#define s second\n#define pb push_back\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<typename T> int die(T x) { cout << x << endl; return 0; }\n\n#define LNF 1e15\n\nint N;\nvector<pll> segtree;\n\npll f(pll a, pll b) {\n    return {max(a.first, a.second + b.first), a.second + b.second};\n}\n\nvoid pull(int t) {\n    segtree[t] = f(segtree[2*t], segtree[2*t+1]);\n}\n\nvoid point_set(int idx, pll val, int L = 1, int R = N, int t = 1) {\n    if (L == R) segtree[t] = val;\n    else {\n        int M = (L + R) / 2;\n        if (idx <= M) point_set(idx, val, L, M, 2*t);\n        else point_set(idx, val, M+1, R, 2*t+1);\n        pull(t);\n    }\n}\n\npll range_add(int left, int right, int L = 1, int R = N, int t = 1) {\n    if (left <= L && R <= right) return segtree[t];\n    else {\n        int M = (L + R) / 2;\n        pll ret = {0, 0};\n        if (left <= M) ret = f(ret, range_add(left, right, L, M, 2*t));\n        if (right > M) ret = f(ret, range_add(left, right, M+1, R, 2*t+1));\n        return ret;\n    }\n}\n\nvoid build(vector<pll>& arr, int L = 1, int R = N, int t = 1) {\n    if (L == R) segtree[t] = arr[L-1];\n    else {\n        int M = (L + R) / 2;\n        build(arr, L, M, 2*t);\n        build(arr, M+1, R, 2*t+1);\n        pull(t);\n    }\n}\n\nvector<int> theoretical(const vector<pii>& arr) {\n    vector<int> idx(arr.size());\n    for (int i = 0; i < arr.size(); ++i) {\n        idx[i] = i;\n    }\n\n    vector<int> ut, eq, lt;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i].first < arr[i].second) {\n            ut.push_back(i);\n        } else if (arr[i].first == arr[i].second) {\n            eq.push_back(i);\n        } else {\n            lt.push_back(i);\n        }\n    }\n\n    sort(ut.begin(), ut.end(), [&arr](int i, int j) {\n        return arr[i].first < arr[j].first;\n    });\n\n    sort(eq.begin(), eq.end(), [&arr](int i, int j) {\n        return arr[i].first > arr[j].first;\n    });\n\n    sort(lt.begin(), lt.end(), [&arr](int i, int j) {\n        return arr[i].second > arr[j].second;\n    });\n\n    vector<int> result;\n    result.insert(result.end(), ut.begin(), ut.end());\n    result.insert(result.end(), eq.begin(), eq.end());\n    result.insert(result.end(), lt.begin(), lt.end());\n\n    return result;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int T = 1; cin >> T;\n    while (T--) {\n        cin >> N;\n        vector<pll> data(N);\n        ll sum_a = 0;\n        ll sum_b = 0;\n        for (int i = 0; i < N; i++) {\n            cin >> data[i].f >> data[i].s;\n            sum_a += data[i].f;\n            sum_b += data[i].s;\n        }\n        vector<int> order = theoretical(vector<pii>(data.begin(), data.end()));\n\n        vector<pll> data_sorted;\n        for (int i : order) data_sorted.push_back({data[i].first, data[i].first - data[i].second});\n        data_sorted.push_back({0, 0});\n\n        ++N;\n\n        segtree = vector<pll>(4*N);\n        build(data_sorted);\n\n        ll ans = LNF;\n        for (int i = 0; i < N-1; i++) {\n            if (sum_b - (data_sorted[i].first - data_sorted[i].second) >= sum_a) {\n                point_set(i+1, data_sorted[N-1]);\n                point_set(N, data_sorted[i]);\n\n                ans = min(ans, range_add(1, N).first);\n\n                point_set(i+1, data_sorted[i]);\n                point_set(N, data_sorted[N-1]);\n            }\n        }\n        if (ans == LNF) cout << -1 << endl;\n        else cout << ans + sum_a << endl;\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2055d",
      "PROBLEM_ID": "2055D",
      "PROBLEM_STATEMENT": "At his orange orchard, Florida Man receives yet another spam letter, delivered by a crow. Naturally, he's sending it back in the most inconvenient manner possible.\n\nA crow is sitting at position $0$ of the number line. There are $n$ scarecrows positioned at integer coordinates $a_1, a_2, \\ldots, a_n$ along the number line. These scarecrows have been enchanted, allowing them to move left and right at a speed of $1$ unit per second.\n\nThe crow is afraid of scarecrows and wants to stay at least a distance of $k$ ahead of the nearest scarecrow positioned at or before it. To do so, the crow uses its teleportation ability as follows:\n\n- Let $x$ be the current position of the crow, and let $y$ be the largest position of a scarecrow such that $y \\le x$. If $x - y < k$, meaning the scarecrow is too close, the crow will instantly teleport to position $y + k$.\n\nThis teleportation happens instantly and continuously. The crow will keep checking for scarecrows positioned at or to the left of him and teleport whenever one gets too close (which could happen at non-integral times). Note that besides this teleportation ability, the crow will not move on its own.\n\nYour task is to determine the minimum time required to make the crow teleport to a position greater than or equal to $\\ell$, assuming the scarecrows move optimally to allow the crow to reach its goal. For convenience, you are asked to output twice the minimum time needed for the crow to reach the target position $\\ell$. It can be proven that this value will always be an integer.\n\nNote that the scarecrows can start, stop, or change direction at any time (possibly at non-integral times).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n, k, \\ell$ ($1 \\leq n \\leq 2 \\cdot 10^5$, $1 \\leq k \\leq \\ell \\leq 10^8$)\u00a0\u2014 the number of scarecrows, the teleportation distance, and the target position of the crow, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_1 \\leq a_2 \\leq \\ldots \\leq a_n \\leq \\ell$)\u00a0\u2014 the initial positions of the $n$ scarecrows.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer representing the twice the minimum time required for the crow to teleport to a position greater than or equal to $\\ell$.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n1 3 5\n\n0\n\n3 2 5\n\n2 5 5\n\n1 10 10\n\n10\n\n10 1 10\n\n0 1 2 3 4 5 6 7 8 9\n\n2 1 2\n\n0 0\n\n2 1 2\n\n0 2\n\n2 1 3\n\n0 2\n\n2 2 4\n\n1 1\n\n9 12 54\n\n3 3 8 24 25 27 29 34 53\n\n```\n\n#### Output #1\n\n```\n4\n5\n20\n0\n2\n1\n2\n2\n7\n```\n\n### Note\n\nIn the first test case, the crow instantly teleports to position $3$ due to the scarecrow at position $0$. This scarecrow may then move to position $2$, causing the crow to continuously move from position $3$ to position $5$, completing the trip in $2$ seconds. Therefore, the output is $4$.\n\nIn the second test case, scarecrow $1$ and scarecrow $2$ can move to positions $0$ and $3$, respectively, in $2$ seconds, while scarecrow $3$ remains at position $5$. The crow teleports to position $2$ due to scarecrow $1$. Then, scarecrow $1$ moves to the right while scarecrow $2$ and scarecrow $3$ move to the left for $0.5$ seconds. This causes the crow to continuously move from position $2$ to position $2.5$ due to scarecrow $1$ moving right from position $0$. After this half second, the scarecrows will be at positions $0.5, 2.5, 4.5$. Scarecrow $2$, now at position $2.5$, causes the crow to instantly teleport to position $4.5$, and scarecrow $3$ at position $4.5$ causes it to instantly teleport to position $6.5$, which exceeds $\\ell = 5$. Therefore, the crow finishes the trip in just $2.5$ seconds, and the output is $5$.\n\nIt can be shown that these are the minimum possible times for both test cases.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\n#define f first\n#define s second\n#define pb push_back\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int T; cin >> T;\n    while (T--) {\n        int N, k, l;\n        cin >> N >> k >> l;\n        double K = k;\n        double L = l;\n        vector<int> A(N);\n        for (int i = 0; i < N; i++) cin >> A[i];\n        double T = A[0];\n        double last_pt = 0;\n        double S = 0;\n        for (int i = 1; i < N; i++) {\n            double this_pt = min(L, min(A[i] + T,\n                                max(last_pt + K,\n                                    (A[i] - T + last_pt + K)/2.0)));\n            T += max(0.0, this_pt - last_pt - K);\n            S += min(K, this_pt - last_pt);\n            last_pt = this_pt;\n        }\n        S += min(K, L - last_pt);\n        cout << (int)round(2*(L - S + A[0])) << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2055c",
      "PROBLEM_ID": "2055C",
      "PROBLEM_STATEMENT": "There are no mountains in Florida, and Florida Man cannot comprehend their existence. As such, he really needs your help with this one.\n\nIn the wilderness lies a region of mountainous terrain represented as a rectangular grid with $n$ rows and $m$ columns. Each cell in the grid is identified by its position $(i, j)$, where $i$ is the row index and $j$ is the column index. The altitude of cell $(i, j)$ is denoted by $a_{i,j}$.\n\nHowever, this region has been tampered with. A path consisting of $n + m - 1$ cells, starting from the top-left corner $(1, 1)$ and ending at the bottom-right corner $(n, m)$, has been cleared. For every cell $(i, j)$ along this path, the altitude $a_{i,j}$ has been set to $0$. The path moves strictly via downward ($\\mathtt{D}$) or rightward ($\\mathtt{R}$) steps.\n\nTo restore the terrain to its original state, it is known that the region possessed a magical property before it was tampered with: all rows and all columns shared the same sum of altitudes. More formally, there exists an integer $x$ such that $\\sum_{j=1}^m a_{i, j} = x$ for all $1\\le i\\le n$, and $\\sum_{i=1}^n a_{i, j} = x$ for all $1\\le j\\le m$.\n\nYour task is to assign new altitudes to the cells on the path such that the above magical property is restored. It can be proven that a solution always exists. If there are multiple solutions that satisfy the property, any one of them may be provided.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($2 \\leq n, m \\leq 1000$)\u00a0\u2014 the number of rows and columns in the grid.\n\nThe second line of each test case contains a string $s$ of length $n+m-2$ ($s_i = \\mathtt{D}$ or $s_i = \\mathtt{R}$)\u00a0\u2014 the steps the path makes from $(1, 1)$ to $(n, m)$. The character $\\mathtt{D}$ represents a downward step, and $\\mathtt{R}$ represents a rightward step.\n\nThe $i$-th of the next $n$ lines each contain $m$ integers $a_{i,1}, a_{i, 2}, \\ldots, a_{i,m}$ ($-10^6 \\leq a_{i,j} \\leq 10^6$)\u00a0\u2014 the altitude of each cell in the grid. It is guaranteed that if a cell $(i, j)$ lies on the path, then $a_{i,j} = 0$.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output $n$ lines of $m$ integers representing the restored grid of altitudes $b_{i, j}$. The altitudes must satisfy $-10^{15} \\leq b_{i,j} \\leq 10^{15}$, and additionally $a_{i,j} = b_{i,j}$ if $(i, j)$ is not on the path. If multiple solutions exist, output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 3\n\nDRRD\n\n0 2 3\n\n0 0 0\n\n3 1 0\n\n4 5\n\nDRRRRDD\n\n0 1 0 2 3\n\n0 0 0 0 0\n\n-1 0 -3 -3 0\n\n0 0 0 -1 0\n\n2 3\n\nRRD\n\n0 0 0\n\n0 1 0\n\n5 5\n\nDDDDRRRR\n\n0 25 2 9 11\n\n0 6 13 20 22\n\n0 17 24 1 8\n\n0 3 10 12 19\n\n0 0 0 0 0\n\n```\n\n#### Output #1\n\n```\n1 2 3\n2 3 1\n3 1 2\n-6 1 0 2 3\n7 -1 3 2 -11\n-1 0 -3 -3 7\n0 0 0 -1 1\n0 -1 1\n0 1 -1\n18 25 2 9 11\n4 6 13 20 22\n15 17 24 1 8\n21 3 10 12 19\n7 14 16 23 5\n```\n\n### Note\n\nIn the first test case, the grid has been filled such that every row and column contains the numbers $1, 2, 3$ in some order, resulting in a common sum of $6$.\n\nIn the second test case, the grid has been filled such that all rows and columns sum to $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    \n    vector<vector<long long>> grid(n, vector<long long>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    // Simulate the path to find all cells in the path\n    vector<pair<int, int>> path;\n    int i = 0, j = 0;\n    path.emplace_back(i, j);\n    for (char c : s) {\n        if (c == 'D') i++;\n        else j++;\n        path.emplace_back(i, j);\n    }\n    \n    // Calculate sum_Srow and sum_Scol\n    vector<long long> sum_Srow(n, 0), sum_Scol(m, 0);\n    vector<vector<bool>> is_path(n, vector<bool>(m, false));\n    for (auto& p : path) {\n        is_path[p.first][p.second] = true;\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (!is_path[i][j]) {\n                sum_Srow[i] += grid[i][j];\n                sum_Scol[j] += grid[i][j];\n            }\n        }\n    }\n    \n    vector<long long> R(n), C(m);\n    for (int i = 0; i < n; ++i) {\n        R[i] = -sum_Srow[i];\n    }\n    for (int j = 0; j < m; ++j) {\n        C[j] = -sum_Scol[j];\n    }\n    \n    // Process each cell in the path except the last\n    int k = 0;\n    for (; k < path.size() - 1; ++k) {\n        auto [i, j] = path[k];\n        char next_dir = s[k];\n        long long val;\n        if (next_dir == 'D') {\n            val = R[i];\n        } else {\n            val = C[j];\n        }\n        grid[i][j] = val;\n        R[i] -= val;\n        C[j] -= val;\n    }\n    \n    // Assign the last cell\n    auto [last_i, last_j] = path.back();\n    grid[last_i][last_j] = R[last_i];\n    \n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cout << grid[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2055b",
      "PROBLEM_ID": "2055B",
      "PROBLEM_STATEMENT": "As you'd expect, Florida is home to many bizarre magical forces, and Florida Man seeks to tame them.\n\nThere are $n$ different types of magical materials, numbered from $1$ to $n$. Initially, you have $a_i$ units of material $i$ for each $i$ from $1$ to $n$. You are allowed to perform the following operation:\n\n- Select a material $i$ (where $1\\le i\\le n$). Then, spend $1$ unit of every other material $j$ (in other words, $j\\neq i$) to gain $1$ unit of material $i$. More formally, after selecting material $i$, update array $a$ as follows: $a_i := a_i + 1$, and $a_j := a_j - 1$ for all $j$ where $j\\neq i$ and $1\\le j\\le n$. Note that all $a_j$ must remain non-negative, i.e. you cannot spend resources you do not have.\n\nYou are trying to craft an artifact using these materials. To successfully craft the artifact, you must have at least $b_i$ units of material $i$ for each $i$ from $1$ to $n$. Determine if it is possible to craft the artifact by performing the operation any number of times (including zero).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2\\le n\\le 2\\cdot 10^5$)\u00a0\u2014 the number of types of materials.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i\\le 10^9$)\u00a0\u2014 the amount of each material $i$ that you currently hold.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($0 \\le b_i\\le 10^9$)\u00a0\u2014 the amount of each material $i$ needed to produce the artifact.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single line containing either \"YES\" or \"NO\", representing whether or not the artifact can be crafted.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4\n\n0 5 5 1\n\n1 4 4 0\n\n3\n\n1 1 3\n\n2 2 1\n\n2\n\n1 10\n\n3 3\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\n```\n\n### Note\n\nIn the first test case, perform an operation on material $1$. After doing so, we will have exactly the required resources: $1$ unit of material $1$, and $4$ units each of materials $2$ and $3$.\n\nIn the second test case, it can be shown that no matter how the operations are performed, it is impossible to craft the artifact.\n\nIn the third test case, we can perform the operation on material $1$ twice. After these operations, we will have $3$ units of material $1$ and $8$ units of material $2$, which is more than enough to craft the artifact.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing int64 = long long;\n\n// Floor division of x by y, for y > 0\nstatic int64 floor_div(int64 x, int64 y) {\n    if (x >= 0) return x / y;\n    // for negative x, adjust toward -infinity\n    return - ((-x + y - 1) / y);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    // total sum of n across all tests <= 2e5\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int64> a(n), b(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> b[i];\n        }\n        // Special case n == 2\n        if (n == 2) {\n            int64 sa = a[0] + a[1];\n            int64 sb = b[0] + b[1];\n            // For n=2, sum is invariant; we need only sum(a) >= sum(b)\n            cout << (sa >= sb ? \"YES\\n\" : \"NO\\n\");\n            continue;\n        }\n        // For n >= 3, if total sum < target sum, impossible\n        int64 sum_a = 0, sum_b = 0;\n        for (int i = 0; i < n; i++) {\n            sum_a += a[i];\n            sum_b += b[i];\n        }\n        if (sum_a < sum_b) {\n            cout << \"NO\\n\";\n            continue;\n        }\n        // c[i] = a[i] - b[i]\n        vector<int64> c(n+1);\n        for (int i = 1; i <= n; i++) {\n            c[i] = a[i-1] - b[i-1];\n        }\n        // sort c[1..n]\n        sort(c.begin() + 1, c.begin() + n + 1);\n\n        // prefix sums of c\n        vector<int64> A(n+1, 0);\n        // prefix counts of evens\n        vector<int> pe(n+1, 0);\n        for (int i = 1; i <= n; i++) {\n            A[i] = A[i-1] + c[i];\n            pe[i] = pe[i-1] + ( (c[i] % 2 == 0) ? 1 : 0 );\n        }\n        // Maximum number of operations S allowed so that sum constraints hold:\n        // sum(a_final) = sum_a - (n-2)*S >= sum_b => S <= (sum_a - sum_b)/(n-2)\n        int64 M = floor_div(sum_a - sum_b, n - 2);\n\n        bool ok = false;\n        // Try each k = number of c[i] strictly less than S\n        // We partition S so that exactly k values c[i] < S,\n        // i.e. S in (c[k], c[k+1]] => S in [c[k]+1, c[k+1]]\n        for (int k = 0; k <= n; k++) {\n            // Determine the valid interval [L, R] for S when #c[i]<S is k\n            int64 L, R;\n            if (k == 0) {\n                // no c[i] < S => S <= c[1]\n                L = 0;\n                R = min(M, c[1]);\n            } else if (k < n) {\n                // c[k] < S <= c[k+1]\n                L = c[k] + 1;\n                if (L < 0) L = 0;\n                R = min(M, c[k+1]);\n            } else {\n                // k == n => all c[i] < S => S > c[n]\n                L = c[n] + 1;\n                if (L < 0) L = 0;\n                R = M;\n            }\n            if (L > R) {\n                continue;  // no S in that interval\n            }\n            // If k == 0, no requirements => S=0 works if c[1]>=0\n            if (k == 0) {\n                ok = true;\n                break;\n            }\n            // Compute prefix sums and parity counts for first k\n            int64 Ak = A[k];\n            int pe_k = pe[k];\n            int p_odd_k = k - pe_k; // number of odd c among first k\n\n            // Now check feasibility inequalities for this k\n            if (k == 1) {\n                // Inequality: -S + o <= A1  => S >= o - A1\n                for (int p = 0; p < 2; p++) {\n                    // p = 0 => S even => o = #odd c's in first k = p_odd_k\n                    // p = 1 => S odd  => o = #even c's in first k = pe_k\n                    int64 o = (p == 0 ? p_odd_k : pe_k);\n                    int64 lower_req = o - Ak;\n                    int64 eff_low = max(L, lower_req);\n                    int64 eff_high = R;\n                    if (eff_low > eff_high) continue;\n                    // pick S0 >= eff_low with parity p\n                    int64 S0 = eff_low;\n                    if ((S0 & 1LL) != p) S0++;\n                    if (S0 <= eff_high) {\n                        ok = true;\n                        break;\n                    }\n                }\n                if (ok) break;\n            }\n            else if (k == 2) {\n                // Inequality: 0*S + o <= A2  => o <= A2\n                for (int p = 0; p < 2; p++) {\n                    int64 o = (p == 0 ? p_odd_k : pe_k);\n                    if (o > Ak) continue;\n                    int64 eff_low = L;\n                    int64 eff_high = R;\n                    if (eff_low > eff_high) continue;\n                    int64 S0 = eff_low;\n                    if ((S0 & 1LL) != p) S0++;\n                    if (S0 <= eff_high) {\n                        ok = true;\n                        break;\n                    }\n                }\n                if (ok) break;\n            }\n            else {\n                // k >= 3: (k-2)*S + o <= A_k  =>  S <= floor((A_k - o)/(k-2))\n                for (int p = 0; p < 2; p++) {\n                    int64 o = (p == 0 ? p_odd_k : pe_k);\n                    int64 num = Ak - o;\n                    int64 den = k - 2;\n                    // compute floor(num/den)\n                    int64 maxS = floor_div(num, den);\n                    int64 eff_low = L;\n                    int64 eff_high = min(R, maxS);\n                    if (eff_low > eff_high) continue;\n                    int64 S0 = eff_low;\n                    if ((S0 & 1LL) != p) S0++;\n                    if (S0 <= eff_high) {\n                        ok = true;\n                        break;\n                    }\n                }\n                if (ok) break;\n            }\n        }\n\n        cout << (ok ? \"YES\\n\" : \"NO\\n\");\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2055a",
      "PROBLEM_ID": "2055A",
      "PROBLEM_STATEMENT": "Roaming through the alligator-infested Everglades, Florida Man encounters a most peculiar showdown.\n\nThere are $n$ lilypads arranged in a row, numbered from $1$ to $n$ from left to right. Alice and Bob are frogs initially positioned on distinct lilypads, $a$ and $b$, respectively. They take turns jumping, starting with Alice.\n\nDuring a frog's turn, it can jump either one space to the left or one space to the right, as long as the destination lilypad exists. For example, on Alice's first turn, she can jump to either lilypad $a-1$ or $a+1$, provided these lilypads are within bounds. It is important to note that each frog must jump during its turn and cannot remain on the same lilypad.\n\nHowever, there are some restrictions:\n\n- The two frogs cannot occupy the same lilypad. This means that Alice cannot jump to a lilypad that Bob is currently occupying, and vice versa.\n- If a frog cannot make a valid jump on its turn, it loses the game. As a result, the other frog wins.\n\nDetermine whether Alice can guarantee a win, assuming that both players play optimally. It can be proven that the game will end after a finite number of moves if both players play optimally.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first and only line of each test case contains three integers $n$, $a$, and $b$ ($2 \\leq n \\leq 100$, $1 \\leq a, b \\leq n$, $a\\neq b$)\u00a0\u2014 the number of lilypads, and the starting positions of Alice and Bob, respectively.\n\nNote that there are no constraints on the sum of $n$ over all test cases.\n\n### Output\n\nFor each test case, print a single line containing either \"YES\" or \"NO\", representing whether or not Alice has a winning strategy.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2 1 2\n\n3 3 1\n\n4 2 3\n\n5 2 4\n\n7 6 2\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nNO\nYES\nYES\n```\n\n### Note\n\nIn the first test case, Alice has no legal moves. Therefore, Alice loses on the first turn.\n\nIn the second test case, Alice can only move to lilypad $2$. Then, Bob has no legal moves. Therefore, Alice has a winning strategy in this case.\n\nIn the third test case, Alice can only move to lilypad $1$. Then, Bob can move to lilypad $2$. Alice is no longer able to move and loses, giving Bob the win. It can be shown that Bob can always win regardless of Alice's moves; hence, Alice does not have a winning strategy.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n        int n, a, b;\n        cin >> n >> a >> b;\n        int d = abs(a - b);\n        if (d % 2 == 0) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2053i2",
      "PROBLEM_ID": "2053I2",
      "PROBLEM_STATEMENT": "Note that this statement is different to the version used in the official round. The statement has been corrected to a solvable version. In the official round, all submissions to this problem have been removed.\n\nThis is the hard version of the problem. The difference between the versions is that in this version, you need to compute the sum of value of different arrays. You can hack only if you solved all versions of this problem.\n\nIris treasures an integer array $a_1, a_2, \\ldots, a_n$. She knows this array has an interesting property: the maximum absolute value of all elements is less than or equal to the sum of all elements, that is, $\\max(\\lvert a_i\\rvert) \\leq \\sum a_i$.\n\nIris defines the boredom of an array as its maximum subarray$^{\\text{\u2217}}$ sum.\n\nIris's birthday is coming, and Victor is going to send her another array $b_1, b_2, \\ldots, b_m$ as a gift. For some seemingly obvious reasons, he decides the array $b_1, b_2, \\ldots, b_m$ should have the following properties.\n\n- $a_1, a_2, \\ldots, a_n$ should be a subsequence$^{\\text{\u2020}}$ of $b_1, b_2, \\ldots, b_m$.\n- The two arrays have the same sum. That is, $\\sum\\limits_{i=1}^n a_i = \\sum\\limits_{i=1}^m b_i$.\n- The boredom of $b_1, b_2, \\ldots, b_m$ is the smallest possible.\n- Among the arrays with the smallest boredom, the length of the array $b$ (i.e., $m$) is the smallest possible. And in this case, Iris will understand his regard as soon as possible!\n\nFor a possible array $b_1, b_2, \\ldots, b_m$ satisfying all the conditions above, Victor defines the value of the array as the number of occurrences of array $a$ as subsequences in array $b$. That is, he counts the number of array $c_1, c_2, \\ldots, c_{n}$ that $1\\le c_1< c_2< \\ldots< c_n\\le m$ and for all integer $i$ that $1\\le i\\le n$, $b_{c_{i}}=a_i$ is satisfied, and let this be the value of array $b$.\n\nEven constrained as above, there are still too many possible gifts. So Victor asks you to calculate the sum of value of all possible arrays $b_1, b_2, \\ldots, b_m$. Since the answer may be large, Victor only needs the number modulo $998\\,244\\,353$. He promises you: if you help him successfully, he will share a bit of Iris's birthday cake with you.\n\n$^{\\text{\u2217}}$An array $c$ is a subarray of an array $d$ if $c$ can be obtained from $d$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n$^{\\text{\u2020}}$A sequence $c$ is a subsequence of a sequence $d$ if $c$ can be obtained from $d$ by the deletion of several (possibly, zero or all) element from arbitrary positions.\n\n### Input\n\nEach test contains multiple test cases. The first line of input contains an integer $t$ ($1 \\leq t \\leq 10^5$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 3\\cdot 10^6$)\u00a0\u2014 the length of the array $a_1, a_2, \\ldots, a_n$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-10^9 \\leq a_i \\leq 10^9$)\u00a0\u2014 the initial array. It is guaranteed that $\\max(\\lvert a_i\\rvert) \\leq \\sum a_i$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3\\cdot 10^6$.\n\n### Output\n\nFor each test case, output a single line containing an integer: the sum of values of valid arrays $b_1, b_2, \\ldots, b_m$, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4\n\n1 2 3 4\n\n4\n\n2 -3 2 2\n\n4\n\n1 -2 2 1\n\n10\n\n2 -7 6 3 -1 4 2 -5 8 -4\n\n20\n\n4 -2 4 3 -2 1 5 2 3 6 -5 -1 -4 -2 -3 5 -3 1 -4 1\n\n```\n\n#### Output #1\n\n```\n1\n2\n2\n20\n1472\n```\n\n### Note\n\nIn the first test case, $a=[1, 2, 3, 4]$. The only possible array $b$ is $[1, 2, 3, 4]$, and its value is $1$.\n\nIn the second test case, $a=[2, -3, 2, 2]$. The possible arrays $b$ are $[1, 2, -3, 2, -1, 2]$ and $[2, 1, -3, 2, -1, 2]$. Both arrays have value $1$.\n\nIn the third test case, $a=[1, -2, 2, 1]$. The only possible array $b$ is $[1, 1, -2, 2, -1, 1]$. It has value $2$, because we can find arrays $c=[1,3,4,6]$ or $[2,3,4,6]$. That is, the array $a$ occurs twice in $b$, so the answer is $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define Yukinoshita namespace\n#define Yukino std\n#define int long long\nusing Yukinoshita Yukino;\nint read()\n{\n        int s=0,w=1;\n        char ch=getchar();\n        while(ch<'0'||ch>'9') w=ch=='-'?-1:1,ch=getchar();\n        while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n        return s*w;\n}\nconst int mod=998244353;\nvoid getmod(int &x)\n{\n        x-=(x>=mod)*mod;\n}\nconst int mxn=3e6+10;\nint a[mxn],l[mxn],r[mxn];\nint top[mxn];\nint mn[mxn],dp[mxn];\nint pres[mxn];\ninline int get(int l,int r,int v)\n{\n        return l>r?0:(v%mod+mod)*(pres[r]-(l?pres[l-1]:0)+mod)%mod;\n}\nsigned main()\n{\n        int T=read();\n        while(T--)\n        {\n                int n=read(),i,j;\n                for(i=1;i<=n;i++)\n                        a[i]=read()+a[i-1];\n                for(i=1;i<=n;i++)\n                        l[i]=max(-a[i],-a[i-1]),r[i]=min(a[n]-a[i],a[n]-a[i-1]);\n                l[n+1]=r[n+1]=0;\n                dp[0]=pres[0]=1;\n                memset(top,0,n+3<<3);\n                deque<int> q1,q2;\n                int L=0,R=-1,res=0,r0=0,r1=0;\n                for(i=0;i<=n+1;i++)\n                {\n                        while(q1.size()&&r[q1.back()]>r[i])\n                        {\n                                int f=q1.back();\n                                q1.pop_back();\n                                r0=min(r0,(int)q1.size()-1);\n                                getmod(res+=mod-get(q1.size()?q1.back()+1:L,min(f,R),r[f]));\n                        }\n                        while(q2.size()&&l[q2.back()]<l[i])\n                        {\n                                int f=q2.back();\n                                q2.pop_back();\n                                r1=min(r1,(int)q2.size()-1);\n                                getmod(res+=get(q2.size()?q2.back()+1:L,min(f,R),l[f]));\n                        }\n                        getmod(res+=get(q1.size()?q1.back()+1:L,min(i,R),r[i]));\n                        getmod(res+=mod-get(q2.size()?q2.back()+1:L,min(i,R),l[i]));\n                        q1.push_back(i),q2.push_back(i);\n                        while(r[q1.front()]<l[q2.front()])\n                        {\n                                if(L+1>R)\n                                        res=0;\n                                else res=(res+(l[q2.front()]-r[q1.front()])%mod*dp[L])%mod; \n                                L++;\n                                for(;q1.front()<L;q1.pop_front());\n                                for(;q2.front()<L;q2.pop_front());\n                                r0=max(r0-1,0ll);\n                                r1=max(r1-1,0ll);\n                        }\n                        for(R=max(L-1,R);R<top[mn[L]];)\n                        {\n                                R++;\n                                for(;q1[r0]<R;r0++);\n                                for(;q2[r1]<R;r1++);\n                                res=(res+(r[q1[r0]]-l[q2[r1]])%mod*dp[R])%mod;\n                        }\n                        mn[i+1]=mn[L]+1;\n                        top[mn[i+1]]=i+1;\n                        getmod(dp[i+1]=res+get(L,R,1));\n                        getmod(pres[i+1]=pres[i]+dp[i+1]);\n                }\n                printf(\"%lld\\n\",dp[n+2]);\n        }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2053i1",
      "PROBLEM_ID": "2053I1",
      "PROBLEM_STATEMENT": "You are the beginning of the letter, the development of a poem, and the end of a fairy tale.\n\n\u2014 ilem, [Pinky Promise](https://www.bilibili.com/video/BV1Jb411U7u2/)\n\nThis is the easy version of the problem. The difference between the versions is that in this version, you need to compute the minimum length of the arrays. You can hack only if you solved all versions of this problem.\n\nIris treasures an integer array $a_1, a_2, \\ldots, a_n$. She knows this array has an interesting property: the maximum absolute value of all elements is less than or equal to the sum of all elements, that is, $\\max(\\lvert a_i\\rvert) \\leq \\sum a_i$.\n\nIris defines the boredom of an array as its maximum subarray$^{\\text{\u2217}}$ sum.\n\nIris's birthday is coming, and Victor is going to send her another array $b_1, b_2, \\ldots, b_m$ as a gift. For some seemingly obvious reasons, he decides the array $b_1, b_2, \\ldots, b_m$ should have the following properties.\n\n- $a_1, a_2, \\ldots, a_n$ should be a subsequence$^{\\text{\u2020}}$ of $b_1, b_2, \\ldots, b_m$.\n- The two arrays have the same sum. That is, $\\sum\\limits_{i=1}^n a_i = \\sum\\limits_{i=1}^m b_i$.\n- The boredom of $b_1, b_2, \\ldots, b_m$ is the smallest possible.\n- Among the arrays with the smallest boredom, the length of the array $b$ (i.e., $m$) is the smallest possible. And in this case, Iris will understand his regard as soon as possible!\n\nEven constrained as above, there are still too many possible gifts. So Victor asks you to compute the value of $\\boldsymbol{m}$ of any array $b_1, b_2, \\ldots, b_m$ satisfying all the conditions above. He promises you: if you help him successfully, he will share a bit of Iris's birthday cake with you.\n\nNote: since the input is large, you may need to optimize it for this problem.\n\nFor example, in C++, it is enough to use the following lines at the start of the main() function:\n\n```\n`int main() {<br/>    std::ios::sync_with_stdio(false);<br/>    std::cin.tie(nullptr); std::cout.tie(nullptr);<br/>}<br/>````\n\n$^{\\text{\u2217}}$An array $c$ is a subarray of an array $d$ if $c$ can be obtained from $d$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n$^{\\text{\u2020}}$A sequence $c$ is a subsequence of a sequence $d$ if $c$ can be obtained from $d$ by the deletion of several (possibly, zero or all) element from arbitrary positions.\n\n### Input\n\nEach test contains multiple test cases. The first line of input contains an integer $t$ ($1 \\leq t \\leq 10^5$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 3\\cdot 10^6$)\u00a0\u2014 the length of the array $a_1, a_2, \\ldots, a_n$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-10^9 \\leq a_i \\leq 10^9$)\u00a0\u2014 the initial array. It is guaranteed that $\\max(\\lvert a_i\\rvert) \\leq \\sum a_i$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3\\cdot 10^6$.\n\n### Output\n\nFor each test case, output a single line containing an integer: the length $m$ of a valid array $b$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4\n\n1 2 3 4\n\n4\n\n2 -3 2 2\n\n10\n\n2 -7 6 3 -1 4 2 -5 8 -4\n\n20\n\n4 -2 4 3 -2 1 5 2 3 6 -5 -1 -4 -2 -3 5 -3 1 -4 1\n\n```\n\n#### Output #1\n\n```\n4\n6\n14\n25\n```\n\n### Note\n\nIn the first test case, $a=[1, 2, 3, 4]$. The only array $b$ which satisfies all the properties above is $[1, 2, 3, 4]$, so we should output $4$.\n\nIn the second test case, $a=[2, -3, 2, 2]$. The possible arrays $b$ are $[1, 2, -3, 2, -1, 2]$ and $[2, 1, -3, 2, -1, 2]$, so we should output $6$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;                   // number of test cases\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n\n        vector<long long> a(n);\n        long long S = 0;     // total sum of a\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            S += a[i];\n        }\n\n        if (S == 0) {        // all ai are zero\n            cout << n << '\\n';\n            continue;\n        }\n\n        long long L = 0, R = 0;      // current feasible interval\n        long long add = 0;           // inserted elements\n\n        for (int i = 0; i < n; ++i) {\n            long long nl = L + a[i];\n            long long nr = R + a[i];\n\n            nl = max(0LL, nl);\n            nr = min(S,  nr);\n\n            if (nl > nr) {           // interval empty \u2192 must insert\n                ++add;\n                nl = max(0LL, a[i]);         // new interval after ai\n                nr = min(S , S + a[i]);\n            }\n            L = nl;\n            R = nr;\n        }\n\n        if (R < S) ++add;            // final fixing element if needed\n\n        cout << n + add << '\\n';\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2053h",
      "PROBLEM_ID": "2053H",
      "PROBLEM_STATEMENT": "I shall be looking for you who would be out of Existence.\n\n\u2014 HyuN, [Disorder](https://soundcloud.com/k-sounds-studio/g2r2018-hyun-disorder-feat-yuri)\n\nThere are always many repetitive tasks in life. Iris always dislikes them, so she refuses to repeat them. However, time cannot be turned back; we only have to move forward.\n\nFormally, Iris has an integer sequence $a_1, a_2, \\ldots, a_n$, where each number in the sequence is between $1$ and $w$, inclusive. It is guaranteed that $w \\geq 2$.\n\nIris defines an operation as selecting two numbers $a_i, a_{i+1}$ satisfying $a_i = a_{i+1}$, and then changing them to two arbitrary integers within the range $[1, w]$. Iris does not like equality, so she must guarantee that $a_i \\neq a_{i+1}$ after the operation. Two identical pairs $a_i, a_{i+1}$ can be selected multiple times.\n\nIris wants to know the maximum possible sum of all elements of $a$ after several (possible, zero) operations, as well as the minimum number of operations required to achieve this maximum value.\n\n### Input\n\nEach test contains multiple test cases. The first line contains an integer $t$ ($1 \\leq t \\leq 10^5$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $w$ ($1 \\leq n \\leq 2\\cdot 10^5$, $2 \\leq w \\leq 10^8$)\u00a0\u2014 the length of the array, and the maximum allowed value of the elements.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq w$)\u00a0\u2014 the elements in the array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output two integers\u00a0\u2014 the maximum possible sum of all elements of $a$ and the minimum number of operations required, respectively.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5 8\n\n1 2 3 4 5\n\n7 5\n\n3 1 2 3 4 1 1\n\n```\n\n#### Output #1\n\n```\n15 0\n34 6\n```\n\n### Note\n\nIn the first test case, no operation can be performed so the answers are $\\sum a_i = 15$ and $0$, respectively.\n\nIn the second test case, the operations can be performed as follows:\n\n\n\n$$[3, 1, 2, 3, 4, \\underline{1, 1}] \\rightarrow [3, 1, 2, 3, \\underline{4, 4}, 5] \\rightarrow [3, 1, 2, \\underline{3, 3}, 5, 5] \\rightarrow [3, 1, \\underline{2, 2}, 5, 5, 5] \\rightarrow [3, \\underline{1, 1}, 5, 5, 5, 5] \\rightarrow [\\underline{3, 3}, 5, 5, 5, 5, 5] \\rightarrow [4, 5, 5, 5, 5, 5, 5]$$\n\nIt can be shown this is optimal, so we should output $\\sum a_i = 34$ and the number of operations, $6$, respectively.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD         998244353\n#define speMOD      2933256077ll\n#define int         long long\n#define pii         pair<int,int>\n#define all(v)      v.begin(),v.end()\n#define pb          push_back\n#define REP(i,b,e)  for(int i=(b);i<(int)(e);++i)\n#define over(x)     {cout<<(x)<<endl;return;}\n#define lowbit(x)   ((x)&(-(x)))\n#define cntbit(x)   __builtin_popcount(x)\n#define deal(v)     sort(all(v));v.erase(unique(v.begin(),v.end()),v.end())\n#define lbound(v,x) lower_bound(all(v),x)-v.begin()\nint n,w,N;\nint a[200005],b[200005];\nint solve(){\n\tint x=0,ans=0;\n\tREP(i,1,n)if(b[i]==b[i-1]){\n\t\tx=i-1;break;\n\t}\n\tint m=n;while(b[m-1]==w-1)--m;//>=m \u7684\u90fd\u662f w\n\t//\u5148\u628a same \u63a8\u5230\u6700\u8fb9\u4e0a\n\tans+=x;//x x+1 m\n\tint f=m<=x+2,g=0,h=0;\n\tif(m<=x)return 1e18;\n\tif(!f&&x){\n\t\tint len=x+2;\n\t\twhile(len<n&&b[len]==w-1)++len;\n\t\tif(len==x+3)g=1;\n\t\telse g=0;\n\t}\n\tif(g){\n\t\tif(b[x-1]!=w-1)b[x+1]=w-1,b[x]=b[x-1],--x;\n\t\telse ans+=2,b[x+2]=b[x]? b[x]-1:1;\n\t}\n\tfor(int i=x-1;i>=0;--i){\n\t\tif(!i&&b[i]==w-1){--ans;h=1;break;}\n\t\tif(b[i]==w-1)f=0;\n\t\tif(!f)b[i+2]=b[i]? b[i]-1:1;\n\t\telse b[i+2]=w-1;\n\t\tb[i+1]=b[i];\n\t}\n\tif(h)x=1;\n\telse{\n\t\tx=0;\n\t\tif(b[0]==w-1){while(x+2<n&&b[x+2]==b[x+1])++x;if(x+3<n&&b[x+2]==b[x+3])x+=2;}\n\t}\n\t//b[x]=b[x+1], \u76ee\u6807\u63a8\u8fdb b[x+2]\n\twhile(x+1<m){\n\t\tif(x+2==m)return ++ans;\n\t\tif(b[x]==w-1&&b[x+1]==w-1&&b[x+2]==w-1){++x;continue;}\n\t\tif(b[x+2]!=w-1){\n\t\t\tb[x]=w-1;b[x+1]=b[x+2];++ans;++x;\n\t\t\tcontinue;\n\t\t}\n\t\t//9119\n\t\t// x  \n\t\tif(b[x+3]==w-1){\n\t\t\tif(x+4<n&&b[x+4]==w-1&&(x+5>=n||b[x+5]!=w-1)){\n\t\t\t\t//911999 911199 991199\n\t\t\t\tans+=2;swap(b[x],b[x+2]);++x;\n\t\t\t}else{\n\t\t\t\t//91199 91188 99888 99988\n\t\t\t\tans+=3;\n\t\t\t\tb[x]=b[x+1]=w-1;b[x+2]=b[x+3]=w-2;\n\t\t\t\tx+=2;\n\t\t\t}\n\t\t}else{\n\t\t\t//91191 92991 92211 99111 99911\n\t\t\tans+=4;b[x]=b[x+1]=w-1;b[x+2]=b[x+3];\n\t\t\tx+=2;\n\t\t}\n\t}\n\treturn ans;\n}\nint spesolve(){\n\tN=n;\n\tREP(i,0,n)b[i]=a[i];\n\tif(b[0]==w-1&&b[1]==w-1){\n\t\tint x=0,y=n-1;\n\t\twhile(b[x]==w-1)++x;\n\t\twhile(b[y]==w-1)--y;\n\t\tint f=0;\n\t\tREP(i,x+1,y+1)if(b[i]==b[i-1])f=1;\n\t\tif(!f){\n\t\t\tn=y+1;\n\t\t}else{\n\t\t\tf=0;\n\t\t\tREP(i,x+1,n)if(b[i]==b[i-1])f=1;\n\t\t\tif(f){\n\t\t\t\tint cur=solve();\n\t\t\t\tREP(i,0,n)b[i]=a[i];\n\t\t\t\tn-=x;\n\t\t\t\tREP(i,0,n)b[i]=b[i+x];\n\t\t\t\treturn min(cur,solve());\n\t\t\t}\n\t\t}\n\t}\n\treturn solve();\n}\nvoid Main() {\n\tcin>>n>>w;\n\tREP(i,0,n)cin>>a[i];\n\tif(w==2){\n\t\tint ans=0;\n\t\tREP(i,1,n){\n\t\t\tif(a[i]==1&&a[i-1]==1)a[i-1]=2,++ans;\n\t\t}\n\t\tint res=0;\n\t\tREP(i,0,n)res+=a[i];\n\t\tcout<<res<<' '<<ans<<endl;\n\t\treturn;\n\t}\n\tbool f=1;int s=0;\n\tREP(i,1,n)if(a[i]==a[i-1])f=0;\n\tREP(i,0,n)s+=a[i];\n\tif(f||s>=n*w-1){\n\t\tcout<<s<<' '<<0<<endl;\n\t\treturn;\n\t}\n\tcout<<n*w-1<<' ';\n\tif(w>4){\n\t\tint lst=-1,op=1;\n\t\tREP(i,0,n)if(a[i]<w-1){\n\t\t\tif(lst!=a[i])op^=3,lst=a[i];\n\t\t\ta[i]=op;\n\t\t}else a[i]-=w-4;\n\t\tw=4;\n\t}\n\tREP(i,0,n)--a[i];\n\tif(n==2)over(1)\n\tint cans=spesolve();n=N;\n\treverse(a,a+n);\n\tcans=min(cans,spesolve());\n\tover(cans)\n}\nvoid TC() {\n    int tc=1;\n    cin>>tc;\n\twhile(tc--){\n\t\tMain();\n\t\tcout.flush();\n\t}\n}\nsigned main() {\n\treturn cin.tie(0),cout.tie(0),ios::sync_with_stdio(0),TC(),0;\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2053f",
      "PROBLEM_ID": "2053F",
      "PROBLEM_STATEMENT": "3, 2, 1, ... We are the \u2014 RiOI Team!\n\n\u2014 Felix & All, [Special Thanks 3](https://www.luogu.com.cn/problem/T351681)\n\n- Peter: Good news: My problem T311013 is approved!\n- $\\delta$: I'm glad my computer had gone out of battery so that I wouldn't have participated in wyrqwq's round and gained a negative delta.\n- Felix: \\[thumbs\\_up\\] The problem statement concerning a removed song!\n- Aquawave: Do I mourn my Chemistry?\n- E.Space: ahh?\n- Trine: Bread.\n- Iris: So why am I always testing problems?\n\nTime will pass, and we might meet again. Looking back at the past, everybody has lived the life they wanted.\n\nAquawave has a matrix $A$ of size $n\\times m$, whose elements can only be integers in the range $[1, k]$, inclusive. In the matrix, some cells are already filled with an integer, while the rest are currently not filled, denoted by $-1$.\n\nYou are going to fill in all the unfilled places in $A$. After that, let $c_{u,i}$ be the number of occurrences of element $u$ in the $i$-th row. Aquawave defines the beauty of the matrix as\n\n\n\n$$\\sum_{u=1}^k \\sum_{i=1}^{n-1} c_{u,i} \\cdot c_{u,i+1}.$$\n\nYou have to find the maximum possible beauty of $A$ after filling in the blanks optimally.\n\n### Input\n\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 2\\cdot 10^4$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$ ($2 \\leq n \\leq 2\\cdot 10^5$, $2 \\leq m \\leq 2\\cdot 10^5$, $n \\cdot m \\leq 6\\cdot 10^5$, $1 \\leq k \\leq n\\cdot m$)\u00a0\u2014 the number of rows and columns of the matrix $A$, and the range of the integers in the matrix, respectively.\n\nThen $n$ lines follow, the $i$-th line containing $m$ integers $A_{i,1},A_{i,2},\\ldots,A_{i,m}$ ($1 \\leq A_{i,j} \\leq k$ or $A_{i,j} = -1$) \u2014 the elements in $A$.\n\nIt is guaranteed that the sum of $n\\cdot m$ over all test cases does not exceed $6\\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the maximum possible beauty.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n3 3 3\n\n1 2 2\n\n3 1 3\n\n3 2 1\n\n2 3 3\n\n-1 3 3\n\n2 2 -1\n\n3 3 6\n\n-1 -1 1\n\n1 2 -1\n\n-1 -1 4\n\n3 4 5\n\n1 3 2 3\n\n-1 -1 2 -1\n\n3 1 5 1\n\n5 3 8\n\n5 -1 2\n\n1 8 -1\n\n-1 5 6\n\n7 7 -1\n\n4 4 4\n\n6 6 5\n\n-1 -1 5 -1 -1 -1\n\n-1 -1 -1 -1 2 -1\n\n-1 1 3 3 -1 -1\n\n-1 1 -1 -1 -1 4\n\n4 2 -1 -1 -1 4\n\n-1 -1 1 2 -1 -1\n\n6 6 4\n\n-1 -1 -1 -1 1 -1\n\n3 -1 2 2 4 -1\n\n3 1 2 2 -1 -1\n\n3 3 3 3 -1 2\n\n-1 3 3 -1 1 3\n\n3 -1 2 2 3 -1\n\n5 5 3\n\n1 1 3 -1 1\n\n2 2 -1 -1 3\n\n-1 -1 -1 2 -1\n\n3 -1 -1 -1 2\n\n-1 1 2 3 -1\n\n6 2 7\n\n-1 7\n\n-1 6\n\n7 -1\n\n-1 -1\n\n-1 -1\n\n2 2\n\n```\n\n#### Output #1\n\n```\n4\n4\n10\n10\n8\n102\n93\n58\n13\n```\n\n### Note\n\nIn the first test case, the matrix $A$ is already determined. Its beauty is\n\n\n\n$$\\sum_{u=1}^k \\sum_{i=1}^{n-1} c_{u,i} \\cdot c_{u,i+1} = c_{1,1}\\cdot c_{1,2} + c_{1,2}\\cdot c_{1,3} + c_{2,1}\\cdot c_{2,2} + c_{2,2}\\cdot c_{2,3} + c_{3,1}\\cdot c_{3,2} + c_{3,2}\\cdot c_{3,3} = 1\\cdot 1 + 1\\cdot 1 + 2\\cdot 0 + 0\\cdot 1 + 0\\cdot 2 + 2\\cdot 1 = 4.$$\n\nIn the second test case, one can fill the matrix as follows:\n\n\n\n$$ \\begin{bmatrix} 2 &3 &3 \\\\ 2 &2 &3 \\end{bmatrix}, $$\n\nand get the value $4$. It can be proven this is the maximum possible answer one can get.\n\nIn the third test case, one of the possible optimal configurations is:\n\n\n\n$$ \\begin{bmatrix} 1 &1 &1 \\\\ 1 &2 &1 \\\\ 1 &1 &4 \\end{bmatrix}. $$\n\nIn the fourth test case, one of the possible optimal configurations is:\n\n\n\n$$ \\begin{bmatrix} 1 &3 &2 &3 \\\\ 1 &3 &2 &1 \\\\ 3 &1 &5 &1 \\end{bmatrix}. $$\n\nIn the fifth test case, one of the possible optimal configurations is:\n\n\n\n$$ \\begin{bmatrix} 5 &5 &2 \\\\ 1 &8 &5 \\\\ 7 &5 &6 \\\\ 7 &7 &4 \\\\ 4 &4 &4 \\end{bmatrix}. $$\n\n",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\n#define int         long long\n#define pii         pair<int,int>\n#define all(v)      v.begin(),v.end()\n#define pb          push_back\n#define REP(i,b,e)  for(int i=(b);i<(int)(e);++i)\n#define over(x)     {cout<<(x)<<endl;return;}\nint n,m,t;\nint f[4000005],X,Y,g[1000005],c[1000005];\nvoid Main() {\n\tcin>>n>>m>>t;\n\tvector<vector<int>>a(n, vector<int>(m));\n\tvector<int>cnt(n);\n\tREP(i,0,n){\n\t\tcnt[i]=0;\n\t\tvector<int>b;\n\t\tREP(j,0,m){\n\t\t\tint x;cin>>x;\n\t\t\tif(x>0)b.pb(x-1);\n\t\t\telse ++cnt[i];\n\t\t}\n\t\treverse(all(b));REP(j,0,cnt[i])b.pb(-1);\n\t\treverse(all(b));a[i]=b;\n\t}\n\tif(n==1)over(0)\n\tREP(i,0,t)f[i]=0;\n\tint ans=0;\n\tREP(i,0,n-1){\n\t\tREP(j,cnt[i],m)++f[a[i][j]];\n\t\tREP(j,cnt[i+1],m)ans+=f[a[i+1][j]];\n\t\tREP(j,cnt[i],m)--f[a[i][j]];\n\t}\n\tREP(j,cnt[1],m)f[a[1][j]]+=cnt[0];\n\tX=Y=0;int mx=0;\n\tREP(i,0,t)mx=max(mx,f[i]);\n\tREP(i,1,n){\n        vector<int>T;\n        REP(j,cnt[i-1],m)T.pb(a[i-1][j]);\n        if(i<n-1)REP(j,cnt[i+1],m)T.pb(a[i+1][j]);\n        for(auto j:T)c[j]=0;\n        for(auto j:T)++c[j];\n        int co=cnt[i]*cnt[i-1];\n        X+=co;Y=max(Y+co,mx);mx+=co;\n        for(auto j:T)if(c[j]){\n            f[j]=max(X+f[j],Y)+c[j]*cnt[i];\n            mx=max(mx,f[j]);\n            f[j]-=X;c[j]=0;\n        }\n\t}\n\tmx=0;\n\tREP(j,0,t)mx=max(mx,max(f[j]+X,Y));\n\tover(mx+ans)\n}\nvoid TC() {\n    int tc=1;\n    cin>>tc;\n\twhile(tc--){\n\t\tMain();\n\t\tcout.flush();\n\t}\n}\nsigned main() {\n\treturn cin.tie(0),cout.tie(0),ios::sync_with_stdio(0),TC(),0;\n}\n/*\n1. CLEAR the arrays (ESPECIALLY multitests)\n2. DELETE useless output\n */\n\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2053e",
      "PROBLEM_ID": "2053E",
      "PROBLEM_STATEMENT": "Endless Repeating 7 Days\n\n\u2014 r-906, [Panopticon](https://www.youtube.com/watch?v=_-Vd0ZGB-lo)\n\nThere is a tree consisting of $n$ vertices. Let a caterpillar be denoted by an integer pair $(p, q)$ ($1 \\leq p, q \\leq n$, $p \\neq q$): its head is at vertex $p$, its tail is at vertex $q$, and it dominates all the vertices on the simple path from $p$ to $q$ (including $p$ and $q$). The caterpillar sequence of $(p, q)$ is defined as the sequence consisting only of the vertices on the simple path, sorted in the ascending order of the distance to $p$.\n\nNora and Aron are taking turns moving the caterpillar, with Nora going first. Both players will be using his or her own optimal strategy:\n\n- They will play to make himself or herself win;\n- However, if it is impossible, they will play to prevent the other person from winning (thus, the game will end in a tie).\n\nIn Nora's turn, she must choose a vertex $u$ adjacent to vertex $p$, which is not dominated by the caterpillar, and move all the vertices in it by one edge towards vertex $u$$^{\\\\text{\u2217}}$. In Aron's turn, he must choose a vertex $v$ adjacent to vertex $q$, which is not dominated by the caterpillar, and move all the vertices in it by one edge towards vertex $v$. Note that the moves allowed to the two players are different.\n\nWhenever $p$ is a leaf$^{\\text{\u2020}}$, Nora wins$^{\\text{\u2021}}$. Whenever $q$ is a leaf, Aron wins. If either initially both $p$ and $q$ are leaves, or after $10^{100}$ turns the game has not ended, the result is a tie.\n\nPlease count the number of integer pairs $(p, q)$ with $1 \\leq p, q \\leq n$ and $p \\neq q$ such that, if the caterpillar is initially $(p, q)$, Aron wins the game.\n\n$^{\\text{\u2217}}$In other words: Let the current caterpillar sequence be $c_1, c_2, \\ldots, c_k$, then after the move, the new caterpillar sequence becomes $d(u, c_1), d(u, c_2), \\ldots, d(u, c_k)$. Here, $d(x, y)$ is the next vertex on the simple path from $y$ to $x$.\n\n$^{\\text{\u2020}}$In a tree, a vertex is called a leaf if and only if its degree is $1$.\n\n$^{\\text{\u2021}}$Therefore, Nora never fails to choose a vertex $u$ when the game has not ended. The same goes for Aron.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 2\\cdot 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 2\\cdot 10^5$)\u00a0\u2014 the number of vertices in the tree.\n\nThe following $n - 1$ lines each contain two integers $u$ and $v$ ($1 \\leq u, v \\leq n$), denoting an edge between vertices $u$ and $v$. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $4\\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single line containing an integer: the number of integer pairs $(p, q)$ which make Aron win.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n1 2\n\n5\n\n1 2\n\n1 3\n\n2 4\n\n2 5\n\n12\n\n1 6\n\n11 2\n\n4 8\n\n12 3\n\n2 7\n\n6 12\n\n8 1\n\n2 3\n\n5 12\n\n9 2\n\n10 3\n\n10\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n5 6\n\n4 7\n\n6 8\n\n4 9\n\n4 10\n\n25\n\n1 16\n\n11 22\n\n6 14\n\n3 1\n\n20 14\n\n23 17\n\n25 19\n\n10 11\n\n3 18\n\n10 6\n\n2 21\n\n4 5\n\n11 12\n\n4 9\n\n9 13\n\n8 6\n\n6 1\n\n3 7\n\n8 19\n\n10 24\n\n15 13\n\n1 2\n\n3 4\n\n17 8\n\n```\n\n#### Output #1\n\n```\n0\n6\n40\n27\n171\n```\n\n### Note\n\nIn the first test case, all possible caterpillars are $(1, 2)$ and $(2, 1)$, resulting in a tie at the beginning, since both $p$ and $q$ are leaves.\n\nIn the second test case, the caterpillars that allow Aron to win are the following: $(1, 3)$, $(1, 4)$, $(1, 5)$, $(2, 3)$, $(2, 4)$, $(2, 5)$. Let's look at some specific caterpillars.\n\n- For the caterpillar $(1, 5)$: vertex $p = 1$ is not a leaf, but vertex $q = 5$ is, so Aron wins at the beginning.\n- For the caterpillar $(2, 1)$: vertex $p = 2$ is not a leaf, neither is vertex $q = 1$. In Nora's first move, she can choose to move the caterpillar towards vertex $5$, therefore the caterpillar becomes $(5, 2)$, and vertex $p = 5$ is a leaf, so Nora will win.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<vector<int>> adj(n+1);\n        vector<pair<int,int>> edges;\n        edges.reserve(n-1);\n        for(int i = 0; i < n-1; i++){\n            int u,v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            edges.emplace_back(u,v);\n        }\n        // degrees\n        vector<int> deg(n+1);\n        for(int v = 1; v <= n; v++){\n            deg[v] = adj[v].size();\n        }\n        // count how many neighbors of v are leaves\n        vector<int> leaf_neighbors(n+1,0);\n        for(int v = 1; v <= n; v++){\n            int cnt = 0;\n            for(int u: adj[v]){\n                if(deg[u] == 1) cnt++;\n            }\n            leaf_neighbors[v] = cnt;\n        }\n        // count leaves and non\u2011leaves\n        ll leaf_count = 0, non_leaf_count = 0;\n        for(int v = 1; v <= n; v++){\n            if(deg[v] == 1) leaf_count++;\n            else non_leaf_count++;\n        }\n        // immediate Aron wins: q is a leaf and p is non\u2011leaf\n        ll immediateAron = leaf_count * non_leaf_count;\n\n        // classify S1 (p has no leaf\u2011neighbors, deg>=2) and S2 (r has >=1 leaf\u2011neighbor)\n        vector<char> is_S1(n+1,0), is_S2(n+1,0);\n        int total_S1 = 0;\n        for(int v = 1; v <= n; v++){\n            if(deg[v] >= 2 && leaf_neighbors[v] == 0){\n                is_S1[v] = 1;\n                total_S1++;\n            }\n            if(leaf_neighbors[v] >= 1){\n                is_S2[v] = 1;\n            }\n        }\n\n        // compute subtree\u2011counts of S1 by DFS\n        vector<int> parent(n+1,0), s1_subtree(n+1,0);\n        {\n            // iterative DFS stack: (node, parent, processed_flag)\n            vector<array<int,3>> st;\n            st.reserve(2*n);\n            int root = 1;\n            st.push_back({root, 0, 0});\n            while(!st.empty()){\n                auto cur = st.back(); st.pop_back();\n                int u = cur[0], p = cur[1], done = cur[2];\n                if(!done){\n                    parent[u] = p;\n                    st.push_back({u, p, 1});\n                    for(int w: adj[u]){\n                        if(w == p) continue;\n                        st.push_back({w, u, 0});\n                    }\n                } else {\n                    int sum = is_S1[u] ? 1 : 0;\n                    for(int w: adj[u]){\n                        if(w == p) continue;\n                        sum += s1_subtree[w];\n                    }\n                    s1_subtree[u] = sum;\n                }\n            }\n        }\n\n        // now sum over directed edges for second\u2011level Aron wins\n        ll level2 = 0;\n        for(auto &e: edges){\n            int u = e.first, v = e.second;\n            // figure out parent\u2011child in the DFS tree\n            if(parent[v] == u){\n                // v is child of u\n                // directed r=v -> q=u\n                if(is_S2[v] && deg[u] >= 2) \n                    level2 += s1_subtree[v];\n                // directed r=u -> q=v\n                if(is_S2[u] && deg[v] >= 2)\n                    level2 += (ll)(total_S1 - s1_subtree[v]);\n            } else if(parent[u] == v){\n                // u is child of v\n                // directed r=u -> q=v\n                if(is_S2[u] && deg[v] >= 2)\n                    level2 += s1_subtree[u];\n                // directed r=v -> q=u\n                if(is_S2[v] && deg[u] >= 2)\n                    level2 += (ll)(total_S1 - s1_subtree[u]);\n            }\n        }\n\n        // total Aron wins\n        ll answer = immediateAron + level2;\n        cout << answer << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2053d",
      "PROBLEM_ID": "2053D",
      "PROBLEM_STATEMENT": "As a tester, when my solution has a different output from the example during testing, I suspect the author first.\n\n\u2014 Chris, [a comment](https://codeforces.com/blog/entry/133116?#comment-1190579)\n\nAlthough Iris occasionally sets a problem where the solution is possibly wrong, she still insists on creating problems with her imagination; after all, everyone has always been on the road with their stubbornness... And like ever before, Iris has set a problem to which she gave a wrong solution, but Chris is always supposed to save it! You are going to play the role of Chris now:\n\n- Chris is given two arrays $a$ and $b$, both consisting of $n$ integers.\n- Iris is interested in the largest possible value of $P = \\prod\\limits_{i=1}^n \\min(a_i, b_i)$ after an arbitrary rearrangement of $b$. Note that she only wants to know the maximum value of $P$, and no actual rearrangement is performed on $b$.\n- There will be $q$ modifications. Each modification can be denoted by two integers $o$ and $x$ ($o$ is either $1$ or $2$, $1 \\leq x \\leq n$). If $o = 1$, then Iris will increase $a_x$ by $1$; otherwise, she will increase $b_x$ by $1$.\n- Iris asks Chris the maximum value of $P$ for $q + 1$ times: once before any modification, then after every modification.\n- Since $P$ might be huge, Chris only needs to calculate it modulo $998\\,244\\,353$.\n\nChris soon worked out this problem, but he was so tired that he fell asleep. Besides saying thanks to Chris, now it is your turn to write a program to calculate the answers for given input data.\n\nNote: since the input and output are large, you may need to optimize them for this problem.\n\nFor example, in C++, it is enough to use the following lines at the start of the main() function:\n\n```\n`int main() {<br/>    std::ios::sync_with_stdio(false);<br/>    std::cin.tie(nullptr); std::cout.tie(nullptr);<br/>}<br/>````\n\n### Input\n\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\leq n \\leq 2\\cdot 10^5$, $1 \\leq q \\leq 2\\cdot 10^5$)\u00a0\u2014 the length of the array and the number of operations.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 5\\cdot 10^8$)\u00a0\u2014 the array $a$.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq 5\\cdot 10^8$)\u00a0\u2014 the array $b$.\n\nThen $q$ lines follow, each line contains two integers $o$ and $x$ ($o \\in \\{1, 2\\}$, $1 \\leq x \\leq n$), representing an operation.\n\nIt's guaranteed that the sum of $n$ and the sum of $q$ over all test cases does not exceed $4\\cdot 10^5$, respectively.\n\n### Output\n\nFor each test case, output $q + 1$ integers in a line, representing the answers that Chris will calculate, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 4\n\n1 1 2\n\n3 2 1\n\n1 3\n\n2 3\n\n1 1\n\n2 1\n\n6 8\n\n1 4 2 7 3 5\n\n7 6 5 6 3 3\n\n2 5\n\n1 6\n\n1 5\n\n1 5\n\n1 5\n\n2 3\n\n2 3\n\n1 6\n\n13 8\n\n7 7 6 6 5 5 5 2 2 3 4 5 1\n\n1 4 1 9 6 6 9 1 5 1 3 8 4\n\n2 2\n\n2 11\n\n2 4\n\n2 4\n\n1 7\n\n1 1\n\n2 12\n\n1 5\n\n5 3\n\n10000000 20000000 30000000 40000000 50000000\n\n10000000 20000000 30000000 40000000 50000000\n\n1 1\n\n2 2\n\n2 1\n\n```\n\n#### Output #1\n\n```\n2 3 3 6 6\n840 840 1008 1344 1680 2016 2016 2016 2352\n2116800 2646000 3528000 3528000 3528000 4233600 4838400 4838400 4838400\n205272023 205272023 205272023 264129429\n```\n\n### Note\n\nIn the first test case:\n\n- Before the modifications, Chris can rearrange $b$ to $[1, 2, 3]$ so that $P = \\prod\\limits_{i=1}^n \\min(a_i, b_i) = 1 \\cdot 1 \\cdot 2 = 2$. We can prove that this is the maximum possible value. For example, if Chris rearranges $b = [2, 3, 1]$, $P$ will be equal $1 \\cdot 1 \\cdot 1 = 1 < 2$, which is not optimal.\n- After the first modification, Chris can rearrange $b$ to $[1, 2, 3]$ so that $P = 1 \\cdot 1 \\cdot 3 = 3$, which is maximized.\n- After the second modification, Chris can rearrange $b$ to $[2, 2, 3]$ so that $P = 1 \\cdot 1 \\cdot 3 = 3$, which is maximized.\n- After the third modification, Chris can rearrange $b$ to $[2, 2, 3]$ so that $P = 6$, which is maximized.\n- After the fourth modification, Chris can rearrange $b$ to $[2, 2, 4]$ so that $P = 6$, which is maximized.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 998244353;\n\n// Fast exponentiation modulo MOD\nll modpow(ll a, ll e = MOD - 2) {\n    ll res = 1;\n    a %= MOD;\n    while (e) {\n        if (e & 1) res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        e >>= 1;\n    }\n    return res;\n}\n\n// Fenwick Tree (Binary Indexed Tree) for point updates and prefix sums\nstruct Fenwick {\n    int n;\n    vector<int> bit;\n    Fenwick(int _n): n(_n), bit(n+1, 0) {}\n    // add 'val' at position i (1-based)\n    void add(int i, int val) {\n        for (; i <= n; i += i & -i)\n            bit[i] += val;\n    }\n    // sum of [1..i] (1-based)\n    int sum(int i) const {\n        int s = 0;\n        for (; i > 0; i -= i & -i)\n            s += bit[i];\n        return s;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, q;\n        cin >> n >> q;\n        vector<int> a(n), b(n);\n        for (int i = 0; i < n; i++) cin >> a[i];\n        for (int i = 0; i < n; i++) cin >> b[i];\n\n        // Read operations\n        vector<pair<int,int>> ops(q);\n        for (int i = 0; i < q; i++) {\n            cin >> ops[i].first >> ops[i].second;\n            --ops[i].second; // make 0-based\n        }\n\n        // We'll collect all values that ever appear in A or B (initial and after increments)\n        vector<int> all_vals;\n        all_vals.reserve(2*n + 2*q);\n\n        // initial values\n        for (int i = 0; i < n; i++) {\n            all_vals.push_back(a[i]);\n            all_vals.push_back(b[i]);\n        }\n\n        // We'll record the old and new values for each operation\n        vector<int> old_val(q), new_val(q);\n\n        // Simulate A and B to collect possible values\n        vector<int> cur_a = a, cur_b = b;\n        for (int i = 0; i < q; i++) {\n            int o = ops[i].first, x = ops[i].second;\n            if (o == 1) {\n                int v = cur_a[x];\n                old_val[i] = v;\n                new_val[i] = v + 1;\n                all_vals.push_back(v);\n                all_vals.push_back(v + 1);\n                cur_a[x]++;\n            } else {\n                int v = cur_b[x];\n                old_val[i] = v;\n                new_val[i] = v + 1;\n                all_vals.push_back(v);\n                all_vals.push_back(v + 1);\n                cur_b[x]++;\n            }\n        }\n\n        // Compress values\n        sort(all_vals.begin(), all_vals.end());\n        all_vals.erase(unique(all_vals.begin(), all_vals.end()), all_vals.end());\n        int m = (int)all_vals.size();\n\n        // Precompute inverses of all distinct values\n        vector<ll> inv_val(m);\n        for (int i = 0; i < m; i++) {\n            inv_val[i] = modpow(all_vals[i]);\n        }\n\n        // Build Fenwicks for A and B frequencies\n        Fenwick BIT_A(m), BIT_B(m);\n        // Initialize with the counts of initial a[] and b[]\n        for (int i = 0; i < n; i++) {\n            int idxA = int(lower_bound(all_vals.begin(), all_vals.end(), a[i]) - all_vals.begin());\n            BIT_A.add(idxA + 1, 1);\n            int idxB = int(lower_bound(all_vals.begin(), all_vals.end(), b[i]) - all_vals.begin());\n            BIT_B.add(idxB + 1, 1);\n        }\n\n        // Precompute compressed indices for each operation's old/new values\n        vector<int> idx_v(q), idx_v1(q);\n        for (int i = 0; i < q; i++) {\n            idx_v[i]  = int(lower_bound(all_vals.begin(), all_vals.end(), old_val[i]) - all_vals.begin());\n            idx_v1[i] = int(lower_bound(all_vals.begin(), all_vals.end(), new_val[i]) - all_vals.begin());\n        }\n\n        // Compute initial product P = prod_{k=1..n} min(sorted(a)[k], sorted(b)[k])\n        vector<int> sa = a, sb = b;\n        sort(sa.begin(), sa.end());\n        sort(sb.begin(), sb.end());\n        ll P = 1;\n        for (int i = 0; i < n; i++) {\n            P = (P * min(sa[i], sb[i])) % MOD;\n        }\n\n        // Prepare answer list\n        vector<ll> answer;\n        answer.reserve(q + 1);\n        answer.push_back(P);\n\n        // Process each operation\n        for (int i = 0; i < q; i++) {\n            int o = ops[i].first;\n            int iv  = idx_v[i];\n            int iv1 = idx_v1[i];\n            // prefix sums fA(v) and fB(v)\n            int fA = BIT_A.sum(iv + 1);\n            int fB = BIT_B.sum(iv + 1);\n\n            if (o == 1) {\n                // A update\n                if (fA > fB) {\n                    // P *= (v+1)/v\n                    P = P * all_vals[iv1] % MOD;\n                    P = P * inv_val[iv] % MOD;\n                }\n                // move one count from v to v+1 in A\n                BIT_A.add(iv + 1, -1);\n                BIT_A.add(iv1 + 1, +1);\n            } else {\n                // B update\n                if (fB > fA) {\n                    P = P * all_vals[iv1] % MOD;\n                    P = P * inv_val[iv] % MOD;\n                }\n                BIT_B.add(iv + 1, -1);\n                BIT_B.add(iv1 + 1, +1);\n            }\n            answer.push_back(P);\n        }\n\n        // Output the results for this test case\n        for (int i = 0; i < (int)answer.size(); i++) {\n            if (i) cout << ' ';\n            cout << answer[i];\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2051g",
      "PROBLEM_ID": "2051G",
      "PROBLEM_STATEMENT": "Suppose you play a game where the game field looks like a strip of $1 \\times 10^9$ square cells, numbered from $1$ to $10^9$.\n\nYou have $n$ snakes (numbered from $1$ to $n$) you need to place into some cells. Initially, each snake occupies exactly one cell, and you can't place more than one snake into one cell. After that, the game starts.\n\nThe game lasts for $q$ seconds. There are two types of events that may happen each second:\n\n- snake $s_i$ enlarges: if snake $s_i$ occupied cells $[l, r]$, it enlarges to a segment $[l, r + 1]$;\n- snake $s_i$ shrinks: if snake $s_i$ occupied cells $[l, r]$, it shrinks to a segment $[l + 1, r]$.\n\nEach second, exactly one of the events happens.\n\nIf at any moment of time, any snake runs into some obstacle (either another snake or the end of the strip), you lose. Otherwise, you win with the score equal to the maximum cell occupied by any snake so far.\n\nWhat is the minimum possible score you can achieve?\n\n### Input\n\nThe first line contains two integers $n$ and $q$ ($1 \\le n \\le 20$; $1 \\le q \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of snakes and the number of events. Next $q$ lines contain the description of events\u00a0\u2014 one per line.\n\nThe $i$-th line contains\n\n- either \"$s_i$ +\" ($1 \\le s_i \\le n$) meaning that the $s_i$-th snake enlarges\n- or \"$s_i$ -\" ($1 \\le s_i \\le n$) meaning that the $s_i$-th snake shrinks.\n\nAdditional constraint on the input: the given sequence of events is valid, i.\u00a0e. a snake of length $1$ never shrinks.\n\n### Output\n\nPrint one integer\u00a0\u2014 the minimum possible score.\n\n### Examples\n\n#### Input #1\n\n```\n\n3 6\n\n1 +\n\n1 -\n\n3 +\n\n3 -\n\n2 +\n\n2 -\n\n```\n\n#### Output #1\n\n```\n4\n```\n\n#### Input #2\n\n```\n\n5 13\n\n5 +\n\n3 +\n\n5 -\n\n2 +\n\n4 +\n\n3 +\n\n5 +\n\n5 -\n\n2 +\n\n3 -\n\n3 +\n\n3 -\n\n2 +\n\n```\n\n#### Output #2\n\n```\n11\n```\n\n### Note\n\nIn the first test, the optimal strategy is to place the second snake at cell $1$, the third snake\u00a0\u2014 at $2$, and the first one\u00a0\u2014 at $3$. The maximum occupied cell is cell $4$, and it's the minimum possible score.\n\nIn the second test, one of the optimal strategies is to place:\n\n- snake $2$ at position $1$;\n- snake $3$ at position $4$;\n- snake $5$ at position $6$;\n- snake $1$ at position $9$;\n- snake $4$ at position $10$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n    // A[i]: # of shrinks for snake i so far; B[i]: # of enlarges so far\n    static int A[20], B[20], d[20];\n    // C[i][j] = max over time of (B_i(t) - A_j(t))\n    static int Cmat[20][20];\n    for (int i = 0; i < n; i++) {\n        A[i] = B[i] = 0;\n        d[i] = 0;\n        for (int j = 0; j < n; j++) Cmat[i][j] = 0;\n    }\n\n    for (int it = 0; it < q; it++) {\n        int s;\n        char op;\n        cin >> s >> op;\n        --s;\n        if (op == '+') {\n            // enlarge snake s\n            B[s]++;\n            for (int j = 0; j < n; j++) if (j != s) {\n                int val = B[s] - A[j];\n                if (val > Cmat[s][j]) Cmat[s][j] = val;\n            }\n        } else {\n            // shrink snake s\n            A[s]++;\n            for (int j = 0; j < n; j++) if (j != s) {\n                int val = B[j] - A[s];\n                if (val > Cmat[j][s]) Cmat[j][s] = val;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        d[i] = B[i];  // total enlarges for snake i\n    }\n    // w[i][j] = C[i][j] + 1  (required gap if i is before j)\n    static int w[20][20];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) w[i][j] = 0;\n            else w[i][j] = Cmat[i][j] + 1;\n        }\n    }\n\n    const uint32_t INF = 1000000000u;\n    int maxmask = 1 << n;\n    // sp[mask * n + j]: minimum sum of w-edges on a Hamiltonian path\n    //    that visits exactly the set 'mask' and ends at j.\n    // dp[mask * n + j]: minimal possible max(prefix_sum + d[last])\n    //    for any ordering of 'mask' that ends at j.\n    uint32_t *sp = (uint32_t*)malloc(sizeof(uint32_t) * maxmask * n);\n    uint32_t *dp = (uint32_t*)malloc(sizeof(uint32_t) * maxmask * n);\n    if (!sp || !dp) {\n        // allocation failed\n        return 0;\n    }\n    // initialize\n    for (int i = 0; i < maxmask * n; i++) {\n        sp[i] = INF;\n        dp[i] = INF;\n    }\n\n    // DP over subsets in increasing popcount order\n    for (int mask = 1; mask < maxmask; mask++) {\n        int s = __builtin_popcount(mask);\n        if (s == 1) {\n            // base case: a single snake\n            int j = __builtin_ctz(mask);\n            sp[mask * n + j] = 0;\n            dp[mask * n + j] = d[j];\n        } else {\n            // for each possible last snake j in this mask\n            int m = mask;\n            while (m) {\n                int j = __builtin_ctz(m);\n                m &= m - 1;\n                int mask2 = mask ^ (1 << j);\n                uint32_t bestSP = INF;\n                uint32_t bestDP = INF;\n                // try predecessor k in mask2\n                int mm = mask2;\n                while (mm) {\n                    int k = __builtin_ctz(mm);\n                    mm &= mm - 1;\n                    uint32_t spk = sp[mask2 * n + k];\n                    uint32_t wkj = (uint32_t)w[k][j];\n                    uint32_t candSP = spk + wkj;\n                    if (candSP < bestSP) bestSP = candSP;\n                    // compute the max of (previous dp, new completion for j)\n                    uint32_t candComplete = candSP + (uint32_t)d[j];\n                    uint32_t dpk = dp[mask2 * n + k];\n                    uint32_t candDP = dpk > candComplete ? dpk : candComplete;\n                    if (candDP < bestDP) bestDP = candDP;\n                }\n                sp[mask * n + j] = bestSP;\n                dp[mask * n + j] = bestDP;\n            }\n        }\n    }\n\n    // answer is min over j of dp[fullmask][j] + 1\n    int full = maxmask - 1;\n    uint32_t ans = INF;\n    for (int j = 0; j < n; j++) {\n        uint32_t v = dp[full * n + j];\n        if (v < ans) ans = v;\n    }\n    // add 1 for the initial offset\n    uint64_t result = (uint64_t)ans + 1ULL;\n    cout << result << \"\\n\";\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2051f",
      "PROBLEM_ID": "2051F",
      "PROBLEM_STATEMENT": "Consider a deck of $n$ cards. The positions in the deck are numbered from $1$ to $n$ from top to bottom. A joker is located at position $m$.\n\n$q$ operations are applied sequentially to the deck. During the $i$-th operation, you need to take the card at position $a_i$ and move it either to the beginning or to the end of the deck. For example, if the deck is $[2, 1, 3, 5, 4]$, and $a_i=2$, then after the operation the deck will be either $[1, 2, 3, 5, 4]$ (the card from the second position moved to the beginning) or $[2, 3, 5, 4, 1]$ (the card from the second position moved to the end).\n\nYour task is to calculate the number of distinct positions where the joker can be after each operation.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains three integers $n$, $m$, and $q$ ($2 \\le n \\le 10^9$; $1 \\le m \\le n$; $1 \\le q \\le 2 \\cdot 10^5$).\n\nThe second line contains $q$ integers $a_1, a_2, \\dots, a_q$ ($1 \\le a_i \\le n$).\n\nAdditional constraint on the input: the sum of $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print $q$ integers \u2014 the number of distinct positions where the joker can be after each operation.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n6 5 3\n\n1 2 3\n\n2 1 4\n\n2 1 1 2\n\n5 3 1\n\n3\n\n3 2 4\n\n2 1 1 1\n\n18 15 4\n\n13 15 1 16\n\n```\n\n#### Output #1\n\n```\n2 3 5\n2 2 2 2\n2\n2 3 3 3\n2 4 6 8\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--){\n        ll n, m, q;\n        cin >> n >> m >> q;\n        vector<ll> a(q);\n        for(auto &x: a) cin >> x;\n        // Initialize current intervals\n        vector<pii> current_intervals;\n        current_intervals.emplace_back(m, m);\n        // To store results\n        vector<ll> results;\n        for(int i=0; i<q; ++i){\n            ll ai = a[i];\n            vector<pii> temp_intervals;\n            for(auto &[L, R] : current_intervals){\n                // Option1\n                if(L <= ai && ai <= R){\n                    // Add position 1\n                    temp_intervals.emplace_back(1,1);\n                    // Add [L+1, ai] if valid\n                    if(L <= ai-1){\n                        ll newL = L +1;\n                        ll newR = ai;\n                        if(newL <= newR)\n                            temp_intervals.emplace_back(newL, newR);\n                    }\n                    // Add [ai+1, R] if valid\n                    if(ai +1 <= R){\n                        ll newL = ai +1;\n                        ll newR = R;\n                        if(newL <= newR)\n                            temp_intervals.emplace_back(newL, newR);\n                    }\n                }\n                else if(R < ai){\n                    // Shift [L, R] by +1\n                    ll newL = L +1;\n                    ll newR = R +1;\n                    if(newL <= newR && newR <=n){\n                        temp_intervals.emplace_back(newL, newR);\n                    }\n                }\n                else { // L > ai\n                    // Add [L, R]\n                    temp_intervals.emplace_back(L, R);\n                }\n\n                // Option2\n                if(L <= ai && ai <= R){\n                    // Add position n\n                    temp_intervals.emplace_back(n, n);\n                    // Add [L, ai-1] if valid\n                    if(L <= ai-1){\n                        ll newL = L;\n                        ll newR = ai -1;\n                        if(newL <= newR)\n                            temp_intervals.emplace_back(newL, newR);\n                    }\n                    // Add [ai, R-1] if valid\n                    if(ai +1 <= R){\n                        ll newL = ai;\n                        ll newR = R -1;\n                        if(newL <= newR)\n                            temp_intervals.emplace_back(newL, newR);\n                    }\n                }\n                else if(L > ai){\n                    // Shift [L, R] by -1\n                    ll newL = L -1;\n                    ll newR = R -1;\n                    if(newL >=1 && newL <= newR){\n                        temp_intervals.emplace_back(newL, newR);\n                    }\n                }\n                else if(R < ai){\n                    // Add [L, R]\n                    temp_intervals.emplace_back(L, R);\n                }\n            }\n            // Sort temp_intervals by L\n            sort(temp_intervals.begin(), temp_intervals.end());\n            // Merge overlapping intervals\n            vector<pii> merged;\n            if(!temp_intervals.empty()){\n                ll current_L = temp_intervals[0].first;\n                ll current_R = temp_intervals[0].second;\n                for(int j=1; j<temp_intervals.size(); ++j){\n                    ll next_L = temp_intervals[j].first;\n                    ll next_R = temp_intervals[j].second;\n                    if(next_L <= current_R +1){\n                        current_R = max(current_R, next_R);\n                    }\n                    else{\n                        merged.emplace_back(current_L, current_R);\n                        current_L = next_L;\n                        current_R = next_R;\n                    }\n                }\n                merged.emplace_back(current_L, current_R);\n            }\n            current_intervals = move(merged);\n            // Calculate the number of distinct positions\n            ll count =0;\n            for(auto &[L, R] : current_intervals){\n                count += (R - L +1);\n            }\n            results.emplace_back(count);\n        }\n        // Output the results\n        for(int i=0; i<results.size(); ++i){\n            if(i>0) cout << ' ';\n            cout << results[i];\n        }\n        cout << '\\n';\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2051d",
      "PROBLEM_ID": "2051D",
      "PROBLEM_STATEMENT": "You are given a sequence $a$, consisting of $n$ integers, where the $i$-th element of the sequence is equal to $a_i$. You are also given two integers $x$ and $y$ ($x \\le y$).\n\nA pair of integers $(i, j)$ is considered interesting if the following conditions are met:\n\n- $1 \\le i < j \\le n$;\n- if you simultaneously remove the elements at positions $i$ and $j$ from the sequence $a$, the sum of the remaining elements is at least $x$ and at most $y$.\n\nYour task is to determine the number of interesting pairs of integers for the given sequence $a$.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n- The first line contains three integers $n, x, y$ ($3 \\le n \\le 2 \\cdot 10^5$, $1 \\le x \\le y \\le 2 \\cdot 10^{14}$);\n- The second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^{9}$).\n\nAdditional constraint on the input: the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output one integer \u2014 the number of interesting pairs of integers for the given sequence $a$.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n4 8 10\n\n4 6 3 6\n\n6 22 27\n\n4 9 6 3 4 5\n\n3 8 10\n\n3 2 1\n\n3 1 1\n\n2 3 4\n\n3 3 6\n\n3 2 1\n\n4 4 12\n\n3 3 2 1\n\n6 8 8\n\n1 1 2 2 2 3\n\n```\n\n#### Output #1\n\n```\n4\n7\n0\n0\n1\n5\n6\n```\n\n### Note\n\nIn the first example, there are $4$ interesting pairs of integers:\n\n1. $(1, 2)$;\n2. $(1, 4)$;\n3. $(2, 3)$;\n4. $(3, 4)$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nusing ll = long long;\n\nll count_interesting_pairs(const vector<int>& a, ll min_range, ll max_range) {\n    ll count = 0;\n    int n = a.size();\n    for (int i = 0; i < n; ++i) {\n        // Binary search for range of valid pairs\n        auto itLow = lower_bound(a.begin() + i + 1, a.end(), min_range - a[i]);\n        auto itHigh = upper_bound(a.begin() + i + 1, a.end(), max_range - a[i]);\n        count += (itHigh - itLow); // Number of valid pairs for index i\n    }\n    return count;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n\n    vector<ll> results;\n    while (t--) {\n        int n;\n        ll x, y;\n        cin >> n >> x >> y;\n\n        vector<int> a(n);\n        ll total_sum = 0;\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            total_sum += a[i];\n        }\n\n        // Sort the array to use binary search\n        sort(a.begin(), a.end());\n\n        // Calculate the valid range for pair sums:\n        ll min_range = total_sum - y;\n        ll max_range = total_sum - x;\n\n        // Count the number of interesting pairs\n        ll count = count_interesting_pairs(a, min_range, max_range);\n        results.push_back(count);\n    }\n\n    // Output all results\n    for (ll result : results) {\n        cout << result << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2051c",
      "PROBLEM_ID": "2051C",
      "PROBLEM_STATEMENT": "Monocarp is preparing for his first exam at the university. There are $n$ different questions which can be asked during the exam, numbered from $1$ to $n$. There are $m$ different lists of questions; each list consists of exactly $n-1$ different questions. Each list $i$ is characterized by one integer $a_i$, which is the index of the only question which is not present in the $i$-th list. For example, if $n = 4$ and $a_i = 3$, the $i$-th list contains questions $[1, 2, 4]$.\n\nDuring the exam, Monocarp will receive one of these $m$ lists of questions. Then, the professor will make Monocarp answer all questions from the list. So, Monocarp will pass only if he knows all questions from the list.\n\nMonocarp knows the answers for $k$ questions $q_1, q_2, \\dots, q_k$. For each list, determine if Monocarp will pass the exam if he receives that list.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of three lines:\n\n- the first line contains three integers $n$, $m$ and $k$ ($2 \\le n \\le 3 \\cdot 10^5$; $1 \\le m, k \\le n$);\n- the second line contains $m$ distinct integers $a_1, a_2, \\dots, a_m$ ($1 \\le a_i \\le n$; $a_i < a_{i+1}$);\n- the third line contains $k$ distinct integers $q_1, q_2, \\dots, q_k$ ($1 \\le q_i \\le n$; $q_i < q_{i+1}$).\n\nAdditional constraints on the input:\n\n- the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a string of $m$ characters. The $i$-th character should be 1 if Monocarp passes the exam if he receives the $i$-th question list, 0 if Monocarp won't pass.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4 4 3\n\n1 2 3 4\n\n1 3 4\n\n5 4 3\n\n1 2 3 4\n\n1 3 4\n\n4 4 4\n\n1 2 3 4\n\n1 2 3 4\n\n2 2 1\n\n1 2\n\n2\n\n```\n\n#### Output #1\n\n```\n0100\n0000\n1111\n10\n```\n\n### Note\n\nIn the first test case, Monocarp knows the questions $[1, 3, 4]$. Let's consider all the question lists:\n\n- the first list consists of questions $[2, 3, 4]$. Monocarp doesn't know the $2$-nd question, so he won't pass;\n- the second list consists of questions $[1, 3, 4]$. Monocarp knows all these questions, so he will pass;\n- the third list consists of questions $[1, 2, 4]$. Monocarp doesn't know the $2$-nd question, so he won't pass;\n- the fourth list consists of questions $[1, 2, 3]$. Monocarp doesn't know the $2$-nd question, so he won't pass.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        vector<int> a(m);\n        for (int i = 0; i < m; ++i) {\n            cin >> a[i];\n        }\n        vector<int> q(k);\n        for (int i = 0; i < k; ++i) {\n            cin >> q[i];\n        }\n        vector<bool> known(n + 1, false);\n        for (int x : q) {\n            known[x] = true;\n        }\n        vector<int> U;\n        for (int x = 1; x <= n; ++x) {\n            if (!known[x]) {\n                U.push_back(x);\n            }\n        }\n        int size = U.size();\n        if (size == 0) {\n            string res(m, '1');\n            cout << res << endl;\n        } else if (size == 1) {\n            int u = U[0];\n            string res;\n            for (int x : a) {\n                res += (x == u) ? '1' : '0';\n            }\n            cout << res << endl;\n        } else {\n            string res(m, '0');\n            cout << res << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2051b",
      "PROBLEM_ID": "2051B",
      "PROBLEM_STATEMENT": "Monocarp decided to embark on a long hiking journey.\n\nHe decided that on the first day he would walk $a$ kilometers, on the second day he would walk $b$ kilometers, on the third day he would walk $c$ kilometers, on the fourth day, just like on the first, he would walk $a$ kilometers, on the fifth day, just like on the second, he would walk $b$ kilometers, on the sixth day, just like on the third, he would walk $c$ kilometers, and so on.\n\nMonocarp will complete his journey on the day when he has walked at least $n$ kilometers in total. Your task is to determine the day on which Monocarp will complete his journey.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of one line containing four integers $n$, $a$, $b$, $c$ ($1 \\le n \\le 10^9$; $1 \\le a, b, c \\le 10^6$).\n\n### Output\n\nFor each test case, output one integer \u2014 the day on which Monocarp will have walked at least $n$ kilometers in total and will complete his journey.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n12 1 5 3\n\n6 6 7 4\n\n16 3 4 1\n\n1000000000 1 1 1\n\n```\n\n#### Output #1\n\n```\n5\n1\n6\n1000000000\n```\n\n### Note\n\nIn the first example, over the first four days, Monocarp will cover $1 + 5 + 3 + 1 = 10$ kilometers. On the fifth day, he will cover another $5$ kilometers, meaning that in total over five days he will have covered $10 + 5 = 15$ kilometers. Since $n = 12$, Monocarp will complete his journey on the fifth day.\n\nIn the second example, Monocarp will cover $6$ kilometers on the first day. Since $n = 6$, Monocarp will complete his journey on the very first day.\n\nIn the third example, Monocarp will cover $3 + 4 + 1 + 3 + 4 + 1 = 16$ kilometers over the first six days. Since $n = 16$, Monocarp will complete his journey on the sixth day.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid solve() {\n    long long n, a, b, c;\n    cin >> n >> a >> b >> c;\n    \n    // Calculate how many complete cycles of 3 days are needed\n    long long cycle_sum = a + b + c;\n    long long complete_cycles = (n - 1) / cycle_sum;\n    long long remaining = n - complete_cycles * cycle_sum;\n    \n    long long day = complete_cycles * 3;\n    \n    if (remaining <= 0) {\n        day = max(1LL, day);\n    } else {\n        // Handle the remaining distance\n        long long curr_sum = 0;\n        // Try each day until we reach or exceed the remaining distance\n        if (curr_sum < remaining) {\n            curr_sum += a;\n            day++;\n        }\n        if (curr_sum < remaining) {\n            curr_sum += b;\n            day++;\n        }\n        if (curr_sum < remaining) {\n            curr_sum += c;\n            day++;\n        }\n    }\n    \n    cout << day << \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2051a",
      "PROBLEM_ID": "2051A",
      "PROBLEM_STATEMENT": "Monocarp and Stereocarp are preparing for the Olympiad. There are $n$ days left until the Olympiad. On the $i$-th day, if Monocarp plans to practice, he will solve $a_i$ problems. Similarly, if Stereocarp plans to practice on the same day, he will solve $b_i$ problems.\n\nMonocarp can train on any day he wants. However, Stereocarp watches Monocarp and follows a different schedule: if Monocarp trained on day $i$ and $i < n$, then Stereocarp will train on day $(i+1)$.\n\nMonocarp wants to organize his training process in a way that the difference between the number of problems he solves and the number of problems Stereocarp solves is as large as possible. Formally, Monocarp wants to maximize the value of $(m-s)$, where $m$ is the number of problems he solves, and $s$ is the number of problems Stereocarp solves. Help Monocarp determine the maximum possible difference in the number of solved problems between them.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^3$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 100$).\n\nThe third line contains $n$ integers $b_1, b_2, \\dots, b_n$ ($1 \\le b_i \\le 100$).\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the maximum possible difference between the number of problems Monocarp solves and the number of problems Stereocarp solves.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n3 2\n\n2 1\n\n1\n\n5\n\n8\n\n3\n\n1 1 1\n\n2 2 2\n\n6\n\n8 2 5 6 2 6\n\n8 2 7 4 3 4\n\n```\n\n#### Output #1\n\n```\n4\n5\n1\n16\n```\n\n### Note\n\nLet's analyze the example from the statement:\n\n- In the first test case, it is optimal for Monocarp to train both days; then Stereocarp will train on day $2$.\n- In the second test case, it is optimal for Monocarp to train on the only day, and Stereocarp will not train at all.\n- In the third test case, it is optimal for Monocarp to train on the last day (and only on that day).\n- In the fourth test case, it is optimal for Monocarp to train on days $1, 3, 4, 6$; then Stereocarp will train on days $2, 4, 5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    \n    // Input arrays\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) cin >> b[i];\n    \n    // dp[i][j] represents the maximum difference achievable considering days [i..n-1]\n    // where j indicates if Stereocarp will train on day i (due to Monocarp's training on day i-1)\n    vector<vector<int>> dp(n + 1, vector<int>(2, INT_MIN));\n    dp[n][0] = dp[n][1] = 0;\n    \n    // Going backwards from last day\n    for(int i = n-1; i >= 0; i--) {\n        // Case when Stereocarp is not training on current day\n        dp[i][0] = max({\n            // Monocarp trains today (Stereocarp will train tomorrow if not last day)\n            a[i] + (i == n-1 ? dp[i+1][0] : dp[i+1][1]),\n            // Monocarp doesn't train today\n            dp[i+1][0]\n        });\n        \n        // Case when Stereocarp is training on current day\n        dp[i][1] = max({\n            // Monocarp trains today (Stereocarp will train tomorrow if not last day)\n            a[i] - b[i] + (i == n-1 ? dp[i+1][0] : dp[i+1][1]),\n            // Monocarp doesn't train today\n            -b[i] + dp[i+1][0]\n        });\n    }\n    \n    cout << dp[0][0] << \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int t;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2050g",
      "PROBLEM_ID": "2050G",
      "PROBLEM_STATEMENT": "Given a tree$^{\\text{\u2217}}$ with $n$ vertices. You can choose two vertices $a$ and $b$ once and remove all vertices on the path from $a$ to $b$, including the vertices themselves. If you choose $a=b$, only one vertex will be removed.\n\nYour task is to find the maximum number of connected components$^{\\text{\u2020}}$ that can be formed after removing the path from the tree.\n\n$^{\\text{\u2217}}$A tree is a connected graph without cycles.\n\n$^{\\text{\u2020}}$A connected component is a set of vertices such that there is a path along the edges from any vertex to any other vertex in the set (and it is not possible to reach vertices not belonging to this set)\n\n### Input\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the size of the tree.\n\nThe next $n-1$ lines contain two integers $u$ and $v$ ($1 \\le u, v \\le n$, $u \\ne v$)\u00a0\u2014 the vertices connected by an edge. It is guaranteed that the edges form a tree.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the maximum number of connected components that can be achieved using the described operation.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n2\n\n1 2\n\n5\n\n1 2\n\n2 3\n\n3 4\n\n3 5\n\n4\n\n1 2\n\n2 3\n\n3 4\n\n5\n\n2 1\n\n3 1\n\n4 1\n\n5 4\n\n6\n\n2 1\n\n3 1\n\n4 1\n\n5 3\n\n6 3\n\n6\n\n2 1\n\n3 2\n\n4 2\n\n5 3\n\n6 4\n\n```\n\n#### Output #1\n\n```\n1\n3\n2\n3\n4\n3\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        // Initialize adjacency list\n        vector<vector<int>> adj(n+1, vector<int>());\n        // Initialize degrees\n        vector<int> degree(n+1, 0);\n        for(int i=0;i<n-1;i++){\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            degree[u]++;\n            degree[v]++;\n        }\n        // Assign weights\n        vector<int> weight(n+1, 0);\n        for(int vtx=1; vtx<=n; vtx++) {\n            weight[vtx] = degree[vtx] - 2;\n        }\n        // Find maximum degree\n        int max_degree = 0;\n        for(int vtx=1; vtx<=n; vtx++) {\n            if(degree[vtx] > max_degree){\n                max_degree = degree[vtx];\n            }\n        }\n        // Initialize for iterative DFS\n        // We need to store for each node its max_down_sum\n        vector<long long> max_down(n+1, 0);\n        // Initialize global max path sum\n        long long global_max = LLONG_MIN;\n        // Choose root as node 1\n        int root = 1;\n        // Stack elements: (node, parent, state)\n        // state = 0: pre-processing\n        // state = 1: post-processing\n        stack<tuple<int, int, bool>> stk;\n        stk.emplace(root, -1, false);\n        while(!stk.empty()){\n            auto [node, parent, processed] = stk.top();\n            stk.pop();\n            if(!processed){\n                // Push post-processing\n                stk.emplace(node, parent, true);\n                // Push children for processing\n                for(auto &child: adj[node]){\n                    if(child != parent){\n                        stk.emplace(child, node, false);\n                    }\n                }\n            }\n            else{\n                // Post-processing\n                long long curr_weight = (long long)weight[node];\n                // Find top two max_down from children\n                long long first = 0, second = 0;\n                for(auto &child: adj[node]){\n                    if(child != parent){\n                        if(max_down[child] > first){\n                            second = first;\n                            first = max_down[child];\n                        }\n                        else if(max_down[child] > second){\n                            second = max_down[child];\n                        }\n                    }\n                }\n                // Calculate path sum with current node\n                long long path_sum = curr_weight;\n                if(first > 0){\n                    path_sum += first;\n                }\n                if(second > 0){\n                    path_sum += second;\n                }\n                // Update global max path sum\n                global_max = max(global_max, path_sum);\n                // Update max_down for current node\n                long long current_max_down = curr_weight;\n                if(first > 0){\n                    current_max_down += first;\n                }\n                max_down[node] = current_max_down;\n            }\n        }\n        // Compute the answer\n        // The number of connected components is max(max_degree, global_max +2)\n        // However, global_max can be negative, so ensure to handle it\n        long long option1 = max_degree;\n        long long option2;\n        if(global_max == LLONG_MIN){\n            option2 = 0; // No path selected\n        }\n        else{\n            option2 = global_max + 2;\n        }\n        // The answer is the maximum of the two options\n        long long answer = max(option1, option2);\n        cout << answer << \"\\n\";\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2050c",
      "PROBLEM_ID": "2050C",
      "PROBLEM_STATEMENT": "You are given a number $n$ with a length of no more than $10^5$.\n\nYou can perform the following operation any number of times: choose one of its digits, square it, and replace the original digit with the result. The result must be a digit (that is, if you choose the digit $x$, then the value of $x^2$ must be less than $10$).\n\nIs it possible to obtain a number that is divisible by $9$ through these operations?\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains the number $n$, without leading zeros. The length of the number does not exceed $10^5$.\n\nIt is guaranteed that the sum of the lengths of the numbers across all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output \"YES\" if it is possible to obtain a number divisible by $9$ using the described operations, and \"NO\" otherwise.\n\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n123\n\n322\n\n333333333333\n\n9997\n\n5472778912773\n\n1234567890\n\n23\n\n33\n\n52254522632\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nYES\nNO\nNO\nYES\nNO\nYES\nYES\n```\n\n### Note\n\nIn the first example, from the integer $123$, it is possible to obtain only $123$, $143$, $129$, and $149$, none of which are divisible by $9$.\n\nIn the second example, you need to replace the second digit with its square; then $n$ will equal $342 = 38 \\cdot 9$.\n\nIn the third example, the integer is already divisible by $9$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--){\n        string n;\n        cin >> n;\n        long long S =0;\n        int c2=0, c3=0;\n        for(char ch: n){\n            int d = ch - '0';\n            S += d;\n            if(d ==2) c2++;\n            if(d ==3) c3++;\n        }\n        int target = (9 - (S %9)) %9;\n        bool possible = false;\n        int max_b = min((int)c3, 8);\n        for(int b=0; b<=max_b; b++){\n            // Compute (target -6*b) mod9\n            int temp = (target - 6*b) %9;\n            if(temp <0) temp +=9;\n            // a_needed = (temp *5) mod9\n            int a_needed = (temp *5) %9;\n            if(a_needed <=c2){\n                possible = true;\n                break;\n            }\n        }\n        if(possible){\n            cout << \"YES\\n\";\n        }\n        else{\n            cout << \"NO\\n\";\n        }\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2050b",
      "PROBLEM_ID": "2050B",
      "PROBLEM_STATEMENT": "You are given an array $a$ of length $n$. In one operation, you can pick an index $i$ from $2$ to $n-1$ inclusive, and do one of the following actions:\n\n- Decrease $a_{i-1}$ by $1$, then increase $a_{i+1}$ by $1$.\n\n- Decrease $a_{i+1}$ by $1$, then increase $a_{i-1}$ by $1$.\n\nAfter each operation, all the values must be non-negative. Can you make all the elements equal after any number of operations?\n\n### Input\n\nFirst line of input consists of one integer $t$ ($1 \\le t \\le 10^4$) \u00a0\u2014 the number of test cases.\n\nFirst line of each test case consists of one integer $n$ ($3 \\le n \\le 2\\cdot 10^5$).\n\nSecond line of each test case consists of $n$ integers $a_i$ ($1 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ of all test cases doesn't exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, print \"YES\" without quotation marks if it is possible to make all the elements equal after any number of operations; otherwise, print \"NO\" without quotation marks.\n\nYou can print answers in any register: \"yes\", \"YeS\", \"nO\" \u00a0\u2014 will also be considered correct.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n3\n\n3 2 1\n\n3\n\n1 1 3\n\n4\n\n1 2 5 4\n\n4\n\n1 6 6 1\n\n5\n\n6 2 1 4 2\n\n4\n\n1 4 2 1\n\n5\n\n3 1 2 1 3\n\n3\n\n2 4 2\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMakeEqual(vector<int>& a, int n) {\n    long long sum = 0;\n    for (int num : a) {\n        sum += num;\n    }\n    if (sum % n != 0) {\n        return false;\n    }\n    long long target = sum / n;\n    long long oddSum = 0, evenSum = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            evenSum += a[i];\n        } else {\n            oddSum += a[i];\n        }\n    }\n    // We need to check if the oddSum and evenSum can be adjusted to match the target\n    // Since the operations cannot change the first and last elements, but can shuffle the rest,\n    // the key is that the sum of elements at even positions and odd positions must be such\n    // that after redistribution, all elements can be equal.\n    // However, since the operations can only redistribute between even and odd positions,\n    // the sum of even and odd positions must be consistent with the target.\n    // The sum of all even positions should be equal to (target * (number of even positions)),\n    // and similarly for odd positions.\n    int numEven = (n + 1) / 2;\n    int numOdd = n / 2;\n    if (evenSum == target * numEven && oddSum == target * numOdd) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        if (canMakeEqual(a, n)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2050a",
      "PROBLEM_ID": "2050A",
      "PROBLEM_STATEMENT": "Kostya has a text $s$ consisting of $n$ words made up of Latin alphabet letters. He also has two strips on which he must write the text. The first strip can hold $m$ characters, while the second can hold as many as needed.\n\nKostya must choose a number $x$ and write the first $x$ words from $s$ on the first strip, while all the remaining words are written on the second strip. To save space, the words are written without gaps, but each word must be entirely on one strip.\n\nSince space on the second strip is very valuable, Kostya asks you to choose the maximum possible number $x$ such that all words $s_1, s_2, \\dots, s_x$ fit on the first strip of length $m$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 50$; $1 \\le m \\le 500$) \u2014 the number of words in the list and the maximum number of characters that can be on the first strip.\n\nThe next $n$ lines contain one word $s_i$ of lowercase Latin letters, where the length of $s_i$ does not exceed $10$.\n\n### Output\n\nFor each test case, output the maximum number of words $x$ such that the first $x$ words have a total length of no more than $m$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3 1\n\na\n\nb\n\nc\n\n2 9\n\nalpha\n\nbeta\n\n4 12\n\nhello\n\nworld\n\nand\n\ncodeforces\n\n3 2\n\nab\n\nc\n\nd\n\n3 2\n\nabc\n\nab\n\na\n\n```\n\n#### Output #1\n\n```\n1\n2\n2\n1\n0\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<string> words(n);\n    for(int i = 0; i < n; i++) {\n        cin >> words[i];\n    }\n    \n    int totalLength = 0;\n    int count = 0;\n    \n    // Try to add words one by one\n    for(int i = 0; i < n; i++) {\n        // If current word's length is more than remaining space\n        if(totalLength + words[i].length() > m) {\n            break;\n        }\n        totalLength += words[i].length();\n        count++;\n    }\n    \n    cout << count << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2049c",
      "PROBLEM_ID": "2049C",
      "PROBLEM_STATEMENT": "Evirir the dragon has many friends. They have 3 friends! That is one more than the average dragon.\n\nYou are given integers $n$, $x$, and $y$. There are $n$ dragons sitting in a circle. The dragons are numbered $1, 2, \\ldots, n$. For each $i$ ($1 \\le i \\le n$), dragon $i$ is friends with dragon $i - 1$ and $i + 1$, where dragon $0$ is defined to be dragon $n$ and dragon $n + 1$ is defined to be dragon $1$. Additionally, dragons $x$ and $y$ are friends with each other (if they are already friends, this changes nothing). Note that all friendships are mutual.\n\nOutput $n$ non-negative integers $a_1, a_2, \\ldots, a_n$ such that for each dragon $i$ ($1 \\le i \\le n$), the following holds:\n\n- Let $f_1, f_2, \\ldots, f_k$ be the friends of dragon $i$. Then $a_i = \\operatorname{mex}(a_{f_1}, a_{f_2}, \\ldots, a_{f_k})$.$^{\\text{\u2217}}$\n\n$^{\\text{\u2217}}$The minimum excluded (MEX) of a collection of integers $c_1, c_2, \\ldots, c_m$ is defined as the smallest non-negative integer $t$ which does not occur in the collection $c$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first and only line of each test case contains three integers $n$, $x$, $y$ ($3 \\le n \\le 2 \\cdot 10^5$, $1 \\le x < y \\le n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n$ space-separated non-negative integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) on a line that satisfy the condition in the statement. If there are multiple solutions, print any of them. It can be proven that under the problem constraints, a solution with $0 \\le a_i \\le 10^9$ always exists.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n5 1 3\n\n4 2 4\n\n6 3 5\n\n7 3 6\n\n3 2 3\n\n5 1 5\n\n6 2 5\n\n```\n\n#### Output #1\n\n```\n0 2 1 0 1\n1 2 1 0\n1 2 0 1 2 0\n0 1 2 0 1 0 1\n2 0 1\n1 0 2 1 0\n0 1 2 0 2 1\n```\n\n### Note\n\nFor the first test case:\n\n- $i = 1$: Dragon $1$'s friends are dragons $2, 3, 5$. $\\operatorname{mex}(a_2, a_3, a_5) = \\operatorname{mex}(2, 1, 1) = 0 = a_1$, so the condition for dragon $1$ is satisfied.\n- $i = 2$: Dragon $2$'s friends are dragons $1, 3$. $\\operatorname{mex}(a_1, a_3) = \\operatorname{mex}(0, 1) = 2 = a_2$.\n- $i = 3$: Dragon $3$'s friends are dragons $1, 2, 4$. $\\operatorname{mex}(a_1, a_2, a_4) = \\operatorname{mex}(0, 2, 0) = 1 = a_3$.\n- $i = 4$: Dragon $4$'s friends are dragons $3, 5$. $\\operatorname{mex}(a_3, a_5) = \\operatorname{mex}(1, 1) = 0 = a_4$.\n- $i = 5$: Dragon $5$'s friends are dragons $1, 4$. $\\operatorname{mex}(a_1, a_4) = \\operatorname{mex}(0, 0) = 1 = a_5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, x, y;\n        cin >> n >> x >> y;\n        \n        // Making 1-indexed (as per problem)\n        vector<int> answer(n + 1, 0);\n        \n        // Special values for a start\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                answer[i] = 0;\n            } else {\n                answer[i] = 1;\n            }\n        }\n        \n        // Create graph to represent friendships\n        vector<vector<int>> friends(n + 1);\n        for (int i = 1; i <= n; i++) {\n            friends[i].push_back(i == 1 ? n : i - 1);\n            friends[i].push_back(i == n ? 1 : i + 1);\n        }\n        \n        // Add the extra friendship\n        if (abs(x - y) != 1 && abs(x - y) != n - 1) {\n            friends[x].push_back(y);\n            friends[y].push_back(x);\n        }\n        \n        // Assign values to ensure MEX property\n        for (int iterations = 0; iterations < 100; iterations++) {\n            bool changed = false;\n            \n            for (int i = 1; i <= n; i++) {\n                vector<int> friendValues;\n                for (int friend_id : friends[i]) {\n                    friendValues.push_back(answer[friend_id]);\n                }\n                \n                // Calculate MEX\n                set<int> present(friendValues.begin(), friendValues.end());\n                int mex = 0;\n                while (present.count(mex)) mex++;\n                \n                if (answer[i] != mex) {\n                    answer[i] = mex;\n                    changed = true;\n                }\n            }\n            \n            if (!changed) break;\n        }\n        \n        // Output the result\n        for (int i = 1; i <= n; i++) {\n            cout << answer[i] << (i == n ? '\\n' : ' ');\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2049b",
      "PROBLEM_ID": "2049B",
      "PROBLEM_STATEMENT": "Cats are attracted to pspspsps, but Evirir, being a dignified dragon, is only attracted to pspspsps with oddly specific requirements...\n\nGiven a string $s = s_1s_2\\ldots s_n$ of length $n$ consisting of characters p, s, and . (dot), determine whether a permutation$^{\\text{\u2217}}$ $p$ of length $n$ exists, such that for all integers $i$ ($1 \\le i \\le n$):\n\n- If $s_i$ is p, then $[p_1, p_2, \\ldots, p_i]$ forms a permutation (of length $i$);\n- If $s_i$ is s, then $[p_i, p_{i+1}, \\ldots, p_{n}]$ forms a permutation (of length $n-i+1$);\n- If $s_i$ is ., then there is no additional restriction.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 500$), the length of $s$.\n\nThe second line of each test case contains a string $s$ of length $n$ that consists of the characters p, s, and ..\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, output YES or NO on a line. Output YES if there is such a permutation and NO otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n4\n\ns.sp\n\n6\n\npss..s\n\n5\n\nppppp\n\n2\n\nsp\n\n4\n\n.sp.\n\n8\n\npsss....\n\n1\n\n.\n\n8\n\npspspsps\n\n20\n\n....................\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nYES\nNO\nNO\nYES\nNO\nYES\n```\n\n### Note\n\nFor the first test case, one permutation that works is $p = [3, 4, 1, 2]$. The restrictions are as follows:\n\n- $s_1 =$ s: $[p_1, p_2, p_3, p_4] = [3, 4, 1, 2]$ forms a permutation.\n- $s_2 =$ .: No additional restriction.\n- $s_3 =$ s: $[p_3, p_4] = [1, 2]$ forms a permutation.\n- $s_4 =$ p: $[p_1, p_2, p_3, p_4] = [3, 4, 1, 2]$ forms a permutation.\n\nFor the second test case, it can be proven that there is no permutation that satisfies all restrictions.\n\nFor the third test case, one permutation that satisfies the constraints is $p = [1, 2, 3, 4, 5]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <functional>\n\nusing namespace std;\n\nbool check_permutation(int n, const string& s) {\n    // possible[val][pos] = true if value 'val' can be placed at position 'pos'\n    vector<vector<bool>> possible(n + 1, vector<bool>(n + 1, true));\n    \n    for (int i = 1; i <= n; i++) {\n        if (s[i - 1] == 'p') {\n            // Values 1 to i must be in positions 1 to i (as a permutation)\n            // Values 1 to i can't be in positions i+1 to n\n            for (int val = 1; val <= i; val++) {\n                for (int pos = i + 1; pos <= n; pos++) {\n                    possible[val][pos] = false;\n                }\n            }\n            \n            // Values i+1 to n can't be in positions 1 to i\n            for (int val = i + 1; val <= n; val++) {\n                for (int pos = 1; pos <= i; pos++) {\n                    possible[val][pos] = false;\n                }\n            }\n        } else if (s[i - 1] == 's') {\n            // Values 1 to (n-i+1) must be in positions i to n (as a permutation)\n            // Values 1 to (n-i+1) can't be in positions 1 to i-1\n            for (int val = 1; val <= n - i + 1; val++) {\n                for (int pos = 1; pos <= i - 1; pos++) {\n                    possible[val][pos] = false;\n                }\n            }\n            \n            // Values (n-i+2) to n can't be in positions i to n\n            for (int val = n - i + 2; val <= n; val++) {\n                for (int pos = i; pos <= n; pos++) {\n                    possible[val][pos] = false;\n                }\n            }\n        }\n    }\n    \n    // Check if there's a perfect matching using bipartite matching algorithm\n    vector<int> match(n + 1, 0);  // match[pos] = val assigned to position 'pos'\n    vector<bool> vis(n + 1);\n    \n    function<bool(int)> dfs = [&](int u) {\n        for (int v = 1; v <= n; v++) {\n            if (possible[u][v] && !vis[v]) {\n                vis[v] = true;\n                if (match[v] == 0 || dfs(match[v])) {\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    \n    for (int i = 1; i <= n; i++) {\n        fill(vis.begin(), vis.end(), false);\n        if (!dfs(i)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        string s;\n        cin >> s;\n        \n        if (check_permutation(n, s)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2049a",
      "PROBLEM_ID": "2049A",
      "PROBLEM_STATEMENT": "Evirir the dragon snuck into a wizard's castle and found a mysterious contraption, and their playful instincts caused them to play with (destroy) it...\n\nEvirir the dragon found an array $a_1, a_2, \\ldots, a_n$ of $n$ non-negative integers.\n\nIn one operation, they can choose a non-empty subarray$^{\\\\text{\u2217}}$ $b$ of $a$ and replace it with the integer $\\\\operatorname{mex}(b)$$^{\\\\text{\u2020}}$. They want to use this operation any number of times to make $a$ only contain zeros. It can be proven that this is always possible under the problem constraints.\n\nWhat is the minimum number of operations needed?\n\n$^{\\text{\u2217}}$An array $c$ is a subarray of an array $d$ if $c$ can be obtained from $d$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n$^{\\text{\u2020}}$The minimum excluded (MEX) of a collection of integers $f_1, f_2, \\ldots, f_k$ is defined as the smallest non-negative integer $x$ which does not occur in the collection $f$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 200$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 50$), the length of $a$.\n\nThe second line of each test case contains $n$ space-separated integers, $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 100$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $500$.\n\n### Output\n\nFor each test case, output a single integer on a line, the minimum number of operations needed to make $a$ contain only zeros.\n\n### Example\n\n#### Input #1\n\n```\n\n10\n\n4\n\n0 1 2 3\n\n6\n\n0 0 0 0 0 0\n\n5\n\n1 0 1 0 1\n\n5\n\n3 1 4 1 5\n\n4\n\n3 2 1 0\n\n7\n\n9 100 0 89 12 2 3\n\n4\n\n0 3 9 0\n\n7\n\n0 7 0 2 0 7 0\n\n1\n\n0\n\n2\n\n0 1\n\n```\n\n#### Output #1\n\n```\n1\n0\n2\n1\n1\n2\n1\n2\n0\n1\n```\n\n### Note\n\nIn the first test case, Evirir can choose the subarray $b = [1, 2, 3]$ and replace it with $\\operatorname{mex}(1, 2, 3) = 0$, changing $a$ from $[0, \\underline{1, 2, 3}]$ to $[0, 0]$ (where the chosen subarray is underlined). Therefore, the answer is $1$.\n\nIn the second test case, $a$ already contains only $0$s, so no operation is needed.\n\nIn the third test case, Evirir can change $a$ as follows: $[1, \\underline{0, 1, 0, 1}] \\to [\\underline{1, 2}] \\to [0]$. Here, $\\operatorname{mex}(0, 1, 0, 1) = 2$ and $\\operatorname{mex}(1, 2) = 0$.\n\nIn the fourth test case, Evirir can choose $b$ to be the entire array $a$, changing $a$ from $[\\underline{3, 1, 4, 1, 5}]$ to $[0]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        int ans = 0;\n        while (true) {\n            bool found = false;\n            for (int i = 0; i < n; i++) {\n                if (a[i] != 0) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) break;\n            int l = 0, r = n - 1;\n            while (a[l] == 0) l++;\n            while (a[r] == 0) r--;\n            vector<int> cnt(r - l + 1, 0);\n            for (int i = l; i <= r; i++) {\n                if (a[i] <= r - l) cnt[a[i]]++;\n            }\n            int mex = 0;\n            while (cnt[mex]) mex++;\n            for (int i = l; i <= r; i++) {\n                a[i] = 0;\n            }\n            a[l] = mex;\n            ans++;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2048i2",
      "PROBLEM_ID": "2048I2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the versions is that in this version, you need to count the number of good arrays. You can hack only if you solved all versions of this problem.\n\nKevin is visiting the Red Church, and he found a puzzle on the wall.\n\nFor an array $ a $, let $ c(l,r) $ indicate how many distinct numbers are among $ a_l, a_{l+1}, \\ldots, a_r $. In particular, if $ l > r $, define $ c(l,r) = 0 $.\n\nYou are given a string $ s $ of length $ n $ consisting of letters $ \\texttt{L} $ and $ \\texttt{R} $ only. Let a non-negative array $ a $ be called good, if the following conditions hold for $ 1 \\leq i \\leq n $:\n\n- if $s_i=\\verb!L!$, then $c(1,i-1)=a_i$;\n- if $s_i=\\verb!R!$, then $c(i+1,n)=a_i$.\n\nYou need to count the number of good arrays $a$. Since the answer may be large, you only need to output the answer modulo $998\\,244\\,353$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1\\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2\\leq n\\leq 2\\cdot 10^5$)\u00a0\u2014 the length of string $s$.\n\nThe second line of each test case contains a string $s$ with a length $n$, containing only English uppercase letters $\\verb!L!$ and $\\verb!R!$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output the number of good arrays modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\nLLR\n\n3\n\nRRL\n\n4\n\nRRLR\n\n5\n\nLLRLR\n\n```\n\n#### Output #1\n\n```\n1\n2\n0\n1\n```\n\n### Note\n\nAll arrays satisfying the conditions can be found in the easy version of this problem.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<stdio.h>\n#include<string.h>\nconst int N=200000;\nconst int W=64;\nconst int M=((N+W-1)/W);\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nchar*cc;\nunsigned long long aa[M],bb[M];\nint n;\nvoid init(){\n\tint m,i;\n\tm=(n+W-1)/W;\n\tmemset(aa,0,m*sizeof *aa);\n\tmemset(bb,0,m*sizeof *bb);\n\tfor(i=0;i<n;i++)\n\t\tif(cc[i]=='R')\n\t\t\taa[i/W]|=1ULL<<i%W;\n\t\telse\n\t\t\tbb[(n-1-i)/W]|=1ULL<<(n-1-i)%W;\n}\nint check(int i,int j){\n\tint k;\n\tif(i>j)\n\t\treturn 0;\n\twhile(i<j){\n\t\tk=min(W-max(i%W,(n-1-j)%W),(j-i+1)/2);\n\t\tif(((aa[i/W]>>i%W&bb[(n-1-j)/W]>>(n-1-j)%W)&(k==W?0:1ULL<<k)-1)!=0)\n\t\t\treturn 0;\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn 1;\n}\nint main(){\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--){\n\t\tstatic char s[N+1];\n\t\tint i,i_,i1,j,j_,j1,ans;\n\t\tscanf(\"%d%s\",&n,s);\n\t\tcc=s;\n\t\twhile(n>=2&&cc[0]=='L'&&cc[n-1]=='R'){\n\t\t\tcc++;\n\t\t\tn-=2;\n\t\t}\n\t\tif(n<=1)\n\t\t\tprintf(\"1\\n\");\n\t\telse{\n\t\t\tinit();\n\t\t\tif(cc[0]==cc[n-1])\n\t\t\t\tprintf(\"%d\\n\",check(0,n-1)?1:0);\n\t\t\telse{\n\t\t\t\ti=1;\n\t\t\t\tj=n-2;\n\t\t\t\tans=0;\n\t\t\t\twhile(1){\n\t\t\t\t\ti_=i;\n\t\t\t\t\twhile(cc[i_]!='L')\n\t\t\t\t\t\ti_++;\n\t\t\t\t\tj_=j;\n\t\t\t\t\twhile(cc[j_]!='R')\n\t\t\t\t\t\tj_--;\n\t\t\t\t\tans++;\n\t\t\t\t\tfor(i1=i;i1<i_;i1++)\n\t\t\t\t\t\tif(check(i1,j_))\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\tfor(j1=j;j1>j_;j1--)\n\t\t\t\t\t\tif(check(i_,j1))\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\tif(i_>j_)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ti=i_+1;\n\t\t\t\t\tj=j_-1;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2048g",
      "PROBLEM_ID": "2048G",
      "PROBLEM_STATEMENT": "Kevin has been transported to Sacred Heart Hospital, which contains all the $ n \\times m $ matrices with integer values in the range $ [1,v] $.\n\nNow, Kevin wants to befriend some matrices, but he is willing to befriend a matrix $ a $ if and only if the following condition is satisfied:\n\n\n\n$$ \\min_{1\\le i\\le n}\\left(\\max_{1\\le j\\le m}a_{i,j}\\right)\\le\\max_{1\\le j\\le m}\\left(\\min_{1\\le i\\le n}a_{i,j}\\right). $$\n\nPlease count how many matrices in Sacred Heart Hospital can be friends with Kevin.\n\nSince Kevin is very friendly, there could be many matrices that meet this condition. Therefore, you only need to output the result modulo $998\\,244\\,353$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $ t $ ($ 1 \\le t \\le 8\\cdot 10^3 $).\n\nThe only line of each test case contains three integers $n$, $m$, $v$ ($ 1 \\le n, v, n \\cdot v \\leq 10^6$, $1 \\le m \\le 10^9 $).\n\nIt is guaranteed that the sum of $ n \\cdot v $ over all test cases doesn't exceed $ 10^6 $.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the number of matrices that can be friends with Kevin modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2 2\n\n2 3 4\n\n11 45 14\n\n```\n\n#### Output #1\n\n```\n14\n2824\n883799966\n```\n\n### Note\n\nIn the first test case, besides the matrices $ a=\\begin{bmatrix}1&2\\\\2&1\\end{bmatrix} $ and $ a=\\begin{bmatrix}2&1\\\\1&2\\end{bmatrix} $, which do not satisfy the condition, the remaining $ 2^{2 \\cdot 2} - 2 = 14 $ matrices can all be friends with Kevin.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\n// Define the modulus\nconst long long MOD = 998244353;\n\n/**\n * @brief Computes (base^exp) % MOD using binary exponentiation.\n * Handles base = 0 correctly: 0^0 = 1, 0^exp = 0 for exp > 0.\n * @param base The base of the power.\n * @param exp The exponent.\n * @return (base^exp) % MOD.\n */\nlong long power(long long base, long long exp) {\n    long long res = 1;\n    base %= MOD;\n    // Definition: 0^0 = 1\n    if (base == 0 && exp == 0) return 1;\n    // If base is 0 and exp > 0, result is 0\n    if (base == 0) return 0; \n\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return res;\n}\n\n/**\n * @brief Computes the modular multiplicative inverse of n modulo MOD using Fermat's Little Theorem.\n * Assumes MOD is a prime number.\n * @param n The number to find the inverse of.\n * @return The modular inverse of n modulo MOD. Returns 0 if n is 0 (inverse undefined).\n */\nlong long modInverse(long long n) {\n    // Modular inverse is not defined for 0\n    if (n == 0) return 0; \n    // Using Fermat's Little Theorem: n^(MOD-2) % MOD\n    return power(n, MOD - 2);\n}\n\n// Precomputed factorials and inverse factorials for combinations\n// The maximum value of n is related to the constraint sum(n*v) <= 10^6. The max n could be 10^6.\nconst int MAXN_COMB = 1000001; \nlong long fact[MAXN_COMB];\nlong long invFact[MAXN_COMB];\n\n/**\n * @brief Precomputes factorials and their modular inverses up to n_max.\n * @param n_max The maximum value for which combinations might be needed.\n */\nvoid precompute_combinations(int n_max) {\n    // Ensure n_max does not exceed allocated buffer size\n    if (n_max >= MAXN_COMB) n_max = MAXN_COMB - 1; \n    fact[0] = 1;\n    invFact[0] = 1;\n    // Compute factorials\n    for (int i = 1; i <= n_max; ++i) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    // Compute inverse factorial for n_max using modular inverse\n    invFact[n_max] = modInverse(fact[n_max]);\n    // Compute inverse factorials downwards efficiently: invFact[i] = invFact[i+1] * (i+1)\n    for (int i = n_max - 1; i >= 1; --i) {\n        invFact[i] = (invFact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\n/**\n * @brief Computes modular combinations nCr % MOD using precomputed factorials.\n * @param n The total number of items.\n * @param r The number of items to choose.\n * @return (nCr) % MOD. Returns 0 if r < 0 or r > n.\n */\nlong long nCr_mod(int n, int r) {\n    if (r < 0 || r > n) return 0;\n    // Using the formula nCr = n! / (r! * (n-r)!)\n    // In modular arithmetic: nCr = fact[n] * invFact[r] * invFact[n-r] % MOD\n    return (((fact[n] * invFact[r]) % MOD) * invFact[n - r]) % MOD;\n}\n\n/**\n * @brief Computes the value N(k, l) based on the derived formula.\n * N(k, l) represents the count of matrices where L > l and R <= k.\n * The formula is: Sum_{i=0..n} C(n,i) * (-1)^(n-i) * ( (v^i * l^(n-i)) - ((v-k)^i * (l-k)^(n-i)) )^m % MOD.\n * @param n Number of rows.\n * @param m Number of columns.\n * @param v Maximum value for matrix entries.\n * @param k Parameter related to R constraint (R <= k).\n * @param l Parameter related to L constraint (L > l).\n * @return The computed value N(k, l) % MOD.\n */\nlong long compute_N(int n, long long m, int v, int k, int l) {\n    // Base case derived from the summation formula logic: N(k,l) for k=-1 is 0.\n    if (k < 0) return 0; \n\n    long long total_N = 0;\n    \n    // Precompute modular inverses needed for efficient power updates. Handle potential division by zero.\n    long long mod_l = (l == 0) ? 0 : modInverse(l);\n    // Calculate (l-k) ensuring it's non-negative modulo MOD\n    long long l_minus_k = (l - k + MOD) % MOD; \n    long long mod_lk = (l_minus_k == 0) ? 0 : modInverse(l_minus_k);\n\n    // Initial powers for i=0. Using v^0 = 1, (v-k)^0=1 etc.\n    long long v_pow_i = 1; \n    long long vk_pow_i = 1; \n    // Calculate l^n and (l-k)^n using modular exponentiation, handling base 0 case.\n    long long l_pow_ni = power(l, n); \n    long long lk_pow_ni = power(l_minus_k, n); \n\n    // Values needed for updates inside loop, ensured to be modulo MOD.\n    long long v_val = v % MOD; \n    long long vk_val = (v - k + MOD) % MOD; \n\n    // Loop through i from 0 to n to compute the summation terms.\n    for (int i = 0; i <= n; ++i) {\n        // Term Q = v^i * l^(n-i) % MOD\n        long long term_Q = (v_pow_i * l_pow_ni) % MOD;\n        \n        // Term P = (v-k)^i * (l-k)^(n-i) % MOD\n        long long term_P = (vk_pow_i * lk_pow_ni) % MOD;\n        \n        // Difference diff = (Q - P) % MOD\n        long long diff = (term_Q - term_P + MOD) % MOD;\n        \n        // Calculate diff^m % MOD\n        long long term_val = power(diff, m);\n\n        // Get combination C(n,i) % MOD\n        long long comb = nCr_mod(n, i);\n        \n        // Apply factor (-1)^(n-i). If (n-i) is odd, negate the term value.\n        if ((n - i) % 2 == 1) {\n            term_val = (MOD - term_val) % MOD;\n        }\n        \n        // Add the computed term to the total sum: total_N = (total_N + comb * term_val) % MOD\n        total_N = (total_N + (comb * term_val) % MOD) % MOD;\n\n        // Efficiently update powers for the next iteration (i+1)\n        if (i < n) {\n             // Update v^i -> v^(i+1) and (v-k)^i -> (v-k)^(i+1)\n             v_pow_i = (v_pow_i * v_val) % MOD;\n             vk_pow_i = (vk_pow_i * vk_val) % MOD;\n             \n             // Update l^(n-i) -> l^(n-(i+1)) by dividing by l (multiplying by modular inverse)\n             if (l != 0) {\n                 l_pow_ni = (l_pow_ni * mod_l) % MOD;\n             } else {\n                 // If l=0, l^x = 0 for x>0, 1 for x=0. Update l_pow_ni for exponent n-(i+1).\n                 l_pow_ni = (n - i - 1 == 0) ? 1 : 0;\n             }\n\n             // Update (l-k)^(n-i) -> (l-k)^(n-(i+1)) by dividing by (l-k)\n             if (l_minus_k != 0) {\n                lk_pow_ni = (lk_pow_ni * mod_lk) % MOD;\n             } else {\n                 // If l-k=0, (l-k)^x = 0 for x>0, 1 for x=0. Update lk_pow_ni for exponent n-(i+1).\n                 lk_pow_ni = (n - i - 1 == 0) ? 1 : 0;\n             }\n        }\n    }\n    return total_N;\n}\n\nint main() {\n    // Faster I/O operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // Precompute combinations required, up to the max possible N\n    precompute_combinations(1000000);\n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n_int, v_int; // Input variables for n and v\n        long long m; // Input variable for m (can be large)\n        std::cin >> n_int >> m >> v_int;\n        \n        // Use int types for n and v as per problem constraints\n        int n = n_int;\n        int v = v_int;\n\n        long long N_bad = 0; // Counter for the number of \"bad\" matrices (where L > R)\n        // Calculate N_bad using the formula: Sum_{k=1..v-1} (N(k, k) - N(k-1, k))\n        for (int k = 1; k < v; ++k) { // Loop through k from 1 to v-1\n             // N(k,k) represents matrices with L > k, R <= k\n             long long Nk = compute_N(n, m, v, k, k); \n             // N(k-1, k) represents matrices with L > k, R <= k-1\n             long long Nk_minus_1_k = compute_N(n, m, v, k - 1, k); \n             \n             // Calculate Sk = N(k, k) - N(k-1, k). This term counts matrices where L > k AND R = k.\n             long long Sk = (Nk - Nk_minus_1_k + MOD) % MOD;\n             // Accumulate the count of bad matrices\n             N_bad = (N_bad + Sk) % MOD; \n        }\n\n        // Calculate the total number of possible matrices: v^(n*m)\n        // Cast n*m to long long to avoid overflow if n*m is large\n        long long total_matrices = power(v, (long long)n * m);\n        \n        // The number of \"good\" matrices (where L <= R) is Total - N_bad\n        long long N_good = (total_matrices - N_bad + MOD) % MOD;\n        \n        // Output the result for the current test case\n        std::cout << N_good << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2048f",
      "PROBLEM_ID": "2048F",
      "PROBLEM_STATEMENT": "Kevin is a student from Eversleeping Town, currently attending a math class where the teacher is giving him division exercises.\n\nOn the board, there are two rows of positive integers written, each containing $ n $ numbers. The first row is $ a_1, a_2, \\ldots, a_n $, and the second row is $ b_1, b_2, \\ldots, b_n $.\n\nFor each division exercise, Kevin can choose any segment $ [l, r] $ and find the smallest value $ x $ among $ b_l, b_{l+1}, \\ldots, b_r $. He will then modify each $ a_i $ for $ l \\leq i \\leq r $ to be the ceiling of $ a_i $ divided by $ x $.\n\nFormally, he selects two integers $ 1 \\leq l \\leq r \\leq n $, sets $ x = \\min_{l \\leq i \\leq r} b_i $, and changes all $ a_i $ for $ l \\leq i \\leq r $ to $ \\lceil \\frac{a_i}{x} \\rceil $.\n\nKevin can leave class and go home when all $ a_i $ become $ 1 $. He is eager to leave and wants to know the minimum number of division exercises required to achieve this.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $ t $ ($ 1 \\le t \\le 10^4 $).\n\nThe first line of each test case contains an integer $ n $ ($ 1 \\le n \\leq 2 \\cdot 10^5 $)\u00a0\u2014 the length of the sequence $ a $ and $ b $.\n\nThe second line of each test case contains $ n $ integers $ a_1, a_2, \\ldots, a_n $ ($ 1 \\le a_i \\le 10^{18} $)\u00a0\u2014 the first row of integers on the board.\n\nThe third line of each test case contains $ n $ integers $ b_1, b_2, \\ldots, b_n $ ($ 2 \\le b_i \\le 10^{18} $)\u00a0\u2014 the second row of integers on the board.\n\nIt is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 2 \\cdot 10^5 $.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the minimum number of division exercises required to leave class.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n5 4 2\n\n6 3 2\n\n5\n\n3 6 1 3 2\n\n3 5 3 2 2\n\n6\n\n8 3 3 7 5 8\n\n3 2 3 4 2 3\n\n```\n\n#### Output #1\n\n```\n2\n3\n3\n```\n\n### Note\n\nFor the first test case: $ [{\\color{red}{5,4}},2]\\xrightarrow[\\min(b_1,b_2)=3]{\\text{operate segment }[1,2]}[{\\color{red}{2,2,2}}]\\xrightarrow[\\min(b_1,b_2,b_3)=2]{\\text{operate segment }[1,3]}[1,1,1] $.\n\nFor the second test case: $ [{\\color{red}{3,6,1}},3,2]\\xrightarrow[\\min(b_1,b_2,b_3)=3]{\\text{operate segment }[1,3]}[1,{\\color{red}{2,1,3}},2]\\xrightarrow[\\min(b_2,b_3,b_4)=2]{\\text{operate segment }[2,4]}[1,1,1,{\\color{red}{2,2}}]\\xrightarrow[\\min(b_4,b_5)=2]{\\text{operate segment }[4,5]}[1,1,1,1,1] $.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll _=2e5+5;\ninline void Min(ll &x,ll y){y<x?x=y:0;}\ninline void Max(ll &x,ll y){y>x?x=y:0;}\nll N,n,a[_],b[_],t,c[_],d[_][61],L[_],R[_];\nvoid p(ll x,ll l,ll r){\n\tll u=L[x],v=R[x],i,j;\n\tif(u)p(u,l,x-1);if(v)p(v,x+1,r);\n\tfor(i=0;i<61;i++){\n\t\td[x][i]=4e18;\n\t\tfor(j=0;j<=i;j++)Min(d[x][i],max(d[u][j],d[v][i-j]));\n\t\tMax(d[x][i],a[x]);\n\t\tif(i)Min(d[x][i],(d[x][i-1]-1)/b[x]+1);\n\t}\n}\nvoid P(){\n\tcin>>n;ll i;\n\tfor(i=0;i<61;i++)d[0][i]=1;\n\tfor(t=i=0;i<=n+1;i++)c[i]=L[i]=R[i]=0;\n\tfor(i=1;i<=n;i++)cin>>a[i];\n\tfor(i=1;i<=n;i++){\n\t\tcin>>b[i];\n\t\twhile(t&&b[i]<b[c[t]])L[i]=c[t],t--;\n\t\tR[c[t]]=i;c[++t]=i;\n\t}\n\tp(R[0],1,n);\n\tfor(i=0;i<61;i++)if(d[R[0]][i]==1)break;\n\tcout<<i<<'\\n';\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>N;while(N--)P();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2048e",
      "PROBLEM_ID": "2048E",
      "PROBLEM_STATEMENT": "The Arms Factory needs a poster design pattern and finds Kevin for help.\n\nA poster design pattern is a bipartite graph with $ 2n $ vertices in the left part and $ m $ vertices in the right part, where there is an edge between each vertex in the left part and each vertex in the right part, resulting in a total of $ 2nm $ edges.\n\nKevin must color each edge with a positive integer in the range $ [1, n] $. A poster design pattern is good if there are no monochromatic cycles$^{\\text{\u2217}}$ in the bipartite graph.\n\nKevin needs your assistance in constructing a good bipartite graph or informing him if it is impossible.\n\n$^{\\text{\u2217}}$A monochromatic cycle refers to a simple cycle in which all the edges are colored with the same color.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $ t $ ($ 1 \\le t \\le 100 $).\n\nThe only line of each test case contains two integers $ n $ and $ m $ ($ 1 \\le n, m \\leq 10^3 $)\u00a0\u2014 the bipartite graph has $ 2n $ vertices in the left part and $ m $ vertices in the right part.\n\nIt is guaranteed that both the sum of $ n $ and the sum of $ m $ over all test cases do not exceed $ 10^3 $.\n\n### Output\n\nFor each test case, if there is no solution, then output No.\n\nOtherwise, output Yes, and then output $ 2n $ lines, with each line containing $ m $ positive integers. The $ i $-th line's $ j $-th integer represents the color of the edge between the $ i $-th vertex in the left part and the $ j $-th vertex in the right part.\n\nIf there are multiple answers, you can print any of them.\n\nYou can output each letter in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2\n\n3 7\n\n5 4\n\n```\n\n#### Output #1\n\n```\nYES\n1 2\n2 1\n2 2\n2 1\nNO\nYES\n1 1 1 1\n1 2 2 2\n1 2 3 3\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n```\n\n### Note\n\nFor the first test case, the graph is shown as follows:\n\n![](https://espresso.codeforces.com/820af5656123195e8f3a7204d13e75d5825110b3.png)\n\nFor the second test case, it can be proven that there is no valid solution.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nbool testcases = true;\n\nvoid solve() {\n    int x, y;\n    cin >> x >> y;\n    if (x*2 <= y) {\n        cout << \"NO\" << endl;\n        return;\n    }\n    cout << \"YES\" << endl;\n    for (int i = 0; i < 2*x; i++) {\n        for (int j = 0; j < y; j++) cout <<(i-j+2*x)%(2*x)/2+1 << \" \";\n        cout << endl;\n    }\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int t;\n    t = 1;\n    if (testcases) {\n        cin >> t;\n    }\n    for (int i = 1; i <= t; i++) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2048d",
      "PROBLEM_ID": "2048D",
      "PROBLEM_STATEMENT": "Kevin used to get into Rio's Memories, and in Rio's Memories, a series of contests was once held. Kevin remembers all the participants and all the contest problems from that time, but he has forgotten the specific rounds, the distribution of problems, and the exact rankings.\n\nThere are $ m $ problems in total, with the $ i $-th problem having a difficulty of $ b_i $. Let each contest consist of $ k $ problems, resulting in a total of $ \\lfloor \\frac{m}{k} \\rfloor $ contests. This means that you select exactly $ \\lfloor \\frac{m}{k} \\rfloor \\cdot k $ problems for the contests in any combination you want, with each problem being selected at most once, and the remaining $m\\bmod k$ problems are left unused. For example, if $m = 17$ and $k = 3$, you should create exactly $5$ contests consisting of $3$ problems each, and exactly $2$ problems will be left unused.\n\nThere are $ n $ participants in the contests, with Kevin being the $1$-st participant. The $ i $-th participant has a rating of $ a_i $. During the contests, each participant solves all problems with a difficulty not exceeding their rating, meaning the $ i $-th participant solves the $ j $-th problem if and only if $ a_i \\geq b_j $. In each contest, Kevin's rank is one plus the number of participants who solve more problems than he does.\n\nFor each $ k = 1, 2, \\ldots, m $, Kevin wants to know the minimum sum of his ranks across all $ \\lfloor \\frac{m}{k} \\rfloor $ contests. In other words, for some value of $k$, after selecting the problems for each contest, you calculate the rank of Kevin in each contest and sum up these ranks over all $ \\lfloor \\frac{m}{k} \\rfloor $ contests. Your goal is to minimize this value.\n\nNote that contests for different values of $k$ are independent. It means that for different values of $k$, you can select the distribution of problems into the contests independently.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $ t $ ($ 1 \\le t \\le 5\\cdot 10^4 $).\n\nThe first line of each test case contains two integers $ n $ and $ m $ ($ 1 \\le n, m \\leq 3\\cdot 10^5 $)\u00a0\u2014 the number of participants and the number of problems.\n\nThe second line of each test case contains $ n $ integers $ a_1, a_2, \\ldots, a_n $ ($ 0 \\le a_i \\le 10^9 $)\u00a0\u2014 the rating of each participant.\n\nThe third line of each test case contains $ m $ integers $ b_1, b_2, \\ldots, b_m $ ($ 0 \\le b_i \\le 10^9 $)\u00a0\u2014 the difficulty of each problem.\n\nIt is guaranteed that both the sum of $ n $ and the sum of $ m $ over all test cases do not exceed $ 3 \\cdot 10^5 $.\n\n### Output\n\nFor each test case, output $m$ integers\u00a0\u2014 the minimum sum of Kevin's ranks for each $ k = 1, 2, \\ldots, m$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4 4\n\n4 3 7 5\n\n2 5 4 6\n\n5 5\n\n5 0 4 8 6\n\n1 3 9 2 7\n\n6 7\n\n1 1 4 5 1 4\n\n1 9 1 9 8 1 0\n\n7 6\n\n1 9 1 9 8 1 0\n\n1 1 4 5 1 4\n\n```\n\n#### Output #1\n\n```\n7 4 2 3\n6 2 1 1 2\n7 3 2 1 1 1 1\n15 9 5 4 4 4\n```\n\n### Note\n\nFor the first test case:\n\nWhen $k=1$, since each contest only contains one problem, the distribution is in fact unique. For example, in the contest which only includes the third problem (which has a difficulty of $4$), all participants except the $2$-nd can solve it. Since no one solves strictly more problems than Kevin, his ranking in this contest is $1$. Similarly, in all $4$ contests, Kevin's rankings are $1,3,1,2$, and the sum is $7$.\n\nWhen $k=2$, one optimal way is to choose the $1$-st and the $3$-rd problem to form a contest, while the $2$-nd and $4$-th for another. In the former contest, $4$ participants respectively solve $2,1,2,2$ problems, so Kevin's ranking is $1$; in the latter one, they respectively solve $0,0,2,1$, since there are $2$ participants ($3$-rd and $4$-th) solve more problems than Kevin, his ranking is $1+2=3$. Thus the answer is $1+3=4$. It can be proven that there's no way to achieve a lower sum.\n\nWhen $k=3$, we can simply choose the $1$-st, the $3$-rd, and the $4$-th problem to make a contest, and Kevin has a ranking of $2$, which is optimal.\n\nWhen $k=4$, since there's only one contest, the distribution is also unique, and Kevin's ranking is $3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m;\n        cin >> n >> m;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        int K = a[0];  // Kevin's rating\n\n        // Collect ratings of participants who can beat Kevin\n        vector<int> higher;\n        higher.reserve(n);\n        for (int i = 1; i < n; i++) {\n            if (a[i] > K) {\n                higher.push_back(a[i]);\n            }\n        }\n        sort(higher.begin(), higher.end());\n        int P = higher.size();\n\n        // Read problems and classify\n        vector<int> b(m);\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n\n        // Count easy problems (b[i] <= K), and build list of hard-problem penalties\n        int E = 0;\n        vector<int> hard_pen;\n        hard_pen.reserve(m);\n        for (int i = 0; i < m; i++) {\n            if (b[i] <= K) {\n                E++;\n            } else {\n                // G(b[i]) = number of participants with rating >= b[i]\n                auto it = lower_bound(higher.begin(), higher.end(), b[i]);\n                int G = P - int(it - higher.begin());\n                hard_pen.push_back(G);\n            }\n        }\n\n        // Sort hard-problem penalties (lower is better)\n        sort(hard_pen.begin(), hard_pen.end());\n        int H = hard_pen.size();\n\n        // Prepare answers for k = 1..m\n        vector<ll> ans(m, 0LL);\n        for (int k = 1; k <= m; k++) {\n            int t = m / k;           // number of contests\n            int take = t * k;        // total problems to use\n            int y = take - E;        // how many hard problems we must use\n            if (y <= 0) {\n                // We can fill all contests with easy problems only\n                ans[k-1] = t;\n            } else {\n                // We must use y hard problems; pack into c = ceil(y/k) contests\n                // to minimize the number of contests incurring penalties\n                int c = (y + k - 1) / k;      // number of hard contests\n                // In optimal grouping, the first bucket has size r, rest size k\n                int r = y - (c - 1) * k;      // 1 <= r <= k\n\n                // Sum the penalties: each bucket's penalty is the max of its assigned h_j\n                ll extra = 0;\n                int pos = r - 1;\n                for (int i = 0; i < c; i++) {\n                    extra += hard_pen[pos];\n                    pos += k;\n                }\n                ans[k-1] = ll(t) + extra;\n            }\n        }\n\n        // Output the results\n        for (int i = 0; i < m; i++) {\n            cout << ans[i] << (i + 1 < m ? ' ' : '\\n');\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2048c",
      "PROBLEM_ID": "2048C",
      "PROBLEM_STATEMENT": "Kevin discovered a binary string $s$ that starts with 1 in the river at Moonlit River Park and handed it over to you. Your task is to select two non-empty substrings$^{\\text{\u2217}}$ of $s$ (which can be overlapped) to maximize the XOR value of these two substrings.\n\nThe XOR of two binary strings $a$ and $b$ is defined as the result of the $\\oplus$ operation applied to the two numbers obtained by interpreting $a$ and $b$ as binary numbers, with the leftmost bit representing the highest value. Here, $\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nThe strings you choose may have leading zeros.\n\n$^{\\text{\u2217}}$A string $a$ is a substring of a string $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$).\n\nThe only line of each test case contains a binary string $s$ that starts with 1 ($1\\le\\lvert s\\rvert\\le 5000$).\n\nIt is guaranteed that the sum of $\\lvert s\\rvert$ over all test cases doesn't exceed $5000$.\n\n### Output\n\nFor each test case, output four integers $l_1, r_1, l_2, r_2$ ($1 \\le l_1 \\le r_1 \\le |s|$, $1 \\le l_2 \\le r_2 \\le |s|$)\u00a0\u2014 in the case the two substrings you selected are $s_{l_1} s_{l_1 + 1} \\ldots s_{r_1}$ and $s_{l_2} s_{l_2 + 1} \\ldots s_{r_2}$.\n\nIf there are multiple solutions, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n111\n\n1000\n\n10111\n\n11101\n\n1100010001101\n\n```\n\n#### Output #1\n\n```\n2 2 1 3\n1 3 1 4\n1 5 1 4\n3 4 1 5\n1 13 1 11\n```\n\n### Note\n\nIn the first test case, we can choose $ s_2=\\texttt{1} $ and $ s_1 s_2 s_3=\\texttt{111} $, and $ \\texttt{1}\\oplus\\texttt{111}=\\texttt{110} $. It can be proven that it is impossible to obtain a larger result. Additionally, $ l_1=3$, $r_1=3$, $l_2=1$, $r_2=3 $ is also a valid solution.\n\nIn the second test case, $ s_1 s_2 s_3=\\texttt{100} $, $ s_1 s_2 s_3 s_4=\\texttt{1000} $, the result is $ \\texttt{100}\\oplus\\texttt{1000}=\\texttt{1100} $, which is the maximum.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5005;\nint logs_arr[MAXN + 5];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    // Precompute logs for RMQ\n    logs_arr[1] = 0;\n    for (int i = 2; i <= MAXN; ++i)\n        logs_arr[i] = logs_arr[i / 2] + 1;\n\n    int t;\n    cin >> t;\n    while (t--) {\n        string s;\n        cin >> s;\n        int n = s.size();\n        if (n == 1) {\n            // Only one substring possible, pick it twice\n            cout << \"1 1 1 1\\n\";\n            continue;\n        }\n        // Build suffix array of s (0-indexed)\n        vector<int> sa(n), rankv(n), tmp(n);\n        for (int i = 0; i < n; ++i) {\n            sa[i] = i;\n            rankv[i] = s[i] - '0';\n        }\n        for (int k = 1; k < n; k <<= 1) {\n            auto cmp = [&](int a, int b) {\n                if (rankv[a] != rankv[b])\n                    return rankv[a] < rankv[b];\n                int ra = (a + k < n ? rankv[a + k] : -1);\n                int rb = (b + k < n ? rankv[b + k] : -1);\n                return ra < rb;\n            };\n            sort(sa.begin(), sa.end(), cmp);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i < n; ++i) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n            for (int i = 0; i < n; ++i)\n                rankv[i] = tmp[i];\n            if (rankv[sa[n - 1]] == n - 1) break;\n        }\n        // Build LCP array\n        vector<int> rank2(n), lcp(n);\n        for (int i = 0; i < n; ++i)\n            rank2[sa[i]] = i;\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; ++i) {\n            if (rank2[i] > 0) {\n                int j = sa[rank2[i] - 1];\n                while (i + h < n && j + h < n && s[i + h] == s[j + h])\n                    ++h;\n                lcp[rank2[i]] = h;\n                if (h > 0) --h;\n            }\n        }\n        // Build RMQ (sparse table) on LCP\n        int maxlg = logs_arr[n] + 1;\n        vector< vector<int> > st(maxlg, vector<int>(n));\n        for (int i = 0; i < n; ++i)\n            st[0][i] = lcp[i];\n        for (int k = 1; (1 << k) <= n; ++k) {\n            for (int i = 0; i + (1 << k) <= n; ++i) {\n                st[k][i] = min(st[k - 1][i], st[k - 1][i + (1 << (k - 1))]);\n            }\n        }\n        auto getLCP = [&](int a, int b) {\n            if (a == b) return n - a;\n            int ra = rank2[a], rb = rank2[b];\n            if (ra > rb) swap(ra, rb);\n            // query min of lcp[ra+1..rb]\n            int l = ra + 1, r = rb;\n            int lg = logs_arr[r - l + 1];\n            return min(st[lg][l], st[lg][r - (1 << lg) + 1]);\n        };\n\n        // Function to pick best starting l for a given offset O\n        auto bestStartForOffset = [&](int O) {\n            int m = n - O;  // length of substring\n            int best_l = 0;\n            // consider l in [0..O]\n            for (int l = 1; l <= O; ++l) {\n                int lcp_len = getLCP(best_l, l);\n                if (lcp_len >= m) continue; // Qs equal on prefix m\n                char Pbit = s[O + lcp_len];\n                char x = s[l + lcp_len];\n                char y = s[best_l + lcp_len];\n                if (Pbit == '0') {\n                    if (x > y) best_l = l;\n                } else {\n                    if (x < y) best_l = l;\n                }\n            }\n            return best_l;\n        };\n\n        // Compare two candidates (O1,l1) vs (O2,l2)\n        // return true if candidate2 > candidate1\n        auto isBetter = [&](int O1, int l1, int O2, int l2) {\n            // O2,l2 is the \"new\" candidate, O1,l1 is \"current best\"\n            int j0 = min(O1, O2);\n            for (int j = j0; j < n; ++j) {\n                int z1 = 0, z2 = 0;\n                if (j >= O1) z1 = s[l1 + (j - O1)] - '0';\n                if (j >= O2) z2 = s[l2 + (j - O2)] - '0';\n                int c1 = (s[j] - '0') ^ z1;\n                int c2 = (s[j] - '0') ^ z2;\n                if (c1 != c2)\n                    return c2 > c1;\n            }\n            return false;\n        };\n\n        // Initialize best with O=1\n        int best_O = 1;\n        int best_l = bestStartForOffset(1);\n\n        // Try all other offsets\n        for (int O = 2; O < n; ++O) {\n            int cur_l = bestStartForOffset(O);\n            if (isBetter(best_O, best_l, O, cur_l)) {\n                best_O = O;\n                best_l = cur_l;\n            }\n        }\n\n        // Output two substrings:\n        // First: the whole string [1..n]\n        // Second: substring of length m = n-best_O starting at best_l\n        int l1 = 1, r1 = n;\n        int l2 = best_l + 1;\n        int r2 = best_l + (n - best_O);\n        cout << l1 << \" \" << r1 << \" \" << l2 << \" \" << r2 << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2048b",
      "PROBLEM_ID": "2048B",
      "PROBLEM_STATEMENT": "Kevin is a master of permutation-related problems. You are taking a walk with Kevin in Darkwoods, and during your leisure time, he wants to ask you the following question.\n\nGiven two positive integers $ n $ and $ k $, construct a permutation$^{\\text{\u2217}}$ $ p $ of length $ n $ to minimize the sum of the minimum values of all subarrays$^{\\text{\u2020}}$ of length $ k $. Formally, you need to minimize\n\n\n\n$$ \\sum_{i=1}^{n-k+1}\\left( \\min_{j=i}^{i+k-1} p_j\\right). $$\n\ntext{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n$^{\\text{\u2020}}$An array $a$ is a subarray of an array $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Two subarrays are considered different if the sets of positions of the deleted elements are different.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$).\n\nThe only line of each test case contains two integers $ n $ and $ k $ ($ 1\\le k\\le n\\le 10^5 $).\n\nIt is guaranteed that the sum of $ n $ over all test cases doesn't exceed $ 10^5 $.\n\n### Output\n\nFor each test case, output $ n $ integers on a single line\u00a0\u2014 the permutation $ p $ you constructed.\n\nIf there are multiple answers, you can print any of them.\n\n### Example\n\n#### Input #1\n\n```\n3\n4 2\n6 1\n8 3\n```\n\n#### Output #1\n\n```\n3 1 2 4\n5 2 1 6 4 3\n4 6 2 8 3 1 5 7\n```\n\n### Note\n\nIn the first test case, with $ k=2 $, consider all subarrays of length $ 2 $: the minimum value of $ p_1,p_2 $ is $ 1 $, the minimum value of $ p_2,p_3 $ is $ 1 $, and the minimum value of $ p_3,p_4 $ is $ 2 $. The sum $ 1+1+2=4 $ is the smallest among all possible permutations.\n\nIn the second test case, all subarrays of length $ 1 $ have minimum values of $ 5, 2, 1, 6, 4, 3 $, and the sum $ 5+2+1+6+4+3=21 $ is proven to be the smallest.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> res(n);\n    \n    int low = 1, high = n;\n\n    // Key idea is to put the smallest elements separated by gaps of at least k.\n    for(int i = k - 1; i < n; i += k){\n        res[i] = low++;\n    }\n    \n    // Fill remaining positions with largest numbers first\n    for(int i = 0; i < n; ++i){\n        if(res[i] == 0) res[i] = low++;\n    }\n    \n    for(int x : res) cout << x << \" \";\n    cout << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) solve();\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2048a",
      "PROBLEM_ID": "2048A",
      "PROBLEM_STATEMENT": "Kevin is trapped in Lakeside Village by Grace. At the exit of the village, there is a combination lock that can only be unlocked if Kevin solves it.\n\nThe combination lock starts with an integer $ x $. Kevin can perform one of the following two operations zero or more times:\n\n1. If $ x \\neq 33 $, he can select two consecutive digits $ 3 $ from $ x $ and remove them simultaneously. For example, if $ x = 13\\,323 $, he can remove the second and third $ 3 $, changing $ x $ to $ 123 $.\n2. If $ x \\geq 33 $, he can change $ x $ to $ x - 33 $. For example, if $ x = 99 $, he can choose this operation to change $ x $ to $ 99 - 33 = 66 $.\n\nWhen the value of $ x $ on the combination lock becomes $ 0 $, Kevin can unlock the lock and escape from Lakeside Village. Please determine whether it is possible for Kevin to unlock the combination lock and escape.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$).\n\nThe only line of each test case contains a positive integer $x$ ($1\\leq x\\leq 10^9$).\n\n### Output\n\nFor each test case, output \"YES\" or \"NO\" (without quotes) in one line, representing whether Kevin can unlock the combination lock and escape. You can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n165\n\n6369\n\n666\n\n114514\n\n133333332\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\nNO\nYES\n```\n\n### Note\n\nFor the first test case, $165\\xrightarrow{-33}132\\xrightarrow{-33}99\\xrightarrow{-33}66\\xrightarrow{-33}33\\xrightarrow{-33}0$.\n\nFor the second test case, $6369\\xrightarrow{-33}6{\\color{red}{33}}6\\xrightarrow{\\text{remove \"33\"}}66\\xrightarrow{-33}33\\xrightarrow{-33}0$.\n\nFor the third test case, it can be proven that, regardless of the operations performed, $666$ cannot be transformed into $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if Kevin can unlock the lock\nbool canUnlock(int x) {\n    // Check divisibility by 33 (Operation 2)\n    if (x % 33 == 0) {\n        return true;\n    }\n\n    // Convert integer x to string for \"33\" removal (Operation 1)\n    string s = to_string(x);\n\n    // Try repeatedly removing \"33\"\n    while (true) {\n        size_t pos = s.find(\"33\");\n        if (pos == string::npos) {\n            break; // No more \"33\" found\n        }\n\n        // Erase \"33\" from the string\n        s.erase(pos, 2);\n\n        // If the resulting string becomes empty or 0\n        if (s.empty() || stoi(s) == 0) {\n            return true;\n        }\n    }\n\n    // After removing all possible \"33\", check if the number is divisible by 33\n    if (!s.empty() && stoi(s) % 33 == 0) {\n        return true;\n    }\n\n    // Otherwise, Kevin cannot unlock\n    return false;\n}\n\n// Main driver function\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t; // Number of test cases\n    while (t--) {\n        int x;\n        cin >> x;\n\n        // Output result for each test case\n        if (canUnlock(x)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2047a",
      "PROBLEM_ID": "2047A",
      "PROBLEM_STATEMENT": "Alyona assembles an unusual square Jigsaw Puzzle. She does so in $n$ days in the following manner:\n\n- On the first day, she starts by placing the central piece in the center of the table.\n- On each day after the first one, she places a certain number of pieces around the central piece in clockwise order, always finishing each square layer completely before starting a new one.\n\nFor example, she places the first $14$ pieces in the following order:\n\n![](https://espresso.codeforces.com/0bf6bf6b73e87a48f211b53722a2e082fe0d198f.png)The colors denote the layers. The third layer is still unfinished.\n\nAlyona is happy if at the end of the day the assembled part of the puzzle does not have any started but unfinished layers. Given the number of pieces she assembles on each day, find the number of days Alyona is happy on.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100$), the number of days.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 100$, $a_1 = 1$), where $a_i$ is the number of pieces Alyona assembles on the $i$-th day.\n\nIt is guaranteed in each test case that at the end of the $n$ days, there are no unfinished layers.\n\n### Output\n\nFor each test case, print a single integer: the number of days when Alyona is happy.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n1\n\n2\n\n1 8\n\n5\n\n1 3 2 1 2\n\n7\n\n1 2 1 10 2 7 2\n\n14\n\n1 10 10 100 1 1 10 1 10 2 10 2 10 1\n\n```\n\n#### Output #1\n\n```\n1\n2\n2\n2\n3\n```\n\n### Note\n\nIn the first test case, in the only day Alyona finishes the only layer.\n\nIn the second test case, on the first day, Alyona finishes the first layer, and on the second day, she finishes the second layer.\n\nIn the third test case, she finishes the second layer in a few days.\n\nIn the fourth test case, she finishes the second layer and immediately starts the next one on the same day, therefore, she is not happy on that day. She is only happy on the first and last days.\n\nIn the fifth test case, Alyona is happy on the first, fourth, and last days.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    \n    long long total = 0;  // total pieces placed\n    int happy_days = 0;\n    int current_layer = 1;  // start with layer 1\n    \n    for(int i = 0; i < n; i++) {\n        total += a[i];\n        \n        // Calculate how many pieces are needed for complete layers\n        long long pieces_needed = 1;  // center piece\n        int layer = 1;\n        while(pieces_needed <= total) {\n            if(pieces_needed == total) {  // if exactly matches a complete layer\n                happy_days++;\n                break;\n            }\n            layer++;\n            pieces_needed += 8 * (layer - 1);  // next layer needs 8*(layer-1) pieces\n        }\n    }\n    \n    cout << happy_days << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2046f1",
      "PROBLEM_ID": "2046F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, there are no question marks. You can hack only if you solved all versions of this problem.\n\nFor a long time, no one could decipher Sumerian cuneiform. However, it has finally succumbed to pressure! Today, you have the chance to decipher Yandex cuneiform.\n\nYandex cuneiform is defined by the following rules:\n\n1. An empty string is a Yandex cuneiform.\n2. If you insert exactly one copy of each of the three letters 'Y', 'D', and 'X' into a Yandex cuneiform in such a way that no two adjacent letters become equal after the operation, you obtain a Yandex cuneiform.\n3. If a string can't be obtained using the above rules, it is not a Yandex cuneiform.\n\nYou are given a template. A template is a string consisting of the characters 'Y', 'D', 'X', and '?'.\n\nYou need to check whether there exists a way to replace each question mark with 'Y', 'D', or 'X' to obtain a Yandex cuneiform, and if it exists, output any of the matching options, as well as a sequence of insertion operations to obtain the resulting cuneiform.\n\nIn this version of the problem, there are no question marks in the template.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5 \\cdot 10^4$). The description of the test cases follows.\n\nEach test case consists of a single line containing a template of length $n$ ($3 \\leq n < 2 \\cdot 10^5$, $n \\bmod 3 = 0$), consisting only of characters 'Y', 'D', 'X'.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single line containing 'NO' if it is not possible to obtain a cuneiform from the given template.\n\nOtherwise, output 'YES' on the first line, and on the second line, any obtainable cuneiform. After that, you need to output the sequence of operations that leads to the cuneiform you printed.\n\nA sequence of operations is described by $\\frac{n}{3}$ triples of pairs. A pair has the form c p, where $c$ is one of the letters 'Y', 'D', or 'X', and $p$ is the position at which the letter $c$ should be inserted. The insertion position is the number of letters to skip from the beginning of the string for the insertion. For example, after inserting the character 'D' into the string \"YDX\" with $p=3$, the result is \"YDXD\", and with $p=0$, it is \"DYDX\". Note that the index cannot exceed the current length of the string.\n\nThe operations are applied from top to bottom, left to right. After inserting each triple to the string, there should be no two adjacent identical characters.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\nYDX\n\nYDXDYX\n\nYDX\n\nDYYDXYXYX\n\n```\n\n#### Output #1\n\n```\nYES\nYDX\nX 0 D 0 Y 0\nYES\nYDXDYX\nX 0 Y 0 D 1\nX 2 D 3 Y 4\nYES\nYDX\nY 0 D 1 X 2\nNO```\n\n### Note\n\nIn the second example, the string is transformed like this: $\"\" \\to \\mathtt{YDX} \\to \\mathtt{YDXDYX}$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=2e5+5;\nint n,a[MAXN],pr[MAXN],sf[MAXN],wys[MAXN];\nchar s[MAXN];\nset <int> ps[4];\nstruct FenwickTree {\n\tint tr[MAXN],s;\n\tvoid init() { fill(tr+1,tr+n+1,0); }\n\tvoid add(int x,int v) { for(;x<=n;x+=x&-x) tr[x]+=v; }\n\tint qry(int x) { for(s=0;x;x&=x-1) s+=tr[x]; return s; }\n}\tTR;\nvoid solve() {\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tfor(int i=1;i<=n;++i) pr[i]=i-1,sf[i]=i+1,a[i]=(s[i]=='D'?1:(s[i]=='X'?2:3));\n\tpr[n+1]=n,sf[0]=1;\n\tfor(int i=1;i<n;++i) if(s[i]==s[i+1]) return puts(\"NO\"),void();\n\tint c[4]={0,0,0};\n\tfor(int i=1;i<=n;++i) ++c[a[i]];\n\tif(c[1]!=n/3||c[2]!=n/3||c[3]!=n/3) return puts(\"NO\"),void();\n\tfor(int i=1;i<n;++i) ps[a[i]^a[i+1]].insert(i);\n\tint tp=n;\n\tauto del=[&](int x) {\n\t\twys[tp--]=x;\n\t\tint l=pr[x],r=sf[x];\n\t\tif(l>=1) ps[a[l]^a[x]].erase(l);\n\t\tif(r<=n) ps[a[x]^a[r]].erase(x);\n\t\tif(l>=1&&r<=n) ps[a[l]^a[r]].insert(l);\n\t\tsf[l]=r,pr[r]=l;\n\t};\n\tfor(int _=0;_<n/3;++_) {\n\t\tint y=*ps[a[sf[0]]].begin(),z=sf[y],x=(sf[z]<=n&&a[pr[y]]==a[sf[z]]?pr[y]:sf[0]);\n\t\tdel(z),del(y),del(x);\n\t}\n\tprintf(\"YES\\n%s\\n\",s+1);\n\tfor(int i=1;i<=n;++i) {\n\t\tprintf(\"%c %d%c\",\" DXY\"[a[wys[i]]],TR.qry(wys[i]),\" \\n\"[i%3==0]);\n\t\tTR.add(wys[i],1);\n\t}\n\tTR.init();\n\tfor(int i:{1,2,3}) ps[i].clear();\n}\nsigned main() {\n\tint _; scanf(\"%d\",&_);\n\twhile(_--) solve();\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2046e1",
      "PROBLEM_ID": "2046E1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the versions is that in this version, $m$ equals $2$. You can hack only if you solved all versions of this problem.\n\nThere is a problem-solving competition in Ancient Egypt with $n$ participants, numbered from $1$ to $n$. Each participant comes from a certain city; the cities are numbered from $1$ to $m$. There is at least one participant from each city.\n\nThe $i$-th participant has strength $a_i$, specialization $s_i$, and wisdom $b_i$, so that $b_i \\ge a_i$. Each problem in the competition will have a difficulty $d$ and a unique topic $t$. The $i$-th participant will solve the problem if\n\n- $a_i \\ge d$, i.e., their strength is not less than the problem's difficulty, or\n- $s_i = t$, and $b_i \\ge d$, i.e., their specialization matches the problem's topic, and their wisdom is not less than the problem's difficulty.\n\nCheops wants to choose the problems in such a way that each participant from city $i$ will solve strictly more problems than each participant from city $j$, for all $i < j$.\n\nPlease find a set of at most $5n$ problems, where the topics of all problems are distinct, so that Cheops' will is satisfied, or state that it is impossible.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $T$ ($1 \\le T \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $m$ ($2 \\mathbf{=} m \\le n \\le 3 \\cdot {10}^5$)\u00a0\u2014 the number of participants and the number of cities.\n\nThe following $n$ lines describe the participants. The $i$-th line contains three integers \u2014$a_i$, $b_i$, $s_i$ ($0 \\le a_i, b_i, s_i \\le {10}^9$, $a_i \\le b_i$)\u00a0\u2014 strength, wisdom, and specialization of the $i$-th participant, respectively.\n\nThe next $m$ lines describe the cities. In the $i$-th line, the first number is an integer $k_i$ ($1 \\le k_i \\le n$)\u00a0\u2014 the number of participants from the $i$-th city. It is followed by $k_i$ integers $q_{i, 1}, q_{i, 2}, \\ldots, q_{i, k_i}$\u00a0\u2014 ($1 \\le q_{i, j} \\le n$, $1 \\le j \\le k_i$)\u00a0\u2014 the indices of the participants from this city. It is guaranteed that each participant is mentioned exactly once.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, if there exists a set of problems that satisfies Cheops' conditions, then in the first line output a single integer $p$ ($1 \\le p \\le 5n$)\u00a0\u2014 the number of problems in your solution.\n\nThen output $p$ lines, each containing two integers $d$ and $t$ ($0 \\le d, t \\le {10}^9$)\u00a0\u2014 the difficulty and topic of the respective problem. The topics must be distinct.\n\nIf there is no set of problems that meets Cheops' wishes, print $-1$ instead.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5 2\n\n5 7 1\n\n6 7 2\n\n3 9 2\n\n5 10 3\n\n4 4 1\n\n2 1 2\n\n3 3 4 5\n\n2 2\n\n1 2 1\n\n1 2 1\n\n1 2\n\n1 1\n\n```\n\n#### Output #1\n\n```\n7\n6 4\n6 5\n5 6\n5 7\n4 8\n4 9\n7 1\n-1\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nint a[300005],b[300005],s[300005];\nvector<int>g[300005];\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tint n,m;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tmap<int,int>vist;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tscanf(\"%d%d%d\",&a[i],&b[i],&s[i]);\n\t\t\tvist[s[i]]=1;\n\t\t}\n\t\tfor(int i=1;i<=m;++i){\n\t\t\tg[i].clear();\n\t\t\tint k;scanf(\"%d\",&k);\n\t\t\tfor(int j=1;j<=k;++j){\n\t\t\t\tint z;scanf(\"%d\",&z);\n\t\t\t\tg[i].emplace_back(z);\n\t\t\t}\n\t\t}\n\t\tint fl=1;\n\t\tint mx=0,mn=1e9;\n\t\tfor(auto z:g[1])mn=min(mn,a[z]);\n\t\tfor(auto z:g[2])mx=max(mx,a[z]);\n\t\tmap<int,int>m1;\n\t\tfor(auto z:g[1]){\n\t\t\tif(a[z]<=mx){\n\t\t\t\tif(!m1[s[z]])m1[s[z]]=1e9;\n\t\t\t\tif(b[z]<=mx)fl=0;\n\t\t\t\tm1[s[z]]=min(m1[s[z]],b[z]);\n\t\t\t}\n\t\t}\n\t\tfor(auto z:g[2])if(a[z]>=mn){\n\t\t\tif(m1.find(s[z])==m1.end())continue;\n\t\t\tif(m1[s[z]]<=b[z])fl=0;\n\t\t}\n\t\tif(!fl)puts(\"-1\");\n\t\telse{\n\t\t\tint p=m1.size()+1;\n\t\t\tprintf(\"%d\\n\",n+p);\n\t\t\tint w=1;\n\t\t\tfor(int i=1;i<=n;++i){\n\t\t\t\twhile(vist[w])++w;\n\t\t\t\tprintf(\"%d %d\\n\",mn,w);++w;\n\t\t\t}\n\t\t\twhile(vist[w])++w;\n\t\t\tprintf(\"%d %d\\n\",mx+1,w);\n\t\t\tfor(auto pi:m1)printf(\"%d %d\\n\",pi.second,pi.first);\n\t\t}\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2046d",
      "PROBLEM_ID": "2046D",
      "PROBLEM_STATEMENT": "In Ancient Rome, a plan to defeat the barbarians was developed, but for its implementation, each city must be informed about it.\n\nThe northern part of the Roman Empire consists of $n$ cities connected by $m$ one-way roads. Initially, the $i$-th city has $a_i$ messengers, and each messenger can freely move between cities following the existing roads. A messenger can carry a copy of the plan with him and inform the cities he visits, and can make unlimited copies for other messengers in the city he is currently in.\n\nAt the start, you will produce some number of plans and deliver them to messengers of your choice. Your goal is to make sure that every city is visited by a messenger with a plan. Find the smallest number of the plans you need to produce originally, so that the messengers will deliver them to every city, or determine that it is impossible to do so at all.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line contains two integers $n$ and $m$ ($2 \\le n \\le 200$, $1 \\le m \\le 800$)\u00a0\u2014 the number of cities and roads.\n\nThe second line contains $n$ non-negative integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_{i} \\le n$)\u00a0\u2014 the initial number of messengers in each city.\n\nEach of the following $m$ lines contains two integers $u$ and $v$ ($1 \\le u,v \\le n, u \\ne v$), indicating that there is a one-way road from city $u$ to city $v$. The roads may repeat.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $200$. It is guaranteed that the sum of $m$ over all test cases does not exceed $800$.\n\n### Output\n\nOutput a single line containing a single integer \u2014 the smallest number of messengers you need to give a copy of the plan in the beginning, or $-1$ if it is not possible to inform all cities.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n7 6\n\n2 1 0 1 2 3 4\n\n1 2\n\n1 3\n\n2 4\n\n2 5\n\n3 6\n\n3 7\n\n4 4\n\n1 1 1 1\n\n1 2\n\n1 3\n\n2 4\n\n3 4\n\n```\n\n#### Output #1\n\n```\n2\n2\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define N 1005\n#define M 10005\nusing namespace std;\nconst int inf=1e9;\nint n,m,s,t,k;\nint h[N],to[M],nxt[M],w[M],c[M],cnt;\nvoid jb(int u,int v,int W,int C){\n\tto[++cnt]=v;\n\tw[cnt]=W;c[cnt]=C;\n\tnxt[cnt]=h[u];\n\th[u]=cnt;\n}\nvoid JB(int u,int v,int W,int C){\n\tjb(u,v,W,C);\n\tjb(v,u,0,-C);\n}\nint dis[N],fl[N],lst[N];\nbool vis[N];\nqueue<int > Q;\nbool spfa(){\n\tfor(int i=1;i<=k;i++) dis[i]=inf,lst[i]=0,vis[i]=0;\n\tdis[s]=0;fl[s]=inf;\n\tQ.push(s);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tvis[u]=0;\n\t\tfor(int i=h[u];i!=0;i=nxt[i]){\n\t\t\tint v=to[i];\n\t\t\tif(w[i]>0&&dis[v]>dis[u]+c[i]){\n\t\t\t\tdis[v]=dis[u]+c[i];\n\t\t\t\tfl[v]=min(fl[u],w[i]);\n\t\t\t\tlst[v]=i;\n\t\t\t\tif(vis[v]==0){\n\t\t\t\t\tvis[v]=1;\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lst[t]!=0;\n}\npair<int ,int > work(){\n\tint res=0,ct=0;;\n\twhile(spfa()){\n\t\tres+=dis[t]*fl[t];\n\t\tct+=fl[t];\n\t\tfor(int i=t;i!=s;i=to[lst[i]^1]){\n\t\t\tw[lst[i]]-=fl[t];\n\t\t\tw[lst[i]^1]+=fl[t]; \n\t\t}\n\t}\n\treturn make_pair(res,ct);\n}\nint a[N],sa[N];\nint dfn[N],low[N],tot,bel[N],sc;\nint st[N],hd;\nvector<int > vec[N];\nvoid tarjan(int u){\n\tst[++hd]=u;\n\tlow[u]=dfn[u]=++tot;\n\tfor(int v:vec[u]){\n\t\tif(!dfn[v]){\n\t\t\ttarjan(v);\n\t\t\tlow[u]=min(low[u],low[v]);\n\t\t}\n\t\telse if(!bel[v])\n\t\t\tlow[u]=min(low[u],dfn[v]);\n\t}\n\tif(low[u]==dfn[u]){\n\t\tsc++;\n\t\twhile(1){\n\t\t\tint x=st[hd];hd--;\n\t\t\tbel[x]=sc;\n\t\t\tif(x==u) break;\n\t\t}\n\t}\n}\nvoid solve(){\n\tcnt=1;hd=tot=sc=0;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tvec[u].push_back(v);\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);\n\tt=k=2*sc+2;s=k-1;\n\tfor(int i=1;i<=sc;i++) sa[i]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tsa[bel[i]]+=a[i];\n\t\tfor(int v:vec[i]){\n\t\t\tif(bel[i]!=bel[v])\n\t\t\t\tJB(bel[i]+sc,bel[v],inf,0);\n\t\t}\n\t}\n\tfor(int i=1;i<=sc;i++){\n\t\tJB(s,i+sc,sa[i]+1,0);\n\t\tJB(i,i+sc,inf,0);\n\t\tif(sa[i]>0) JB(i+sc,i,1,1);\n\t\tJB(i,t,1,0);\n\t}\n\tpair<int ,int > ans=work();\n\tif(ans.second!=sc) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans.first);\n\tfor(int i=1;i<=n;i++) vec[i].clear(),dfn[i]=bel[i]=0;\n\tfor(int i=1;i<=k;i++) h[i]=0;\n\tfor(int i=1;i<=sc;i++) sa[i]=0;\n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2046c",
      "PROBLEM_ID": "2046C",
      "PROBLEM_STATEMENT": "Once, four Roman merchants met in a Roman mansion to discuss their trading plans. They faced the following problem: they traded the same type of goods, and if they traded in the same city, they would inevitably incur losses. They decided to divide up the cities between them where they would trade.\n\nThe map of Rome can be represented in this problem as a plane with certain points marked \u2014 the cities of the Roman Empire.\n\nThe merchants decided to choose a certain dividing point $(x_0, y_0)$. Then, in a city with coordinates $(x_i, y_i)$,\n\n- the first merchant sells goods if $x_0 \\le x_i$ and $y_0 \\le y_i$;\n- the second merchant sells goods if $x_0 > x_i$ and $y_0 \\le y_i$;\n- the third merchant sells goods if $x_0 \\le x_i$ and $y_0 > y_i$;\n- the fourth merchant sells goods if $x_0 > x_i$ and $y_0 > y_i$.\n\nThe merchants want to choose $(x_0, y_0)$ in such a way as to maximize the smallest number of cities that any of them gets (i.\u00a0e., as fair as possible). Please find such a point for them.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($4 \\le n \\le 10^5$) \u2014 the number of cities on the map.\n\nEach of the next $n$ lines contains two integers $x_i, y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$) \u2014 the coordinates of the cities.\n\nNote that some points may coincide. This is because some cities may be so close that they cannot be distinguished on the map at the given scale.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, in the first line, print a single integer $k$ ($0 \\le k \\le \\frac{n}{4}$) \u2014 the maximum possible number of cities that each merchant can get at a minimum.\n\nIn the second line, print two integers $x_0$ and $y_0$ ($|x_0|, |y_0| \\le 10^9$)\u00a0\u2014 the coordinates of the dividing point. If there are multiple suitable points, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4\n\n1 1\n\n1 2\n\n2 1\n\n2 2\n\n4\n\n0 0\n\n0 0\n\n0 0\n\n0 0\n\n8\n\n1 2\n\n2 1\n\n2 -1\n\n1 -2\n\n-1 -2\n\n-2 -1\n\n-2 1\n\n-1 2\n\n7\n\n1 1\n\n1 2\n\n1 3\n\n1 4\n\n2 1\n\n3 1\n\n4 1\n\n```\n\n#### Output #1\n\n```\n1\n2 2\n0\n0 0\n2\n1 0\n0\n0 0\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\nstatic int fenw_init[MAXN], fenw_L[MAXN], fenw_R[MAXN];\nstatic pair<int,int> pts[MAXN];\nstatic int rev_y[MAXN];\nstatic int x_orig[MAXN], y_orig[MAXN];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        for (int i = 0; i < n; i++) {\n            cin >> x_orig[i] >> y_orig[i];\n        }\n        // Compress y-coordinates\n        vector<int> y_vals(n);\n        for (int i = 0; i < n; i++) y_vals[i] = y_orig[i];\n        sort(y_vals.begin(), y_vals.end());\n        y_vals.erase(unique(y_vals.begin(), y_vals.end()), y_vals.end());\n        int M = (int)y_vals.size();\n        // rev_y is 1-indexed: rev_y[id] = original y\n        for (int i = 0; i < M; i++) {\n            rev_y[i+1] = y_vals[i];\n        }\n        // Build pts array: (x, y_id)\n        for (int i = 0; i < n; i++) {\n            int yid = int(lower_bound(y_vals.begin(), y_vals.end(), y_orig[i]) - y_vals.begin()) + 1;\n            pts[i].first = x_orig[i];\n            pts[i].second = yid;\n        }\n        // Sort by x\n        sort(pts, pts + n, [](const pair<int,int>& a, const pair<int,int>& b){\n            return a.first < b.first;\n        });\n        // Build initial Fenwick tree fenw_init from frequencies\n        // fenw_init will hold BIT internal representation\n        for (int i = 1; i <= M; i++) {\n            fenw_init[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            fenw_init[ pts[i].second ]++;\n        }\n        for (int i = 1; i <= M; i++) {\n            int j = i + (i & -i);\n            if (j <= M) fenw_init[j] += fenw_init[i];\n        }\n        // Precompute largest power of two <= M for BIT search\n        int pw = 1;\n        while ((pw << 1) <= M) pw <<= 1;\n\n        // Lambda to test feasibility for given k; if needans==true, output x0,y0 in out_x,out_y\n        auto feasible = [&](int k, bool needans, int &out_x, int &out_y)->bool {\n            if (k == 0) {\n                if (needans) {\n                    out_x = 0;\n                    out_y = 0;\n                }\n                return true;\n            }\n            if (4LL * k > n) return false;\n            // reset Fenwick trees\n            // fenw_R = fenw_init, fenw_L = 0\n            for (int i = 1; i <= M; i++) {\n                fenw_R[i] = fenw_init[i];\n                fenw_L[i] = 0;\n            }\n            int m_L = 0, m_R = n;\n            // Sweep through x-groups\n            int i = 0;\n            while (i < n) {\n                int xval = pts[i].first;\n                int j = i;\n                // group [i..j-1] have same x\n                while (j < n && pts[j].first == xval) j++;\n                // move this group from R to L\n                for (int t = i; t < j; t++) {\n                    int id = pts[t].second;\n                    // remove from R\n                    int p = id;\n                    while (p <= M) {\n                        fenw_R[p]--;\n                        p += p & -p;\n                    }\n                    // add to L\n                    p = id;\n                    while (p <= M) {\n                        fenw_L[p]++;\n                        p += p & -p;\n                    }\n                }\n                int gsz = j - i;\n                m_L += gsz;\n                m_R -= gsz;\n                if (m_L >= 2*k && m_R >= 2*k) {\n                    // Compute L interval: (L_lo, L_hi]\n                    // L_lo = k-th smallest in L\n                    int need = k, pos = 0;\n                    for (int step = pw; step > 0; step >>= 1) {\n                        int nxt = pos + step;\n                        if (nxt <= M && fenw_L[nxt] < need) {\n                            need -= fenw_L[nxt];\n                            pos = nxt;\n                        }\n                    }\n                    int L_lo = rev_y[pos + 1];\n                    // L_hi = (m_L - k + 1)-th smallest in L\n                    need = m_L - k + 1; pos = 0;\n                    for (int step = pw; step > 0; step >>= 1) {\n                        int nxt = pos + step;\n                        if (nxt <= M && fenw_L[nxt] < need) {\n                            need -= fenw_L[nxt];\n                            pos = nxt;\n                        }\n                    }\n                    int L_hi = rev_y[pos + 1];\n                    // Compute R interval: (R_lo, R_hi]\n                    need = k; pos = 0;\n                    for (int step = pw; step > 0; step >>= 1) {\n                        int nxt = pos + step;\n                        if (nxt <= M && fenw_R[nxt] < need) {\n                            need -= fenw_R[nxt];\n                            pos = nxt;\n                        }\n                    }\n                    int R_lo = rev_y[pos + 1];\n                    need = m_R - k + 1; pos = 0;\n                    for (int step = pw; step > 0; step >>= 1) {\n                        int nxt = pos + step;\n                        if (nxt <= M && fenw_R[nxt] < need) {\n                            need -= fenw_R[nxt];\n                            pos = nxt;\n                        }\n                    }\n                    int R_hi = rev_y[pos + 1];\n                    // Intersection of (max_lo, min_hi]\n                    int ylo = max(L_lo, R_lo);\n                    int yhi = min(L_hi, R_hi);\n                    if (ylo + 1 <= yhi) {\n                        if (needans) {\n                            out_x = xval + 1;\n                            out_y = ylo + 1;\n                        }\n                        return true;\n                    }\n                }\n                i = j;\n            }\n            return false;\n        };\n\n        // Binary search for maximum k\n        int low = 0, high = n / 4;\n        while (low < high) {\n            int mid = (low + high + 1) >> 1;\n            int dummy_x = 0, dummy_y = 0;\n            if (feasible(mid, false, dummy_x, dummy_y)) {\n                low = mid;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        // Output result\n        if (low > 0) {\n            int ans_x = 0, ans_y = 0;\n            feasible(low, true, ans_x, ans_y);\n            cout << low << \"\\n\" << ans_x << \" \" << ans_y << \"\\n\";\n        } else {\n            // k = 0, arbitrary dividing point\n            cout << 0 << \"\\n\" << 0 << \" \" << 0 << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2046b",
      "PROBLEM_ID": "2046B",
      "PROBLEM_STATEMENT": "You are given an array of integers $a$ of length $n$. You can perform the following operation zero or more times:\n\n- In one operation choose an index $i$ ($1 \\le i \\le n$), assign $a_i := a_i + 1$, and then move $a_i$ to the back of the array (to the rightmost position). For example, if $a = [3, 5, 1, 9]$, and you choose $i = 2$, the array becomes $[3, 1, 9, 6]$.\n\nFind the lexicographically smallest$^{\\text{\u2217}}$ array you can get by performing these operations.\n\n$^{\\text{\u2217}}$An array $c$ is lexicographically smaller than an array $d$ if and only if one of the following holds:\n\n- $c$ is a prefix of $d$, but $c \\ne d$; or\n- in the first position where $c$ and $d$ differ, the array $c$ has a smaller element than the corresponding element in $d$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^5$), the length of the array.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$), the elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, print the lexicographically smallest array you can get.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n2 1 3\n\n5\n\n1 2 2 1 4\n\n6\n\n1 2 3 6 5 4\n\n```\n\n#### Output #1\n\n```\n1 3 3\n1 1 3 3 5\n1 2 3 4 6 7\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\nconst int INF = 2000000005;\n\nstruct SegTree {\n    int n, size;\n    vector<pii> t;\n    SegTree(int _n): n(_n) {\n        size = 1;\n        while (size < n) size <<= 1;\n        t.assign(2*size, {INF, INF});\n    }\n    // build from array a (0-based)\n    void build(const vector<int>& a) {\n        for (int i = 0; i < n; i++) {\n            t[size + i] = {a[i], i};\n        }\n        // the rest of the leaves (i >= n) stay at INF\n        for (int i = size - 1; i >= 1; i--) {\n            t[i] = min(t[2*i], t[2*i+1]);\n        }\n    }\n    // point update: set a[pos] = val\n    void update(int pos, int val) {\n        int idx = pos + size;\n        t[idx] = {val, pos};\n        idx >>= 1;\n        while (idx >= 1) {\n            t[idx] = min(t[2*idx], t[2*idx+1]);\n            idx >>= 1;\n        }\n    }\n    // range minimum query on [l..r], 0-based inclusive\n    pii query(int l, int r) {\n        pii res = {INF, INF};\n        int left = l + size;\n        int right = r + size;\n        while (left <= right) {\n            if (left & 1) {\n                res = min(res, t[left]);\n                left++;\n            }\n            if (!(right & 1)) {\n                res = min(res, t[right]);\n                right--;\n            }\n            left >>= 1;\n            right >>= 1;\n        }\n        return res;\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        // Build a segment tree for range-min queries + point updates\n        SegTree st(n);\n        st.build(a);\n\n        vector<bool> headPicked(n, false);\n        vector<int> headVals;\n        headVals.reserve(n);\n\n        // prev is the next position in the array from which we may pick the head\n        int prev = 0;\n        while (prev < n) {\n            // global minimum in the \"remaining\" set\n            pii gmin = st.query(0, n-1);\n            int gval = gmin.first;\n            // threshold: if the next head pick > gval+1, \n            // then it's better to stop head and dump the rest to tail\n            int threshold = gval + 1;\n\n            // find the minimum in suffix [prev..n-1]\n            pii suf = st.query(prev, n-1);\n            int sval = suf.first;\n            if (sval > threshold) {\n                // no suitable head pick remains\n                break;\n            }\n            // otherwise pick that index into the head\n            int j = suf.second;\n            headVals.push_back(a[j]);\n            headPicked[j] = true;\n            // remove it from consideration\n            st.update(j, INF);\n            // next head pick must come after j\n            prev = j + 1;\n        }\n\n        // Collect the tail elements (those not picked into head),\n        // sort them by original value, and then each is incremented by 1\n        vector<int> tailVals;\n        tailVals.reserve(n - headVals.size());\n        for (int i = 0; i < n; i++) {\n            if (!headPicked[i]) {\n                tailVals.push_back(a[i]);\n            }\n        }\n        sort(tailVals.begin(), tailVals.end());\n\n        // Output the result: head (unchanged), then tail (each +1)\n        bool first = true;\n        for (int v : headVals) {\n            if (!first) cout << ' ';\n            cout << v;\n            first = false;\n        }\n        for (int v : tailVals) {\n            if (!first) cout << ' ';\n            cout << (v + 1);\n            first = false;\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2046a",
      "PROBLEM_ID": "2046A",
      "PROBLEM_STATEMENT": "There is a matrix consisting of $2$ rows and $n$ columns. The rows are numbered from $1$ to $2$ from top to bottom; the columns are numbered from $1$ to $n$ from left to right. Let's denote the cell on the intersection of the $i$-th row and the $j$-th column as $(i,j)$. Each cell contains an integer; initially, the integer in the cell $(i,j)$ is $a_{i,j}$.\n\nYou can perform the following operation any number of times (possibly zero):\n\n- choose two columns and swap them (i.\u2009e. choose two integers $x$ and $y$ such that $1 \\le x < y \\le n$, then swap $a_{1,x}$ with $a_{1,y}$, and then swap $a_{2,x}$ with $a_{2,y}$).\n\nAfter performing the operations, you have to choose a path from the cell $(1,1)$ to the cell $(2,n)$. For every cell $(i,j)$ in the path except for the last, the next cell should be either $(i+1,j)$ or $(i,j+1)$. Obviously, the path cannot go outside the matrix.\n\nThe cost of the path is the sum of all integers in all $(n+1)$ cells belonging to the path. You have to perform the operations and choose a path so that its cost is maximum possible.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5000$). The description of the test cases follows.\n\nEach test case consists of three lines:\n\n- the first line contains one integer $n$ ($1 \\le n \\le 5000$) \u2014 the number of columns in the matrix;\n- the second line contains $n$ integers $a_{1,1}, a_{1,2}, \\ldots, a_{1,n}$ ($-10^5 \\le a_{i,j} \\le 10^5$) \u2014 the first row of the matrix;\n- the third line contains $n$ integers $a_{2,1}, a_{2,2}, \\ldots, a_{2,n}$ ($-10^5 \\le a_{i,j} \\le 10^5$) \u2014 the second row of the matrix.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\n### Output\n\nFor each test case, print one integer \u2014 the maximum cost of a path you can obtain.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n1\n\n-10\n\n5\n\n3\n\n1 2 3\n\n10 -5 -3\n\n4\n\n2 8 5 3\n\n1 10 3 4\n\n```\n\n#### Output #1\n\n```\n-5\n16\n29\n```\n\n### Note\n\nHere are the explanations of the first three test cases of the example. The left matrix is the matrix given in the input, the right one is the state of the matrix after several column swaps (possibly zero). The optimal path is highlighted in green.\n\n![](https://espresso.codeforces.com/e7b0e0b73deafdd300cca5214c9e7584889e20ad.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main()\n{\n\tint t;\n\tcin >> t;\n\tint n;\n\twhile(t --)\n\t{\n\t\tcin >> n;\n\t\tvector<int>a(n) , b(n);\n\t\tfor(int i = 0;i < n;i ++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t}\n\t\tint cnt = 0 , minn = -10000000;\n\t\tfor(int i = 0;i < n;i ++)\n\t\t{\n\t\t\tcin >> b[i];\n\t\t\tcnt += max(a[i] , b[i]);\n\t\t\tminn = max(minn , min(a[i] , b[i]));\n\t\t}\n\t\tcout << cnt + minn << endl;\n\t}\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2044g2",
      "PROBLEM_ID": "2044G2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The key difference between the two versions is highlighted in bold.\n\nA group of $n$ spiders has come together to exchange plushies. Initially, each spider has $1$ plushie. Every year, if spider $i$ has at least one plushie, he will give exactly one plushie to spider $r_i$. Otherwise, he will do nothing. Note that all plushie transfers happen at the same time. In this version, each spider is allowed to have more than 1 plushie at any point in time.\n\nThe process is stable in the current year if each spider has the same number of plushies (before the current year's exchange) as he did the previous year (before the previous year's exchange). Note that year $1$ can never be stable.\n\nFind the first year in which the process becomes stable.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the number of spiders.\n\nThe following line contains $n$ integers $r_1, r_2, \\ldots, r_n$ ($1 \\leq r_i \\leq n, r_i \\neq i$) \u2014 the recipient of the plushie of each spider.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output an integer on a new line, the first year in which the process becomes stable.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n2 1\n\n5\n\n2 3 4 5 1\n\n5\n\n2 1 4 2 3\n\n5\n\n4 1 1 5 4\n\n10\n\n4 3 9 1 6 7 9 10 10 3\n\n```\n\n#### Output #1\n\n```\n2\n2\n5\n5\n5\n```\n\n### Note\n\nFor the second test case:\n\n- At year $1$, the following array shows the number of plushies each spider has: $[1, 1, 1, 1, 1]$. Then, year $1$'s exchange happens.\n- At year $2$, the following array shows the number of plushies each spider has: $[1, 1, 1, 1, 1]$. Since this array is the same as the previous year, this year is stable.\n\nFor the third test case:\n\n- At year $1$, the following array shows the number of plushies each spider has: $[1, 1, 1, 1, 1]$. Then, year $1$'s exchange happens.\n- At year $2$, the following array shows the number of plushies each spider has: $[1, 2, 1, 1, 0]$. Then, year $2$'s exchange happens.\n- At year $3$, the following array shows the number of plushies each spider has: $[1, 3, 0, 1, 0]$. Then, year $3$'s exchange happens.\n- At year $4$, the following array shows the number of plushies each spider has: $[1, 4, 0, 0, 0]$. Then, year $4$'s exchange happens.\n- At year $5$, the following array shows the number of plushies each spider has: $[1, 4, 0, 0, 0]$. Since this array is the same as the previous year, this year is stable.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> r(n+1), indeg(n+1), sz(n+1, 1);\n        for (int i = 1; i <= n; ++i) {\n            cin >> r[i];\n        }\n        // Compute indegrees in the original graph\n        for (int i = 1; i <= n; ++i) {\n            indeg[i] = 0;\n        }\n        for (int i = 1; i <= n; ++i) {\n            indeg[r[i]]++;\n        }\n        // Kahn's algorithm to remove non-cycle nodes, computing subtree sizes\n        vector<int> q;\n        q.reserve(n);\n        for (int i = 1; i <= n; ++i) {\n            if (indeg[i] == 0) {\n                q.push_back(i);\n            }\n        }\n        int head = 0;\n        int max_sz = 0;\n        while (head < (int)q.size()) {\n            int u = q[head++];\n            // u is a non-cycle node; its subtree size is sz[u]\n            max_sz = max(max_sz, sz[u]);\n            int v = r[u];\n            // Propagate its size to its parent in the functional graph\n            sz[v] += sz[u];\n            // Remove the edge u -> v\n            if (--indeg[v] == 0) {\n                q.push_back(v);\n            }\n        }\n        // The first stable year is (max subtree size) + 2\n        cout << (max_sz + 2) << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2044g1",
      "PROBLEM_ID": "2044G1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The key difference between the two versions is highlighted in bold.\n\nA group of $n$ spiders has come together to exchange plushies. Initially, each spider has $1$ plushie. Every year, if spider $i$ has at least one plushie, he will give exactly one plushie to spider $r_i$. Otherwise, he will do nothing. Note that all plushie transfers happen at the same time. In this version, if any spider has more than $1$ plushie at any point in time, they will throw all but $1$ away.\n\nThe process is stable in the current year if each spider has the same number of plushies (before the current year's exchange) as he did the previous year (before the previous year's exchange). Note that year $1$ can never be stable.\n\nFind the first year in which the process becomes stable.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the number of spiders.\n\nThe following line contains $n$ integers $r_1, r_2, \\ldots, r_n$ ($1 \\leq r_i \\leq n, r_i \\neq i$) \u2014 the recipient of the plushie of each spider.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output an integer on a new line, the first year in which the process becomes stable.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n2 1\n\n5\n\n2 3 4 5 1\n\n5\n\n2 1 4 2 3\n\n5\n\n4 1 1 5 4\n\n10\n\n4 3 9 1 6 7 9 10 10 3\n\n```\n\n#### Output #1\n\n```\n2\n2\n5\n4\n5\n```\n\n### Note\n\nFor the second test case:\n\n- At year $1$, the following array shows the number of plushies each spider has: $[1, 1, 1, 1, 1]$. Then, year $1$'s exchange happens.\n- At year $2$, the following array shows the number of plushies each spider has: $[1, 1, 1, 1, 1]$. Since this array is the same as the previous year, this year is stable.\n\nFor the third test case:\n\n- At year $1$, the following array shows the number of plushies each spider has: $[1, 1, 1, 1, 1]$. Then, year $1$'s exchange happens.\n- At year $2$, the following array shows the number of plushies each spider has: $[1, 1, 1, 1, 0]$. Then, year $2$'s exchange happens. Note that even though two spiders gave spider $2$ plushies, spider $2$ may only keep one plushie.\n- At year $3$, the following array shows the number of plushies each spider has: $[1, 1, 0, 1, 0]$. Then, year $3$'s exchange happens.\n- At year $4$, the following array shows the number of plushies each spider has: $[1, 1, 0, 0, 0]$. Then, year $4$'s exchange happens.\n- At year $5$, the following array shows the number of plushies each spider has: $[1, 1, 0, 0, 0]$. Since this array is the same as the previous year, this year is stable.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> r(n+1);\n        for (int i = 1; i <= n; i++) {\n            cin >> r[i];\n        }\n\n        // Build reverse graph and compute indegrees\n        vector<vector<int>> rev(n+1);\n        vector<int> indegree(n+1, 0);\n        for (int i = 1; i <= n; i++) {\n            indegree[r[i]]++;\n            rev[r[i]].push_back(i);\n        }\n\n        // Kahn's algorithm to remove all non-cycle nodes\n        vector<char> removed(n+1, 0);\n        queue<int> q;\n        for (int i = 1; i <= n; i++) {\n            if (indegree[i] == 0) {\n                removed[i] = 1;\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            int v = r[u];\n            if (!removed[v]) {\n                indegree[v]--;\n                if (indegree[v] == 0) {\n                    removed[v] = 1;\n                    q.push(v);\n                }\n            }\n        }\n\n        // BFS from all cycle nodes on the reverse graph to compute\n        // distance (number of steps) from each node to its cycle.\n        vector<int> dist(n+1, -1);\n        queue<int> q2;\n        for (int i = 1; i <= n; i++) {\n            if (!removed[i]) {\n                dist[i] = 0;\n                q2.push(i);\n            }\n        }\n\n        int maxDist = 0;\n        while (!q2.empty()) {\n            int u = q2.front(); q2.pop();\n            for (int v : rev[u]) {\n                if (dist[v] == -1) {\n                    dist[v] = dist[u] + 1;\n                    maxDist = max(maxDist, dist[v]);\n                    q2.push(v);\n                }\n            }\n        }\n\n        // The process becomes stable at year = maxDist + 2\n        cout << (maxDist + 2) << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2044d",
      "PROBLEM_ID": "2044D",
      "PROBLEM_STATEMENT": "Given a sequence of positive integers, a positive integer is called a mode of the sequence if it occurs the maximum number of times that any positive integer occurs. For example, the mode of $[2,2,3]$ is $2$. Any of $9$, $8$, or $7$ can be considered to be a mode of the sequence $[9,9,8,8,7,7]$.\n\nYou gave UFO an array $a$ of length $n$. To thank you, UFO decides to construct another array $b$ of length $n$ such that $a_i$ is a mode of the sequence $[b_1, b_2, \\ldots, b_i]$ for all $1 \\leq i \\leq n$.\n\nHowever, UFO doesn't know how to construct array $b$, so you must help her. Note that $1 \\leq b_i \\leq n$ must hold for your array for all $1 \\leq i \\leq n$.\n\n### Input\n\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the length of $a$.\n\nThe following line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n$ numbers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq n$) on a new line. It can be shown that $b$ can always be constructed. If there are multiple possible arrays, you may print any.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n1 2\n\n4\n\n1 1 1 2\n\n8\n\n4 5 5 5 1 1 2 1\n\n10\n\n1 1 2 2 1 1 3 3 1 1\n\n```\n\n#### Output #1\n\n```\n1 2\n1 1 2 2\n4 5 5 1 1 2 2 3\n1 8 2 2 1 3 3 9 1 1\n```\n\n### Note\n\nLet's verify the correctness for our sample output in test case $2$.\n\n- At $i = 1$, $1$ is the only possible mode of $[1]$.\n- At $i = 2$, $1$ is the only possible mode of $[1, 1]$.\n- At $i = 3$, $1$ is the only possible mode of $[1, 1, 2]$.\n- At $i = 4$, $1$ or $2$ are both modes of $[1, 1, 2, 2]$. Since $a_i = 2$, this array is valid.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for(auto &x: a) cin >> x;\n        vector<int> b(n, 0);\n        // Initialize frequency array\n        // Using 1-based indexing for convenience\n        vector<int> freq(n+1, 0);\n        int current_max_freq = 0;\n        int replacement_num = 1;\n        for(int i=0; i<n; ++i){\n            int x = a[i];\n            if(freq[x] == current_max_freq && current_max_freq > 0){\n                // Need to set to 'other'\n                // Find y !=x with freq[y] < current_max_freq\n                while( (replacement_num == x) || (replacement_num >=1 && replacement_num <=n && freq[replacement_num] >= current_max_freq)){\n                    replacement_num++;\n                    if(replacement_num > n){\n                        replacement_num = 1;\n                    }\n                }\n                // It's guaranteed that such y exists\n                // Assign y = replacement_num\n                int y = replacement_num;\n                b[i] = y;\n                freq[y] +=1;\n                if(freq[y] > current_max_freq){\n                    current_max_freq = freq[y];\n                }\n                // Move replacement_num forward for next use\n                replacement_num++;\n                if(replacement_num > n){\n                    replacement_num =1;\n                }\n            }\n            else{\n                // Set to a_i\n                b[i] = x;\n                freq[x] +=1;\n                if(freq[x] > current_max_freq){\n                    current_max_freq = freq[x];\n                }\n            }\n        }\n        // Output the sequence\n        for(int i=0; i<n; ++i){\n            cout << b[i] << (i<n-1?\" \":\"\\n\");\n        }\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2044c",
      "PROBLEM_ID": "2044C",
      "PROBLEM_STATEMENT": "Ball is the teacher in Paperfold University. The seats of his classroom are arranged in $2$ rows with $m$ seats each.\n\nBall is teaching $a + b + c$ monkeys, and he wants to assign as many monkeys to a seat as possible. Ball knows that $a$ of them only want to sit in row $1$, $b$ of them only want to sit in row $2$, and $c$ of them have no preference. Only one monkey may sit in each seat, and each monkey's preference must be followed if it is seated.\n\nWhat is the maximum number of monkeys that Ball can seat?\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nEach test case contains four integers $m$, $a$, $b$, and $c$ ($1 \\leq m, a, b, c \\leq 10^8$).\n\n### Output\n\nFor each test case, output the maximum number of monkeys you can seat.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n10 5 5 10\n\n3 6 1 1\n\n15 14 12 4\n\n1 1 1 1\n\n420 6 9 69\n\n```\n\n#### Output #1\n\n```\n20\n5\n30\n2\n84\n```\n\n### Note\n\nIn the second test case, $6$ monkeys want to sit in the front row, but only $3$ seats are available. The monkeys that have no preference and the monkeys who prefer sitting in the second row can sit in the second row together. Thus, the answer is $3+2=5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvoid solve() {\n    long long m, a, b, c;\n    cin >> m >> a >> b >> c;\n    \n    // For row 1: Take minimum of available seats and monkeys who want row 1\n    long long row1_fixed = min(m, a);\n    \n    // For row 2: Take minimum of available seats and monkeys who want row 2\n    long long row2_fixed = min(m, b);\n    \n    // Now distribute remaining flexible monkeys\n    long long remaining_seats = (m - row1_fixed) + (m - row2_fixed);\n    long long flexible_monkeys = min(remaining_seats, c);\n    \n    // Total seated monkeys is sum of fixed and flexible\n    cout << row1_fixed + row2_fixed + flexible_monkeys << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2044b",
      "PROBLEM_ID": "2044B",
      "PROBLEM_STATEMENT": "A string consisting of only characters 'p', 'q', and 'w' is painted on a glass window of a store. Ship walks past the store, standing directly in front of the glass window, and observes string $a$. Ship then heads inside the store, looks directly at the same glass window, and observes string $b$.\n\nShip gives you string $a$. Your job is to find and output $b$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases.\n\nThe only line of each test case contains a string $a$ ($1 \\leq |a| \\leq 100$) \u2014 the string Ship observes from outside the store. It is guaranteed that $a$ only contains characters 'p', 'q', and 'w'.\n\n### Output\n\nFor each test case, output string $b$, the string Ship observes from inside the store, on a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\nqwq\n\nppppp\n\npppwwwqqq\n\nwqpqwpqwwqp\n\npqpqpqpq\n\n```\n\n#### Output #1\n\n```\npwp\nqqqqq\npppwwwqqq\nqpwwpqwpqpw\npqpqpqpq\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring mirrorString(const string& s) {\n    string result = s;\n    // First reverse the string\n    int n = s.length();\n    for(int i = 0; i < n; i++) {\n        // Get character from opposite end\n        char c = s[n-1-i];\n        // Mirror the character if needed\n        if(c == 'p') c = 'q';\n        else if(c == 'q') c = 'p';\n        // 'w' remains unchanged\n        result[i] = c;\n    }\n    return result;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while(t--) {\n        string s;\n        cin >> s;\n        cout << mirrorString(s) << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2043g",
      "PROBLEM_ID": "2043G",
      "PROBLEM_STATEMENT": "You are given an array $a$, consisting of $n$ integers. Your task is to process $q$ queries of two types:\n\n- $1~p~x$\u00a0\u2014 set the value of the element at index $p$ equal to $x$;\n- $2~l~r$\u00a0\u2014 count the number of pairs of indices $(i, j)$ such that $l \\le i < j \\le r$ and $a_i \\ne a_j$.\n\nNote that the queries in this task are encoded; each subsequent query can only be decoded after calculating the answer to the preceding query of the second type.\n\n### Input\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$).\n\nThe third line contains a single integer $q$ ($1 \\le q \\le 3 \\cdot 10^5$)\u00a0\u2014 the number of queries.\n\nThe next $q$ lines describe the queries in one of the following formats:\n\n- $1~p'~x'$ ($0 \\le p', x' \\le n-1$);\n- $2~l'~r'$ ($0 \\le l', r' \\le n-1$).\n\nThe queries are encoded as follows: let $\\mathit{last}$ be the answer to the latest processed query of the second type (initially, $\\mathit{last} = 0$).\n\n- if the type of the query is $1$, then $p = ((p' + \\mathit{last}) \\bmod n) + 1$, $x = ((x' + \\mathit{last}) \\bmod n) + 1$.\n- if the type of the query is $2$, $l = ((l' + \\mathit{last}) \\bmod n) + 1$, $r = ((r' + \\mathit{last}) \\bmod n) + 1$. If $l > r$, swap their values.\n\nDon't forget to update the value of $\\mathit{last}$ after answering each query of the second type.\n\nAdditional constraint on the input: there is at least one query of the second type.\n\n### Output\n\nFor each query of the second type, print the answer\u00a0\u2014 the number of pairs of indices $(i, j)$ such that $l \\le i < j \\le r$ and $a_i \\ne a_j$.\n\n### Examples\n\n#### Input #1\n\n```\n\n3\n\n1 2 3\n\n5\n\n2 0 2\n\n1 0 2\n\n2 0 2\n\n1 2 0\n\n2 1 0\n\n```\n\n#### Output #1\n\n```\n3 2 0 ```\n\n#### Input #2\n\n```\n\n7\n\n1 3 4 4 7 1 3\n\n3\n\n2 1 6\n\n2 1 0\n\n2 5 6\n\n```\n\n#### Output #2\n\n```\n13 18 0 ```\n\n### Note\n\nIn the first example, the actual queries (after decoding) are:\n\n- 2 1 3\n- 1 1 3\n- 2 1 3\n- 1 2 3\n- 2 1 3",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n \n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define FIO ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <ll, ll> pii;\n \nconst int N = 1e5 + 7, B = 400;\n \nint n, nn, q;\nint a[N], fr[N];\nll ps[B][N], le[B][B], ri[B][B];\n \nvoid add(int x, int y, int o) {\n\ta[x] = y;\n\tint p = x/B;\n\tfor (int i = 0; i <= p; i++) ri[i][p] += (ps[p+1][y]-ps[i][y]-(o==-1))*o;\n\tfor (int i = p+1; i < nn; i++) le[i][p] += (ps[i+1][y]-ps[p+1][y])*o;\n\tfor (int i = p+1; i <= nn; i++) ps[i][y] += o;\n}\n \nint main () {\n\tFIO;\n\tcin >> n;\n\tnn = (n+B-1)/B;\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i]; a[i]--;\n\t\tadd(i, a[i], 1);\n\t}\n\t\n\tcin >> q;\n\tll la = 0;\n\twhile (q--) {\n\t\tint o, x, y; cin >> o >> x >> y;\n\t\tx = (x+la)%n; y = (y+la)%n;\n\t\tif (o == 2 && x > y) swap(x, y);\n\t\tif (o == 1) {\n\t\t\tadd(x, a[x], -1);\n\t\t\tadd(x, y, 1);\n\t\t}\n\t\telse {\n\t\t\tll res = 0;\n\t\t\tint xb = x/B+1, yb = y/B;\n\t\t\tfor (int i = xb; i < yb; i++) res += ri[xb][i]+le[yb-1][i];\n\t\t\tif (xb > yb) {\n\t\t\t\tfor (int i = x; i <= y; i++) res += fr[a[i]]++;\n\t\t\t\tfor (int i = x; i <= y; i++) fr[a[i]] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = x; i < xb*B; i++) res += ps[yb][a[i]]-ps[xb][a[i]]+fr[a[i]]++;\n\t\t\t\tfor (int i = yb*B; i <= y; i++) res += ps[yb][a[i]]-ps[xb][a[i]]+fr[a[i]]++;\n\t\t\t\tfor (int i = x; i < xb*B; i++) fr[a[i]] = 0;\n\t\t\t\tfor (int i = yb*B; i <= y; i++) fr[a[i]] = 0;\n\t\t\t}\n\t\t\tcout << (la = (ll)(y-x)*(y-x+1)/2-res) << \" \";\n\t\t}\n\t}\n \n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2043c",
      "PROBLEM_ID": "2043C",
      "PROBLEM_STATEMENT": "You are given an array $a$ of $n$ integers, where all elements except for at most one are equal to $-1$ or $1$. The remaining element $x$ satisfies $-10^9 \\le x \\le 10^9$.\n\nFind all possible sums of subarrays of $a$, including the empty subarray, whose sum is defined as $0$. In other words, find all integers $x$ such that the array $a$ has at least one subarray (possibly empty) with sum equal to $x$. A subarray is a contiguous subsegment of an array.\n\nOutput these sums in ascending order. Each sum should be printed only once, even if it is achieved by multiple subarrays.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. Then, $t$ test cases follow.\n\nEach test case consists of two lines:\n\n- The first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the size of the array.\n- The second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$) \u2014 the elements of the array $a$. In the array $a$, there is at most one element that is neither $1$ nor $-1$.\n\nAdditional constraint on the input: the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output two lines:\n\n- In the first line, print a single integer \u2014 the number of distinct subarray sums.\n- In the second line, print these sums in ascending order.\n\nEach sum should be printed only once, even if it is produced by multiple subarrays.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n5\n\n1 -1 10 1 1\n\n5\n\n-1 -1 -1 -1 -1\n\n2\n\n-1 2\n\n2\n\n7 1\n\n3\n\n1 4 -1\n\n```\n\n#### Output #1\n\n```\n8\n-1 0 1 2 9 10 11 12\n6\n-5 -4 -3 -2 -1 0\n4\n-1 0 1 2\n4\n0 1 7 8\n6\n-1 0 1 3 4 5\n```\n\n### Note\n\nLet's define $a[i,j]$ as the subarray of $a$ from position $i$ to position $j$.\n\nConsider the first test case of the example:\n\n- $-1$ is produced by $a[2,2]$;\n- $0$ is produced by the empty subarray;\n- $1$ is produced by $a[4,4]$;\n- $2$ is produced by $a[4,5]$;\n- $9$ is produced by $a[2,3]$;\n- $10$ is produced by $a[1,3]$;\n- $11$ is produced by $a[3,4]$;\n- $12$ is produced by $a[3,5]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <vector> // Ensure vector is included if not implicitly by others\n\n// Use long long for sums as they can exceed 32-bit integer limits\ntypedef long long ll;\n\nusing namespace std;\n\n// Structure to represent an interval [L, R]\nstruct Interval {\n    ll L, R;\n\n    // Custom comparison for sorting intervals based on start point\n    // This is needed for the std::sort function.\n    bool operator<(const Interval& other) const {\n        if (L != other.L) return L < other.L;\n        // If start points are equal, sort by end point. This isn't strictly necessary for merging logic\n        // but provides a consistent ordering.\n        return R < other.R; \n    }\n};\n\n// Function to compute max subarray sum using a Kadane's algorithm variant.\n// This version returns max(0, max non-empty subarray sum).\n// It correctly handles the case where all elements are negative (returns 0)\n// and includes the empty subarray sum (0) implicitly.\nll max_subarray_sum(const vector<int>& arr) {\n    ll max_so_far = 0; // Initialize max sum found so far to 0 (for empty subarray)\n    ll current_max = 0; // Initialize current subarray sum to 0\n    if (arr.empty()) return 0; // If array is empty, only sum is 0\n\n    for (int x_int : arr) {\n        ll x = x_int; // Use long long for intermediate sum calculations\n        current_max += x;\n        // If current_max drops below 0, it's better to start a new subarray from the next element.\n        // Reset current_max to 0.\n        if (current_max < 0) {\n            current_max = 0;\n        }\n        // Update the overall maximum sum found.\n        max_so_far = max(max_so_far, current_max);\n    }\n    return max_so_far;\n}\n\n// Function to compute min subarray sum using a Kadane's algorithm variant.\n// This version returns min(0, min non-empty subarray sum).\n// It correctly handles the case where all elements are positive (returns 0)\n// and includes the empty subarray sum (0) implicitly.\nll min_subarray_sum(const vector<int>& arr) {\n    ll min_so_far = 0; // Initialize min sum found so far to 0 (for empty subarray)\n    ll current_min = 0; // Initialize current subarray sum to 0\n    if (arr.empty()) return 0; // If array is empty, only sum is 0\n\n    for (int x_int : arr) {\n        ll x = x_int; // Use long long for intermediate sum calculations\n        current_min += x;\n         // If current_min becomes positive, it's better to start a new subarray from the next element\n         // when looking for the minimum sum. Reset current_min to 0.\n        if (current_min > 0) {\n            current_min = 0;\n        }\n        // Update the overall minimum sum found.\n        min_so_far = min(min_so_far, current_min);\n    }\n    return min_so_far;\n}\n\n// Function to compute max prefix sum, including 0 for the empty prefix.\nll max_prefix_sum(const vector<int>& arr) {\n    ll max_pref = 0; // Initialize max prefix sum to 0 (empty prefix)\n    ll current_sum = 0;\n    for (int x_int : arr) {\n         ll x = x_int; // Use long long for sum calculation\n        current_sum += x;\n        max_pref = max(max_pref, current_sum); // Update max prefix sum\n    }\n    return max_pref;\n}\n\n// Function to compute min prefix sum, including 0 for the empty prefix.\nll min_prefix_sum(const vector<int>& arr) {\n    ll min_pref = 0; // Initialize min prefix sum to 0 (empty prefix)\n    ll current_sum = 0;\n    for (int x_int : arr) {\n         ll x = x_int; // Use long long for sum calculation\n        current_sum += x;\n        min_pref = min(min_pref, current_sum); // Update min prefix sum\n    }\n    return min_pref;\n}\n\n// Function to compute max suffix sum, including 0 for the empty suffix.\nll max_suffix_sum(const vector<int>& arr) {\n    ll max_suff = 0; // Initialize max suffix sum to 0 (empty suffix)\n    ll current_sum = 0;\n    // Iterate from the end of the array to the beginning\n    for (int i = arr.size() - 1; i >= 0; --i) {\n         ll x = arr[i]; // Use long long for sum calculation\n        current_sum += x;\n        max_suff = max(max_suff, current_sum); // Update max suffix sum\n    }\n    return max_suff;\n}\n\n// Function to compute min suffix sum, including 0 for the empty suffix.\nll min_suffix_sum(const vector<int>& arr) {\n    ll min_suff = 0; // Initialize min suffix sum to 0 (empty suffix)\n    ll current_sum = 0;\n     // Iterate from the end of the array to the beginning\n    for (int i = arr.size() - 1; i >= 0; --i) {\n         ll x = arr[i]; // Use long long for sum calculation\n        current_sum += x;\n        min_suff = min(min_suff, current_sum); // Update min suffix sum\n    }\n    return min_suff;\n}\n\n// Helper function to extract a subarray as a new vector.\n// Takes 0-based indices [start, end] inclusive. \n// Handles edge cases like invalid ranges or indices outside array bounds.\nvector<int> get_subarray(const vector<int>& a, int start, int end) {\n     // Basic check for invalid range before any index access\n     if (start > end || start >= (int)a.size() || end < 0) {\n          return {}; // Return empty vector for invalid range request\n     }\n     \n     // Clamp indices to ensure they are within the valid bounds [0, a.size()-1]\n     start = max(0, start);\n     end = min((int)a.size() - 1, end);\n\n     // Check again after clamping, the range might become invalid (e.g., start > end)\n     if (start > end) {\n         return {}; // Return empty vector if range is invalid after clamping\n     }\n\n     // Create the subarray vector\n     vector<int> sub;\n     sub.reserve(end - start + 1); // Reserve memory for efficiency\n     // Copy elements from the original array to the subarray vector\n     for (int i = start; i <= end; ++i) {\n         sub.push_back(a[i]);\n     }\n     return sub;\n }\n\nint main() {\n    // Use faster I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        int n; // Size of the array for the current test case\n        cin >> n;\n        vector<int> a(n); // Declare the array\n        ll x_val = 0; // Stores the value of the exceptional element (if any), use long long\n        int x_idx = -1; // Stores the 0-based index of the exceptional element, -1 if none exists\n        \n        // Read array elements and identify the exceptional element\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            // An element is exceptional if it's not 1 and not -1\n            if (a[i] != 1 && a[i] != -1) {\n                // According to problem statement, there's at most one such element.\n                x_val = a[i];\n                x_idx = i;\n            }\n        }\n\n        vector<Interval> intervals; // Vector to store intervals representing possible sums\n        \n        if (x_idx == -1) {\n            // Case 1: No exceptional element. All elements are 1 or -1.\n            // The set of all possible subarray sums forms a single continuous interval.\n            // This interval is [min(0, S_min), max(0, S_max)], where S_min and S_max are the min/max subarray sums.\n            ll S_min = min_subarray_sum(a);\n            ll S_max = max_subarray_sum(a);\n            \n            ll final_min = min(0LL, S_min); // The lower bound of the interval\n            ll final_max = max(0LL, S_max); // The upper bound of the interval\n            \n            intervals.push_back({final_min, final_max}); // Add the single interval\n\n        } else {\n             // Case 2: There is one exceptional element `x_val` at index `x_idx`.\n             // We consider three types of subarrays based on their relation to the exceptional element.\n\n             // Interval 1: Sums from subarrays entirely before the exceptional element.\n             // These subarrays are within a[0...x_idx-1].\n             vector<int> pre_arr = get_subarray(a, 0, x_idx - 1);\n             ll S_min_pre = min_subarray_sum(pre_arr);\n             ll S_max_pre = max_subarray_sum(pre_arr);\n             // The sums form the interval [min(0, S_min_pre), max(0, S_max_pre)].\n             intervals.push_back({min(0LL, S_min_pre), max(0LL, S_max_pre)});\n            \n             // Interval 2: Sums from subarrays entirely after the exceptional element.\n             // These subarrays are within a[x_idx+1...n-1].\n             vector<int> post_arr = get_subarray(a, x_idx + 1, n - 1);\n             ll S_min_post = min_subarray_sum(post_arr);\n             ll S_max_post = max_subarray_sum(post_arr);\n              // The sums form the interval [min(0, S_min_post), max(0, S_max_post)].\n             intervals.push_back({min(0LL, S_min_post), max(0LL, S_max_post)});\n\n             // Interval 3: Sums from subarrays containing the exceptional element.\n             // A subarray a[i...j] containing x (i <= x_idx <= j) has sum:\n             // (sum of suffix of pre_arr starting at i) + x_val + (sum of prefix of post_arr ending at j)\n             // We need the range of possible suffix sums of pre_arr and prefix sums of post_arr.\n             \n             // Calculate range for suffix sums of pre_arr (including empty suffix sum 0)\n             ll min_suf_pre = min_suffix_sum(pre_arr);\n             ll max_suf_pre = max_suffix_sum(pre_arr);\n             ll L1_prime = min(0LL, min_suf_pre); // Lower bound for suffix sums part\n             ll R1_prime = max(0LL, max_suf_pre); // Upper bound for suffix sums part\n\n             // Calculate range for prefix sums of post_arr (including empty prefix sum 0)\n             ll min_pref_post = min_prefix_sum(post_arr);\n             ll max_pref_post = max_prefix_sum(post_arr);\n             ll L2_prime = min(0LL, min_pref_post); // Lower bound for prefix sums part\n             ll R2_prime = max(0LL, max_pref_post); // Upper bound for prefix sums part\n             \n             // The interval for sums containing x is the sum of ranges: [L1' + x_val + L2', R1' + x_val + R2']\n             intervals.push_back({L1_prime + x_val + L2_prime, R1_prime + x_val + R2_prime});\n        }\n\n        // Merge the potentially overlapping intervals into a set of disjoint intervals.\n        sort(intervals.begin(), intervals.end()); // Sort intervals based on their start points (L)\n\n        vector<Interval> merged; // Stores the final disjoint merged intervals\n        for(const auto& current_interval : intervals) {\n            // Skip intervals that are invalid (start > end), although our calculations should produce valid intervals [L, R] where L <= R.\n            if (current_interval.L > current_interval.R) continue; \n\n            if (merged.empty() || current_interval.L > merged.back().R + 1) {\n                // If the list of merged intervals is empty, or if the current interval starts\n                // strictly after the last merged interval ends (with a gap of at least 1),\n                // then start a new merged interval.\n                merged.push_back(current_interval);\n            } else {\n                // Otherwise, the current interval overlaps with or touches the last merged interval.\n                // Extend the end of the last merged interval to encompass the current interval.\n                merged.back().R = max(merged.back().R, current_interval.R);\n            }\n        }\n\n        // Calculate the total count of distinct sums from the merged intervals.\n        ll total_count = 0;\n        for (const auto& interval : merged) {\n             // The number of integers in an interval [L, R] is R - L + 1.\n             total_count += (interval.R - interval.L + 1);\n        }\n        \n        // Output the total count of distinct sums.\n        cout << total_count << \"\\n\";\n\n        // Output all distinct sums in ascending order.\n        bool first = true; // Flag to manage spacing between printed numbers\n        for (const auto& interval : merged) {\n             // Iterate through each integer value within the current merged interval.\n             for (ll val = interval.L; val <= interval.R; ++val) {\n                 if (!first) {\n                     cout << \" \"; // Print a space before the number if it's not the first one printed.\n                 }\n                 cout << val;\n                 first = false; // Update flag after printing the first number.\n             }\n        }\n        cout << \"\\n\"; // Print a newline at the end of the output for this test case.\n    }\n    return 0; // Indicate successful execution.\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2043b",
      "PROBLEM_ID": "2043B",
      "PROBLEM_STATEMENT": "Artem wrote the digit $d$ on the board exactly $n!$ times in a row. So, he got the number $dddddd \\dots ddd$ (exactly $n!$ digits).\n\nNow he is curious about which odd digits from $1$ to $9$ divide the number written on the board.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases. The next $t$ test cases follow.\n\nEach test case consists of a single line containing two integers $n$ and $d$ ($2 \\le n \\le 10^9$, $1 \\le d \\le 9$).\n\n### Output\n\nFor each test case, output the odd digits in ascending order that divide the number written on the board.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 6\n\n7 1\n\n8 5\n\n```\n\n#### Output #1\n\n```\n1 3\n1 3 7 9\n1 3 5 7 9\n```\n\n### Note\n\nThe factorial of a positive integer $n$ ($n!$) is the product of all integers from $1$ to $n$. For example, the factorial of $5$ is $1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 = 120$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, d;\n        std::cin >> n >> d;\n        std::vector<int> divisors;\n        divisors.push_back(1);\n        if ((n >= 3) || (n == 2 && (d == 3 || d == 6 || d == 9))) {\n            divisors.push_back(3);\n        }\n        if (d == 5) {\n            divisors.push_back(5);\n        }\n        if ((n >= 3) || (n == 2 && d == 7)) {\n            divisors.push_back(7);\n        }\n        if ((n >= 6) || ((n >= 3 && n <= 5) && (d == 3 || d == 6 || d == 9)) || (n == 2 && d == 9)) {\n            divisors.push_back(9);\n        }\n        std::sort(divisors.begin(), divisors.end());\n        divisors.erase(std::unique(divisors.begin(), divisors.end()), divisors.end());\n        for (size_t i = 0; i < divisors.size(); ++i) {\n            std::cout << divisors[i] << (i == divisors.size() - 1 ? \"\" : \" \");\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2043a",
      "PROBLEM_ID": "2043A",
      "PROBLEM_STATEMENT": "Initially, you have a coin with value $n$. You can perform the following operation any number of times (possibly zero):\n\n- transform one coin with value $x$, where $x$ is greater than $3$ ($x>3$), into two coins with value $\\lfloor \\frac{x}{4} \\rfloor$.\n\nWhat is the maximum number of coins you can have after performing this operation any number of times?\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of one line containing one integer $n$ ($1 \\le n \\le 10^{18}$).\n\n### Output\n\nFor each test case, print one integer \u2014 the maximum number of coins you can have after performing the operation any number of times.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n5\n\n16\n\n1000000000000000000\n\n```\n\n#### Output #1\n\n```\n1\n2\n4\n536870912\n```\n\n### Note\n\nIn the first example, you have a coin of value $1$, and you can't do anything with it. So, the answer is $1$.\n\nIn the second example, you can transform a coin of value $5$ into two coins with value $1$.\n\nIn the third example, you can transform a coin of value $16$ into two coins with value $4$. Each of the resulting coins can be transformed into two coins with value $1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\n// Memoization map\nunordered_map<long long, long long> dp;\n\nlong long getMaxCoins(long long n) {\n    // Base case: If the coin value is less than or equal to 3, it cannot be split further\n    if (n <= 3) {\n        return 1;\n    }\n    // If already computed, return the stored result\n    if (dp.find(n) != dp.end()) {\n        return dp[n];\n    }\n    // Recurring case: Split the coin and sum up the results\n    long long halfCoins = getMaxCoins(n / 4);\n    dp[n] = 2 * halfCoins;\n\n    return dp[n];\n}\n\nint main() {\n    int t;\n    cin >> t; // Number of test cases\n    while (t--) {\n        long long n;\n        cin >> n;\n        // Reset memoization map for new test cases\n        cout << getMaxCoins(n) << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2042f",
      "PROBLEM_ID": "2042F",
      "PROBLEM_STATEMENT": "You are given two integer arrays $a$ and $b$, both of size $n$.\n\nLet's define the cost of the subarray $[l, r]$ as $a_l + a_{l + 1} + \\cdots + a_{r - 1} + a_r + b_l + b_r$. If $l=r$, then the cost of the subarray is $a_l + 2 \\cdot b_l$.\n\nYou have to perform queries of three types:\n\n- \"$1$ $p$ $x$\"\u00a0\u2014 assign $a_{p} := x$;\n- \"$2$ $p$ $x$\"\u00a0\u2014 assign $b_{p} := x$;\n- \"$3$ $l$ $r$\"\u00a0\u2014 find two non-empty non-overlapping subarrays within the segment $[l, r]$ with the maximum total cost and print their total cost.\n\n### Input\n\nThe first line contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$).\n\nThe third line contains $n$ integers $b_1, b_2, \\dots, b_n$ ($-10^9 \\le b_i \\le 10^9$).\n\nThe fourth line contains a single integer $q$ ($1 \\le q \\le 2 \\cdot 10^5$).\n\nThe next $q$ lines contain the queries: one per line. Each query is of one of three types:\n\n- \"$1$ $p$ $x$\" ($1 \\le p \\le n$; $-10^9 \\le x \\le 10^9$);\n- \"$2$ $p$ $x$\" ($1 \\le p \\le n$; $-10^9 \\le x \\le 10^9$);\n- \"$3$ $l$ $r$\" ($1 \\le l < r \\le n$).\n\nIt is guaranteed that there is at least one query of the third type.\n\n### Output\n\nFor each query of the third type, print the maximum possible total cost of two non-empty non-overlapping subarrays within the segment $[l, r]$.\n\n### Examples\n\n#### Input #1\n\n```\n\n7\n\n3 -1 4 -3 2 4 0\n\n0 6 1 0 -3 -2 -1\n\n6\n\n3 1 7\n\n1 2 0\n\n3 3 6\n\n2 5 -3\n\n1 3 2\n\n3 1 5\n\n```\n\n#### Output #1\n\n```\n18\n7\n16\n```\n\n#### Input #2\n\n```\n\n10\n\n2 -1 -3 -2 0 4 5 6 2 5\n\n2 -4 -5 -1 6 2 5 -6 4 2\n\n10\n\n3 6 7\n\n1 10 -2\n\n3 5 7\n\n3 2 8\n\n2 1 -5\n\n2 7 4\n\n3 1 3\n\n3 3 8\n\n3 2 3\n\n1 4 4\n\n```\n\n#### Output #2\n\n```\n23\n28\n28\n-17\n27\n-22\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstatic const ll NEG_INF = -(1LL << 60);\n\nstruct Node {\n    ll m[5][5];\n};\n\n// Multiply two nodes in max-plus semiring: C = A * B\ninline Node multiply(const Node &A, const Node &B) {\n    Node C;\n    // initialize C with NEG_INF\n    for(int i = 0; i < 5; i++) {\n        for(int j = 0; j < 5; j++) {\n            C.m[i][j] = NEG_INF;\n        }\n    }\n    // compute only for i <= k (upper triangular)\n    for(int i = 0; i < 5; i++) {\n        for(int k = i; k < 5; k++) {\n            ll best = NEG_INF;\n            // j from i..k\n            for(int j = i; j <= k; j++) {\n                ll v1 = A.m[i][j];\n                if(v1 == NEG_INF) continue;\n                ll v2 = B.m[j][k];\n                if(v2 == NEG_INF) continue;\n                ll v = v1 + v2;\n                if(v > best) best = v;\n            }\n            C.m[i][k] = best;\n        }\n    }\n    return C;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n    vector<ll> a(n), b(n);\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for(int i = 0; i < n; i++) {\n        cin >> b[i];\n    }\n\n    // build identity node\n    Node identity;\n    for(int i = 0; i < 5; i++) {\n        for(int j = 0; j < 5; j++) {\n            identity.m[i][j] = (i == j ? 0 : NEG_INF);\n        }\n    }\n\n    // next power of two >= n\n    int N = 1;\n    while(N < n) N <<= 1;\n    // segment tree array size = 2*N\n    vector<Node> seg(2 * N);\n\n    // function to build leaf node for position i\n    auto build_node = [&](int i)->Node {\n        Node nd;\n        // initialize with NEG_INF\n        for(int p = 0; p < 5; p++)\n            for(int q = 0; q < 5; q++)\n                nd.m[p][q] = NEG_INF;\n        ll ai = a[i], bi = b[i];\n        // transitions\n        nd.m[0][0] = 0;\n        nd.m[0][1] = bi + ai;\n        nd.m[0][2] = bi + ai + bi;  // = ai + 2*bi\n        nd.m[1][1] = ai;\n        nd.m[1][2] = ai + bi;\n        nd.m[2][2] = 0;\n        nd.m[2][3] = bi + ai;\n        nd.m[2][4] = bi + ai + bi;\n        nd.m[3][3] = ai;\n        nd.m[3][4] = ai + bi;\n        nd.m[4][4] = 0;\n        return nd;\n    };\n\n    // build leaves\n    for(int i = 0; i < N; i++) {\n        if(i < n) {\n            seg[N + i] = build_node(i);\n        } else {\n            seg[N + i] = identity;\n        }\n    }\n    // build internals\n    for(int i = N - 1; i >= 1; i--) {\n        seg[i] = multiply(seg[2 * i], seg[2 * i + 1]);\n    }\n\n    int q;\n    cin >> q;\n    while(q--) {\n        int type;\n        cin >> type;\n        if(type == 1) {\n            int p;\n            ll x;\n            cin >> p >> x;\n            --p;\n            a[p] = x;\n            int idx = N + p;\n            seg[idx] = build_node(p);\n            idx >>= 1;\n            while(idx >= 1) {\n                seg[idx] = multiply(seg[2 * idx], seg[2 * idx + 1]);\n                idx >>= 1;\n            }\n        } else if(type == 2) {\n            int p;\n            ll x;\n            cin >> p >> x;\n            --p;\n            b[p] = x;\n            int idx = N + p;\n            seg[idx] = build_node(p);\n            idx >>= 1;\n            while(idx >= 1) {\n                seg[idx] = multiply(seg[2 * idx], seg[2 * idx + 1]);\n                idx >>= 1;\n            }\n        } else {\n            int l, r;\n            cin >> l >> r;\n            --l; --r;\n            // query [l..r]\n            Node left_res = identity, right_res = identity;\n            int li = N + l, ri = N + r;\n            while(li <= ri) {\n                if(li & 1) {\n                    left_res = multiply(left_res, seg[li]);\n                    li++;\n                }\n                if(!(ri & 1)) {\n                    right_res = multiply(seg[ri], right_res);\n                    ri--;\n                }\n                li >>= 1;\n                ri >>= 1;\n            }\n            Node ans_node = multiply(left_res, right_res);\n            ll ans = ans_node.m[0][4];\n            cout << ans << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2042e",
      "PROBLEM_ID": "2042E",
      "PROBLEM_STATEMENT": "You are given a tree consisting of $2n$ vertices. Recall that a tree is a connected undirected graph with no cycles. Each vertex has an integer from $1$ to $n$ written on it. Each value from $1$ to $n$ is written on exactly two different vertices. Each vertex also has a cost\u00a0\u2014vertex $i$ costs $2^i$.\n\nYou need to choose a subset of vertices of the tree such that:\n\n- the subset is connected; that is, from each vertex in the subset, you can reach every other vertex in the subset by passing only through the vertices in the subset;\n- each value from $1$ to $n$ is written on at least one vertex in the subset.\n\nAmong all such subsets, you need to find the one with the smallest total cost of the vertices in it. Note that you are not required to minimize the number of vertices in the subset.\n\n### Input\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$ ($1 \\le a_i \\le n$). Each value from $1$ to $n$ appears exactly twice.\n\nEach of the next $2n-1$ lines contains two integers $v$ and $u$ ($1 \\le v, u \\le 2n$)\u00a0\u2014 the edges of the tree. These edges form a valid tree.\n\n### Output\n\nIn the first line, print a single integer $k$\u00a0\u2014 the number of vertices in the subset.\n\nIn the second line, print $k$ distinct integers from $1$ to $2n$\u00a0\u2014 the indices of the vertices in the chosen subset. The vertices can be printed in an arbitrary order.\n\n### Examples\n\n#### Input #1\n\n```\n\n3\n\n1 1 3 2 3 2\n\n4 2\n\n1 6\n\n6 2\n\n6 3\n\n2 5\n\n```\n\n#### Output #1\n\n```\n3\n2 4 5\n```\n\n#### Input #2\n\n```\n\n3\n\n2 3 1 3 2 1\n\n6 4\n\n2 4\n\n5 2\n\n3 6\n\n3 1\n\n```\n\n#### Output #2\n\n```\n4\n1 3 4 6\n```\n\n#### Input #3\n\n```\n\n6\n\n5 2 3 4 6 4 2 5 6 1 1 3\n\n10 8\n\n2 10\n\n12 7\n\n4 10\n\n5 9\n\n6 2\n\n1 9\n\n3 4\n\n12 6\n\n11 5\n\n4 5\n\n```\n\n#### Output #3\n\n```\n6\n2 3 4 5 8 10\n```\n\n### Note\n\n![](https://espresso.codeforces.com/dbaf0c03e6466f3b077e29f011d0bc2be9d080da.png)\n\nThe images show the answers to the first two examples. The numbers in parentheses are the values written on the vertices.\n\nIn the first example, there are valid subsets such as: $[2, 4, 5]$ (with a cost of $2^2 + 2^4 + 2^5 = 52$), $[2, 4, 5, 6]$ (with a cost of $116$), $[1, 6, 3]$ (with a cost of $74$), $[2, 6, 3]$ (with a cost of $76$), and many others.\n\nIn the second example, the cost of the subset $[4, 6, 3, 1]$ is $90$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\nconst int INF_INT = 1000000007;\n\nint n;\nint N2;\nvector<int> a_val;\nvector<vector<int>> adj;\n\n// For check(mid)\nvector<char> visitedCheck;\nvector<char> seenCheck;\nvector<int> compColorsCheck;\n\n// For getComp(mid)\nvector<char> visitedComp;\nvector<char> seenComp;\nvector<int> compColorsComp;\nvector<int> compNodes;\n\n// Euler tour arrays for C0\nvector<int> tin, tout, euler_inv;\nvector<char> inC0;\n\n// For dynamic removal\nvector<char> inC;\nvector<int> staticPos1, staticPos2;\nvector<int> L_cur, R_cur;\nvector<int> cCount;\n\n// Segment Tree for range-min queries\nstruct SegTree {\n    int n; // size (power of two)\n    vector<int> st;\n    SegTree(int _n = 0) { init(_n); }\n    void init(int _n) {\n        n = 1;\n        while (n < _n) n <<= 1;\n        st.assign(2*n, INF_INT);\n    }\n    // set position p (0-based) to value v\n    void update(int p, int v) {\n        int idx = p + n;\n        st[idx] = v;\n        idx >>= 1;\n        while (idx >= 1) {\n            st[idx] = min(st[2*idx], st[2*idx+1]);\n            idx >>= 1;\n        }\n    }\n    // query min in [l..r] (0-based inclusive)\n    int query(int l, int r) {\n        if (l > r) return INF_INT;\n        int res = INF_INT;\n        int L = l + n, R = r + n;\n        while (L <= R) {\n            if (L & 1) res = min(res, st[L++]);\n            if (!(R & 1)) res = min(res, st[R--]);\n            L >>= 1; R >>= 1;\n        }\n        return res;\n    }\n};\n\n// Check if there is a connected component in induced graph on vertices [1..mid]\n// that covers all colors 1..n. Returns true/false.\nbool checkMid(int mid) {\n    // visitedCheck: 1..mid\n    for (int i = 1; i <= mid; i++) visitedCheck[i] = 0;\n    compColorsCheck.clear();\n    // seenCheck: color 1..n\n    // We'll clear seenCheck entries by compColorsCheck each comp\n    for (int start = 1; start <= mid; start++) {\n        if (!visitedCheck[start]) {\n            // BFS/DFS this component\n            vector<int> st;\n            st.reserve(16);\n            st.push_back(start);\n            visitedCheck[start] = 1;\n            compColorsCheck.clear();\n            int distinct = 0;\n            // iterative DFS\n            while (!st.empty()) {\n                int v = st.back();\n                st.pop_back();\n                int c = a_val[v];\n                if (!seenCheck[c]) {\n                    seenCheck[c] = 1;\n                    compColorsCheck.push_back(c);\n                    distinct++;\n                }\n                for (int u : adj[v]) {\n                    if (u <= mid && !visitedCheck[u]) {\n                        visitedCheck[u] = 1;\n                        st.push_back(u);\n                    }\n                }\n            }\n            // Check distinct count\n            if (distinct == n) {\n                // clear seenCheck\n                for (int c : compColorsCheck) seenCheck[c] = 0;\n                return true;\n            }\n            // clear seenCheck for these colors\n            for (int c : compColorsCheck) seenCheck[c] = 0;\n        }\n    }\n    return false;\n}\n\n// Get the one component in induced graph on [1..mid] covering all colors.\n// Fills compNodes with the node IDs of that component.\nvoid getComponent(int mid) {\n    compNodes.clear();\n    // visitedComp and seenComp analogous\n    for (int i = 1; i <= mid; i++) visitedComp[i] = 0;\n    compColorsComp.clear();\n    for (int start = 1; start <= mid; start++) {\n        if (!visitedComp[start]) {\n            vector<int> st;\n            st.reserve(16);\n            st.push_back(start);\n            visitedComp[start] = 1;\n            compColorsComp.clear();\n            int distinct = 0;\n            vector<int> thisComp;\n            thisComp.reserve(16);\n            // DFS this comp\n            while (!st.empty()) {\n                int v = st.back();\n                st.pop_back();\n                thisComp.push_back(v);\n                int c = a_val[v];\n                if (!seenComp[c]) {\n                    seenComp[c] = 1;\n                    compColorsComp.push_back(c);\n                    distinct++;\n                }\n                for (int u : adj[v]) {\n                    if (u <= mid && !visitedComp[u]) {\n                        visitedComp[u] = 1;\n                        st.push_back(u);\n                    }\n                }\n            }\n            if (distinct == n) {\n                // found desired component\n                compNodes = move(thisComp);\n                // clear seenComp\n                for (int c : compColorsComp) seenComp[c] = 0;\n                break;\n            }\n            // clear seenComp\n            for (int c : compColorsComp) seenComp[c] = 0;\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n    N2 = 2*n;\n    a_val.assign(N2+1, 0);\n    for (int i = 1; i <= N2; i++) {\n        cin >> a_val[i];\n    }\n    adj.assign(N2+1, vector<int>());\n    for (int i = 0; i < N2-1; i++) {\n        int u,v;\n        cin >> v >> u;\n        adj[v].push_back(u);\n        adj[u].push_back(v);\n    }\n    // prepare arrays for check\n    visitedCheck.assign(N2+2, 0);\n    seenCheck.assign(n+2, 0);\n    compColorsCheck.reserve(n+1);\n    // Binary search minimal M0\n    int l = 1, r = N2;\n    while (l < r) {\n        int mid = (l + r) >> 1;\n        if (checkMid(mid)) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    int M0 = l;\n    // Prepare getComponent arrays\n    visitedComp.assign(N2+2, 0);\n    seenComp.assign(n+2, 0);\n    compColorsComp.reserve(n+1);\n    getComponent(M0);\n    // Mark inC0 for nodes in compNodes\n    inC0.assign(N2+2, 0);\n    for (int u : compNodes) inC0[u] = 1;\n\n    // Euler tour of C0 tree, root at M0\n    tin.assign(N2+2, -1);\n    tout.assign(N2+2, -1);\n    int C0_size = compNodes.size();\n    euler_inv.clear();\n    euler_inv.reserve(C0_size);\n    // iterative DFS for Euler\n    vector<int> st_u, st_p, st_idx;\n    st_u.reserve(C0_size);\n    st_p.reserve(C0_size);\n    st_idx.reserve(C0_size);\n    st_u.push_back(M0);\n    st_p.push_back(0);\n    st_idx.push_back(-1);\n    int curt = 0;\n    while (!st_u.empty()) {\n        int u = st_u.back();\n        int p = st_p.back();\n        int &idx = st_idx.back();\n        if (idx == -1) {\n            // entry\n            tin[u] = curt;\n            euler_inv.push_back(u);\n            curt++;\n            idx = 0;\n        } else if (idx < (int)adj[u].size()) {\n            int v = adj[u][idx++];\n            if (v != p && inC0[v]) {\n                st_u.push_back(v);\n                st_p.push_back(u);\n                st_idx.push_back(-1);\n            }\n        } else {\n            // exit\n            tout[u] = curt - 1;\n            st_u.pop_back();\n            st_p.pop_back();\n            st_idx.pop_back();\n        }\n    }\n    C0_size = curt; // number of nodes in C0\n\n    // Prepare staticPos and dynamic L,R, cCount\n    staticPos1.assign(n+2, -1);\n    staticPos2.assign(n+2, -1);\n    L_cur.assign(n+2, -1);\n    R_cur.assign(n+2, -1);\n    cCount.assign(n+2, 0);\n\n    // Fill staticPos from euler_inv\n    for (int t = 0; t < C0_size; t++) {\n        int u = euler_inv[t];\n        int c = a_val[u];\n        cCount[c]++;\n        if (staticPos1[c] == -1) staticPos1[c] = t;\n        else staticPos2[c] = t;\n    }\n    // Build initial dynamic intervals\n    for (int c = 1; c <= n; c++) {\n        if (cCount[c] == 1) {\n            L_cur[c] = staticPos1[c];\n            R_cur[c] = staticPos1[c];\n        } else if (cCount[c] == 2) {\n            int p1 = staticPos1[c];\n            int p2 = staticPos2[c];\n            if (p1 <= p2) {\n                L_cur[c] = p1;\n                R_cur[c] = p2;\n            } else {\n                L_cur[c] = p2;\n                R_cur[c] = p1;\n            }\n        } else {\n            // Should not happen: in C0 each color must appear >=1\n            // but not >2\n        }\n    }\n\n    // Build segment tree\n    SegTree st(C0_size);\n    int STINF = C0_size + 5;\n    for (int i = 0; i < st.n; i++) {\n        if (i < C0_size) st.st[st.n + i] = STINF;\n        else st.st[st.n + i] = STINF;\n    }\n    for (int c = 1; c <= n; c++) {\n        if (cCount[c] > 0) {\n            int L = L_cur[c], R = R_cur[c];\n            // put interval\n            st.st[st.n + L] = min(st.st[st.n + L], R);\n        }\n    }\n    // build internal nodes\n    for (int i = st.n - 1; i >= 1; i--) {\n        st.st[i] = min(st.st[2*i], st.st[2*i+1]);\n    }\n\n    // Prepare inC dynamic array\n    inC.assign(N2+2, 0);\n    for (int u : compNodes) inC[u] = 1;\n\n    // Removal loop\n    for (int i = M0 - 1; i >= 1; i--) {\n        if (!inC[i]) continue;\n        int l0 = tin[i];\n        int r0 = tout[i];\n        // query if any interval fully inside [l0..r0]\n        int minR = st.query(l0, r0);\n        if (minR <= r0) {\n            // removal unsafe\n            continue;\n        }\n        // removal safe: remove all nodes in static subtree [l0..r0]\n        for (int t = l0; t <= r0; t++) {\n            int u = euler_inv[t];\n            if (inC[u]) {\n                inC[u] = 0;\n                int c = a_val[u];\n                // cCount[c] should be 2\n                if (cCount[c] == 2) {\n                    cCount[c] = 1;\n                    int Lold = L_cur[c], Rold = R_cur[c];\n                    // remove old interval\n                    st.update(Lold, STINF);\n                    // determine other position\n                    int other;\n                    if (t == Lold) other = Rold;\n                    else other = Lold;\n                    L_cur[c] = other;\n                    R_cur[c] = other;\n                    // add new interval [other, other]\n                    st.update(other, other);\n                } else {\n                    // cCount==1 should not happen (we would not remove last occurrence)\n                    // but ignore\n                    cCount[c]--;\n                }\n            }\n        }\n    }\n\n    // Collect answer nodes\n    vector<int> answer;\n    answer.reserve(compNodes.size());\n    for (int u : compNodes) {\n        if (inC[u]) answer.push_back(u);\n    }\n    // Output\n    cout << answer.size() << \"\\n\";\n    for (int i = 0; i < (int)answer.size(); i++) {\n        cout << answer[i] << (i+1 < (int)answer.size() ? ' ' : '\\n');\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2042d",
      "PROBLEM_ID": "2042D",
      "PROBLEM_STATEMENT": "Suppose you are working in some audio streaming service. The service has $n$ active users and $10^9$ tracks users can listen to. Users can like tracks and, based on likes, the service should recommend them new tracks.\n\nTracks are numbered from $1$ to $10^9$. It turned out that tracks the $i$-th user likes form a segment $[l_i, r_i]$.\n\nLet's say that the user $j$ is a predictor for user $i$ ($j \\neq i$) if user $j$ likes all tracks the $i$-th user likes (and, possibly, some other tracks too).\n\nAlso, let's say that a track is strongly recommended for user $i$ if the track is not liked by the $i$-th user yet, but it is liked by every predictor for the $i$-th user.\n\nCalculate the number of strongly recommended tracks for each user $i$. If a user doesn't have any predictors, then print $0$ for that user.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. Next, $t$ cases follow.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of users.\n\nThe next $n$ lines contain two integers $l_i$ and $r_i$ per line ($1 \\le l_i \\le r_i \\le 10^9$)\u00a0\u2014 the segment of tracks the $i$-th user likes.\n\nAdditional constraint on the input: the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print $n$ integers, where the $i$-th integer is the number of strongly recommended tracks for the $i$-th user (or $0$, if that user doesn't have any predictors).\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\n3 8\n\n2 5\n\n4 5\n\n2\n\n42 42\n\n1 1000000000\n\n3\n\n42 42\n\n1 1000000000\n\n42 42\n\n6\n\n1 10\n\n3 10\n\n3 7\n\n5 7\n\n4 4\n\n1 2\n\n```\n\n#### Output #1\n\n```\n0\n0\n1\n999999999\n0\n0\n0\n0\n0\n2\n3\n2\n4\n8\n```\n\n### Note\n\nIn the first test case:\n\n- the first user has no predictors;\n- the second user has no predictors;\n- the third user has two predictors: users $1$ and $2$; only track $3$ is liked by both of them and not liked by the third user.\n\nIn the second test case, the second user is a predictor for the first user. Therefore, all tracks, except $42$, are strongly recommended for the first user.\n\nIn the third test case, the first user has two predictors: users $2$ and $3$, but there is no track that is liked by them and not liked by the first user himself.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility> // For pair\n\nusing namespace std;\n\n// Use a large value slightly bigger than 10^9 for infinity marker.\n// 10^9 + 7 is a common choice to avoid collision with coordinate values.\n// Could also use 10^9 + 1.\nconst int INF = 1e9 + 7; \n\n// Structure to represent a user with their interval [l, r] and original ID\nstruct User {\n    int l, r;\n    int id; // Original index 0..N-1\n};\n\n// Comparator for sorting users:\n// Primary key: l ascending. Users with smaller starting points come first.\n// Secondary key: r descending. If l values are equal, users with larger ending points come first.\n// This sort order ensures that if user A contains user B and they share the same start point l,\n// user A is processed first. This is crucial because user A might be a predictor for user B.\nbool compareUsers(const User& a, const User& b) {\n    if (a.l != b.l) {\n        return a.l < b.l; \n    }\n    return a.r > b.r; \n}\n\n// Node structure for the segment tree\n// Each node represents a range of ranks (compressed r values) and stores:\n// max_l: The maximum 'l' value among all users whose 'r' rank falls within this node's range.\n// min_r: The minimum 'r' value among all users whose 'r' rank falls within this node's range.\nstruct Node {\n    int max_l = 0; // Initialize max_l to 0 (since minimum possible l is 1)\n    int min_r = INF; // Initialize min_r to a value larger than max possible r (10^9)\n};\n\n// Function to combine results from two segment tree nodes (typically children)\n// The combined node aggregates information from its children.\nNode combine(const Node& left, const Node& right) {\n    Node res;\n    // The overall maximum 'l' is the maximum of the children's maximum 'l's.\n    res.max_l = max(left.max_l, right.max_l);\n    // The overall minimum 'r' is the minimum of the children's minimum 'r's.\n    res.min_r = min(left.min_r, right.min_r);\n    return res;\n}\n\n// Update function for the segment tree. \n// Updates the values at the leaf node corresponding to `rank` and propagates changes upwards.\n// `l_val`, `r_val` are the interval endpoints of the user being added.\nvoid update(vector<Node>& tree, int node, int start, int end, int rank, int l_val, int r_val) {\n    // Base case: Reached the leaf node corresponding to the rank.\n    if (start == end) {\n        // Update the leaf node's information. Use max for max_l and min for min_r\n        // because multiple users might have the same 'r' value (map to the same rank).\n        tree[node].max_l = max(tree[node].max_l, l_val);\n        tree[node].min_r = min(tree[node].min_r, r_val);\n        return;\n    }\n    \n    // Recursive step: Determine whether to go left or right based on the rank.\n    int mid = start + (end - start) / 2;\n    if (rank <= mid) {\n        update(tree, 2 * node, start, mid, rank, l_val, r_val); // Go left\n    } else {\n        update(tree, 2 * node + 1, mid + 1, end, rank, l_val, r_val); // Go right\n    }\n    \n    // After the child node is updated, update the current node by combining children results.\n    tree[node] = combine(tree[2 * node], tree[2 * node + 1]);\n}\n\n// Query function for the segment tree. \n// Finds the combined Node information (max_l, min_r) over a given range of ranks [`query_start`, `query_end`].\nNode query(vector<Node>& tree, int node, int start, int end, int query_start, int query_end) {\n    // Case 1: The query range is completely outside the current node's range.\n    if (query_start > end || query_end < start || query_start > query_end) { \n        // Return an identity node: {0, INF}. These values won't affect the max/min aggregation.\n        return {0, INF}; \n    }\n    \n    // Case 2: The current node's range is completely within the query range.\n    if (query_start <= start && end <= query_end) {\n        // Return the precomputed values stored in this node.\n        return tree[node];\n    }\n    \n    // Case 3: The query range partially overlaps the current node's range.\n    // Recursively query the left and right children and combine their results.\n    int mid = start + (end - start) / 2;\n    Node left_res = query(tree, 2 * node, start, mid, query_start, query_end);\n    Node right_res = query(tree, 2 * node + 1, mid + 1, end, query_start, query_end);\n    \n    return combine(left_res, right_res); // Combine results from children\n}\n\n// Function to solve a single test case\nvoid solve() {\n    int n;\n    cin >> n; // Read the number of users\n    \n    vector<User> users(n);\n    vector<int> r_values; // Stores all 'r' values for coordinate compression\n    map<pair<int, int>, int> counts; // Counts occurrences of each interval [l, r]\n    \n    // Read user data, collect 'r' values, and count interval occurrences\n    for (int i = 0; i < n; ++i) {\n        cin >> users[i].l >> users[i].r;\n        users[i].id = i; // Store original index (0-based)\n        r_values.push_back(users[i].r); \n        counts[{users[i].l, users[i].r}]++; \n    }\n\n    // Coordinate compression for 'r' values:\n    // Sort the 'r' values\n    sort(r_values.begin(), r_values.end()); \n    // Remove duplicates to get unique sorted 'r' values\n    r_values.erase(unique(r_values.begin(), r_values.end()), r_values.end()); \n    \n    map<int, int> r_to_rank; // Map from an 'r' value to its compressed rank (1-based)\n    int m = r_values.size(); // The number of distinct 'r' values\n    \n    // Defensive check: If N >= 1, there should be at least one user, hence m >= 1.\n    // If somehow m=0 (e.g., N=0, though problem constraints say N>=1), handle it.\n    if (m == 0 && n > 0) { \n         vector<long long> ans(n, 0);\n         for(int i=0; i<n; ++i) cout << ans[i] << (i == n-1 ? \"\" : \" \");\n         cout << endl;\n         return;\n    }\n    \n    // Build the rank map: map each distinct 'r' value to its 1-based index\n    for (int i = 0; i < m; ++i) {\n        r_to_rank[r_values[i]] = i + 1; \n    }\n\n    // Initialize the segment tree. Size 4*m is standard for array-based implementation.\n    // Adding a small buffer `+ 4` for extra safety.\n    vector<Node> tree(4 * m + 4); \n    \n    // Sort users based on the custom comparator: (l ascending, r descending)\n    sort(users.begin(), users.end(), compareUsers);\n    \n    vector<long long> ans(n); // Stores the answer for each user, indexed by original ID\n    \n    // Iterate through the sorted users\n    for (int i = 0; i < n; ++i) {\n        int current_l = users[i].l;\n        int current_r = users[i].r;\n        int current_id = users[i].id;\n        \n        // Get the compressed rank of the current user's 'r' value\n        int rk = r_to_rank[current_r]; \n        \n        // Check if there exists another user with the exact same interval [l, r]\n        // This check handles the case where predictors might include users identical to the current one.\n        if (counts[{current_l, current_r}] > 1) {\n            // If duplicates exist, any user 'j' with the same interval [l, r] is a predictor.\n            // The intersection of predictor intervals will be exactly [l, r] in this case.\n            // Therefore, the set of strongly recommended tracks is empty.\n             ans[current_id] = 0;\n        } else {\n             // If the current user's interval is unique:\n             // Query the segment tree for potential predictors processed so far.\n             // The query range [rk, m] finds users 'j' processed before 'i' such that r_j >= current_r.\n             // Since users are sorted by l, these 'j' also satisfy l_j <= current_l.\n             // Thus, the query considers users 'j' that satisfy predictor conditions and were processed earlier.\n             Node res = query(tree, 1, 1, m, rk, m);\n             \n             // If res.max_l is 0 (initial value), it means no predictors were found in the query.\n             if (res.max_l == 0) { \n                 ans[current_id] = 0;\n             } else {\n                 // Predictors were found. res contains (L_i, R_i) derived from these predictors.\n                 // L_i = res.max_l is the maximum 'l' among found predictors.\n                 // R_i = res.min_r is the minimum 'r' among found predictors.\n                 // The number of strongly recommended tracks is (current_l - L_i) + (R_i - current_r).\n                 // Use long long for calculation to prevent potential overflow (up to 2 * 10^9).\n                 long long recommended_count = (long long)(current_l - res.max_l) + (long long)(res.min_r - current_r);\n                 ans[current_id] = recommended_count;\n             }\n        }\n        \n        // After processing user 'i', update the segment tree with their information (l_i, r_i)\n        // at the rank corresponding to r_i. This makes user 'i' available for queries by subsequent users.\n        update(tree, 1, 1, m, rk, current_l, current_r);\n    }\n    \n    // Print the results for all users in their original input order\n    for (int i = 0; i < n; ++i) {\n        cout << ans[i] << (i == n - 1 ? \"\" : \" \");\n    }\n    cout << endl;\n}\n\n// Main function: handles multiple test cases and sets up fast I/O\nint main() {\n    // Optimize input/output operations\n    ios_base::sync_with_stdio(false); \n    cin.tie(NULL); // Untie cin from cout\n    \n    int t;\n    cin >> t; // Read the number of test cases\n    while (t--) {\n        solve(); // Solve each test case\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2042c",
      "PROBLEM_ID": "2042C",
      "PROBLEM_STATEMENT": "Alice and Bob participate in a fishing contest! In total, they caught $n$ fishes, numbered from $1$ to $n$ (the bigger the fish, the greater its index). Some of these fishes were caught by Alice, others \u2014 by Bob.\n\nTheir performance will be evaluated as follows. First, an integer $m$ will be chosen, and all fish will be split into $m$ non-empty groups. The first group should contain several (at least one) smallest fishes, the second group \u2014 several (at least one) next smallest fishes, and so on. Each fish should belong to exactly one group, and each group should be a contiguous subsegment of fishes. Note that the groups are numbered in exactly that order; for example, the fishes from the second group cannot be smaller than the fishes from the first group, since the first group contains the smallest fishes.\n\nThen, each fish will be assigned a value according to its group index: each fish in the first group gets value equal to $0$, each fish in the second group gets value equal to $1$, and so on. So, each fish in the $i$-th group gets value equal to $(i-1)$.\n\nThe score of each contestant is simply the total value of all fishes that contestant caught.\n\nYou want Bob's score to exceed Alice's score by at least $k$ points. What is the minimum number of groups ($m$) you have to split the fishes into? If it is impossible, you should report that.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2 \\le n \\le 2 \\cdot 10^5$; $1 \\le k \\le 10^9$).\n\nThe second line contains a string, consisting of exactly $n$ characters. The $i$-th character is either 0 (denoting that the $i$-th fish was caught by Alice) or 1 (denoting that the $i$-th fish was caught by Bob).\n\nAdditional constraint on the input: the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the minimum number of groups you have to split the fishes into; or -1 if it's impossible.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n4 1\n\n1001\n\n4 1\n\n1010\n\n4 1\n\n0110\n\n4 2\n\n0110\n\n6 3\n\n001110\n\n10 20\n\n1111111111\n\n5 11\n\n11111\n\n```\n\n#### Output #1\n\n```\n2\n-1\n2\n-1\n3\n4\n-1\n```\n\n### Note\n\nIn the first test case of the example, you can split the fishes into groups as follows: the first three fishes form the $1$-st group, the last fish forms the $2$-nd group. Then, Bob's score will be $1$, and Alice's score will be $0$.\n\nIn the third test case of the example, you can split the fishes into groups as follows: the first fish forms the $1$-st group, the last three fishes form the $2$-nd group. Then, Bob's score will be $2$, and Alice's score will be $1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Fast IO\nvoid fast_io() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n}\n\nint main() {\n    fast_io();\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        long long k;\n        cin >> n >> k;\n        string s;\n        cin >> s;\n\n        vector<int> prefix_bob(n+1, 0), prefix_alice(n+1, 0);\n\n        // Precompute prefix sums for Bob and Alice\n        for (int i = 0; i < n; ++i) {\n            prefix_bob[i+1] = prefix_bob[i] + (s[i] == '1');\n            prefix_alice[i+1] = prefix_alice[i] + (s[i] == '0');\n        }\n\n        int total_bob = prefix_bob[n];\n        int total_alice = prefix_alice[n];\n\n        // For each cut after i (i from 1 to n-1), compute delta\n        vector<int> deltas;\n        for (int i = 1; i < n; ++i) {\n            int bob_right = total_bob - prefix_bob[i];\n            int alice_right = total_alice - prefix_alice[i];\n            int delta = bob_right - alice_right;\n            deltas.push_back(delta);\n        }\n\n        // Sort descending\n        sort(deltas.rbegin(), deltas.rend());\n\n        // Check prefix sums\n        long long curr = 0;\n        int answer = -1;\n        for (int m = 2; m <= n; ++m) {\n            curr += deltas[m-2]; // because m-1 cuts, 0-indexed\n            if (curr >= k) {\n                answer = m;\n                break;\n            }\n        }\n        cout << answer << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2042b",
      "PROBLEM_ID": "2042B",
      "PROBLEM_STATEMENT": "Alice and Bob play a game. There are $n$ marbles, the $i$-th of them has color $c_i$. The players take turns; Alice goes first, then Bob, then Alice again, then Bob again, and so on.\n\nDuring their turn, a player must take one of the remaining marbles and remove it from the game. If there are no marbles left (all $n$ marbles have been taken), the game ends.\n\nAlice's score at the end of the game is calculated as follows:\n\n- she receives $1$ point for every color $x$ such that she has taken at least one marble of that color;\n- additionally, she receives $1$ point for every color $x$ such that she has taken all marbles of that color (of course, only colors present in the game are considered).\n\nFor example, suppose there are $5$ marbles, their colors are $[1, 3, 1, 3, 4]$, and the game goes as follows: Alice takes the $1$-st marble, then Bob takes the $3$-rd marble, then Alice takes the $5$-th marble, then Bob takes the $2$-nd marble, and finally, Alice takes the $4$-th marble. Then, Alice receives $4$ points: $3$ points for having at least one marble for colors $1$, $3$ and $4$, and $1$ point for having all marbles of color $4$. Note that this strategy is not necessarily optimal for both players.\n\nAlice wants to maximize her score at the end of the game. Bob wants to minimize it. Both players play optimally (i.\u2009e. Alice chooses a strategy which allows her to get as many points as possible, and Bob chooses a strategy which minimizes the amount of points Alice can get).\n\nCalculate Alice's score at the end of the game.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n- the first line contains one integer $n$ ($1 \\le n \\le 1000$) \u2014 the number of marbles;\n- the second line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$) \u2014 the colors of the marbles.\n\nAdditional constraint on the input: the sum of $n$ over all test cases does not exceed $1000$.\n\n### Output\n\nFor each test case, print one integer \u2014 Alice's score at the end of the game, assuming that both players play optimally.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5\n\n1 3 1 3 4\n\n3\n\n1 2 3\n\n4\n\n4 4 4 4\n\n```\n\n#### Output #1\n\n```\n4\n4\n1\n```\n\n### Note\n\nIn the second test case of the example, the colors of all marbles are distinct, so, no matter how the players act, Alice receives $4$ points for having all marbles of two colors, and no marbles of the third color.\n\nIn the third test case of the example, the colors of all marbles are the same, so, no matter how the players act, Alice receives $1$ point for having at least one (but not all) marble of color $4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solveTestCase() {\n    int n;\n    cin >> n;\n    vector<int> c(n);\n    for(auto &x: c) cin >> x;\n    \n    // Count frequency of each color\n    vector<int> freq(n+1, 0);\n    for(int color : c){\n        freq[color]++;\n    }\n    \n    // List of counts of each color (ignore colors with count 0)\n    vector<int> freqList;\n    for(int i=1;i<=n;i++) {\n        if(freq[i] > 0) freqList.push_back(freq[i]);\n    }\n\n    // Sort frequencies in ascending order\n    sort(freqList.begin(), freqList.end());\n    \n    // Alice picks first so initialize turn\n    bool aliceTurn = true;\n    int aliceScore = 0;\n    \n    // Simulate the game\n    for(int f : freqList){\n        if(aliceTurn){\n            // Alice picks the color with smallest count first\n            if(f == 1){\n                aliceScore += 2; // Unique color + all marbles\n            }\n            else{\n                aliceScore += 1; // At least one marble of this color\n            }\n        }\n        else{\n            // Bob's turn: if count > 1, Bob prevents Alice from \"all marble\" score\n            // Bob does not gain points, but forces Alice to lose a \"all marble\" point\n            if(f == 1){\n                // Nothing happens to Alice\n            }\n            else{\n                // Alice gets the \"at least one marble\" only\n                aliceScore += 1;\n            }\n        }\n        aliceTurn = !aliceTurn; // Alternate turns\n    }\n    \n    // Output Alice's score\n    cout << aliceScore << \"\\n\";\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--){\n        solveTestCase();\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2042a",
      "PROBLEM_ID": "2042A",
      "PROBLEM_STATEMENT": "There are $n$ chests; the $i$-th chest initially contains $a_i$ coins. For each chest, you can choose any non-negative ($0$ or greater) number of coins to add to that chest, with one constraint: the total number of coins in all chests must become at least $k$.\n\nAfter you've finished adding coins to the chests, greedy Monocarp comes, who wants the coins. He will take the chests one by one, and since he is greedy, he will always choose the chest with the maximum number of coins. Monocarp will stop as soon as the total number of coins in chests he takes is at least $k$.\n\nYou want Monocarp to take as few coins as possible, so you have to add coins to the chests in such a way that, when Monocarp stops taking chests, he will have exactly $k$ coins. Calculate the minimum number of coins you have to add.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n- the first line contains two integers $n$ and $k$ ($1 \\le n \\le 50$; $1 \\le k \\le 10^7$);\n- the second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le k$).\n\n### Output\n\nFor each test case, print one integer \u2014 the minimum number of coins you have to add so that, when Monocarp stops taking the chests, he has exactly $k$ coins. It can be shown that under the constraints of the problem, it is always possible.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n5 4\n\n4 1 2 3 2\n\n5 10\n\n4 1 2 3 2\n\n2 10\n\n1 1\n\n3 8\n\n3 3 3\n\n```\n\n#### Output #1\n\n```\n0\n1\n8\n2\n```\n\n### Note\n\nIn the first test case of the example, you don't have to add any coins. When Monocarp arrives, he will take the chest with $4$ coins, so he will have exactly $4$ coins.\n\nIn the second test case of the example, you can add $1$ coin to the $4$-th chest, so, when Monocarp arrives, he will take a chest with $4$ coins, then another chest with $4$ coins, and a chest with $2$ coins.\n\nIn the third test case of the example, you can add $3$ coins to the $1$-st chest and $5$ coins to the $2$-nd chest.\n\nIn the fourth test case of the example, you can add $1$ coin to the $1$-st chest and $1$ coin to the $3$-rd chest.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        for (int &x : a) cin >> x;\n        sort(a.rbegin(), a.rend()); // Sort in non-increasing order\n        \n        // Compute prefix sums\n        vector<long long> prefix(n + 1, 0);\n        for (int i = 0; i < n; ++i) {\n            prefix[i + 1] = prefix[i] + a[i];\n        }\n        \n        long long best = 0;\n        for (int m = 1; m <= n; ++m) {\n            long long current_sum = prefix[m];\n            if (current_sum <= k && current_sum > best) {\n                best = current_sum;\n            }\n        }\n        cout << (k - best) << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2040e",
      "PROBLEM_ID": "2040E",
      "PROBLEM_STATEMENT": "You are given a tree with $n$ vertices.\n\nLet's place a robot in some vertex $v \\ne 1$, and suppose we initially have $p$ coins. Consider the following process, where in the $i$-th step (starting from $i = 1$):\n\n- If $i$ is odd, the robot moves to an adjacent vertex in the direction of vertex $1$;\n- Else, $i$ is even. You can either pay one coin (if there are some left) and then the robot moves to an adjacent vertex in the direction of vertex $1$, or not pay, and then the robot moves to an adjacent vertex chosen uniformly at random.\n\nThe process stops as soon as the robot reaches vertex $1$. Let $f(v, p)$ be the minimum possible expected number of steps in the process above if we spend our coins optimally.\n\nAnswer $q$ queries, in the $i$-th of which you have to find the value of $f(v_i, p_i)$, modulo$^{\\text{\u2217}}$ $998\\,244\\,353$.\n\n$^{\\text{\u2217}}$ Formally, let $M = 998\\,244\\,353$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$ ($2 \\le n \\le 2 \\cdot 10^3$; $1 \\le q \\le 2 \\cdot 10^3$)\u00a0\u2014 the number of vertices in the tree and the number of queries.\n\nThe next $n - 1$ lines contain the edges of the tree, one edge per line. The $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$; $u_i \\neq v_i$), denoting the edge between the nodes $u_i$ and $v_i$.\n\nThe next $q$ lines contain two integers $v_i$ and $p_i$ ($2 \\le v_i \\le n$; $0 \\le p_i \\le n$).\n\nIt's guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10 ^ 3$.\n\nIt is guaranteed that the sum of $q$ over all test cases does not exceed $2 \\cdot 10 ^ 3$.\n\n### Output\n\nFor each test case, print $q$ integers: the values of $f(v_i, p_i)$ modulo $998\\,244\\,353$.\n\nFormally, let $M = 998\\,244\\,353$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n4 4\n\n1 2\n\n2 3\n\n2 4\n\n2 0\n\n3 0\n\n4 0\n\n3 1\n\n12 10\n\n1 2\n\n2 3\n\n2 4\n\n1 5\n\n5 6\n\n6 7\n\n6 8\n\n6 9\n\n8 10\n\n10 11\n\n10 12\n\n6 0\n\n9 0\n\n10 0\n\n11 0\n\n3 1\n\n7 1\n\n10 1\n\n12 1\n\n12 2\n\n11 12\n\n```\n\n#### Output #1\n\n```\n1\n6\n6\n2\n4\n9\n8\n15\n2\n3\n6\n9\n5\n5\n```\n\n### Note\n\nThe tree in the first test case:\n\n![](https://espresso.codeforces.com/e4dd6d29016ec239c8901966b682432022feee23.png)\n\nIn the first query, the expected value is equal to $1$, since the robot starts moving from vertex $2$ to vertex $1$ in the first step and the process stops.\n\nLet's calculate the expected value in the second query ($x$ is the number of steps):\n\n- $P(x < 2) = 0$, the distance to vertex $1$ is $2$ and the robot cannot reach it in fewer steps.\n- $P(x = 2) = \\frac{1}{3}$, since there is only one sequence of steps leading to $x = 2$. This is $3 \\rightarrow_{1} 2 \\rightarrow_{0.33} 1$ with probability $1 \\cdot \\frac{1}{3}$.\n- $P(x \\bmod 2 = 1) = 0$, since the robot can reach vertex $1$ by only taking an even number of steps.\n- $P(x = 4) = \\frac{2}{9}$: possible paths $3 \\rightarrow_{1} 2 \\rightarrow_{0.67} [3, 4] \\rightarrow_{1} 2 \\rightarrow_{0.33} 1$.\n- $P(x = 6) = \\frac{4}{27}$: possible paths $3 \\rightarrow_{1} 2 \\rightarrow_{0.67} [3, 4] \\rightarrow_{1} 2 \\rightarrow_{0.67} [3, 4] \\rightarrow_{1} 2 \\rightarrow_{0.33} 1$.\n- $P(x = i \\cdot 2) = \\frac{2^{i - 1}}{3^i}$ in the general case.\n\nAs a result, $f(v, p) = \\sum\\limits_{i=1}^{\\infty}{i \\cdot 2 \\cdot \\frac{2^{i - 1}}{3^i}} = 6$.\n\nThe tree in the second test case:\n\n![](https://espresso.codeforces.com/8a8969f859fff085171f272e9a14ce0d42940506.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\n// Define MOD\nlong long MOD = 998244353;\n\n// Modular arithmetic functions\n// Perform addition modulo MOD\nlong long add(long long a, long long b) {\n    long long res = a + b;\n    // Use conditional subtraction which might be faster than % operator\n    if (res >= MOD) res -= MOD; \n    return res;\n}\n\n// Perform subtraction modulo MOD, ensuring the result is non-negative\nlong long sub(long long a, long long b) {\n    long long res = a - b;\n    // Use conditional addition which might be faster than % operator\n    if (res < 0) res += MOD; \n    return res;\n}\n\n// Perform multiplication modulo MOD\nlong long mul(long long a, long long b) {\n    return (a * b) % MOD;\n}\n\n// Maximum N value based on constraints\nconst int MAXN_VAL = 2005; \n\n// Global variables for tree structure and BFS results\nvector<int> adj[MAXN_VAL]; // Adjacency list for the tree\nint parent[MAXN_VAL];     // Stores the parent of each node in the BFS tree rooted at 1\nint dist[MAXN_VAL];       // Stores the distance of each node from root 1\nint degree[MAXN_VAL];     // Stores the degree of each node\nvector<int> nodes_at_dist[MAXN_VAL]; // Stores lists of nodes grouped by their distance from root 1\nint max_dist; // Stores the maximum distance found from root 1\n\n// DP table: dp[parity][vertex][coins]\n// Stores the minimum expected steps.\n// parity 0: The next step to be taken is odd-numbered.\n// parity 1: The next step to be taken is even-numbered.\n// dimensions: 2 x (N+1) x (N+1)\nvector<vector<long long>> dp[2]; \n\n// Performs Breadth-First Search starting from vertex 1 to compute distances,\n// parents, degrees, and group nodes by distance level.\nvoid bfs(int n) {\n    // Initialize BFS related arrays and structures\n    for (int i = 0; i <= n; ++i) { // Initialize up to N, including index 0 for safety\n        dist[i] = -1;         // Distance initialized to -1 (unvisited)\n        parent[i] = 0;        // Parent of root 1 is conventionally 0\n        degree[i] = 0;        // Degree initialized to 0\n        nodes_at_dist[i].clear(); // Clear lists of nodes per distance level\n    }\n    max_dist = 0; // Reset maximum distance\n\n    queue<int> q; // Queue for BFS\n    q.push(1);    // Start BFS from vertex 1\n    dist[1] = 0;  // Distance of root 1 is 0\n    nodes_at_dist[0].push_back(1); // Add root 1 to distance level 0\n\n    // Standard BFS loop\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        // Update maximum distance encountered\n        max_dist = max(max_dist, dist[u]);\n        \n        // Calculate the degree of node u based on its adjacency list size\n        degree[u] = adj[u].size();\n\n        // Explore neighbors of u\n        for (int v : adj[u]) {\n            // If neighbor v hasn't been visited yet\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1; // Set distance\n                parent[v] = u;         // Set parent\n                nodes_at_dist[dist[v]].push_back(v); // Add node v to its distance level list\n                q.push(v);             // Add neighbor v to the queue\n            }\n        }\n    }\n}\n\n// Solves a single test case\nvoid solve() {\n    int n; // Number of vertices\n    int q_count; // Number of queries\n    cin >> n >> q_count;\n\n    // Clear adjacency list for the new test case\n    for (int i = 1; i <= n; ++i) {\n        adj[i].clear();\n    }\n\n    // Read edges and build the adjacency list representation of the tree\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Perform BFS starting from root 1 to initialize tree properties\n    bfs(n);\n\n    // Resize DP table according to N. Initialize all values to 0.\n    // Need dimensions N+1 for vertices 1..N and N+1 for coins 0..N.\n    for (int p = 0; p < 2; ++p) {\n        dp[p].assign(n + 1, vector<long long>(n + 1, 0));\n    }\n    \n    // === Base Case Computation: k = 0 coins ===\n    // First, compute dp[1][u][0] (expected steps if next step is even) for all vertices u.\n    // We iterate vertices by distance from root 1. This ensures dependencies are met.\n    \n    // Iterate through distances d = 1 up to max_dist\n    for (int d = 1; d <= max_dist; ++d) {\n        // For each node u at distance d\n        for (int u : nodes_at_dist[d]) {\n           // Base case for vertex 1: dp[1][1][0] = 0 (already initialized)\n           if (u == 1) continue; \n\n            if (d == 1) {\n                // Special case for nodes directly adjacent to root 1. Formula derived is 2*deg(u) - 1.\n                dp[1][u][0] = sub(mul(2, degree[u]), 1);\n            } else { // d >= 2\n                 // General case using the recurrence relation derived in thought process.\n                 // Relies on grandparent's DP value dp[1][parent[parent[u]]][0].\n                 int ppu = parent[parent[u]]; // Grandparent node\n                 // Access grandparent's DP value. If ppu=0 (grandparent is root or undefined), use dp[1][0][0].\n                 // Since dp table is indexed 1..N, access dp[1][ppu][0]. If ppu=0, this accesses index 0.\n                 // We ensure dp[1][0][0] is implicitly 0 due to initialization or safe indexing.\n                 long long term = dp[1][ppu][0]; \n                 dp[1][u][0] = add(mul(2, degree[u]), term);\n            }\n        }\n    }\n    \n    // Next, compute dp[0][u][0] (expected steps if next step is odd) using the computed dp[1][...][0] values.\n    // The relation is dp[0][u][0] = 1 + dp[1][parent[u]][0].\n    for (int d = 1; d <= max_dist; ++d) {\n        for (int u : nodes_at_dist[d]) {\n             // Base case for vertex 1: dp[0][1][0] = 0 (already initialized)\n             if (u == 1) continue; \n             dp[0][u][0] = add(1, dp[1][parent[u]][0]);\n        }\n    }\n\n    // === Main DP Computation: k = 1 to n coins ===\n    // Iterate through number of coins k from 1 to N.\n    for (int k = 1; k <= n; ++k) {\n        // Compute dp[1][u][k] first (even step next) for all u.\n        // Iterate vertices by distance to ensure dependencies are met.\n        for (int d = 1; d <= max_dist; ++d) {\n            for (int u : nodes_at_dist[d]) {\n                 // Base case for vertex 1: dp[1][1][k] = 0 (already initialized)\n                 if (u == 1) continue; \n\n                 if (d == 1) {\n                     // Special case for nodes adjacent to root 1. If k > 0, it's always optimal to pay 1 coin.\n                     // This move takes 1 step and reaches vertex 1. Expected steps = 1.\n                     dp[1][u][k] = 1;\n                 } else { // d >= 2\n                     // Option 1: Pay a coin. Takes 1 step, moves to parent. Remaining coins k-1. Next step is odd.\n                     // Total expected steps = 1 + dp[0][parent[u]][k-1].\n                     long long option1 = add(1, dp[0][parent[u]][k-1]);\n                     \n                     // Option 2: Don't pay a coin. Takes 1 step, moves randomly. Remaining coins k. Next step is odd.\n                     // Total expected steps derived as = 2 * deg(u) + dp[1][parent[parent[u]]][k].\n                     int ppu = parent[parent[u]]; // Grandparent node\n                     // Access grandparent's DP value for the current k. This value is computed in this k iteration but for a smaller distance d-2.\n                     long long term = dp[1][ppu][k]; \n                     long long option2 = add(mul(2, degree[u]), term);\n                     \n                     // Choose the minimum of the two options.\n                     // This assumes that the true expected values are less than MOD, so min behaves correctly on modular values.\n                     dp[1][u][k] = min(option1, option2); \n                 }\n            }\n        }\n        \n        // Compute dp[0][u][k] (odd step next) using the computed dp[1][...][k] values.\n        // Relation: dp[0][u][k] = 1 + dp[1][parent[u]][k].\n        for (int d = 1; d <= max_dist; ++d) {\n            for (int u : nodes_at_dist[d]) {\n                 // Base case for vertex 1: dp[0][1][k] = 0 (already initialized)\n                 if (u == 1) continue; \n                 dp[0][u][k] = add(1, dp[1][parent[u]][k]);\n            }\n        }\n    }\n\n    // === Answer Queries ===\n    // Process each query using the precomputed DP table.\n    for (int i = 0; i < q_count; ++i) {\n        int v; // Starting vertex for the query\n        int p; // Initial number of coins for the query\n        cin >> v >> p;\n        // The number of useful coins is bounded. Having more than N coins is equivalent to having N coins.\n        // Clamp p to be at most n.\n        p = min(p, n);\n        // The required answer is f(v, p), which corresponds to dp[0][v][p] (start at v, p coins, first step is odd).\n        cout << dp[0][v][p] << \"\\n\";\n    }\n}\n\nint main() {\n    // Faster I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        solve(); // Solve each test case\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2040d",
      "PROBLEM_ID": "2040D",
      "PROBLEM_STATEMENT": "You are given a tree with $n$ vertices.\n\nYou need to construct an array $a_1, a_2, \\ldots, a_n$ of length $n$, consisting of unique integers from $1$ to $2 \\cdot n$, and such that for each edge $u_i \\leftrightarrow v_i$ of the tree, the value $|a_{u_i} - a_{v_i}|$ is not a prime number.\n\nFind any array that satisfies these conditions, or report that there is no such array.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of vertices in the tree.\n\nThe next $n - 1$ lines contain the edges of the tree, one edge per line. The $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$; $u_i \\neq v_i$), denoting the edge between the nodes $u_i$ and $v_i$.\n\nIt's guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10 ^ 5$.\n\n### Output\n\nFor each test case, if an array that satisfies the conditions exists, print its elements $a_1, a_2, \\ldots, a_n$. Otherwise, print $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5\n\n1 2\n\n2 3\n\n2 4\n\n3 5\n\n7\n\n1 2\n\n1 3\n\n2 4\n\n3 5\n\n3 6\n\n3 7\n\n```\n\n#### Output #1\n\n```\n2 10 1 6 5\n8 7 12 1 4 6 3\n```\n\n### Note\n\nThe possible answers are shown below. Instead of the vertex numbers, the corresponding elements of the array $a$ are written in them.\n\nThe image of the tree in the first test case![](https://espresso.codeforces.com/5ca65da19933368698c761665282cb25069ce311.png)The image of the tree in the second test case![](https://espresso.codeforces.com/b60d252fcad91d0d0847a645925436a7e9ba10b3.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAXV = 400000 + 5;\nstatic vector<bool> is_prime;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    // Sieve for primality up to MAXV\n    is_prime.assign(MAXV, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i * i < MAXV; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAXV; j += i)\n                is_prime[j] = false;\n        }\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<vector<int>> adj(n + 1);\n        for (int i = 0; i < n - 1; ++i) {\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        // used[x] = true means label x has been taken\n        vector<char> used(2 * n + 2, false);\n        vector<char> vis(n + 1, false);\n        vector<int> a(n + 1, 0);\n\n        // BFS from root = 1\n        queue<int> q;\n        q.push(1);\n        vis[1] = true;\n        // assign root = 1\n        a[1] = 1;\n        used[1] = true;\n        int cur = 2;  // next candidate label\n\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            int puval = a[u];\n            for (int v : adj[u]) {\n                if (!vis[v]) {\n                    vis[v] = true;\n                    // find next available label cur such that |cur - puval| is not prime\n                    while (cur <= 2 * n && (used[cur] || is_prime[abs(cur - puval)]))\n                        ++cur;\n                    // cur must be <= 2n here (a solution always exists)\n                    a[v] = cur;\n                    used[cur] = true;\n                    ++cur;\n                    q.push(v);\n                }\n            }\n        }\n\n        // Output the labeling a[1..n]\n        for (int i = 1; i <= n; ++i) {\n            cout << a[i] << (i == n ? '\\n' : ' ');\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2040c",
      "PROBLEM_ID": "2040C",
      "PROBLEM_STATEMENT": "Consider a permutation$^{\\text{\u2217}}$ $p_1, p_2, \\ldots, p_n$ of integers from $1$ to $n$. We can introduce the following sum for it$^{\\text{\u2020}}$:\n\n\n\n$$S(p) = \\sum_{1 \\le l \\le r \\le n} \\min(p_l, p_{l + 1}, \\ldots, p_r)$$\n\nLet us consider all permutations of length $n$ with the maximum possible value of $S(p)$. Output the $k$-th of them in lexicographical$^{\\text{\u2021}}$order, or report that there are less than $k$ of them.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n$^{\\text{\u2020}}$For example:\n\n- For the permutation $[1, 2, 3]$ the value of $S(p)$ is equal to $\\min(1) + \\min(1, 2) + \\min(1, 2, 3) + \\min(2) + \\min(2, 3) + \\min(3) =$ $1 + 1 + 1 + 2 + 2 + 3 = 10$\n- For the permutation $[2, 4, 1, 3]$ the value of $S(p)$ is equal to $\\min(2) + \\min(2, 4) + \\min(2, 4, 1) + \\min(2, 4, 1, 3) \\ +$ $ \\min(4) + \\min(4, 1) + \\min(4, 1, 3) \\ +$ $\\min(1) + \\min(1, 3) \\ +$ $\\min(3) =$ $2 + 2 + 1 + 1 + 4 + 1 + 1 + 1 + 1 + 3 = 17$.\n\n$^{\\text{\u2021}}$An array $a$ is lexicographically smaller than an array $b$ if and only if one of the following holds:\n\n- $a$ is a prefix of $b$, but $a \\ne b$; or\n- in the first position where $a$ and $b$ differ, the array $a$ has a smaller element than the corresponding element in $b$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 2 \\cdot 10^5$; $1 \\le k \\le 10^{12}$)\u00a0\u2014 the length of the permutation and the index number of the desired permutation.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10 ^ 5$.\n\n### Output\n\nFor each test case, if there are less than $k$ suitable permutations, print $-1$.\n\nOtherwise, print the $k$-th suitable permutation.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n3 2\n\n3 3\n\n4 11\n\n4 6\n\n6 39\n\n7 34\n\n```\n\n#### Output #1\n\n```\n1 3 2\n2 3 1\n-1\n2 4 3 1\n-1\n2 3 4 5 7 6 1\n```\n\n### Note\n\nLet us calculate the required sum for all permutations of length $3$ (ordered lexicographically):\n\nPermutationValue of $S(p)\n\n$$[1, 2, 3]$$\n\n10\n\n$$[1, 3, 2]$$\n\n10\n\n$$[2, 1, 3]$$\n\n9\n\n$$[2, 3, 1]$$\n\n10\n\n$$[3, 1, 2]$$\n\n9\n\n$$[3, 2, 1]$$\n\n10$\n\nIn the first test case, you have to print the second suitable permutation of length $3$. Looking at the table, we see that it is the permutation $[1, 3, 2]$.\n\nIn the second test case, you have to print the third suitable permutation of length $3$. Looking at the table, we see that it is the permutation $[2, 3, 1]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <cmath>\n#include <algorithm>\n\nint main() {\n    // Use fast IO to speed up input reading\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Length of the permutation\n        long long k; // The index of the desired permutation (1-based)\n        std::cin >> n >> k;\n        \n        // Check if k is valid. The total number of permutations maximizing S(p) is 2^(n-1).\n        // We need to check if k > 2^(n-1).\n        // This check is only necessary for relatively small n. \n        // If n-1 >= 63, 2^(n-1) might overflow signed long long.\n        // However, k is at most 10^12. 2^40 is roughly 1.1 * 10^12.\n        // So, if n-1 >= 40, 2^(n-1) can exceed k.\n        // If n-1 >= 60, 2^(n-1) >= 2^60 which is approx 1.15 * 10^18, definitely larger than k = 10^12.\n        // We only need to perform the check k > 2^(n-1) if n <= 60.\n        // For n > 60, 2^(n-1) is guaranteed to be larger than k, so k is always valid index-wise.\n        if (n <= 60) {\n             // Handle n=0 case? Problem statement says n >= 1.\n             // For n=1, n-1=0. 1LL << 0 = 1. If k=1, ok. If k>1, invalid.\n             if (n > 0 && k > (1LL << (n - 1))) {\n                std::cout << \"-1\\n\";\n                continue;\n            }\n            // The case n=0 is excluded by constraints. If it were allowed, k=1 might refer to empty permutation, k>1 invalid.\n        } \n        \n        // Initialize the result permutation array\n        std::vector<int> p(n);\n        int L = 0; // Left boundary of available indices (0-based)\n        int R = n - 1; // Right boundary of available indices (0-based)\n        int current_val = 1; // The current smallest value to be placed\n\n        // Optimization part: For large n, the first few elements are fixed as 1, 2, ...\n        // This optimization is applied when the number of permutations resulting from placing\n        // the current value `m` at the leftmost position `L` is guaranteed to be larger than `k`.\n        // The count of such permutations is 2^exponent, where exponent = (number of remaining elements after m) - 1 = (n - m) - 1.\n        // If exponent >= 60, then 2^exponent > 10^18 > k=10^12.\n        // The condition exponent >= 60 simplifies to n - m - 1 >= 60, or m <= n - 61.\n        // So for m = 1 up to n-61, we must place m at the leftmost position L.\n        int optimized_count = 0; // Number of elements placed using optimization\n        if (n > 61) { // Optimization is relevant only if n is large enough for exponent >= 60 to possibly occur.\n             optimized_count = n - 61; // Elements from 1 to n-61 will be placed optimally.\n             for(int i = 0; i < optimized_count; ++i) {\n                 p[L] = current_val; // Place value (i+1) at index i\n                 L++; // Move left boundary\n                 current_val++; // Next value to place\n             }\n        }\n        // After optimization loop (if any):\n        // current_val = optimized_count + 1\n        // Available indices range from L = optimized_count to R = n - 1.\n        \n        // Main logic part: Place remaining elements (or all elements if n <= 61)\n        while (current_val <= n) {\n            // Check termination conditions\n            // If L > R, it means all positions are filled. This should technically not be reached inside the loop.\n            if (L > R) { \n                 break; \n            }\n            // If L == R, only one position remains. The current value must go there.\n            if (L == R) { \n                p[L] = current_val; \n                break; // All elements placed.\n            }\n\n            // If L < R, there are at least two positions left.\n            // Calculate number of remaining elements AFTER placing current_val.\n            // Example: If n=5, current_val=3. Remaining are 4, 5. Count = 2.\n            int remaining_count_after = n - current_val; // This is >= 1 because current_val < n (since L < R implies at least 2 spots left)\n            int exponent = remaining_count_after - 1; // This exponent is >= 0.\n\n            // Calculate the number of permutations if we place current_val at L.\n            // Due to optimization, the maximum value of remaining_count_after here is 61 (when effective n=61).\n            // Max exponent is 61 - 1 = 60.\n            // 1LL << 60 fits within signed long long. So direct calculation is safe.\n            long long count_left;\n             // Check exponent just to be safe, though it shouldn't exceed 60 here.\n             if (exponent >= 63) { // Exponent too large for 1LL << exponent?\n                 // This case should not be reachable due to optimization.\n                 // Use a very large value to represent effectively infinity compared to k.\n                 count_left = 2000000000000LL + 7; \n             } else {\n                 count_left = (1LL << exponent); \n             }\n            \n            // Decide placement based on k\n            if (k <= count_left) {\n                // If k is within the count for left placement, place current_val at L\n                p[L] = current_val;\n                L++; // Shrink available range from left\n            } else {\n                // Otherwise, place current_val at R\n                 p[R] = current_val;\n                 k -= count_left; // Adjust k because we skipped `count_left` permutations\n                 R--; // Shrink available range from right\n            }\n            current_val++; // Move to the next value to place\n        }\n\n        // Output the resulting permutation\n        for (int i = 0; i < n; ++i) {\n            std::cout << p[i] << (i == n - 1 ? \"\" : \" \");\n        }\n        std::cout << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2040b",
      "PROBLEM_ID": "2040B",
      "PROBLEM_STATEMENT": "You have an array of zeros $a_1, a_2, \\ldots, a_n$ of length $n$.\n\nYou can perform two types of operations on it:\n\n1. Choose an index $i$ such that $1 \\le i \\le n$ and $a_i = 0$, and assign $1$ to $a_i$;\n2. Choose a pair of indices $l$ and $r$ such that $1 \\le l \\le r \\le n$, $a_l = 1$, $a_r = 1$, $a_l + \\ldots + a_r \\ge \\lceil\\frac{r - l + 1}{2}\\rceil$, and assign $1$ to $a_i$ for all $l \\le i \\le r$.\n\nWhat is the minimum number of operations of the first type needed to make all elements of the array equal to one?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains one integer $n$ ($1 \\le n \\le 10^5$)\u00a0\u2014 the length of the array.\n\nNote that there is no limit on the sum of $n$ over all test cases.\n\n### Output\n\nFor each test case, print one integer\u00a0\u2014 the minimum number of needed operations of first type.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n2\n\n4\n\n20\n\n```\n\n#### Output #1\n\n```\n1\n2\n2\n4\n```\n\n### Note\n\nIn the first test case, you can perform an operation of the $1$st type with $i = 1$.\n\nIn the second test case, you can perform the following sequence of operations:\n\n1. Operation of $1$st type, $i = 1$. After performing this operation, the array will look like this: $[1, 0]$.\n2. Operation of $1$st type, $i = 2$. After performing this operation, the array will look like this: $[1, 1]$.\n\nThe sequence of operations in the second test case![](https://espresso.codeforces.com/ecf02679535327fda085e7f1b907288a051b3fb0.png)\n\nIn the third test case, you can perform the following sequence of operations:\n\n1. Operation of $1$st type, $i = 1$. After performing this operation, the array will look like this: $[1, 0, 0, 0]$.\n2. Operation of $1$st type, $i = 4$. After performing this operation, the array will look like this: $[1, 0, 0, 1]$.\n3. Operation of $2$nd type, $l = 1$, $r = 4$. On this segment, $a_l + \\ldots + a_r = a_1 + a_2 + a_3 + a_4 = 2$, which is not less than $\\lceil\\frac{r - l + 1}{2}\\rceil = 2$. After performing this operation, the array will look like this: $[1, 1, 1, 1]$.\n\nThe sequence of operations in the third test case![](https://espresso.codeforces.com/d3efd70fa3bf233db7f264ab6039a169081d8cf5.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        ll n;\n        cin >> n;\n        // We need the minimum k such that f(k) >= n,\n        // where f(k) = 3*2^(k-1) - 2 is the maximum length\n        // coverable by k seeds (type-1 ops).\n        //\n        // Solve 3*2^(k-1) - 2 >= n  <=> 2^(k-1) >= (n+2)/3.\n        // Let X = ceil((n+2)/3).  Then we want the smallest p\n        // with 2^p >= X, and answer k = p+1.\n        //\n        // We implement by computing X and then finding p by\n        // doubling from 1.\n\n        // Compute X = ceil((n+2)/3)\n        ll X = (n + 2 + 3 - 1) / 3; // = (n+4)/3\n        // find p = smallest non-negative integer with (1<<p) >= X\n        ll cur = 1;\n        int p = 0;\n        while (cur < X) {\n            cur <<= 1;\n            ++p;\n        }\n        // answer is k = p+1\n        cout << (p + 1) << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2040a",
      "PROBLEM_ID": "2040A",
      "PROBLEM_STATEMENT": "You are given an array of integers $a_1, a_2, \\ldots, a_n$ of length $n$ and an integer $k$.\n\nTwo players are playing a game. The first player chooses an index $1 \\le i \\le n$. Then the second player chooses a different index $1 \\le j \\le n, i \\neq j$. The first player wins if $|a_i - a_j|$ is not divisible by $k$. Otherwise, the second player wins.\n\nWe play as the first player. Determine whether it is possible to win, and if so, which index $i$ should be chosen.\n\nThe absolute value of a number $x$ is denoted by $|x|$ and is equal to $x$ if $x \\ge 0$, and $-x$ otherwise.\n\n### Input\n\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 100$; $1 \\le k \\le 100$)\u00a0\u2014 the length of the array and the number $k$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 100$)\u00a0\u2014 the elements of the array $a$.\n\n### Output\n\nFor each test case, if it is impossible for the first player to win, print \"NO\" (without quotes).\n\nOtherwise, print \"YES\" (without quotes) and on the next line the appropriate index $1 \\le i \\le n$. If there are multiple solutions, print any of them.\n\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n3 2\n\n1 2 3\n\n4 2\n\n1 2 4 5\n\n5 3\n\n10 7 3 4 5\n\n5 3\n\n1 31 15 55 36\n\n2 1\n\n17 17\n\n2 2\n\n17 18\n\n1 3\n\n6\n\n```\n\n#### Output #1\n\n```\nYES\n2\nNO\nYES\n3\nNO\nNO\nYES\n2\nYES\n1\n```\n\n### Note\n\nIn the first test case, the first player can choose $a_2 = 2$. Then:\n\n- If the second player chooses $a_1 = 1$, the resulting difference is $|2 - 1| = 1$ which is not divisible by $k = 2$.\n- If the second player chooses $a_3 = 3$, the resulting difference is $|2 - 3| = 1$ which is not divisible by $k = 2$.\n\nIn the second test case:\n\n- If the first player chooses $a_1 = 1$ and then the second player chooses $a_4 = 5$, the resulting difference is $|1 - 5| = 4$ which is divisible by $k = 2$.\n- If the first player chooses $a_2 = 2$ and then the second player chooses $a_3 = 4$, the resulting difference is $|2 - 4| = 2$ which is divisible by $k = 2$.\n- If the first player chooses $a_3 = 4$ and then the second player chooses $a_2 = 2$, the resulting difference is $|4 - 2| = 2$ which is divisible by $k = 2$.\n- If the first player chooses $a_4 = 5$ and then the second player chooses $a_1 = 1$, the resulting difference is $|5 - 1| = 4$ which is divisible by $k = 2$.\n\nIn any case, the second player wins.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int t;\n    cin >> t;\n    \n    while(t--){\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        for(int &x : a) cin >> x;\n        \n        bool can_win = false;\n        int win_index = -1;\n        \n        for(int i = 0; i < n; ++i){\n            bool good_i = true;\n            for(int j = 0; j < n; ++j){\n                if(i == j) continue;\n                if(abs(a[i] - a[j]) % k == 0){\n                    good_i = false;\n                    break;\n                }\n            }\n            if(good_i){\n                can_win = true;\n                win_index = i + 1; // 1-based index\n                break;\n            }\n        }\n        \n        if(can_win){\n            cout << \"YES\\n\" << win_index << \"\\n\";\n        }\n        else{\n            cout << \"NO\\n\";\n        }\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2039h2",
      "PROBLEM_ID": "2039H2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The only difference is the maximum number of operations you can perform. You can only make hacks if both versions are solved.\n\nYou are given an array $a$ of size $n$.\n\nA cool swap walk is the following process:\n\n- In an $n \\times n$ grid, we note the cells in row $i$ and column $j$ as $(i, j)$. You need to walk from $(1,1)$ to $(n,n)$, taking only steps to the right or down.\n- Formally, if you are in $(x,y)$ currently, you can step to either $(x+1,y)$ or $(x,y+1)$, but you can not step beyond the boundaries of the grid.\n- When you step in $(i,j)$, you must swap $a_i$ and $a_j$ when $i \\neq j$.\n\nYou can perform at most $n+4$ cool swap walks. Sort the array $a_1, a_2, \\ldots, a_n$ in non-decreasing order. We can show that it's always possible to do so.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($2 \\leq n \\leq 500$)\u00a0\u2014 the size of the array.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots ,a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n^2$ over all test cases does not exceed $2.5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, your output should consist of several lines:\n\n- The first line contains an integer $k$ ($0 \\leq k \\leq n+4$), representing the number of cool swap walks you perform.\n- Each of the next $k$ lines contains a string $s$ of length $2n-2$ consisting only of R and D, representing the path (letters are case sensitive). For all $1 \\le i \\le 2n-2$, if $s_i=$ R, you walk right in the $i$-th step, otherwise you walk down in the $i$-th step.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2\n\n1 2\n\n3\n\n2 1 3\n\n4\n\n3 2 3 4\n\n```\n\n#### Output #1\n\n```\n0\n2\nRRDD\nDRDR\n3\nRRDRDD\nDRDDRR\nDDRRRD\n```\n\n### Note\n\nIn the first test case, the array $a$ is already non-decreasing, so you don't need to perform any walk.\n\nIn the second test case, $a=[2,1,3]$ initially.\n\nIn the first walk:\n\n- In the $1$-st step, you step right to $(1,2)$. Then, $a=[1,2,3]$. Note that although the array $a$ is already non-decreasing, you can not stop until you reach $(n,n)$.\n\n- In the $2$-nd step, you step right to $(1,3)$. Then, $a=[3,2,1]$.\n\n- In the $3$-rd step, you step down to $(2,3)$. Then, $a=[3,1,2]$.\n\n- In the $4$-th step, you step down to $(3,3)$. Then, $a=[3,1,2]$.\n\nIn the second walk:\n\n- In the $1$-st step, you step down to $(2,1)$. Then, $a=[1,3,2]$.\n\n- In the $2$-nd step, you step right to $(2,2)$. Then, $a=[1,3,2]$.\n\n- In the $3$-rd step, you step down to $(3,2)$. Then, $a=[1,2,3]$.\n\n- In the $4$-th step, you step down to $(3,3)$. Then, $a=[1,2,3]$.\n\nAfter the two cool swap walks above, we get $a=[1,2,3]$, which is non-decreasing.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=505;\nint n,a[MAXN],id[MAXN],b[MAXN];\nvoid solve() {\n\tcin>>n;\n\tfor(int i=0;i<n;++i) cin>>a[i],id[i]=i;\n\tif(n==2) return cout<<(a[0]<=a[1]?\"0\\n\":\"1\\nRD\\n\"),void();\n\tsort(id,id+n,[&](int x,int y){ return a[x]<a[y]; });\n\tfor(int i=0;i<n;++i) a[id[i]]=((i+4)%n+n)%n;\n\tcout<<n+4<<\"\\n\";\n\tfor(int i=0;i<n+4;++i) {\n\t\tfor(int j=2;j<n;j+=2) {\n\t\t\tint x=(i+j-1)%n,y=(i+j)%n;\n\t\t\tif(y&&a[x]>a[y]) swap(a[x],a[y]),cout<<\"RRDD\";\n\t\t\telse cout<<\"RDRD\";\n\t\t}\n\t\tcout<<(n&1?\"\\n\":\"RD\\n\");\n\t}\n}\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0),cout.tie(0);\n\tint _; cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2039g",
      "PROBLEM_ID": "2039G",
      "PROBLEM_STATEMENT": "Shohag has a tree with $n$ nodes.\n\nPebae has an integer $m$. She wants to assign each node a value\u00a0\u2014 an integer from $1$ to $m$. So she asks Shohag to count the number, modulo $998\\,244\\,353$, of assignments such that following conditions are satisfied:\n\n- For each pair $1 \\le u \\lt v \\le n$, the [least common multiple (LCM)](https://en.wikipedia.org/wiki/Least_common_multiple) of the values of the nodes in the unique simple path from $u$ to $v$ is not divisible by the number of nodes in the path.\n- The [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the values of all nodes from $1$ to $n$ is $1$.\n\nBut this problem is too hard for Shohag to solve. As Shohag loves Pebae, he has to solve the problem. Please save Shohag!\n\n### Input\n\nThe first line contains two space-separated integers $n$ and $m$ ($2 \\le n \\le 10^6$, $1 \\le m \\le 10^{9}$).\n\nEach of the next $n - 1$ lines contains two integers $u$ and $v$ ($1 \\le u, v \\le n$) indicating there is an edge between vertices $u$ and $v$. It is guaranteed that the given edges form a tree.\n\n### Output\n\nPrint a single integer\u00a0\u2014 the number of valid ways to assign each vertex a value, modulo $998\\,244\\,353$.\n\n### Examples\n\n#### Input #1\n\n```\n\n6 6\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n3 6\n\n```\n\n#### Output #1\n\n```\n2\n```\n\n#### Input #2\n\n```\n\n2 5\n\n1 2\n\n```\n\n#### Output #2\n\n```\n7\n```\n\n#### Input #3\n\n```\n\n12 69\n\n3 5\n\n1 4\n\n2 3\n\n4 5\n\n5 6\n\n8 9\n\n7 3\n\n4 8\n\n9 10\n\n1 11\n\n12 1\n\n```\n\n#### Output #3\n\n```\n444144548\n```\n\n### Note\n\nIn the first test case, the valid assignments are $[1, 1, 1, 1, 1, 1]$ and $[1, 1, 1, 1, 1, 5]$.\n\nIn the second test case, the valid assignments are $[1, 1]$, $[1, 3]$, $[1, 5]$, $[3, 1]$, $[3, 5]$, $[5, 1]$ and $[5, 3]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=1e6+5,MOD=998244353;\nll ksm(ll a,ll b) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }\nvector <int> G[MAXN];\nint n,lim[MAXN],dep[MAXN],ot[MAXN];\nvoid dfs1(int u,int fz) {\n\tfor(int v:G[u]) if(v^fz) dfs1(v,u),dep[u]=max(dep[u],dep[v]+1);\n}\nvoid dfs2(int u,int fz) {\n\tint mx=ot[u],smx=0;\n\tfor(int v:G[u]) if(v^fz) {\n\t\tif(mx<dep[v]+1) smx=mx,mx=dep[v]+1;\n\t\telse smx=max(smx,dep[v]+1);\n\t}\n\tlim[u]=mx+smx+1;\n\tfor(int v:G[u]) if(v^fz) ot[v]=(dep[v]+1==mx?smx:mx)+1,dfs2(v,u);\n}\nint q,up,pr[MAXN],tot,qc[MAXN];\nbool isc[MAXN];\nll m,B,vl[MAXN],id1[MAXN],id2[MAXN];\nint id(ll x) { return x<=B?id1[x]:id2[m/x]; }\nll g[MAXN],f[MAXN],h[MAXN],dp[MAXN]; //cnt prime, sum mu, minp>?, answer\nll F(ll x) {\n\tif(x<=pr[up]) return x>=1;\n\treturn f[id(x)]+up+1;\n}\nsigned main() {\n\tscanf(\"%d%lld\",&n,&m),B=sqrt(m);\n\tfor(int i=1,u,v;i<n;++i) scanf(\"%d%d\",&u,&v),G[u].push_back(v),G[v].push_back(u);\n\tdfs1(1,0),dfs2(1,0);\n\tfor(int i=2;i<MAXN;++i) {\n\t\tif(!isc[i]) pr[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*pr[j]<MAXN;++j) {\n\t\t\tisc[i*pr[j]]=true;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) lim[i]=upper_bound(pr+1,pr+tot+1,lim[i])-pr-1;\n\tup=*max_element(lim+1,lim+n+1);\n\tfor(ll l=1,r;l<=m;l=r+1) {\n\t\tr=m/(m/l),vl[++q]=m/l;\n\t\tif(vl[q]<=B) id1[vl[q]]=q;\n\t\telse id2[m/vl[q]]=q;\n\t}\n\tfor(int i=1;i<=q;++i) g[i]=vl[i]-1;\n\tfor(int k=1;k<=tot;++k) {\n\t\tfor(int i=1;i<=q&&1ll*pr[k]*pr[k]<=vl[i];++i) {\n\t\t\tg[i]-=g[id(vl[i]/pr[k])]-(k-1);\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i) f[i]=-g[i];\n\tfor(int k=tot;k>up;--k) {\n\t\tfor(int i=1;i<=q&&1ll*pr[k]*pr[k]<=vl[i];++i) {\n\t\t\tf[i]-=f[id(vl[i]/pr[k])]+k;\n\t\t}\n\t}\n\tif(pr[up]>2*B) {\n\t\tll ans=1;\n\t\tfor(int i=1;i<=n;++i) ans=ans*(max(0ll,g[1]-lim[i])+1)%MOD;\n\t\tif(up<g[1]) ans=(ans-(g[1]-up))%MOD;\n\t\tprintf(\"%lld\\n\",(ans+MOD)%MOD);\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i) ++qc[lim[i]];\n\tfor(int i=1;i<=q;++i) h[i]=g[i],dp[i]=1;\n\tfor(int k=tot;k>=1;--k) {\n\t\tif(qc[k]) {\n\t\t\tfor(int i=1;i<=q&&vl[i]>=pr[k];++i) dp[i]=dp[i]*ksm((h[i]-k+1)%MOD,qc[k])%MOD;\n\t\t}\n\t\tfor(int i=1;i<=q&&1ll*pr[k]*pr[k]<=vl[i];++i) {\n\t\t\tfor(ll pw=pr[k];pw*pr[k]<=vl[i];pw=pw*pr[k]) {\n\t\t\t\th[i]+=1+h[id(vl[i]/pw)]-k;\n\t\t\t}\n\t\t}\n\t}\n\tdp[q]=1;\n\tll ans=0;\n\tfor(ll l=1,r;l<=m;l=r+1) {\n\t\tr=m/(m/l);\n\t\tans=(ans+(F(r)-F(l-1))%MOD*dp[id(m/l)])%MOD;\n\t}\n\tprintf(\"%lld\\n\",(ans+MOD)%MOD);\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2039e",
      "PROBLEM_ID": "2039E",
      "PROBLEM_STATEMENT": "Shohag has an array $a$ of integers. Initially $a = [0, 1]$. He can repeatedly perform the following operation any number of times:\n\n- Let $k$ be the number of inversions$^{\\text{\u2217}}$ in the current array $a$.\n- Insert $k$ at any position in $a$, including the beginning or the end.\n\nFor example, if $a = [4, 6, 2, 4]$, then the number of inversions is $k = 3$. So Shohag can obtain the following arrays after the operation: $[\\textbf{3}, 4, 6, 2, 4]$, $[4, \\textbf{3}, 6, 2, 4]$, $[4, 6, \\textbf{3}, 2, 4]$, $[4, 6, 2, \\textbf{3}, 4]$, and $[4, 6, 2, 4, \\textbf{3}]$.\n\nGiven an integer $n$, help Shohag count, modulo $998\\,244\\,353$, the number of distinct arrays of length $n$ that can be obtained after performing the operations.\n\n$^{\\text{\u2217}}$The number of inversions in an array $a$ is the number of pairs of indices ($i$, $j$) such that $i < j$ and $a_i > a_j$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first and only line of each test case contains an integer $n$ ($2 \\le n \\le 10^6$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output an integer\u00a0\u2014 the number of possible arrays modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4\n\n2\n\n7\n\n69\n\n```\n\n#### Output #1\n\n```\n5\n1\n682\n325188814\n```\n\n### Note\n\nIn the first test case, the following $5$ arrays can be obtained (the inserted inversion count is shown in bold):\n\n- $[0, 1] \\rightarrow [0, \\textbf{0}, 1] \\rightarrow [0, 0, 1, \\textbf{0}]$,\n- $[0, 1] \\rightarrow [0, \\textbf{0}, 1] \\rightarrow [0, 0, \\textbf{0}, 1]$,\n- $[0, 1] \\rightarrow [0, 1, \\textbf{0}] \\rightarrow [0, 1, 0, \\textbf{1}]$,\n- $[0, 1] \\rightarrow [0, 1, \\textbf{0}] \\rightarrow [0, 1, \\textbf{1}, 0]$,\n- $[0, 1] \\rightarrow [0, 1, \\textbf{0}] \\rightarrow [\\textbf{1}, 0, 1, 0]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int MOD = 998244353;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    vector<int> qs(t);\n    int maxn = 2;\n    for(int i = 0; i < t; i++){\n        cin >> qs[i];\n        maxn = max(maxn, qs[i]);\n    }\n    // We need f[2..maxn] and d[3..maxn].\n    vector<int> f(maxn+1, 0), d(maxn+1, 0);\n\n    // base cases\n    f[2] = 1;\n    if(maxn >= 3){\n        d[3] = 1;\n        f[3] = (f[2] + d[3]) % MOD; // = 2\n    }\n    // build up to maxn\n    for(int n = 4; n <= maxn; n++){\n        // d[n] = n * d[n-1] - 1  (mod MOD)\n        long long x = (1LL * n * d[n-1]) % MOD;\n        x = (x - 1 + MOD) % MOD;\n        d[n] = int(x);\n        // f[n] = f[n-1] + d[n]\n        f[n] = f[n-1] + d[n];\n        if(f[n] >= MOD) f[n] -= MOD;\n    }\n\n    // answer queries\n    for(int i = 0; i < t; i++){\n        int n = qs[i];\n        // n is guaranteed >= 2\n        cout << f[n] << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2039c1",
      "PROBLEM_ID": "2039C1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The differences between the two versions are highlighted in bold. You can only make hacks if both versions of the problem are solved.\n\nShohag has two integers $x$ and $m$. Help him count the number of integers $1 \\le y \\le m$ such that $\\mathbf{x \\neq y}$ and $x \\oplus y$ is a divisor$^{\\text{\u2217}}$ of either $x$, $y$, or both. Here $\\oplus$ is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) operator.\n\n$^{\\text{\u2217}}$The number $b$ is a divisor of the number $a$ if there exists an integer $c$ such that $a = b \\cdot c$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first and only line of each test case contains two space-separated integers $x$ and $m$ ($1 \\le x \\le 10^6$, $1 \\le m \\le 10^{18}$).\n\nIt is guaranteed that the sum of $x$ over all test cases does not exceed $10^7$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the number of suitable $y$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n6 9\n\n5 7\n\n2 3\n\n6 4\n\n4 1\n\n```\n\n#### Output #1\n\n```\n3\n2\n1\n1\n0\n```\n\n### Note\n\nIn the first test case, for $x = 6$, there are $3$ valid values for $y$ among the integers from $1$ to $m = 9$, and they are $4$, $5$, and $7$.\n\n- $y = 4$ is valid because $x \\oplus y = 6 \\oplus 4 = 2$ and $2$ is a divisor of both $x = 6$ and $y = 4$.\n- $y = 5$ is valid because $x \\oplus y = 6 \\oplus 5 = 3$ and $3$ is a divisor of $x = 6$.\n- $y = 7$ is valid because $x \\oplus y = 6 \\oplus 7 = 1$ and $1$ is a divisor of both $x = 6$ and $y = 7$.\n\nIn the second test case, for $x = 5$, there are $2$ valid values for $y$ among the integers from $1$ to $m = 7$, and they are $4$ and $6$.\n\n- $y = 4$ is valid because $x \\oplus y = 5 \\oplus 4 = 1$ and $1$ is a divisor of both $x = 5$ and $y = 4$.\n- $y = 6$ is valid because $x \\oplus y = 5 \\oplus 6 = 3$ and $3$ is a divisor of $y = 6$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <numeric>\n\nusing namespace std;\n\nbool is_divisor(long long n, long long d) {\n    if (d == 0) {\n        return false;\n    }\n    return n % d == 0;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        long long x, m;\n        cin >> x >> m;\n        int count = 0;\n        for (long long y = 1; y <= min(m, 2 * x); ++y) {\n            if (x == y) {\n                continue;\n            }\n            long long xor_val = x ^ y;\n            if (is_divisor(x, xor_val) || is_divisor(y, xor_val)) {\n                count++;\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2039a",
      "PROBLEM_ID": "2039A",
      "PROBLEM_STATEMENT": "Shohag has an integer $n$. Please help him find an increasing integer sequence $1 \\le a_1 \\lt a_2 \\lt \\ldots \\lt a_n \\le 100$ such that $a_i \\bmod i \\neq a_j \\bmod j$ $^{\\text{\u2217}}$ is satisfied over all pairs $1 \\le i \\lt j \\le n$.\n\nIt can be shown that such a sequence always exists under the given constraints.\n\n$^{\\\\text{\u2217}}$$a \\\\bmod b$ denotes the remainder of $a$ after division by $b$. For example, $7 \\\\bmod 3 = 1, 8 \\\\bmod 4 = 0$ and $69 \\\\bmod 10 = 9$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 50$)\u00a0\u2014 the number of test cases.\n\nThe first and only line of each test case contains an integer $n$ ($2 \\le n \\le 50$).\n\n### Output\n\nFor each test case, print $n$ integers\u00a0\u2014 the integer sequence that satisfies the conditions mentioned in the statement. If there are multiple such sequences, output any.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n3\n\n6\n\n```\n\n#### Output #1\n\n```\n2 7 8\n2 3 32 35 69 95\n```\n\n### Note\n\nIn the first test case, the sequence is increasing, values are from $1$ to $100$ and each pair of indices satisfies the condition mentioned in the statement:\n\n- For pair $(1, 2)$, $a_1 \\bmod 1 = 2 \\bmod 1 = 0$, and $a_2 \\bmod 2 = 7 \\bmod 2 = 1$. So they are different.\n- For pair $(1, 3)$, $a_1 \\bmod 1 = 2 \\bmod 1 = 0$, and $a_3 \\bmod 3 = 8 \\bmod 3 = 2$. So they are different.\n- For pair $(2, 3)$, $a_2 \\bmod 2 = 7 \\bmod 2 = 1$, and $a_3 \\bmod 3 = 8 \\bmod 3 = 2$. So they are different.\n\nNote that you do not necessarily have to print the exact same sequence, you can print any other sequence as long as it satisfies the necessary conditions.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <set>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a;\n        for (int i = 1; i <= n; ++i) {\n            set<int> forbidden_remainders;\n            for (int j = 1; j < i; ++j) {\n                forbidden_remainders.insert(a[j - 1] % j);\n            }\n            int remainder = -1;\n            for (int r = 0; r < i; ++r) {\n                if (forbidden_remainders.find(r) == forbidden_remainders.end()) {\n                    remainder = r;\n                    break;\n                }\n            }\n            int lower_bound_k = 0;\n            if (i > 1) {\n                lower_bound_k = ceil((double)(a.back() - remainder) / i);\n            } else {\n                lower_bound_k = 0;\n            }\n            int k = max(1, lower_bound_k);\n            int current_a = k * i + remainder;\n            while (current_a <= (i == 1 ? 0 : a.back())) {\n                k++;\n                current_a = k * i + remainder;\n            }\n            a.push_back(current_a);\n        }\n        for (int i = 0; i < n; ++i) {\n            cout << a[i] << (i == n - 1 ? \"\" : \" \");\n        }\n        cout << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2037d",
      "PROBLEM_ID": "2037D",
      "PROBLEM_STATEMENT": "Mualani loves surfing on her sharky surfboard!\n\nMualani's surf path can be modeled by a number line. She starts at position $1$, and the path ends at position $L$. When she is at position $x$ with a jump power of $k$, she can jump to any integer position in the interval $[x, x+k]$. Initially, her jump power is $1$.\n\nHowever, her surf path isn't completely smooth. There are $n$ hurdles on her path. Each hurdle is represented by an interval $[l, r]$, meaning she cannot jump to any position in the interval $[l, r]$.\n\nThere are also $m$ power-ups at certain positions on the path. Power-up $i$ is located at position $x_i$ and has a value of $v_i$. When Mualani is at position $x_i$, she has the option to collect the power-up to increase her jump power by $v_i$. There may be multiple power-ups at the same position. When she is at a position with some power-ups, she may choose to take or ignore each individual power-up. No power-up is in the interval of any hurdle.\n\nWhat is the minimum number of power-ups she must collect to reach position $L$ to finish the path? If it is not possible to finish the surf path, output $-1$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains three integers $n$, $m$, and $L$ ($1 \\leq n, m \\leq 2 \\cdot 10^5, 3 \\leq L \\leq 10^9$) \u2014 the number of hurdles, the number of power-ups, and the position of the end.\n\nThe following $n$ lines contain two integers $l_i$ and $r_i$ ($2 \\leq l_i \\leq r_i \\leq L-1$) \u2014 the bounds of the interval for the $i$'th hurdle. It is guaranteed that $r_i + 1 < l_{i+1}$ for all $1 \\leq i < n$ (i.e. all hurdles are non-overlapping, sorted by increasing positions, and the end point of a previous hurdle is not consecutive with the start point of the next hurdle).\n\nThe following $m$ lines contain two integers $x_i$ and $v_i$ ($1 \\leq x_i, v_i \\leq L$) \u2014 the position and the value for the $i$'th power-up. There may be multiple power-ups with the same $x$. It is guaranteed that $x_i \\leq x_{i+1}$ for all $1 \\leq i < m$ (i.e. the power-ups are sorted by non-decreasing position) and no power-up is in the interval of any hurdle.\n\nIt is guaranteed the sum of $n$ and the sum of $m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the minimum number of power-ups she must collect to reach position $L$. If it is not possible, output $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 5 50\n\n7 14\n\n30 40\n\n2 2\n\n3 1\n\n3 5\n\n18 2\n\n22 32\n\n4 3 50\n\n4 6\n\n15 18\n\n20 26\n\n34 38\n\n1 2\n\n8 2\n\n10 2\n\n1 4 17\n\n10 14\n\n1 6\n\n1 2\n\n1 2\n\n16 9\n\n1 2 10\n\n5 9\n\n2 3\n\n2 2\n\n```\n\n#### Output #1\n\n```\n4\n-1\n1\n2\n```\n\n### Note\n\nIn the first test case, she can collect power-ups $1$, $2$, $3$, and $5$ to clear all hurdles.\n\nIn the second test case, she cannot jump over the first hurdle.\n\nIn the fourth test case, by collecting both power-ups, she can jump over the hurdle.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--){\n        // Read n, m, L\n        int n, m;\n        long long L;\n        cin >> n >> m >> L;\n        \n        // Read hurdles\n        vector<pair<long long, long long>> hurdles(n);\n        for(int i=0;i<n;i++) cin >> hurdles[i].first >> hurdles[i].second;\n        \n        // Generate allowed_intervals\n        vector<pair<long long, long long>> allowed;\n        long long s_prev = 1;\n        for(int i=0;i<n;i++){\n            long long l = hurdles[i].first;\n            long long r = hurdles[i].second;\n            long long e_prev = l -1;\n            if(e_prev >= s_prev){\n                allowed.emplace_back(s_prev, e_prev);\n            }\n            s_prev = r +1;\n        }\n        // Add the last allowed interval\n        if(s_prev <= L){\n            allowed.emplace_back(s_prev, L);\n        }\n        \n        // Generate required_constraints\n        vector<pair<long long, long long>> required_constraints;\n        for(int i=1;i<allowed.size();i++){\n            long long e_prev = allowed[i-1].second;\n            long long s_next = allowed[i].first;\n            long long required_sum = s_next - e_prev -1;\n            required_constraints.emplace_back(e_prev, required_sum);\n        }\n        \n        // Read power-ups\n        vector<pair<long long, long long>> powerups(m);\n        for(int i=0;i<m;i++) cin >> powerups[i].first >> powerups[i].second;\n        \n        // Process constraints\n        // Sort power-ups by x_i already guaranteed\n        int power_up_ptr =0;\n        long long current_sum =0;\n        int count =0;\n        bool possible = true;\n        // Use max heap, store negative values to simulate max heap\n        priority_queue<long long> pq;\n        \n        for(auto &[pos, req_sum] : required_constraints){\n            if(req_sum <=0) continue;\n            // Push all power-ups with x_i <= pos\n            while(power_up_ptr < m && powerups[power_up_ptr].first <= pos){\n                pq.push(powerups[power_up_ptr].second);\n                power_up_ptr++;\n            }\n            // Try to satisfy req_sum\n            while(current_sum < req_sum){\n                if(pq.empty()){\n                    possible = false;\n                    break;\n                }\n                long long val = pq.top();\n                pq.pop();\n                current_sum += val;\n                count++;\n            }\n            if(!possible) break;\n        }\n        \n        if(possible){\n            cout << count << \"\\n\";\n        }\n        else{\n            cout << \"-1\\n\";\n        }\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2036d",
      "PROBLEM_ID": "2036D",
      "PROBLEM_STATEMENT": "One morning, Polycarp woke up and realized that $1543$ is the most favorite number in his life.\n\nThe first thing that Polycarp saw that day as soon as he opened his eyes was a large wall carpet of size $n$ by $m$ cells; $n$ and $m$ are even integers. Each cell contains one of the digits from $0$ to $9$.\n\nPolycarp became curious about how many times the number $1543$ would appear in all layers$^{\\text{\u2217}}$ of the carpet when traversed clockwise.\n\n$^{\\text{\u2217}}$The first layer of a carpet of size $n \\times m$ is defined as a closed strip of length $2 \\cdot (n+m-2)$ and thickness of $1$ element, surrounding its outer part. Each subsequent layer is defined as the first layer of the carpet obtained by removing all previous layers from the original carpet.\n\n### Input\n\nThe first line of the input contains a single integer $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases. The following lines describe the test cases.\n\nThe first line of each test case contains a pair of numbers $n$ and $m$ ($2 \\leq n, m \\leq 10^3$, $n, m$\u00a0\u2014 even integers).\n\nThis is followed by $n$ lines of length $m$, consisting of digits from $0$ to $9$ \u2014 the description of the carpet.\n\nIt is guaranteed that the sum of $n \\cdot m$ across all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output a single number \u2014 the total number of times $1543$ appears in all layers of the carpet in the order of traversal clockwise.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n2 4\n\n1543\n\n7777\n\n2 4\n\n7154\n\n8903\n\n2 4\n\n3451\n\n8888\n\n2 2\n\n54\n\n13\n\n2 2\n\n51\n\n43\n\n2 6\n\n432015\n\n512034\n\n4 4\n\n5431\n\n1435\n\n5518\n\n7634\n\n6 4\n\n5432\n\n1152\n\n4542\n\n2432\n\n2302\n\n5942\n\n```\n\n#### Output #1\n\n```\n1\n1\n0\n1\n0\n2\n2\n2\n```\n\n### Note\n\n![](https://espresso.codeforces.com/376751b0f30c54602e78b686b24d2749f7484632.png)Occurrences of $1543$ in the seventh example. Different layers are colored in different colors.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to extract one layer from the carpet and count occurrences of \"1543\"\nint countInLayer(vector<vector<char>>& carpet, int startRow, int startCol, int rows, int cols) {\n    string sequence;\n    \n    // Top row (left to right)\n    for(int j = startCol; j < cols - startCol; j++)\n        sequence += carpet[startRow][j];\n    \n    // Right column (top to bottom)\n    for(int i = startRow + 1; i < rows - startRow; i++)\n        sequence += carpet[i][cols - startCol - 1];\n    \n    // Bottom row (right to left)\n    for(int j = cols - startCol - 2; j >= startCol; j--)\n        sequence += carpet[rows - startRow - 1][j];\n    \n    // Left column (bottom to top)\n    for(int i = rows - startRow - 2; i > startRow; i--)\n        sequence += carpet[i][startCol];\n    \n    // Make the sequence circular by adding first three characters at the end\n    sequence += sequence.substr(0, 3);\n    \n    // Count occurrences of \"1543\"\n    int count = 0;\n    for(int i = 0; i < sequence.length() - 3; i++) {\n        if(sequence.substr(i, 4) == \"1543\")\n            count++;\n    }\n    \n    return count;\n}\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<char>> carpet(n, vector<char>(m));\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < m; j++)\n            cin >> carpet[i][j];\n    \n    int result = 0;\n    // For each layer\n    for(int layer = 0; layer < min(n, m)/2; layer++) {\n        if(n - 2*layer <= 0 || m - 2*layer <= 0) break;\n        result += countInLayer(carpet, layer, layer, n, m);\n    }\n    \n    cout << result << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2036a",
      "PROBLEM_ID": "2036A",
      "PROBLEM_STATEMENT": "Boris Notkin composes melodies. He represents them as a sequence of notes, where each note is encoded as an integer from $0$ to $127$ inclusive. The interval between two notes $a$ and $b$ is equal to $|a - b|$ semitones.\n\nBoris considers a melody perfect if the interval between each two adjacent notes is either $5$ semitones or $7$ semitones.\n\nAfter composing his latest melodies, he enthusiastically shows you his collection of works. Help Boris Notkin understand whether his melodies are perfect.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of melodies.\n\nEach melody is described by two lines.\n\nThe first line contains an integer $n$ ($2 \\leq n \\leq 50$) \u2014 the number of notes in the melody.\n\nThe second line contains $n$ integers $a_{1}, a_{2}, \\dots, a_{n}$ ($0 \\leq a_{i} \\leq 127$) \u2014 the notes of the melody.\n\n### Output\n\nFor each melody, output \"YES\", if it is perfect; otherwise, output \"NO\".\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n2\n\n114 109\n\n2\n\n17 10\n\n3\n\n76 83 88\n\n8\n\n38 45 38 80 85 92 99 106\n\n5\n\n63 58 65 58 65\n\n8\n\n117 124 48 53 48 43 54 49\n\n5\n\n95 102 107 114 121\n\n10\n\n72 77 82 75 70 75 68 75 68 75\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool isPerfectMelody(const vector<int>& notes) {\n    for (int i = 1; i < notes.size(); i++) {\n        int interval = abs(notes[i] - notes[i-1]);\n        if (interval != 5 && interval != 7) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<int> notes(n);\n        for (int i = 0; i < n; i++) {\n            cin >> notes[i];\n        }\n        \n        if (isPerfectMelody(notes)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2035h",
      "PROBLEM_ID": "2035H",
      "PROBLEM_STATEMENT": "I'm peakly productive and this is deep.\n\nYou are given two permutations$^{\\text{\u2217}}$ $a$ and $b$, both of length $n$.\n\nYou can perform the following three-step operation on permutation $a$:\n\n1. Choose an index $i$ ($1 \\le i \\le n$).\n2. Cyclic shift $a_1, a_2, \\ldots, a_{i-1}$ by $1$ to the right. If you had chosen $i = 1$, then this range doesn't exist, and you cyclic shift nothing.\n3. Cyclic shift $a_{i + 1}, a_{i + 2}, \\ldots, a_n$ by $1$ to the right. If you had chosen $i = n$, then this range doesn't exist, and you cyclic shift nothing.\n\nAfter the operation, $a_1,a_2,\\ldots, a_{i-2},a_{i-1},a_i,a_{i + 1}, a_{i + 2},\\ldots,a_{n-1}, a_n$ is transformed into $a_{i-1},a_1,\\ldots,a_{i-3},a_{i-2},a_i,a_n, a_{i + 1},\\ldots,a_{n-2}, a_{n-1}$.\n\nHere are some examples of operations done on the identity permutation $[1,2,3,4,5,6,7]$ of length $7$:\n\n- If we choose $i = 3$, it will become $[2, 1, 3, 7, 4, 5, 6]$.\n- If we choose $i = 1$, it will become $[1, 7, 2, 3, 4, 5, 6]$.\n- If we choose $i = 7$, it will become $[6, 1, 2, 3, 4, 5, 7]$.\n\nNotably, position $i$ is not shifted.\n\nFind a construction using at most $2n$ operations to make $a$ equal to $b$ or print $-1$ if it is impossible. The number of operations does not need to be minimized. It can be shown that if it is possible to make $a$ equal to $b$, it is possible to do this within $2n$ operations.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 5 \\cdot 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 5 \\cdot 10^5$)\u00a0\u2014 the lengths of permutations $a$ and $b$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the values of permutation $a$.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le n$)\u00a0\u2014 the values of permutation $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases will not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case:\n\nIf there is a sequence of operations to transform $a$ into $b$, output a single integer $q$ ($0\\le q\\le 2n$)\u00a0\u2014 the number of operations in the first line and $q$ integers with the $i$-th number representing the index of the $i$-th operation in the second line.\n\nIf there is no sequence of operations, output $-1$ in the only line.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n1\n\n1\n\n2\n\n1 2\n\n2 1\n\n3\n\n2 1 3\n\n3 2 1\n\n8\n\n7 8 3 5 4 6 1 2\n\n2 1 6 4 5 3 8 7\n\n```\n\n#### Output #1\n\n```\n0\n\n-1\n2\n1 3\n7\n3 4 5 1 2 1 1\n```\n\n### Note\n\nIn the first case, you can do no operation since $a=b$.\n\nIn the second case, it can be proved $a$ can not be transformed into $b$.\n\nIn the third case, $a$ is transformed into $[2,3,1]$ after the first operation and into $b$ after the second operation.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=5e5+5;\nint n,A[MAXN],B[MAXN],z[MAXN];\nstruct arr {\n\tint tg,p[MAXN],a[MAXN*3];\n\tvoid init() { tg=0,fill(p+1,p+n+1,0),fill(a+1,a+3*n+1,0); }\n\tinline int operator [](int i) { return a[i+2*n-tg]; }\n\tinline int operator ()(int x) { return p[x]+tg; }\n\tinline void set(int i,int x) { p[x]=i-tg,a[i+2*n-tg]=x; }\n}\ta;\nvoid opr(int i) {\n\tint l=(i>1?a[i-1]:0),x=a[i],r=(i<n?a[n]:0);\n\t++a.tg,a.set(i,x),cout<<i<<\" \";\n\tif(l) a.set(1,l);\n\tif(r) a.set(i+1,r);\n}\nvoid solve() {\n\tcin>>n;\n\tfor(int i=1;i<=n;++i) cin>>A[i];\n\tfor(int i=1;i<=n;++i) cin>>B[i],z[B[i]]=i;\n\tif(n==1) return cout<<\"0\\n\\n\",void();\n\tif(n==2) return cout<<(A[1]==B[1]?\"0\\n\\n\":\"-1\\n\"),void();\n\tfor(int i=1;i<=n;++i) a.set(i,z[A[i]]);\n\tif(a(n)<n) cout<<2*n-1<<\"\\n\",opr(a(n)+1);\n\telse cout<<2*n<<\"\\n\",opr(1),opr(3);\n\tfor(int x=n-1;x>=1;--x) {\n\t\tint p=a(x);\n\t\tif(p<n) opr(p+1);\n\t\telse if(x==1) opr(1);\n\t\telse opr(a(x-1)+1),opr(a(x)==n?1:a(x)+1),--x;\n\t}\n\tfor(int i=1;i<n;opr(n),++i) if(i<n-1&&a[n-2]==a[n-1]+1) opr(n-1),++i;\n\tcout<<\"\\n\",a.init();\n}\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0),cout.tie(0);\n\tint _; cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2035g2",
      "PROBLEM_ID": "2035G2",
      "PROBLEM_STATEMENT": "The differences between the easy and hard versions are the constraints on $n$ and the sum of $n$. In this version, $n \\leq 3\\cdot 10^5$ and the sum of $n$ does not exceed $10^6$. You can only make hacks if both versions are solved.\n\nWell, well, well, let's see how Bessie is managing her finances. She seems to be in the trenches! Fortunately, she is applying for a job at Moogle to resolve this issue. Moogle interviews require intensive knowledge of obscure algorithms and complex data structures, but Bessie received a tip-off from an LGM on exactly what she has to go learn.\n\nBessie wrote the following code to binary search for a certain element $k$ in a possibly unsorted array $[a_1, a_2,\\ldots,a_n]$ with $n$ elements.\n\n```\n`let l = 1<br/>let h = n<br/><br/>while l < h:<br/>  let m = floor((l + h) / 2)<br/><br/>  if a[m] < k:<br/>    l = m + 1<br/>  else:<br/>    h = m<br/><br/>return l<br/>````\n\nBessie submitted her code to Farmer John's problem with $m$ ($1 \\leq m \\leq n$) tests. The $i$-th test is of the form $(x_i, k_i)$ ($1 \\leq x, k \\leq n$). It is guaranteed all the $x_i$ are distinct and all the $k_i$ are distinct.\n\nTest $i$ is correct if the following hold:\n\n1. The $x_i$-th element in the array is $k_i$.\n2. If Bessie calls the binary search as shown in the above code for $k_i$, it will return $x_i$.\n\nIt might not be possible for all $m$ tests to be correct on the same array, so Farmer John will remove some of them so Bessie can AC. Let $r$ be the minimum of tests removed so that there exists an array $[a_1, a_2,\\ldots,a_n]$ with $1 \\leq a_i \\leq n$ so that all remaining tests are correct.\n\nIn addition to finding $r$, Farmer John wants you to count the number of arrays $[a_1, a_2,\\ldots,a_n]$ with $1 \\leq a_i \\leq n$ such that there exists a way to remove exactly $r$ tests so that all the remaining tests are correct. Since this number may be very large, please find it modulo $998\\,244\\,353$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq m \\leq n \\leq 3 \\cdot 10^5$) denoting the number of the array and the number of tests.\n\nThe following $m$ lines each contain two integers, describing the tests. The $i$-th line contains two integers $x_i$ and $k_i$ ($1 \\leq x_i, k_i \\leq n$) denoting the index and value of the test. It is guaranteed all $x_i$ are distinct and all $k_i$ are distinct.\n\nIt is guaranteed the sum of $n$ across all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output two integers, $r$\u00a0\u2014 the minimum of tests removed so that there exists an array so that all remaining tests are correct, and the number of arrays such that it is possible to remove $r$ tests to make all remaining tests correct modulo $998\\,244\\,353$.\n\n### Examples\n\n#### Input #1\n\n```\n\n2\n\n5 4\n\n1 1\n\n2 2\n\n4 3\n\n5 4\n\n5 4\n\n5 4\n\n2 5\n\n1 2\n\n3 3\n\n```\n\n#### Output #1\n\n```\n0 1\n1 3\n```\n\n#### Input #2\n\n```\n\n3\n\n6 6\n\n1 3\n\n2 5\n\n3 1\n\n4 2\n\n5 4\n\n6 6\n\n30 8\n\n19 22\n\n6 12\n\n12 1\n\n28 27\n\n3 4\n\n14 25\n\n29 14\n\n11 15\n\n300000 1\n\n5 10\n\n```\n\n#### Output #2\n\n```\n3 78\n3 839271911\n0 702730519\n```\n\n### Note\n\nConsider the first example.\n\nIn the first test case, the array $[1,2,2,3,4]$ satisfies all $m$ tests, so the minimum number of tests Bessie has to remove is $0$. Note that this is also the only array that satisfies all $m$ tests.\n\nIn the second test case, the minimum number of tests Bessie has to remove is $1$. The only test Bessie can remove is $(2,5)$. If Bessie removes test $(2,5)$, then the arrays satisfying the remaining $m-1$ tests are $[2,2,3,1,4]$, $[2,2,3,2,4]$, $[2,2,3,3,4]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=3e5+5,MOD=998244353,inf=1e9;\nll ksm(ll a,ll b=MOD-2) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }\nstruct info {\n\tint x; ll w;\n\tinline friend info operator +(const info &u,const info &v) {\n\t\treturn u.x^v.x?(u.x>v.x?u:v):info{u.x,(u.w+v.w)%MOD};\n\t}\n\tinline info operator -(const info &o) const { return {x,(w+MOD-o.w)%MOD}; }\n\tinline info operator *(const ll &o) const { return {x,w*o%MOD}; }\n}\tf[MAXN],s1[MAXN],s2[MAXN];\nvector <int> L[MAXN],R[MAXN];\nint n,m,a[MAXN],p[MAXN];\nvoid solve() {\n\tscanf(\"%d%d\",&n,&m);\n\tll inv=ksm(n);\n\tfor(int i=1,x,y;i<=m;++i) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==1||y>1) a[x]=y,p[y]=x;\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tf[i]=s1[i]=s2[i]={-inf,1};\n\t\tfor(int l=1,r=n;l<r;) {\n\t\t\tint j=(l+r)>>1;\n\t\t\tif(i<=j) {\n\t\t\t\tr=j;\n\t\t\t\tif(i!=j) R[i].push_back(j);\n\t\t\t} else l=j+1,L[i].push_back(j);\n\t\t}\n\t\treverse(L[i].begin(),L[i].end());\n\t\treverse(R[i].begin(),R[i].end());\n\t}\n\tinfo ans={0,1};\n\tfor(int i=1;i<=n;++i) if(p[i]) {\n\t\tint x=p[i]; ll vl=1,wys=(i-1)*inv%MOD;\n\t\tfor(int j:L[x]) {\n\t\t\tf[x]=f[x]+(s1[j]*i-s2[j])*vl*inv;\n\t\t\tif(a[j]) f[x]=f[x]+f[j]*vl;\n\t\t\tvl=vl*wys%MOD;\n\t\t}\n\t\tf[x]=f[x]+info{0,vl},++f[x].x;\n\t\tvl=1,wys=(n-i+1)*inv%MOD;\n\t\tfor(int j:R[x]) {\n\t\t\ts1[j]=s1[j]+f[x]*vl;\n\t\t\ts2[j]=s2[j]+f[x]*vl*i;\n\t\t\tvl=vl*wys%MOD;\n\t\t}\n\t\tans=ans+f[x]*vl;\n\t}\n\tprintf(\"%d %lld\\n\",m-ans.x,ans.w*ksm(n,n-ans.x)%MOD);\n\tfor(int i=1;i<=n;++i) L[i].clear(),R[i].clear(),a[i]=p[i]=0;\n}\nsigned main() {\n\tint _; scanf(\"%d\",&_);\n\twhile(_--) solve();\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2035e",
      "PROBLEM_ID": "2035E",
      "PROBLEM_STATEMENT": "Man, this Genshin boss is so hard. Good thing they have a top-up of $6$ coins for only $ \\$4.99$. I should be careful and spend no more than I need to, lest my mom catches me...\n\nYou are fighting a monster with $z$ health using a weapon with $d$ damage. Initially, $d=0$. You can perform the following operations.\n\n- Increase $d$\u00a0\u2014 the damage of your weapon by $1$, costing $x$ coins.\n- Attack the monster, dealing $d$ damage and costing $y$ coins.\n\nYou cannot perform the first operation for more than $k$ times in a row.\n\nFind the minimum number of coins needed to defeat the monster by dealing at least $z$ damage.\n\n### Input\n\nThe first line contains a single integer $t$ ($1\\le t\\le 100$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains 4 integers $x$, $y$, $z$, and $k$ ($1\\leq x, y, z, k\\leq 10^8$)\u00a0\u2014 the first operation's cost, the second operation's cost, the monster's health, and the limitation on the first operation.\n\n### Output\n\nFor each test case, output the minimum number of coins needed to defeat the monster.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 3 5 5\n\n10 20 40 5\n\n1 60 100 10\n\n60 1 100 10\n\n```\n\n#### Output #1\n\n```\n12\n190\n280\n160\n```\n\n### Note\n\nIn the first test case, $x = 2$, $y = 3$, $z = 5$, and $k = 5$. Here's a strategy that achieves the lowest possible cost of $12$ coins:\n\n- Increase damage by $1$, costing $2$ coins.\n- Increase damage by $1$, costing $2$ coins.\n- Increase damage by $1$, costing $2$ coins.\n- Attack the monster, dealing $3$ damage, costing $3$ coins.\n- Attack the monster, dealing $3$ damage, costing $3$ coins.\n\nYou deal a total of $3 + 3 = 6$ damage, defeating the monster who has $5$ health. The total number of coins you use is $2 + 2 + 2 + 3 + 3 = 12$ coins.\n\nIn the second test case, $x = 10$, $y = 20$, $z = 40$, and $k = 5$. Here's a strategy that achieves the lowest possible cost of $190$ coins:\n\n- Increase damage by $5$, costing $5\\cdot x$ = $50$ coins.\n- Attack the monster once, dealing $5$ damage, costing $20$ coins.\n- Increase damage by $2$, costing $2\\cdot x$ = $20$ coins.\n- Attack the monster $5$ times, dealing $5\\cdot 7 = 35$ damage, costing $5\\cdot y$ = $100$ coins.\n\nYou deal a total of $5 + 35 = 40$ damage, defeating the monster who has exactly $40$ health. The total number of coins you use is $50 + 20 + 20 + 100 = 190$ coins.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        long long x, y, z, k;\n        cin >> x >> y >> z >> k;\n\n        long long ans = 1e18;\n\n        for (int g = 0; ; g++) {\n            long long base_damage = 0;\n            if (g > 0) {\n                base_damage = k * static_cast<long long>(g) * (g + 1) / 2;\n            }\n\n            if (base_damage >= z) {\n                long long candidate = static_cast<long long>(g) * k * x + static_cast<long long>(g) * y;\n                ans = min(ans, candidate);\n                break;\n            }\n\n            long long rem = z - base_damage;\n            long long L = static_cast<long long>(g) * k;\n            long long start_n = (g == 0) ? 1 : L;\n            long long end_n = L + k;\n\n            for (long long n = start_n; n <= end_n; ) {\n                long long v0 = (rem + n - 1) / n;\n                long long candidate = n * x + (g + v0) * y;\n                ans = min(ans, candidate);\n\n                if (v0 == 1) {\n                    break;\n                }\n\n                long long next_n_val = (rem + v0 - 2) / (v0 - 1);\n                if (next_n_val <= n || next_n_val > end_n) {\n                    break;\n                }\n                n = next_n_val;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2035c",
      "PROBLEM_ID": "2035C",
      "PROBLEM_STATEMENT": "Alya has been given a hard problem. Unfortunately, she is too busy running for student council. Please solve this problem for her.\n\nGiven an integer $n$, construct a permutation $p$ of integers $1, 2, \\ldots, n$ that maximizes the value of $k$ (which is initially $0$) after the following process.\n\nPerform $n$ operations, on the $i$-th operation ($i=1, 2, \\dots, n$),\n\n- If $i$ is odd, $k=k\\,\\&\\,p_i$, where $\\&$ denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND).\n- If $i$ is even, $k=k\\,|\\,p_i$, where $|$ denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\n\n### Input\n\nThe first line contains a single integer $t$ ($1\\le t\\le 500$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains a single integer $n$ ($5\\le n\\le 2 \\cdot 10^5$)\u00a0\u2014 the length of the permutation.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the maximum value of $k$ in the first line and output the permutation $p_1, p_2,\\ldots, p_n$ in the second line.\n\nIf there are multiple such permutations, output any.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n```\n\n#### Output #1\n\n```\n5\n2 1 3 4 5\n7\n1 2 4 6 5 3\n7\n2 4 5 1 3 6 7\n15\n2 4 5 1 3 6 7 8\n9\n2 4 5 6 7 1 3 8 9\n15\n1 2 3 4 5 6 8 10 9 7\n```\n\n### Note\n\nFor the first test case, the value of $k$ is determined as follows:\n\n$k = 0$ initially.\n\n- On the $1$st operation, $1$ is odd, so Alya sets $k$ to be $k\\&p_1 = 0\\&2 = 0$.\n- On the $2$nd operation, $2$ is even, so Alya sets $k$ to be $k|p_2 = 0|1 = 1$.\n- On the $3$rd operation, $3$ is odd, so Alya sets $k$ to be $k\\&p_3 = 1\\&3 = 1$.\n- On the $4$th operation, $4$ is even, so Alya sets $k$ to be $k|p_4 = 1|4 = 5$.\n- On the $5$th operation, $5$ is odd, so Alya sets $k$ to be $k\\&p_5 = 5\\&5 = 5$.\n\nThe final value of $k$ is $5$. It can be shown that the final value of $k$ is at most $5$ for all permutations of length $5$. Another valid output is $[2, 3, 1, 4, 5]$.\n\nFor the second test case, the final value of $k$ is $7$. It can be shown that the final value of $k$ is at most $7$ for all permutations of length $6$. Other valid outputs include $[2, 4, 1, 6, 3, 5]$ and $[5, 2, 6, 1, 3, 4]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    if(!(cin >> t)) return 0;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> p(n+1);\n        // compute highest power-of-two m <= n\n        int h = 31 - __builtin_clz(n);\n        int m = 1 << h;\n        long long K;\n        if(n % 2 == 1){\n            // odd n\n            K = n;\n            // mapping p[1]=2,p[2]=3,p[3]=1, then identity\n            if(n >= 1) p[1] = 2;\n            if(n >= 2) p[2] = 3;\n            if(n >= 3) p[3] = 1;\n            for(int i = 4; i <= n; ++i){\n                p[i] = i;\n            }\n        } else {\n            // even n\n            K = (long long)(m << 1) - 1;\n            if(m == n){\n                // n is power of two\n                // use mapping p1..p4 = [2,4,1,3], then p[i]=i for i>=5\n                // n>=8 guaranteed by constraints n>=5 and even power-of-two => n>=8\n                p[1] = 2;\n                p[2] = 4;\n                p[3] = 1;\n                p[4] = 3;\n                for(int i = 5; i <= n; ++i){\n                    p[i] = i;\n                }\n            } else {\n                // general even n != power-of-two\n                // special values: m, m-1, n-1, n\n                vector<char> used(n+1, 0);\n                used[m] = 1;\n                used[m-1] = 1;\n                used[n] = 1;\n                used[n-1] = 1;\n                vector<int> rem;\n                rem.reserve(n);\n                for(int x = 1; x <= n; ++x){\n                    if(!used[x]){\n                        rem.push_back(x);\n                    }\n                }\n                // fill p[1..n-4] with rem in sorted order\n                sort(rem.begin(), rem.end());\n                int idx = 0;\n                int upto = n - 4;\n                for(int i = 1; i <= upto; ++i){\n                    p[i] = rem[idx++];\n                }\n                // fill last 4\n                p[n-3] = m;\n                p[n-2] = n;\n                p[n-1] = n-1;\n                p[n]   = m-1;\n            }\n        }\n        // output\n        cout << K << \"\\n\";\n        for(int i = 1; i <= n; ++i){\n            cout << p[i] << (i==n?'\\n':' ');\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2035a",
      "PROBLEM_ID": "2035A",
      "PROBLEM_STATEMENT": "Red was ejected. They were not the imposter.\n\nThere are $n$ rows of $m$ people. Let the position in the $r$-th row and the $c$-th column be denoted by $(r, c)$. Number each person starting from $1$ in row-major order, i.e., the person numbered $(r-1)\\cdot m+c$ is initially at $(r,c)$.\n\nThe person at $(r, c)$ decides to leave. To fill the gap, let the person who left be numbered $i$. Each person numbered $j>i$ will move to the position where the person numbered $j-1$ is initially at. The following diagram illustrates the case where $n=2$, $m=3$, $r=1$, and $c=2$.\n\n![](https://espresso.codeforces.com/b24389738aac41115cbf116d0cb49065a5710c74.png)\n\nCalculate the sum of the Manhattan distances of each person's movement. If a person was initially at $(r_0, c_0)$ and then moved to $(r_1, c_1)$, the Manhattan distance is $|r_0-r_1|+|c_0-c_1|$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe only line of each testcase contains $4$ integers $n$, $m$, $r$, and $c$ ($1\\le r\\le n\\le 10^6$, $1 \\le c \\le m \\le 10^6$), where $n$ is the number of rows, $m$ is the number of columns, and $(r,c)$ is the position where the person who left is initially at.\n\n### Output\n\nFor each test case, output a single integer denoting the sum of the Manhattan distances.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 3 1 2\n\n2 2 2 1\n\n1 1 1 1\n\n1000000 1000000 1 1\n\n```\n\n#### Output #1\n\n```\n6\n1\n0\n1999998000000\n```\n\n### Note\n\nFor the first test case, the person numbered $2$ leaves, and the distances of the movements of the person numbered $3$, $4$, $5$, and $6$ are $1$, $3$, $1$, and $1$, respectively. So the answer is $1+3+1+1=6$.\n\nFor the second test case, the person numbered $3$ leaves, and the person numbered $4$ moves. The answer is $1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long n, m, r, c;\n        cin >> n >> m >> r >> c;\n        \n        long long total_distance = 2 * (n-r)*m + m - c - n + r;\n        \n        cout << total_distance << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2034h",
      "PROBLEM_ID": "2034H",
      "PROBLEM_STATEMENT": "Rayan makes his final efforts to win Reyhaneh's heart by claiming he is stronger than Rayaneh (i.e., computer in Persian). To test this, Reyhaneh asks [Khwarizmi](https://en.wikipedia.org/wiki/Al-Khwarizmi) for help. Khwarizmi explains that a set is integer linearly independent if no element in the set can be written as an integer linear combination of the others. Rayan is given a set of integers each time and must identify one of the largest possible integer linearly independent subsets.\n\nNote that a single element is always considered an integer linearly independent subset.\n\nAn integer linearly combination of $a_1, \\ldots, a_k$ is any sum of the form $c_1 \\cdot a_1 + c_2 \\cdot a_2 + \\ldots + c_k \\cdot a_k$ where $c_1, c_2, \\ldots, c_k$ are integers (which may be zero, positive, or negative).\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 100$), the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 10^5$), the size of the set. The second line contains $n$ distinct integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^5$).\n\nThe sum of $n$ over all test cases does not exceed $3 \\cdot 10^6$.\n\n### Output\n\nIn the first line of each test case print the size of the largest integer linearly independent subset.\n\nIn the next line, print one such subset in any order. If there are multiple valid subsets, print any one of them.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5\n\n2 4 6 8 10\n\n5\n\n12 15 21 30 35\n\n3\n\n2 3 6\n\n```\n\n#### Output #1\n\n```\n2\n4 6\n3\n35 21 30\n2\n2 3\n```\n\n### Note\n\nIn example 1, $\\{4, 6\\}$ is an integer linearly independent subset. It can be proven that there is no integer linearly independent subset with at least $3$ elements.\n\nIn example 2, $\\{35, 21, 30\\}$ is an integer linearly independent subset because no integer linear combination of any two elements can create the third. There is no integer linearly independent subset with at least $4$ elements.\n\nIn example 3, $\\{2, 3, 6\\}$ is not an integer linearly independent subset since $6$ can be written as $6 \\cdot 2 + (-2) \\cdot 3$, which is an integer linear combination of $\\{2, 3\\}$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define LL long long\n#define fr(x) freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);\nusing namespace std;\nconst int N=1e5+5,M=N-5,L=31700000;\nint T,n,V,a[N],pr[N],cnt,f[N];bool v[N];\nvector<pair<array<int,6>,int>>F[7];array<int,6>g;\nvector<int>ans;\nvoid dfs(int x,int s,int c,LL mn)\n{\n\tif(c>=3) F[c].push_back({g,s}),cnt++;\n\tif(x>pr[0]) return;\n\tfor(int w=x,p=pr[w];w<=pr[0]&&(LL)p*s<=L&&(LL)p*s/min(mn,(LL)p)<=M;p=pr[++w])\n\t\tfor(LL y=p;s*y<=L&&s*y/min(mn,(LL)y)<=M;y*=p) g[c]=y,dfs(w+1,s*y,c+1,min(mn,y));\n}\ninline void init()\n{\n\tfor(int i=2;i<=M;i++)\n\t{\n\t\tif(!v[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=M;j++)\n\t\t{\n\t\t\tv[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}dfs(1,1,0,1e18);\n}\ninline bool get(int i)\n{\n\tfor(auto [u,v]:F[i])\n\t{\n\t\tbool o=1;\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tint p=v/u[j],q=(v<=V)?f[v]:0;p=(p<=V)?f[p]:0;\n\t\t\tif(p==q||!p){o=0;break;}\n\t\t}\n\t\tif(o)\n\t\t{\n\t\t\tans.clear();\n\t\t\tfor(int j=0;j<i;j++) for(int k=1;k<=n;k++)\n\t\t\t\tif(!(a[k]%(v/u[j]))&&(a[k]%v)){ans.push_back(a[k]);break;}\n\t\t\treturn 1;\n\t\t}\n\t}return 0;\n}\nint main()\n{\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);cin>>T;init();\n\t// cerr<<cnt;\n\twhile(T--)\n\t{\n\t\tcin>>n;V=0;\n\t\tfor(int i=1;i<=n;i++) cin>>a[i],V=max(V,a[i]);\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(int i=1;i<=n;i++) f[a[i]]++;\n\t\tfor(int i=1,p=2;p<=V&&p<=pr[0];p=pr[++i])\n\t\t\tfor(int j=V/p;j;j--) f[j]+=f[j*p];\n\t\tsort(a+1,a+1+n);ans={a[1]};\n\t\tfor(int i=2;i<=n;i++) if(a[i]%a[i-1]){ans={a[i-1],a[i]};break;}\n\t\tfor(int i=6;i>2;i--) if(get(i)) break;\n\t\tcout<<ans.size()<<\"\\n\";\n\t\tfor(int i:ans) cout<<i<<\" \";cout<<\"\\n\";\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2034g2",
      "PROBLEM_ID": "2034G2",
      "PROBLEM_STATEMENT": "The only difference between the two versions of the problem is whether overlaps are considered at all points or only at integer points.\n\nThe legendary [Simurgh](https://www.eavartravel.com/blog/2023/11/3/140727/simurgh/), a mythical bird, is responsible for keeping watch over vast lands, and for this purpose, she has enlisted $n$ vigilant warriors. Each warrior is alert during a specific time segment $[l_i, r_i]$, where $l_i$ is the start time (included) and $r_i$ is the end time (included), both positive integers.\n\n![](https://espresso.codeforces.com/e448e919c3f03a9c212cd45c8dcd8e2bb0be579c.webp)\n\nOne of Simurgh's trusted advisors, [Zal](https://asia-archive.si.edu/learn/shahnama/zal-and-the-simurgh/), is concerned that if multiple warriors are stationed at the same time and all wear the same color, the distinction between them might be lost, causing confusion in the watch. To prevent this, whenever multiple warriors are on guard at the same integer moment, there must be at least one color which is worn by exactly one warrior.\n\nSo the task is to determine the minimum number of colors required and assign a color $c_i$ to each warrior's segment $[l_i, r_i]$ such that, for every (integer) time $t$ contained in at least one segment, there exists one color which belongs to exactly one segment containing $t$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nFor each test case:\n\n- The first line contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the number of warriors stationed by Simurgh.\n- The next $n$ lines each contain two integers $l_i$ and $r_i$ ($1 \\leq l_i \\leq r_i \\leq 10^9$) \u2014 the start and end times of the warrior's watch segment.\n\nThe sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case:\n\n- Output the minimum number of colors $k$ needed.\n- Then, output a line of $n$ integers $c_i$ ($1 \\leq c_i \\leq k$), where each $c_i$ is the color assigned to the $i$-th warrior.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5\n\n1 4\n\n2 8\n\n3 7\n\n5 10\n\n6 9\n\n5\n\n1 5\n\n2 6\n\n3 7\n\n4 7\n\n6 7\n\n5\n\n4 9\n\n8 17\n\n2 15\n\n12 19\n\n6 13\n\n```\n\n#### Output #1\n\n```\n2\n1 2 2 1 2\n2\n1 2 2 2 1\n3\n1 1 2 3 1\n```\n\n### Note\n\nWe can represent each warrior's watch segment as an interval on the X-axis;\n\nIn test case 1, the intervals can be colored as shown below (intervals are colored with the selected color; areas are colored if this color occurs exactly once at this point in time):\n\n![](https://espresso.codeforces.com/80b63ec750df7a5ab4b27f062adbfc97cf959e1f.png)\n\nIn test case 2, the intervals can be colored as shown below:\n\n![](https://espresso.codeforces.com/95b4a26427875e70e36b805f77a4b0b38af8c984.png)\n\nIn test case 3, the intervals can be colored as shown below:\n\n![](https://espresso.codeforces.com/6699aab3b108808e3576916130d839f91a86c1f7.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=8e5+5,MAXS=2.4e6+5;\nint n,m,l[MAXN],r[MAXN],vl[MAXM],f[MAXS],z[MAXN];\nvector <int> L[MAXM],R[MAXM];\nbool dp[MAXN];\nunordered_map <int,int> g[MAXS];\nbool chk1() {\n\tbool ok=true;\n\tfor(int i=1,ct=0;i<=m;++i) {\n\t\tct+=L[i].size(),ok&=ct<=1,ct-=R[i].size();\n\t}\n\treturn ok;\n}\nbool chk2() {\n\tunordered_set <int> sg; dp[0]=1;\n\tfor(int i=1;i<=m;++i) {\n\t\tfor(int x:L[i]) {\n\t\t\tsg.insert(x);\n\t\t\tif(dp[0]) dp[x]=true,g[3*i-2][x]=0;\n\t\t}\n\t\tif(sg.size()>1) dp[0]=false;\n\t\tfor(int x:R[i]) {\n\t\t\tif(!dp[0]&&dp[x]) dp[0]=true,g[3*i-1][0]=x;\n\t\t\tsg.erase(x),dp[x]=false;\n\t\t}\n\t\tif(sg.size()==1||sg.size()==2) {\n\t\t\tint x=*sg.begin(),y=(sg.size()==1?0:*++sg.begin());\n\t\t\tif(dp[x]&&!dp[y]) dp[y]=true,g[3*i][y]=x;\n\t\t\tif(!dp[x]&&dp[y]) dp[x]=true,g[3*i][x]=y;\n\t\t}\n\t}\n\treturn dp[0];\n}\nvoid sol2() {\n\tf[3*m]=0;\n\tfor(int i=3*m;i;--i) f[i-1]=g[i].count(f[i])?g[i][f[i]]:f[i];\n\tunordered_set <int> sg;\n\tfor(int i=1;i<=m;++i) {\n\t\tif(g[3*i-2].count(f[3*i-2])) {\n\t\t\tint cl=sg.size()?z[*sg.begin()]:0;\n\t\t\tfor(int x:L[i]) z[x]=cl^(x==f[3*i-2]),sg.insert(x);\n\t\t} else if(f[3*i-3]) {\n\t\t\tfor(int x:L[i]) z[x]=z[f[3*i-3]]^1,sg.insert(x);\n\t\t} else {\n\t\t\tint cl=sg.size()?z[*sg.begin()]:0;\n\t\t\tfor(int x:L[i]) z[x]=cl^1,sg.insert(x);\n\t\t}\n\t\tfor(int x:R[i]) sg.erase(x);\n\t}\n}\nvoid sol3() {\n\tint cur=0,nxt=0;\n\tfor(int i=1;i<=m;++i) if(L[i].size()) {\n\t\tif(cur&&i>r[cur]&&nxt!=cur) z[nxt]=z[cur]^3,cur=nxt;\n\t\tif(i>r[cur]) {\n\t\t\tfor(int x:L[i]) if(r[x]>r[cur]) cur=x;\n\t\t\tz[nxt=cur]=1;\n\t\t}\n\t\tfor(int x:L[i]) if(r[x]>r[nxt]) nxt=x;\n\t}\n\tif(nxt^cur) z[nxt]=z[cur]^3;\n}\nvoid solve() {\n\tcin>>n,m=0;\n\tfor(int i=1;i<=n;++i) {\n\t\tcin>>l[i]>>r[i];\n\t\tvl[++m]=l[i]-1,vl[++m]=l[i];\n\t\tvl[++m]=r[i],vl[++m]=r[i]+1;\n\t}\n\tsort(vl+1,vl+m+1),m=unique(vl+1,vl+m+1)-vl-1;\n\tfor(int i=1;i<=n;++i) {\n\t\tl[i]=lower_bound(vl+1,vl+m+1,l[i])-vl;\n\t\tr[i]=lower_bound(vl+1,vl+m+1,r[i])-vl;\n\t\tL[l[i]].push_back(i),R[r[i]].push_back(i);\n\t}\n\tif(chk1());\n\telse if(chk2()) sol2();\n\telse sol3();\n\tcout<<*max_element(z+1,z+n+1)+1<<\"\\n\";\n\tfor(int i=1;i<=n;++i) cout<<z[i]+1<<\" \\n\"[i==n];\n\tfor(int i=0;i<=n;++i) l[i]=r[i]=z[i]=dp[i]=0;\n\tfor(int i=1;i<=m;++i) L[i].clear(),R[i].clear();\n\tfor(int i=0;i<=3*m;++i) g[i].clear(),f[i]=0;\n}\nsigned main() {\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tint _; cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2034f1",
      "PROBLEM_ID": "2034F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The only differences between the two versions are the constraints on $k$ and the sum of $k$.\n\nIn ancient Persia, [Khayyam](https://en.wikipedia.org/wiki/Omar_Khayyam), a clever merchant and mathematician, is playing a game with his prized treasure chest containing $n$ red rubies worth $2$ dinars each and $m$ blue sapphires worth $1$ dinar each. He also has a satchel, which starts empty, and $k$ scrolls with pairs $(r_1, b_1), (r_2, b_2), \\ldots, (r_k, b_k)$ that describe special conditions.\n\n![](https://espresso.codeforces.com/3576d678d9cd8a4cfa1efad5eb4bc61b9ecbcf4d.webp)\n\nThe game proceeds for $n + m$ turns as follows:\n\n1. Khayyam draws a gem uniformly at random from the chest.\n2. He removes the gem from the chest and places it in his satchel.\n3. If there exists a scroll $i$ ($1 \\leq i \\leq k$) such that the chest contains exactly $r_i$ red rubies and $b_i$ blue sapphires, Khayyam receives a royal decree that doubles the value of all the gems in his satchel as a reward for achieving a special configuration.\n\nNote that the value of some gems might be affected by multiple decrees, and in that case the gems' value is doubled multiple times.\n\nDetermine the expected value of Khayyam's satchel at the end of the game, modulo $998,244,353$.\n\nFormally, let $M = 998,244,353$. It can be shown that the exact answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$ ($1 \\leq n, m \\leq 2 \\cdot 10^5$, $0 \\leq k \\leq 500$)\u00a0\u2014 the number of red rubies, the number of blue sapphires, and the number of scrolls describing special conditions, respectively.\n\nEach of the next $k$ lines contains two integers $r_i$, $b_i$ ($0 \\leq r_i \\leq n$, $0 \\leq b_i \\leq m$, $1 \\leq r_i + b_i \\leq n+m-1$). It is guaranteed that the pairs $(r_i, b_i)$ are distinct.\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ over all test cases do not exceed $2 \\cdot 10^5$, and the sum of $k$ over all test cases does not exceed $500$.\n\n### Output\n\nFor each test case, print a single integer: the expected value of Khayyam's satchel at the end of the process, modulo $998,244,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3 4 0\n\n1 1 1\n\n1 0\n\n3 3 2\n\n1 1\n\n2 2\n\n3 3 2\n\n2 1\n\n1 2\n\n10 4 5\n\n1 0\n\n8 0\n\n6 4\n\n0 2\n\n7 4\n\n```\n\n#### Output #1\n\n```\n10\n499122180\n798595498\n149736666\n414854846\n```\n\n### Note\n\nIn the first test case, at the end of the process, there will always be $3$ red rubies and $4$ blue sapphires. None of the special conditions described in the scrolls are met, so the value of Khayyam's satchel remains unchanged. The total value of the satchel at the end is always $2 \\cdot 3 + 1 \\cdot 4 = 10$.\n\nIn the second test case, consider the following two cases:\n\n- With probability $1/2$, Khayyam draws a red ruby, and the value of his satchel becomes $2$. Then with probability $1$, he draws a blue sapphire, and the value of his satchel becomes $3$.\n- With probability $1/2$, Khayyam draws a blue sapphire, and the value of his satchel becomes $1$. At this point, the chest contains $r_1 = 1$ red rubies and $b_1 = 0$ blue sapphires, which match the special condition described in a scroll. As a result, the value of the satchel is doubled to $2 \\cdot 1 = 2$. Then with probability $1$, he draws a red ruby, and the value of his satchel becomes $4$.\n\nThus, the expected value at the end is $\\frac{1}{2} \\cdot 3 + \\frac{1}{2} \\cdot 4 = \\frac{7}{2}$, which is $499,122,180$ modulo $998,244,353$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 998244353;\n\n// fast exponentiation mod\nll modexp(ll a, ll e) {\n    ll res = 1 % MOD;\n    a %= MOD;\n    while (e) {\n        if (e & 1) res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        e >>= 1;\n    }\n    return res;\n}\n\nint add_mod(int a, int b) {\n    int s = a + b;\n    if (s >= MOD) s -= MOD;\n    return s;\n}\nint sub_mod(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += MOD;\n    return s;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    vector<tuple<int,int,int, vector<pair<int,int>>>> tests;\n    tests.reserve(t);\n    int max_nm = 0;\n    for (int _ = 0; _ < t; _++) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        vector<pair<int,int>> scr;\n        scr.reserve(k);\n        for (int i = 0; i < k; i++) {\n            int r, b;\n            cin >> r >> b;\n            scr.emplace_back(r, b);\n        }\n        tests.emplace_back(n, m, k, scr);\n        max_nm = max(max_nm, n + m);\n    }\n\n    // Precompute factorials and inverse factorials up to max_nm\n    int N = max_nm;\n    vector<int> fac(N+1), ifac(N+1);\n    fac[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        fac[i] = (ll)fac[i-1] * i % MOD;\n    }\n    // inverse factorial\n    ifac[N] = (int)modexp(fac[N], MOD-2);\n    for (int i = N; i > 0; i--) {\n        ifac[i-1] = (ll)ifac[i] * i % MOD;\n    }\n\n    auto comb = [&](int n, int k)->int {\n        if (k < 0 || k > n) return 0;\n        return (ll)fac[n] * ifac[k] % MOD * ifac[n-k] % MOD;\n    };\n\n    // Maximum possible scrolls across tests <= 500\n    // We'll allocate arrays sized [502][502]\n    static int P_basic[502][502];\n    static int P[502][502];\n    static ll D[502], Sarr[502];\n    static int rr[502], bb[502];\n\n    for (int ti = 0; ti < t; ti++) {\n        int n, m, k;\n        vector<pair<int,int>> scr;\n        tie(n,m,k,scr) = tests[ti];\n\n        // sort scrolls by decreasing r+b\n        sort(scr.begin(), scr.end(), [&](const pair<int,int> &A, const pair<int,int> &B){\n            int sa = A.first + A.second;\n            int sb = B.first + B.second;\n            return sa > sb;\n        });\n\n        // Build states: index 0 = origin (n,m), 1..k = scrolls, k+1 = sink (0,0)\n        int K = k;\n        int Nstate = K + 2;\n        // fill rr, bb\n        rr[0] = n; bb[0] = m;\n        for (int i = 1; i <= K; i++) {\n            rr[i] = scr[i-1].first;\n            bb[i] = scr[i-1].second;\n        }\n        rr[K+1] = 0; bb[K+1] = 0;\n\n        // Compute P_basic\n        // P_basic[i][j] = probability path from state i visits j (ignoring other scrolls)\n        // = C(r_i, r_i-r_j) * C(b_i, b_i-b_j) / C(r_i+b_i, (r_i-r_j)+(b_i-b_j))\n        for (int i = 0; i < Nstate; i++) {\n            // we only need j>i\n            for (int j = i+1; j < Nstate; j++) {\n                int ri = rr[i], bi = bb[i];\n                int rj = rr[j], bj = bb[j];\n                if (ri >= rj && bi >= bj) {\n                    int dR = ri - rj;\n                    int dB = bi - bj;\n                    int L = dR + dB;\n                    // numerator = comb(ri, dR) * comb(bi, dB)\n                    int num = comb(ri, dR);\n                    num = (ll)num * comb(bi, dB) % MOD;\n                    // denom = comb(ri+bi, L), so inv(denom) = ifac[ri+bi] * fac[L] * fac[ri+bi-L]\n                    int tot = ri + bi;\n                    int invDen = (ll)ifac[tot] * fac[L] % MOD * fac[tot - L] % MOD;\n                    P_basic[i][j] = (ll)num * invDen % MOD;\n                } else {\n                    P_basic[i][j] = 0;\n                }\n            }\n        }\n\n        // Compute P transitions (probabilities of next scroll or sink)\n        for (int i = 0; i <= K; i++) {\n            // reset P[i][*]\n            // compute for j=i+1..K\n            for (int j = i+1; j <= K; j++) {\n                ll cur = P_basic[i][j];\n                // subtract paths that hit some k in (i,j) first, then j\n                for (int mid = i+1; mid < j; mid++) {\n                    if (P[i][mid] != 0 && P_basic[mid][j] != 0) {\n                        cur = (cur - (ll)P[i][mid] * P_basic[mid][j]) % MOD;\n                    }\n                }\n                if (cur < 0) cur += MOD;\n                P[i][j] = (int)cur;\n            }\n            // Compute P[i][K+1] = probability no scroll events when starting at i\n            ll sumP = 0;\n            for (int j = i+1; j <= K; j++) {\n                sumP += P[i][j];\n                if (sumP >= MOD) sumP -= MOD;\n            }\n            ll sinkP = 1 - sumP;\n            sinkP %= MOD;\n            if (sinkP < 0) sinkP += MOD;\n            P[i][K+1] = (int)sinkP;\n        }\n\n        // DP for D and S\n        // D[K+1] = 1, S[K+1] = 0\n        D[K+1] = 1;\n        Sarr[K+1] = 0;\n\n        for (int i = K; i >= 0; i--) {\n            // Compute D[i]\n            ll Di = P[i][K+1];  // if sink, multiplier 1\n            for (int j = i+1; j <= K; j++) {\n                if (P[i][j]) {\n                    // when scroll j happens, multiplier *2 and then D[j]\n                    ll add = (ll)P[i][j] * ((2LL * D[j]) % MOD) % MOD;\n                    Di += add;\n                    if (Di >= MOD) Di -= MOD;\n                }\n            }\n            Di %= MOD;\n            D[i] = Di;\n\n            // Compute S[i]\n            ll Si = 0;\n            // Contribution from direct to sink:\n            // deltaC(i->sink) = 2*(r_i - 0) + (b_i - 0) = 2*r_i + b_i\n            ll delta_sink = (2LL * rr[i] + bb[i]) % MOD;\n            Si = (Si + (ll)P[i][K+1] * delta_sink) % MOD;\n            // Contributions via scroll j\n            for (int j = i+1; j <= K; j++) {\n                if (!P[i][j]) continue;\n                // part S[j] weighted by P[i][j]\n                Si = (Si + (ll)P[i][j] * Sarr[j]) % MOD;\n                // part contributions from segment i->j: deltaC = 2*(r_i-r_j) + (b_i-b_j)\n                ll delta = 2LL * (rr[i] - rr[j]) + (ll)(bb[i] - bb[j]);\n                delta %= MOD;\n                if (delta < 0) delta += MOD;\n                // these contributions get doubled at scroll j (hence *2), then multiplied by D[j] for future events\n                // weight = 2 * delta * P[i][j] * D[j]\n                ll term = delta * (ll)P[i][j] % MOD * D[j] % MOD;\n                term = (term * 2) % MOD;\n                Si = (Si + term) % MOD;\n            }\n            Sarr[i] = Si;\n        }\n\n        // Answer is Sarr[0]\n        ll ans = Sarr[0] % MOD;\n        if (ans < 0) ans += MOD;\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2034e",
      "PROBLEM_ID": "2034E",
      "PROBLEM_STATEMENT": "Rayan wants to present a gift to Reyhaneh to win her heart. However, Reyhaneh is particular and will only accept a k-harmonic set of permutations.\n\nWe define a k-harmonic set of permutations as a set of $k$ pairwise distinct permutations $p_1, p_2, \\ldots, p_k$ of size $n$ such that for every pair of indices $i$ and $j$ (where $1 \\leq i, j \\leq n$), the following condition holds:\n\n\n\n$$ p_1[i] + p_2[i] + \\ldots + p_k[i] = p_1[j] + p_2[j] + \\ldots + p_k[j] $$\n\nYour task is to help Rayan by either providing a valid k-harmonic set of permutations for given values of $n$ and $k$ or by determining that such a set does not exist.\n\nWe call a sequence of length $n$ a permutation if it contains every integer from $1$ to $n$ exactly once.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 1000$), the number of test cases.\n\nEach test case consists of two integers $n$ and $k$ ($1 \\leq n, k \\leq 10^5$). The sum of $n \\cdot k$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, if a k-harmonic set of permutations exists, print YES on the first line. Then, print $k$ lines, each containing a distinct permutation of the integers from $1$ to $n$.\n\nIf no such set exists, print NO on the first line.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\n\nIf multiple answers are possible, you can output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 3\n\n4 2\n\n5 1\n\n3 2\n\n```\n\n#### Output #1\n\n```\nYES\n1 2 3\n2 3 1\n3 1 2\nYES\n1 2 3 4\n4 3 2 1\nNO\nYES\n1 2 3\n3 2 1\n```\n\n### Note\n\nIn example 1, we have $p_1 = [1, 2, 3]$, $p_2 = [2, 3, 1]$, and $p_3 = [3, 1, 2]$. It's easy to see that $p_1[1] + p_2[1] + p_3[1] = p_1[2] + p_2[2] + p_3[2] = p_1[3] + p_2[3] + p_3[3] = 6$.\n\nIn example 2, we have $p_1 = [1, 2, 3, 4]$ and $p_2 = [4, 3, 2, 1]$. It's easy to see that $p_1[1] + p_2[1] = p_1[2] + p_2[2] = p_1[3] + p_2[3] = p_1[4] + p_2[4] = 5$.\n\nIn example 3, as there are five distinct elements in $p_1$, it's obvious that the answer is \"No\".",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = unsigned long long;\n\n/* -------------- small factorials (only till it exceeds 1e5) ------------- */\nlong long smallFact(int n)                // for n<=10 is enough\n{\n    static long long fact[11] = {0};\n    if (!fact[1])\n    {\n        fact[0] = 1;\n        for (int i = 1; i <= 10; ++i)\n        {\n            fact[i] = fact[i - 1] * i;\n            if (fact[i] > 100000) fact[i] = 100001;   // cap, we only care if it exceeds 1e5\n        }\n    }\n    return (n <= 10 ? fact[n] : 100001);\n}\n\n/* ---------------- hash of a permutation (simple rolling) ---------------- */\null hashPerm(const vector<int>& v)\n{\n    const ull BASE = 1000003ULL;\n    ull h = 0;\n    for (int x : v) h = h * BASE + x;\n    return h;\n}\n\n/* ---------------------- base 3 permutations for odd n ------------------- */\nvoid makeBaseTriple(int n, vector<vector<int>>& out,\n                    unordered_set<ull>& used)\n{\n    int m = (n + 1) / 2;                  // (n+1)/2\n    int C = 3 * m;                        // 3*(n+1)/2\n    vector<int> p1(n), p2(n), p3(n);\n    for (int i = 0; i < n; ++i)\n    {\n        p1[i] = i + 1;\n        p2[i] = (i + m) % n + 1;\n    }\n    for (int i = 0; i < n; ++i) p3[i] = C - p1[i] - p2[i];\n\n    out.push_back(p1);\n    out.push_back(p2);\n    out.push_back(p3);\n    used.insert(hashPerm(p1));\n    used.insert(hashPerm(p2));\n    used.insert(hashPerm(p3));\n}\n\n/* -------- add \u201cpairs\u201d permutations (perm, complement(perm)) ------------- */\nbool makePairs(int n, int pairsNeeded, vector<vector<int>>& out,\n               unordered_set<ull>& used)\n{\n    vector<int> perm(n);\n    iota(perm.begin(), perm.end(), 1);    // identity\n\n    /* iterate over permutations in lexicographic order */\n    while (pairsNeeded > 0)\n    {\n        ull h = hashPerm(perm);\n        if (!used.count(h))\n        {\n            vector<int> comp(n);\n            for (int i = 0; i < n; ++i) comp[i] = n + 1 - perm[i];\n            ull hc = hashPerm(comp);\n\n            if (!used.count(hc))\n            {\n                /* take this pair */\n                out.push_back(perm);\n                out.push_back(comp);\n                used.insert(h);\n                used.insert(hc);\n                --pairsNeeded;\n                if (pairsNeeded == 0) break;\n            }\n        }\n        if (!next_permutation(perm.begin(), perm.end())) break; // exhausted\n    }\n    return pairsNeeded == 0;\n}\n\n/* ------------------------------ solve one test -------------------------- */\nvoid solveOne(int n, int k)\n{\n    /* k == 1 has to be the trivial n==1 case */\n    if (k == 1)\n    {\n        if (n == 1)\n        {\n            cout << \"YES\\n1\\n\";\n        }\n        else\n        {\n            cout << \"NO\\n\";\n        }\n        return;\n    }\n\n    /* parity / divisibility condition: k*(n+1) must be even  */\n    if (((long long)k * (n + 1)) & 1)\n    {\n        cout << \"NO\\n\";\n        return;\n    }\n\n    /* factorial bound \u2013 for n<=10 this is enough, for bigger n fact >1e5 */\n    if (k > smallFact(n))\n    {\n        cout << \"NO\\n\";\n        return;\n    }\n\n    /* odd k requires odd n (because (n+1) must be even) */\n    if ((k & 1) && !(n & 1))\n    {\n        cout << \"NO\\n\";\n        return;\n    }\n\n    vector<vector<int>> ans;\n    ans.reserve(k);\n\n    unordered_set<ull> used;\n    used.reserve(k * 2 + 5);\n\n    /* build permutations */\n    if (k & 1)                       // odd k  (so n is odd here)\n    {\n        makeBaseTriple(n, ans, used);        // gives 3 rows\n    }\n\n    int pairsNeed = (k - (int)ans.size()) / 2;\n    if (!makePairs(n, pairsNeed, ans, used))\n    {\n        cout << \"NO\\n\";\n        return;                        // should not happen if previous checks were correct\n    }\n\n    cout << \"YES\\n\";\n    for (auto& row : ans)\n    {\n        for (int i = 0; i < n; ++i)\n        {\n            if (i) cout << ' ';\n            cout << row[i];\n        }\n        cout << '\\n';\n    }\n}\n\n/* ---------------------------------- main -------------------------------- */\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    if (!(cin >> T)) return 0;\n    while (T--)\n    {\n        int n, k;\n        cin >> n >> k;\n        solveOne(n, k);\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2034d",
      "PROBLEM_ID": "2034D",
      "PROBLEM_STATEMENT": "[Darius the Great](https://en.wikipedia.org/wiki/Darius_the_Great) is constructing $n$ stone columns, each consisting of a base and between $0$, $1$, or $2$ inscription pieces stacked on top.\n\nIn each move, Darius can choose two columns $u$ and $v$ such that the difference in the number of inscriptions between these columns is exactly $1$, and transfer one inscription from the column with more inscriptions to the other one. It is guaranteed that at least one column contains exactly $1$ inscription.\n\n![](https://espresso.codeforces.com/d4cdf6815b1220ffe2be57e8bcb7d42bfa773cfc.webp)\n\nSince beauty is the main pillar of historical buildings, Darius wants the columns to have ascending heights. To avoid excessive workers' efforts, he asks you to plan a sequence of at most $n$ moves to arrange the columns in non-decreasing order based on the number of inscriptions. Minimizing the number of moves is not required.\n\n### Input\n\nThe first line contains an integer $t$ \u2014 the number of test cases. ($1 \\leq t \\leq 3000$)\n\nThe first line of each test case contains an integer $n$ \u2014 the number of stone columns. ($1 \\leq n \\leq 2 \\cdot 10^5$)\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$, where $a_i \\in \\{0,1,2\\}$ represents the initial number of inscriptions in the $i$-th column. It is guaranteed that at least one column has exactly $1$ inscription.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output an integer $k$ \u2014 the number of moves used to sort the columns. ($0 \\leq k \\leq n$)\n\nThen, output $k$ lines, each containing two integers $u_i$ and $v_i$ ($1 \\leq u_i, v_i \\leq n$), representing the indices of the columns involved in the $i$-th move. During each move, it must hold that $|a_{u_i} - a_{v_i}| = 1$, and one inscription is transferred from the column with more inscriptions to the other.\n\nIt can be proven that a valid solution always exists under the given constraints.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4\n\n0 2 0 1\n\n3\n\n1 2 0\n\n6\n\n0 1 1 2 2 2\n\n```\n\n#### Output #1\n\n```\n2\n2 4\n2 3\n2\n3 1\n2 3\n0\n```\n\n### Note\n\nColumns state in the first test case:\n\n- Initial: $0, 2, 0, 1$\n- After the first move: $0, 1, 0, 2$\n- After the second move: $0, 0, 1, 2$\n\nColumns state in the second test case:\n\n- Initial: $1, 2, 0$\n- After the first move: $0, 2, 1$\n- After the second move: $0, 1, 2$\n\nIn the third test case, the column heights are already sorted in ascending order.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> a(n+1);\n        for(int i = 1; i <= n; i++){\n            cin >> a[i];\n        }\n        // Count how many 0s and 1s\n        int c0 = 0, c1 = 0;\n        for(int i = 1; i <= n; i++){\n            if(a[i] == 0) c0++;\n            else if(a[i] == 1) c1++;\n        }\n        // Boundaries of target blocks:\n        // positions [1..c0] -> zeros\n        // positions [c0+1..c0+c1] -> ones\n        int l0 = c0;\n        int r1 = c0 + c1;\n\n        // Find an initial pivot index where a[pivot] == 1\n        int pivot = -1;\n        for(int i = 1; i <= n; i++){\n            if(a[i] == 1){\n                pivot = i;\n                break;\n            }\n        }\n        // We'll record the operations here\n        vector<pii> ops;\n        ops.reserve(n);\n\n        // Helper to apply a swap operation between u and v\n        auto apply_swap = [&](int u, int v){\n            // record it\n            ops.emplace_back(u, v);\n            // actually swap values\n            int tmp = a[u]; a[u] = a[v]; a[v] = tmp;\n            // if pivot was one of these, update its index\n            if(pivot == u) pivot = v;\n            else if(pivot == v) pivot = u;\n        };\n\n        // Stage 1: place zeros into [1..l0]\n        // Build list of all initial zero-positions j > l0\n        vector<int> zerosAfter;\n        zerosAfter.reserve(n);\n        for(int j = l0+1; j <= n; j++){\n            if(a[j] == 0){\n                zerosAfter.push_back(j);\n            }\n        }\n        // We'll pop from the back as we use them\n        for(int i = 1; i <= l0; i++){\n            if(a[i] == 0) {\n                // already correct\n                continue;\n            }\n            if(a[i] == 1){\n                // one-step swap with some zero at j>l0\n                int j = zerosAfter.back();\n                zerosAfter.pop_back();\n                apply_swap(i, j);\n            } else {\n                // a[i] == 2, we need two swaps: first with pivot (1), then with a zero\n                // swap 2 <-> 1\n                apply_swap(i, pivot);\n                // now a[i] == 1, swap with a zero at j>l0\n                int j = zerosAfter.back();\n                zerosAfter.pop_back();\n                apply_swap(i, j);\n            }\n        }\n\n        // Stage 2: sort ones- and twos-block\n        // Now [1..l0] are all zeros.\n        // Positions [l0+1..r1] should be all ones.\n        // Build list of ones in the tail j>r1\n        vector<int> onesAfter;\n        onesAfter.reserve(n);\n        for(int j = r1+1; j <= n; j++){\n            if(a[j] == 1){\n                onesAfter.push_back(j);\n            }\n        }\n        // For each i in [l0+1..r1], if it's a 2, swap with a 1 from onesAfter\n        for(int i = l0+1; i <= r1; i++){\n            if(a[i] == 2){\n                int j = onesAfter.back();\n                onesAfter.pop_back();\n                apply_swap(i, j);\n            }\n        }\n\n        // Output the result\n        cout << ops.size() << \"\\n\";\n        for(auto &pr : ops){\n            cout << pr.first << \" \" << pr.second << \"\\n\";\n        }\n        // Next test case...\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2034c",
      "PROBLEM_ID": "2034C",
      "PROBLEM_STATEMENT": "In the [fourth labor of Rostam](https://www.gathertales.com/story/the-tale-of-the-haft-khan-seven-labors-of-rostam/sid-604), the legendary hero from the [Shahnameh](https://en.wikipedia.org/wiki/Shahnameh), an old witch has created a magical maze to trap him. The maze is a rectangular grid consisting of $n$ rows and $m$ columns. Each cell in the maze points in a specific direction: up, down, left, or right. The witch has enchanted Rostam so that whenever he is in a cell, he will move to the next cell in the direction indicated by that cell.\n\n![](https://espresso.codeforces.com/fe31b399bb2207f13616c91f5553e04c54d77805.webp)\n\nIf Rostam eventually exits the maze, he will be freed from the witch's enchantment and will defeat her. However, if he remains trapped within the maze forever, he will never escape.\n\nThe witch has not yet determined the directions for all the cells. She wants to assign directions to the unspecified cells in such a way that the number of starting cells from which Rostam will be trapped forever is maximized. Your task is to find the maximum number of starting cells which make Rostam trapped.\n\n### Input\n\nThe first line of the input contains an integer $t$ ($1 \\leq t \\leq 10^4$), the number of test cases.\n\nFor each test case:\n\n- The first line contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 1000$), representing the number of rows and columns in the maze.\n- Each of the next $n$ lines contains a string of $m$ characters representing the directions in the maze. Each character is one of the following:\n  - U (up)\n  - D (down)\n  - L (left)\n  - R (right)\n  - ? (unspecified direction)\n\nIt's guaranteed that the sum of $n \\cdot m$ over all test cases is at most $10^6$.\n\n### Output\n\nFor each test case, print a single integer, the maximum number of starting cells from which Rostam will be trapped forever after assigning directions to the unspecified cells optimally.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3 3\n\nUUU\n\nL?R\n\nDDD\n\n2 3\n\n???\n\n???\n\n3 3\n\n?U?\n\nR?L\n\nRDL\n\n```\n\n#### Output #1\n\n```\n0\n6\n5\n```\n\n### Note\n\nIn the first test case, all of the cells will be good no matter what you do.\n\nIn the second test case, if you assign the ?s like the picture below, all of the cells will be bad:\n\n![](https://espresso.codeforces.com/c667fb00a6b0c8bcc1f533cb121685a1542afcf7.png)\n\nIn the third test case, if you assign the ?s like the picture below, you will have $5$ bad cells (red-shaded cells):\n\n![](https://espresso.codeforces.com/f2e2c3b844c4b7a8643622146bdf82e54c8ec8e3.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nint dx[] = {-1, 1, 0, 0}; // U, D, L, R\nint dy[] = {0, 0, -1, 1}; // U, D, L, R\n\nint solve(int n, int m, vector<string>& maze) {\n    // Direction for each cell. 0=U, 1=D, 2=L, 3=R, -1=undecided\n    vector<vector<int>> direction(n, vector<int>(m, -1));\n    \n    // Assign fixed directions\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (maze[i][j] == 'U') direction[i][j] = 0;\n            else if (maze[i][j] == 'D') direction[i][j] = 1;\n            else if (maze[i][j] == 'L') direction[i][j] = 2;\n            else if (maze[i][j] == 'R') direction[i][j] = 3;\n        }\n    }\n    \n    // Find all cells that directly lead outside\n    vector<vector<bool>> leads_outside(n, vector<bool>(m, false));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (direction[i][j] != -1) {\n                int ni = i + dx[direction[i][j]];\n                int nj = j + dy[direction[i][j]];\n                \n                if (ni < 0 || ni >= n || nj < 0 || nj >= m) {\n                    leads_outside[i][j] = true;\n                }\n            }\n        }\n    }\n    \n    // Build a reverse graph for cells with fixed directions\n    vector<vector<vector<pair<int, int>>>> rev_graph(n, vector<vector<pair<int, int>>>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (direction[i][j] != -1) {\n                int ni = i + dx[direction[i][j]];\n                int nj = j + dy[direction[i][j]];\n                \n                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                    rev_graph[ni][nj].push_back({i, j});\n                }\n            }\n        }\n    }\n    \n    // BFS to find all cells that can lead outside\n    queue<pair<int, int>> q;\n    vector<vector<bool>> can_exit(n, vector<bool>(m, false));\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (leads_outside[i][j]) {\n                q.push({i, j});\n                can_exit[i][j] = true;\n            }\n        }\n    }\n    \n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        \n        // Check all cells that point to (x,y)\n        for (auto [px, py] : rev_graph[x][y]) {\n            if (!can_exit[px][py]) {\n                can_exit[px][py] = true;\n                q.push({px, py});\n            }\n        }\n    }\n    \n    // Count cells that can be made to stay inside\n    int trapped = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (direction[i][j] == -1) {\n                // For cells with undecided direction\n                bool can_stay_inside = false;\n                \n                for (int d = 0; d < 4; d++) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    \n                    if (ni >= 0 && ni < n && nj >= 0 && nj < m && !can_exit[ni][nj]) {\n                        can_stay_inside = true;\n                        break;\n                    }\n                }\n                \n                if (can_stay_inside) trapped++;\n            } \n            else if (!can_exit[i][j]) {\n                // For cells with fixed direction\n                trapped++;\n            }\n        }\n    }\n    \n    return trapped;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        vector<string> maze(n);\n        for (int i = 0; i < n; i++) {\n            cin >> maze[i];\n        }\n        \n        cout << solve(n, m, maze) << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2033e",
      "PROBLEM_ID": "2033E",
      "PROBLEM_STATEMENT": "Sakurako's exams are over, and she did excellently. As a reward, she received a permutation $p$. Kosuke was not entirely satisfied because he failed one exam and did not receive a gift. He decided to sneak into her room (thanks to the code for her lock) and spoil the permutation so that it becomes simple.\n\nA permutation $p$ is considered simple if for every $i$ $(1\\le i \\le n)$ one of the following conditions holds:\n\n- $p_i=i$\n- $p_{p_i}=i$\n\nFor example, the permutations $[1, 2, 3, 4]$, $[5, 2, 4, 3, 1]$, and $[2, 1]$ are simple, while $[2, 3, 1]$ and $[5, 2, 1, 4, 3]$ are not.\n\nIn one operation, Kosuke can choose indices $i,j$ $(1\\le i,j\\le n)$ and swap the elements $p_i$ and $p_j$.\n\nSakurako is about to return home. Your task is to calculate the minimum number of operations that Kosuke needs to perform to make the permutation simple.\n\n### Input\n\nThe first line contains one integer $t$ ($1\\le t\\le 10^4$)\u00a0\u2014 the number of test cases.\n\nEach test case is described by two lines.\n\n- The first line contains one integer $n$ ($1\\le n \\le 10^6$)\u00a0\u2014 the length of the permutation $p$.\n- The second line contains $n$ integers $p_i$ ($1\\le p_i\\le n$)\u00a0\u2014 the elements of the permutation $p$.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $10^6$.\n\nIt is guaranteed that $p$ is a permutation.\n\n### Output\n\nFor each test case, output the minimum number of operations that Kosuke needs to perform to make the permutation simple.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n5\n\n1 2 3 4 5\n\n5\n\n5 4 3 2 1\n\n5\n\n2 3 4 5 1\n\n4\n\n2 3 4 1\n\n3\n\n1 3 2\n\n7\n\n2 3 1 5 6 7 4\n\n```\n\n#### Output #1\n\n```\n0\n0\n2\n1\n0\n2\n```\n\n### Note\n\nIn the first and second examples, the permutations are already simple.\n\nIn the fourth example, it is sufficient to swap $p_2$ and $p_4$. Thus, the permutation will become $[2, 1, 4, 3]$ in $1$ operation.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperationsToSimplePermutation(int n, vector<int>& p) {\n    vector<bool> visited(n, false);\n    int operations = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            int cycleLength = 0;\n            int j = i;\n            while (!visited[j]) {\n                visited[j] = true;\n                j = p[j] - 1;\n                cycleLength++;\n            }\n            if (cycleLength > 2) {\n                operations += (cycleLength - 1) / 2;\n            }\n        }\n    }\n\n    return operations;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> p(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> p[i];\n        }\n        cout << minOperationsToSimplePermutation(n, p) << '\\n';\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2033c",
      "PROBLEM_ID": "2033C",
      "PROBLEM_STATEMENT": "Even in university, students need to relax. That is why Sakurakos teacher decided to go on a field trip. It is known that all of the students will be walking in one line. The student with index $i$ has some topic of interest which is described as $a_i$. As a teacher, you want to minimise the disturbance of the line of students.\n\nThe disturbance of the line is defined as the number of neighbouring people with the same topic of interest. In other words, disturbance is the number of indices $j$ ($1 \\le j < n$) such that $a_j = a_{j + 1}$.\n\nIn order to do this, you can choose index $i$ ($1\\le i\\le n$) and swap students at positions $i$ and $n-i+1$. You can perform any number of swaps.\n\nYour task is to determine the minimal amount of disturbance that you can achieve by doing the operation described above any number of times.\n\n### Input\n\nThe first line contains one integer $t$ ($1\\le t\\le 10^4$)\u00a0\u2014 the number of test cases.\n\nEach test case is described by two lines.\n\n- The first line contains one integer $n$ ($2 \\le n \\le 10^5$)\u00a0\u2014 the length of the line of students.\n- The second line contains $n$ integers $a_i$ ($1\\le a_i\\le n$)\u00a0\u2014 the topics of interest of students in line.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output the minimal possible disturbance of the line that you can achieve.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n5\n\n1 1 1 2 3\n\n6\n\n2 1 2 2 1 1\n\n4\n\n1 2 1 1\n\n6\n\n2 1 1 2 2 4\n\n4\n\n2 1 2 3\n\n6\n\n1 2 2 1 2 1\n\n5\n\n4 5 5 1 5\n\n7\n\n1 4 3 5 1 1 3\n\n7\n\n3 1 3 2 2 3 3\n\n```\n\n#### Output #1\n\n```\n1\n2\n1\n0\n0\n1\n1\n0\n2\n```\n\n### Note\n\nIn the first example, it is necessary to apply the operation to $i=2$, thus the array will become $[1, \\textbf{2}, 1, \\textbf{1}, 3]$, with the bold elements indicating those that have swapped places. The disturbance of this array is equal to $1$.\n\nIn the fourth example, it is sufficient to apply the operation to $i=3$, thus the array will become $[2, 1, \\textbf{2}, \\textbf{1}, 2, 4]$. The disturbance of this array is equal to $0$.\n\nIn the eighth example, it is sufficient to apply the operation to $i=3$, thus the array will become $[1, 4, \\textbf{1}, 5, \\textbf{3}, 1, 3]$. The disturbance of this array is equal to $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        \n        // To minimize the disturbance, we can try to arrange the array such that no two adjacent elements are the same.\n        // One way to do this is to alternate the elements as much as possible.\n        // However, since we can only swap elements at positions i and n-i+1, we need to find the best arrangement under this constraint.\n        \n        // We can try to swap elements at positions i and n-i+1 if a[i] == a[i+1] or a[i] == a[i-1].\n        // But a better approach is to count the number of adjacent pairs and see if swapping can reduce it.\n        \n        // Since the problem allows any number of swaps, we can consider the array as a whole and try to minimize the disturbance.\n        // One way is to count the frequency of each element and try to arrange them such that no two same elements are adjacent.\n        \n        // However, given the swap constraint, it's not straightforward. A practical approach is to try all possible swaps and choose the one that minimizes the disturbance.\n        // But with n up to 1e5, this is not feasible.\n        \n        // Instead, we can consider that swapping elements at positions i and n-i+1 can help in breaking sequences of the same element.\n        // For example, if we have a sequence like [1, 1, 1, 2, 3], swapping the second element with the fourth can break the sequence of 1s.\n        \n        // So, for each test case, we can iterate through the array and perform swaps where necessary to minimize the disturbance.\n        \n        // Let's implement this:\n        for (int i = 0; i < n / 2; ++i) {\n            int j = n - i - 1;\n            if (a[i] == a[j]) {\n                // If the elements are the same, swapping them doesn't change the disturbance.\n                continue;\n            }\n            // Check if swapping can reduce the disturbance.\n            // Specifically, check if swapping can break sequences of the same element.\n            if (i > 0 && a[i] == a[i-1]) {\n                swap(a[i], a[j]);\n            } else if (j < n-1 && a[j] == a[j+1]) {\n                swap(a[i], a[j]);\n            }\n        }\n        \n        // Now, count the disturbance.\n        int disturbance = 0;\n        for (int i = 1; i < n; ++i) {\n            if (a[i] == a[i-1]) {\n                disturbance++;\n            }\n        }\n        \n        cout << disturbance << '\\n';\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2033a",
      "PROBLEM_ID": "2033A",
      "PROBLEM_STATEMENT": "Sakurako and Kosuke decided to play some games with a dot on a coordinate line. The dot is currently located in position $x=0$. They will be taking turns, and Sakurako will be the one to start.\n\nOn the $i$-th move, the current player will move the dot in some direction by $2\\cdot i-1$ units. Sakurako will always be moving the dot in the negative direction, whereas Kosuke will always move it in the positive direction.\n\nIn other words, the following will happen:\n\n1. Sakurako will change the position of the dot by $-1$, $x = -1$ now\n2. Kosuke will change the position of the dot by $3$, $x = 2$ now\n3. Sakurako will change the position of the dot by $-5$, $x = -3$ now\n4. $\\cdots$\n\nThey will keep on playing while the absolute value of the coordinate of the dot does not exceed $n$. More formally, the game continues while $-n\\le x\\le n$. It can be proven that the game will always end.\n\nYour task is to determine who will be the one who makes the last turn.\n\n### Input\n\nThe first line contains one integer $t$ ($1\\le t\\le 100$)\u00a0\u2014 the number of games that Sakurako and Kosuke played.\n\nEach game is described by one number $n$ ($1 \\le n\\le 100$)\u00a0\u2014 the number that defines the condition when the game ends.\n\n### Output\n\nFor each of the $t$ games, output a line with the result of that game. If Sakurako makes the last turn, output \"Sakurako\" (without quotes); else output \"Kosuke\".\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n6\n\n3\n\n98\n\n```\n\n#### Output #1\n\n```\nKosuke\nSakurako\nKosuke\nSakurako\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nstring solve(int n) {\n    long long pos = 0;  // Current position of dot\n    int move = 1;       // Current move size\n    bool sakurako = true;  // true if it's Sakurako's turn\n    \n    while (true) {\n        // If it's Sakurako's turn, move left (negative)\n        if (sakurako) {\n            pos -= move;\n        }\n        // If it's Kosuke's turn, move right (positive)\n        else {\n            pos += move;\n        }\n        \n        // Check if dot is outside the valid range\n        if (pos < -n || pos > n) {\n            return sakurako ? \"Sakurako\" : \"Kosuke\";\n        }\n        \n        sakurako = !sakurako;  // Switch turns\n        move += 2;  // Increment move size by 2\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        cout << solve(n) << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2032c",
      "PROBLEM_ID": "2032C",
      "PROBLEM_STATEMENT": "You are given an array $a$ of $n$ elements $a_1, a_2, \\ldots, a_n$.\n\nYou can perform the following operation any number (possibly $0$) of times:\n\n- Choose two integers $i$ and $j$, where $1 \\le i, j \\le n$, and assign $a_i := a_j$.\n\nFind the minimum number of operations required to make the array $a$ satisfy the condition:\n\n- For every pairwise distinct triplet of indices $(x, y, z)$ ($1 \\le x, y, z \\le n$, $x \\ne y$, $y \\ne z$, $x \\ne z$), there exists a non-degenerate triangle with side lengths $a_x$, $a_y$ and $a_z$, i.e. $a_x + a_y > a_z$, $a_y + a_z > a_x$ and $a_z + a_x > a_y$.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of elements in the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations required.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n7\n\n1 2 3 4 5 6 7\n\n3\n\n1 3 2\n\n3\n\n4 5 3\n\n15\n\n9 3 8 1 6 5 3 8 2 1 4 2 9 4 7\n\n```\n\n#### Output #1\n\n```\n3\n1\n0\n8\n```\n\n### Note\n\nIn the first test case, one of the possible series of operations would be:\n\n- Assign $a_1 := a_4 = 4$. The array will become $[4, 2, 3, 4, 5, 6, 7]$.\n- Assign $a_2 := a_5 = 5$. The array will become $[4, 5, 3, 4, 5, 6, 7]$.\n- Assign $a_7 := a_1 = 4$. The array will become $[4, 5, 3, 4, 5, 6, 4]$.\n\nIt can be proven that any triplet of elements with pairwise distinct indices in the final array forms a non-degenerate triangle, and there is no possible answer using less than $3$ operations.\n\nIn the second test case, we can assign $a_1 := a_2 = 3$ to make the array $a = [3, 3, 2]$.\n\nIn the third test case, since $3$, $4$ and $5$ are valid side lengths of a triangle, we don't need to perform any operation to the array.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<ll> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        sort(a.begin(), a.end());\n\n        // We look for the longest contiguous subarray a[l..r] (r >= l+1)\n        // such that a[l] + a[l+1] > a[r].  Call its length `best`.\n        // Then we can keep those `best` elements and change the other\n        // n - best elements, which is minimal.\n        int best = 1;\n        int r = 1;\n        for (int l = 0; l + 1 < n; l++) {\n            // ensure window at least size 2\n            r = max(r, l + 1);\n            ll sum = a[l] + a[l+1];\n            // try to extend r as far as the triangle condition holds\n            while (r + 1 < n && sum > a[r+1]) {\n                r++;\n            }\n            best = max(best, r - l + 1);\n        }\n\n        // minimal operations = remove (n - best) elements\n        cout << (n - best) << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2032b",
      "PROBLEM_ID": "2032B",
      "PROBLEM_STATEMENT": "You are given an array $a = [1, 2, \\ldots, n]$, where $n$ is odd, and an integer $k$.\n\nYour task is to choose an odd positive integer $m$ and to split $a$ into $m$ subarrays$^{\\dagger}$ $b_1, b_2, \\ldots, b_m$ such that:\n\n- Each element of the array $a$ belongs to exactly one subarray.\n- For all $1 \\le i \\le m$, $|b_i|$ is odd, i.e., the length of each subarray is odd.\n- $\\operatorname{median}([\\operatorname{median}(b_1), \\operatorname{median}(b_2), \\ldots, \\operatorname{median}(b_m)]) = k$, i.e., the median$^{\\ddagger}$ of the array of medians of all subarrays must equal $k$. $\\operatorname{median}(c)$ denotes the median of the array $c$.\n\n$^{\\dagger}$A subarray of the array $a$ of length $n$ is the array $[a_l, a_{l + 1}, \\ldots, a_r]$ for some integers $1 \\le l \\le r \\le n$.\n\n$^{\\ddagger}$A median of the array of odd length is the middle element after the array is sorted in non-decreasing order. For example: $\\operatorname{median}([1,2,5,4,3]) = 3$, $\\operatorname{median}([3,2,1]) = 2$, $\\operatorname{median}([2,1,2,1,2,2,2]) = 2$.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 5000$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k \\le n < 2 \\cdot 10^5$, $n$ is odd)\u00a0\u2014 the length of array $a$ and the desired median of the array of medians of all subarrays.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case:\n\n- If there is no suitable partition, output $-1$ in a single line.\n- Otherwise, in the first line, output an odd integer $m$ ($1 \\le m \\le n$), and in the second line, output $m$ distinct integers $p_1, p_2 , p_3 , \\ldots, p_m$ ($1 = p_1 < p_2 < p_3 < \\ldots < p_m \\le n$)\u00a0\u2014 denoting the left borders of each subarray.\n\nIn detail, for a valid answer $[p_1, p_2, \\ldots, p_m]$:\n\n- $b_1 = \\left[ a_{p_1}, a_{p_1 + 1}, \\ldots, a_{p_2 - 1} \\right]$\n- $b_2 = \\left[ a_{p_2}, a_{p_2 + 1}, \\ldots, a_{p_3 - 1} \\right]$\n- $\\ldots$\n- $b_m = \\left[ a_{p_m}, a_{p_m + 1}, \\ldots, a_n \\right]$.\n\nIf there are multiple solutions, you can output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1 1\n\n3 2\n\n3 3\n\n15 8\n\n```\n\n#### Output #1\n\n```\n1\n1\n3\n1 2 3\n-1\n5\n1 4 7 10 13\n```\n\n### Note\n\nIn the first test case, the given partition has $m = 1$ and $b_1 = [1]$. It is obvious that $\\operatorname{median}([\\operatorname{median}([1])]) = \\operatorname{median}([1]) = 1$.\n\nIn the second test case, the given partition has $m = 3$ and:\n\n- $b_1 = [1]$\n- $b_2 = [2]$\n- $b_3 = [3]$\n\nTherefore, $\\operatorname{median}([\\operatorname{median}([1]), \\operatorname{median}([2]), \\operatorname{median}([3])]) = \\operatorname{median}([1, 2, 3]) = 2$.\n\nIn the third test case, there is no valid partition for $k = 3$.\n\nIn the fourth test case, the given partition has $m = 5$ and:\n\n- $b_1 = [1, 2, 3]$\n- $b_2 = [4, 5, 6]$\n- $b_3 = [7, 8, 9]$\n- $b_4 = [10, 11, 12]$\n- $b_5 = [13, 14, 15]$\n\nTherefore, $\\operatorname{median}([\\operatorname{median}([1, 2, 3]), \\operatorname{median}([4, 5, 6]), \\operatorname{median}([7, 8, 9]), \\operatorname{median}([10, 11, 12]), \\operatorname{median}([13, 14, 15])]) = \\operatorname{median}([2, 5, 8, 11, 14]) = 8$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid solve() {\n    int t;\n    cin >> t;\n    for (int _ = 0; _ < t; ++_) {\n        int n, k;\n        cin >> n >> k;\n        int med = (n + 1) / 2;\n        if (med == k) {\n            cout << 1 << endl;\n            cout << 1 << endl;\n        } else {\n            int t_val = min(k - 1, n - k);\n            if (t_val == 0) {\n                cout << -1 << endl;\n            } else {\n                int m = 2 * t_val + 1;\n                vector<int> p;\n                for (int i = 1; i <= t_val; ++i) {\n                    p.push_back(i);\n                }\n                p.push_back(k);\n                for (int i = k + 1; i <= k + t_val; ++i) {\n                    p.push_back(i);\n                }\n                cout << m << endl;\n                for (int num : p) {\n                    cout << num << \" \";\n                }\n                cout << endl;\n            }\n        }\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2032a",
      "PROBLEM_ID": "2032A",
      "PROBLEM_STATEMENT": "Alice has just crafted a circuit with $n$ lights and $2n$ switches. Each component (a light or a switch) has two states: on or off. The lights and switches are arranged in a way that:\n\n- Each light is connected to exactly two switches.\n- Each switch is connected to exactly one light. It's unknown which light each switch is connected to.\n- When all switches are off, all lights are also off.\n- If a switch is toggled (from on to off, or vice versa), the state of the light connected to it will also toggle.\n\nAlice brings the circuit, which shows only the states of the $2n$ switches, to her sister Iris and gives her a riddle: what is the minimum and maximum number of lights that can be turned on?\n\nKnowing her little sister's antics too well, Iris takes no more than a second to give Alice a correct answer. Can you do the same?\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 500$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 50$)\u00a0\u2014 the number of lights in the circuit.\n\nThe second line of each test case contains $2n$ integers $a_1, a_2, \\ldots, a_{2n}$ ($0 \\le a_i \\le 1$)\u00a0\u2014 the states of the switches in the circuit. $a_i = 0$ means the $i$-th switch is off, and $a_i = 1$ means the $i$-th switch is on.\n\n### Output\n\nFor each test case, output two integers\u00a0\u2014 the minimum and maximum number of lights, respectively, that can be turned on.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n0 0\n\n1\n\n0 1\n\n1\n\n1 1\n\n3\n\n0 0 1 0 1 0\n\n3\n\n0 1 1 1 0 0\n\n```\n\n#### Output #1\n\n```\n0 0\n1 1\n0 0\n0 2\n1 3\n```\n\n### Note\n\nIn the first test case, there is only one light in the circuit, and no switch is on, so the light is certainly off.\n\nIn the second test case, there is only one light in the circuit, but one switch connected to it is on, so the light is on.\n\nIn the third test case, there is only one light in the circuit, and both switches are on, so the light is off as it was toggled twice.\n\nIn the fourth test case, to have no lights on, the switches can be arranged in this way:\n\n- Switch $1$ and switch $4$ are connected to light $1$. Since both switches are off, light $1$ is also off.\n- Switch $2$ and switch $6$ are connected to light $2$. Since both switches are off, light $2$ is also off.\n- Switch $3$ and switch $5$ are connected to light $3$. Both switches are on, so light $3$ is toggled twice from its initial off state, and thus also stays off.\n\nAnd to have $2$ lights on, the switches can be arranged in this way:\n\n- Switch $1$ and switch $2$ are connected to light $1$. Since both switches are off, light $1$ is also off.\n- Switch $3$ and switch $4$ are connected to light $2$. Since switch $3$ is on and switch $4$ is off, light $2$ is toggled once from its initial off state, so it is on.\n- Switch $5$ and switch $6$ are connected to light $3$. Since switch $5$ is on and switch $6$ is off, light $3$ is toggled once from its initial off state, so it is on.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(2 * n);\n        int count_0 = 0;\n        int count_1 = 0;\n        for (int i = 0; i < 2 * n; ++i) {\n            cin >> a[i];\n            if (a[i] == 0) {\n                count_0++;\n            } else {\n                count_1++;\n            }\n        }\n        int min_lights = count_0 % 2;\n        int max_lights = min(count_0, count_1);\n        cout << min_lights << \" \" << max_lights << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2031c",
      "PROBLEM_ID": "2031C",
      "PROBLEM_STATEMENT": "Penchick loves two things: square numbers and Hong Kong-style BBQ buns! For his birthday, Kohane wants to combine them with a gift: $n$ BBQ buns arranged from left to right. There are $10^6$ available fillings of BBQ buns, numbered from $1$ to $10^6$. To ensure that Penchick would love this gift, Kohane has a few goals:\n\n- No filling is used exactly once; that is, each filling must either not appear at all or appear at least twice.\n- For any two buns $i$ and $j$ that have the same filling, the distance between them, which is $|i-j|$, must be a perfect square$^{\\text{\u2217}}$.\n\nHelp Kohane find a valid way to choose the filling of the buns, or determine if it is impossible to satisfy her goals! If there are multiple solutions, print any of them.\n\n$^{\\text{\u2217}}$A positive integer $x$ is a perfect square if there exists a positive integer $y$ such that $x = y^2$. For example, $49$ and $1$ are perfect squares because $49 = 7^2$ and $1 = 1^2$ respectively. On the other hand, $5$ is not a perfect square as no integer squared equals $5$\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2\\cdot 10^5$). The description of the test cases follows.\n\nThe only line of each test case contains a single integer $n$ ($1\\le n\\le 2\\cdot 10^5$)\u00a0\u2014 the number of BBQ buns.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, if no valid choice of fillings exists, output $-1$. Otherwise, output $n$ integers, where the $i$-th integer represents the filling of the $i$-th BBQ bun. If there are multiple solutions, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n3\n\n12\n\n```\n\n#### Output #1\n\n```\n-1\n1 2 3 6 10 2 7 6 10 1 7 3\n```\n\n### Note\n\nIn the first test case, the choice of fillings \"1 1 1\" is not allowed because buns $1$ and $3$ have the same filling, but are distance $2$ apart, which is not a perfect square. The choice of fillings \"1 1 2\" is also not allowed as filling $2$ is only used once.\n\nIn the second test case, the solution is valid because no filling is used exactly once, and any two buns with the same filling are spaced at a distance equal to a perfect square. For example, buns $1$ and $10$ both have filling $1$ and are spaced at a distance of $9=3^2$. Similarly, buns $5$ and $9$ both have filling $10$ and are spaced at a distance of $4=2^2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n%2==1&&n<=26)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(n%2==0) for(int i=1;i<=n;i++)\n\t\t\tcout<<(i+1)/2<<\" \";\n\t\telse\n\t\t{\n\t\t\tcout<<\"1 2 2 3 3 4 4 5 5 6 6 7 7 8 9 9 1 8 10 10 11 11 12 13 13 1 12 \";\n\t\t\tfor(int i=28;i<=n;i++)\n\t\t\t\tcout<<(i)/2<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2031a",
      "PROBLEM_ID": "2031A",
      "PROBLEM_STATEMENT": "Amidst skyscrapers in the bustling metropolis of Metro Manila, the newest Noiph mall in the Philippines has just been completed! The construction manager, Penchick, ordered a state-of-the-art monument to be built with $n$ pillars.\n\nThe heights of the monument's pillars can be represented as an array $h$ of $n$ positive integers, where $h_i$ represents the height of the $i$-th pillar for all $i$ between $1$ and $n$.\n\nPenchick wants the heights of the pillars to be in non-decreasing order, i.e. $h_i \\le h_{i + 1}$ for all $i$ between $1$ and $n - 1$. However, due to confusion, the monument was built such that the heights of the pillars are in non-increasing order instead, i.e. $h_i \\ge h_{i + 1}$ for all $i$ between $1$ and $n - 1$.\n\nLuckily, Penchick can modify the monument and do the following operation on the pillars as many times as necessary:\n\n- Modify the height of a pillar to any positive integer. Formally, choose an index $1\\le i\\le n$ and a positive integer $x$. Then, assign $h_i := x$.\n\nHelp Penchick determine the minimum number of operations needed to make the heights of the monument's pillars non-decreasing.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 50$)\u00a0\u2014 the number of pillars.\n\nThe second line of each test case contains $n$ integers $h_1, h_2, \\ldots, h_n$ ($1 \\le h_i \\le n$ and $h_i\\ge h_{i+1}$)\u00a0\u2014 the height of the pillars.\n\nPlease take note that the given array $h$ is non-increasing.\n\nNote that there are no constraints on the sum of $n$ over all test cases.\n\n### Output\n\nFor each test case, output a single integer representing the minimum number of operations needed to make the heights of the pillars non-decreasing.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5\n\n5 4 3 2 1\n\n3\n\n2 2 1\n\n1\n\n1\n\n```\n\n#### Output #1\n\n```\n4\n1\n0\n```\n\n### Note\n\nIn the first test case, the initial heights of pillars are $h = [5, 4, 3, 2, 1]$.\n\n- In the first operation, Penchick changes the height of pillar $1$ to $h_1 := 2$.\n- In the second operation, he changes the height of pillar $2$ to $h_2 := 2$.\n- In the third operation, he changes the height of pillar $4$ to $h_4 := 4$.\n- In the fourth operation, he changes the height of pillar $5$ to $h_5 := 4$.\n\nAfter the operation, the heights of the pillars are $h = [2, 2, 3, 4, 4]$, which is non-decreasing. It can be proven that it is not possible for Penchick to make the heights of the pillars non-decreasing in fewer than $4$ operations.\n\nIn the second test case, Penchick can make the heights of the pillars non-decreasing by modifying the height of pillar $3$ to $h_3 := 2$.\n\nIn the third test case, the heights of pillars are already non-decreasing, so no operations are required.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(vector<int>& h) {\n    int n = h.size();\n    if (n <= 1) return 0;\n    \n    // dp[i][j] represents minimum operations needed to make first i elements\n    // non-decreasing with i-th element having value j\n    vector<vector<int>> dp(n, vector<int>(51, n));\n    \n    // Initialize first element\n    for (int j = 1; j <= 50; j++) {\n        dp[0][j] = (h[0] != j);\n    }\n    \n    // For each position\n    for (int i = 1; i < n; i++) {\n        // Try each possible value for current position\n        for (int j = 1; j <= 50; j++) {\n            // Try each possible value for previous position\n            for (int prev = 1; prev <= j; prev++) {\n                dp[i][j] = min(dp[i][j], \n                             dp[i-1][prev] + (h[i] != j));\n            }\n        }\n    }\n    \n    // Find minimum operations needed\n    int ans = n;\n    for (int j = 1; j <= 50; j++) {\n        ans = min(ans, dp[n-1][j]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> h(n);\n        for (int i = 0; i < n; i++) {\n            cin >> h[i];\n        }\n        cout << solve(h) << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2030g2",
      "PROBLEM_ID": "2030G2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. In this version, $n \\leq 10^6$. You can only make hacks if both versions of the problem are solved.\n\nOrangutans are powerful beings\u2014so powerful that they only need $1$ unit of time to destroy every vulnerable planet in the universe!\n\nThere are $n$ planets in the universe. Each planet has an interval of vulnerability $[l, r]$, during which it will be exposed to destruction by orangutans. Orangutans can also expand the interval of vulnerability of any planet by $1$ unit.\n\nSpecifically, suppose the expansion is performed on planet $p$ with interval of vulnerability $[l_p, r_p]$. Then, the resulting interval of vulnerability may be either $[l_p - 1, r_p]$ or $[l_p, r_p + 1]$.\n\nGiven a set of planets, orangutans can destroy all planets if the intervals of vulnerability of all planets in the set intersect at least one common point. Let the score of such a set denote the minimum number of expansions that must be performed.\n\nOrangutans are interested in the sum of scores of all non-empty subsets of the planets in the universe. As the answer can be large, output it modulo $998\\,244\\,353$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 10^6$)\u00a0\u2014 the number of planets in the universe.\n\nThe following $n$ lines contain two integers $l_i$ and $r_i$ ($1 \\leq l_i \\leq r_i \\leq n$)\u00a0\u2014 the initial interval of vulnerability of the $i$-th planet.\n\nIt is guaranteed that the sum of $n$ does not exceed $10^6$ over all test cases.\n\n### Output\n\nFor each test case, output an integer\u00a0\u2014 the sum of scores to destroy all non-empty subsets of the planets in the universe, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n1 1\n\n2 3\n\n3 3\n\n4\n\n1 4\n\n2 3\n\n2 4\n\n1 1\n\n5\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n1 5\n\n```\n\n#### Output #1\n\n```\n5\n6\n24\n```\n\n### Note\n\nIn the first testcase, there are seven non-empty subsets of planets we must consider:\n\n- For each of the subsets $\\{[1,1]\\}, \\{[2,3]\\}, \\{[3,3]\\}$, the score is $0$.\n- For the subset $\\{[2,3], [3,3]\\}$, the score is $0$, because the point $3$ is already contained in both planets' interval of vulnerability.\n- For the subset $\\{[1,1], [2,3]\\}$, the score is $1$. By using one operation on changing the interval of vulnerability of the second planet to be $[1,3]$, the two planets now both have the point $1$ in their interval.\n- For the subset $\\{[1,1], [3,3]\\}$, the score is $2$. By using two operations on changing the interval of vulnerability of the first planet to be $[1,3]$, the two planets now both have the point $3$ in their interval.\n- For the subset $\\{[1,1], [2,3], [3,3]\\}$, the score is $2$. By using one operation on changing the interval of vulnerability of the first planet to be $[1,2]$ and one operation on changing the interval of vulnerability of the third planet to $[2,3]$, all three planets will have the point $2$ in their interval.\n\nThe sum of scores of all non-empty subsets of the first testcase is $0 \\cdot 4 + 1 \\cdot 1 + 2\\cdot2 = 5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> pr;\ninline LL rd(){\n\tLL x=0,y=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')y=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*y;\n}\nconst LL p=998244353,N=2000005;\nLL qp(LL x,LL y){LL z=1;for(;y;y>>=1,x=x*x%p)if(y&1)z=z*x%p;return z;}\nLL n,m,T,fc[N],s,iv[N],ifc[N],pw[N],sm[N],a[N],b[N];\nLL C(LL x,LL y){if(x<y||x<0||y<0)return 0;return fc[x]*ifc[y]%p*ifc[x-y]%p;}\nint main(){\n\tfc[0]=fc[1]=iv[0]=iv[1]=ifc[0]=ifc[1]=pw[0]=1;pw[1]=2;\n    for(LL i=2;i<=2000000;++i)fc[i]=fc[i-1]*i%p,iv[i]=iv[p%i]*(p-p/i)%p,ifc[i]=ifc[i-1]*iv[i]%p,pw[i]=pw[i-1]*2%p;\n\tfor(T=rd();T--;){\n        n=rd();m=s=0;\n        for(LL i=1;i<=2*n;++i)++sm[a[i]=rd()];\n        for(LL i=1;i<=2*n;++i)sm[i]+=sm[i-1];\n        for(LL i=2*n;i;--i)sm[i]=sm[i-1]+1;\n        for(LL i=1;i<=2*n;++i)b[sm[a[i]]++]=i;\n        for(LL i=1,u=0,o=0,v=n;i<=2*n;++i)\n        if(b[i]&1){\n            --v;s=(s+C(u+v,u-1))*iv[2]%p;m=(m+s*pw[o++]%p*(a[b[i]]-1))%p;\n        }else{\n            m=(m-(pw[u+v]-s-C(u+v,u))*pw[--o]%p*(a[b[i]]-1)%p+p)%p;\n            s=(s*2+C(u+v,u))%p;++u;\n        }\n        printf(\"%lld\\n\",m);\n        for(LL i=1;i<=2*n;++i)sm[i]=0;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2030g1",
      "PROBLEM_ID": "2030G1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. In this version, $n \\leq 5000$. You can only make hacks if both versions of the problem are solved.\n\nOrangutans are powerful beings\u2014so powerful that they only need $1$ unit of time to destroy every vulnerable planet in the universe!\n\nThere are $n$ planets in the universe. Each planet has an interval of vulnerability $[l, r]$, during which it will be exposed to destruction by orangutans. Orangutans can also expand the interval of vulnerability of any planet by $1$ unit.\n\nSpecifically, suppose the expansion is performed on planet $p$ with interval of vulnerability $[l_p, r_p]$. Then, the resulting interval of vulnerability may be either $[l_p - 1, r_p]$ or $[l_p, r_p + 1]$.\n\nGiven a set of planets, orangutans can destroy all planets if the intervals of vulnerability of all planets in the set intersect at least one common point. Let the score of such a set denote the minimum number of expansions that must be performed.\n\nOrangutans are interested in the sum of scores of all non-empty subsets of the planets in the universe. As the answer can be large, output it modulo $998\\,244\\,353$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 5000$)\u00a0\u2014 the number of planets in the universe.\n\nThe following $n$ lines contain two integers $l_i$ and $r_i$ ($1 \\leq l_i \\leq r_i \\leq n$)\u00a0\u2014 the initial interval of vulnerability of the $i$-th planet.\n\nIt is guaranteed that the sum of $n$ does not exceed $5000$ over all test cases.\n\n### Output\n\nFor each test case, output an integer\u00a0\u2014 the sum of scores to destroy all non-empty subsets of the planets in the universe, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n1 1\n\n2 3\n\n3 3\n\n4\n\n1 4\n\n2 3\n\n2 4\n\n1 1\n\n5\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n1 5\n\n```\n\n#### Output #1\n\n```\n5\n6\n24\n```\n\n### Note\n\nIn the first testcase, there are seven non-empty subsets of planets we must consider:\n\n- For each of the subsets $\\{[1,1]\\}, \\{[2,3]\\}, \\{[3,3]\\}$, the score is $0$.\n- For the subset $\\{[2,3], [3,3]\\}$, the score is $0$, because the point $3$ is already contained in both planets' interval of vulnerability.\n- For the subset $\\{[1,1], [2,3]\\}$, the score is $1$. By using one operation on changing the interval of vulnerability of the second planet to be $[1,3]$, the two planets now both have the point $1$ in their interval.\n- For the subset $\\{[1,1], [3,3]\\}$, the score is $2$. By using two operations on changing the interval of vulnerability of the first planet to be $[1,3]$, the two planets now both have the point $3$ in their interval.\n- For the subset $\\{[1,1], [2,3], [3,3]\\}$, the score is $2$. By using one operation on changing the interval of vulnerability of the first planet to be $[1,2]$ and one operation on changing the interval of vulnerability of the third planet to $[2,3]$, all three planets will have the point $2$ in their interval.\n\nThe sum of scores of all non-empty subsets of the first testcase is $0 \\cdot 4 + 1 \\cdot 1 + 2\\cdot2 = 5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define M 998244353\n#define N 1000000\n \nint i,j,k,n,m,t,d,l[N+50],r[N+50];\nll jc[N+50],inv[N+50],res;\n \nll su(ll a,ll b){a+=b;return (a>=M)?a-M:a;}\nll ksm(ll a,ll p){ll res=1;while(p){if(p&1){res=res*a%M;}a=a*a%M;p>>=1;}return res;}\nll c(ll n,ll m){if(n<m||n<0||m<0){return 0;}return jc[n]*inv[m]%M*inv[n-m]%M;}\n \nint main(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\tjc[0]=inv[0]=1;\n\tfor(i=1;i<=N;i++)jc[i]=jc[i-1]*i%M;\n\tinv[N]=ksm(jc[N],M-2);\n\tfor(i=N-1;i>=1;i--)inv[i]=inv[i+1]*(i+1)%M;\n\t\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n; res=0;\n\t\tfor(i=1;i<=n;i++)cin>>l[i]>>r[i];\n\t\tsort(l+1,l+n+1); sort(r+1,r+n+1); reverse(l+1,l+n+1);\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tif(r[i]>=l[j])break;\n\t\t\t\t\n\t\t\t\tres+=c(i+j-2,i-1)*(l[j]-r[i])%M*ksm(2,n-i-j)%M; res%=M;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<'\\n';\n\t}\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2030f",
      "PROBLEM_ID": "2030F",
      "PROBLEM_STATEMENT": "Suppose you have an array $b$. Initially, you also have a set $S$ that contains all distinct elements of $b$. The array $b$ is called orangutan-approved if it can be emptied by repeatedly performing the following operation:\n\n- In one operation, select indices $l$ and $r$ ($1 \\leq l \\leq r \\leq |b|$) such that $v = b_l = b_{l+1} = \\ldots = b_r$ and $v$ is present in $S$. Remove $v$ from $S$, and simultaneously remove all $b_i$ such that $l \\leq i \\leq r$. Then, reindex the elements $b_{r+1}, b_{r+2}, \\ldots$ as $b_l, b_{l+1}, \\ldots$ accordingly.\n\nYou are given an array $a$ of length $n$ and $q$ queries.\n\nEach query consists of two indices $l$ and $r$ ($1 \\le l \\le r \\le n$), and you need to determine whether or not the subarray $a_{l}, a_{l+1}, \\ldots, a_r$ is orangutan-approved.\n\n### Input\n\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains integers $n$ and $q$ ($1 \\leq n,q \\leq 2 \\cdot 10^5$)\u00a0\u2014 the size of $a$ and the number of queries, respectively.\n\nThe following line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq n$)\u00a0\u2014 the elements of the array $a$.\n\nThe following $q$ lines contain two integers $l$ and $r$\u00a0\u2014 the endpoints of the subarray for each query ($1 \\leq l \\leq r \\leq n$).\n\nIt is guaranteed that the sum of $n$ and $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each query, output \"YES\" (without quotes) if the subarray from $l$ to $r$ is orangutan-approved, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4 2\n\n1 2 2 1\n\n1 4\n\n1 3\n\n5 3\n\n1 2 1 2 1\n\n2 5\n\n3 5\n\n1 3\n\n8 4\n\n1 2 3 2 1 3 2 3\n\n1 5\n\n2 8\n\n3 5\n\n6 8\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\n```\n\n### Note\n\nIn the first query of the first testcase, the answer is YES.\n\n- Initially, $S=\\{1,2\\}$ and $b=[1,2,2,1]$\n- Select $l=2$ and $r=3$. Since $b_2=b_3=2$ is in $S$, we may erase $b_2$ and $b_3$ from the array, as well as erasing $2$ from $S$. The set $S$ becomes $\\{1\\}$ and the array becomes $[1,1]$.\n- Select $l=1$ and $r=2$. Since $b_1=b_2=1$ is in $S$, we may erase $b_1$ and $b_2$ from the array, as well as erasing $1$ from $S$. The set $S$ becomes $\\{\\}$ and the array becomes $[]$.\n- Since the array is now empty, we can say the original array is orangutan-approved.\n\nIn the first query of the second testcase, the answer is NO, because it can be shown that the subarray $[2,1,2,1]$ cannot become empty through any sequence of valid operations.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000007;\n\n// Segment tree for range minimum, point update\nstruct SegTree {\n    int n;\n    vector<int> st;\n    SegTree(int _n = 0) {\n        init(_n);\n    }\n    void init(int _n) {\n        n = _n;\n        st.assign(4 * (n + 1), INF);\n    }\n    // point update: set position pos to val\n    void update(int node, int l, int r, int pos, int val) {\n        if (l == r) {\n            st[node] = val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(node << 1, l, mid, pos, val);\n        else           update(node << 1 | 1, mid + 1, r, pos, val);\n        st[node] = min(st[node << 1], st[node << 1 | 1]);\n    }\n    void update(int pos, int val) {\n        update(1, 1, n, pos, val);\n    }\n    // range min query on [ql..qr]\n    int query(int node, int l, int r, int ql, int qr) const {\n        if (ql > r || qr < l) return INF;\n        if (ql <= l && r <= qr) return st[node];\n        int mid = (l + r) >> 1;\n        int res = INF;\n        if (ql <= mid) res = min(res, query(node << 1, l, mid, ql, qr));\n        if (qr > mid)  res = min(res, query(node << 1 | 1, mid + 1, r, ql, qr));\n        return res;\n    }\n    int query(int ql, int qr) const {\n        if (ql > qr) return INF;\n        return query(1, 1, n, ql, qr);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, q;\n        cin >> n >> q;\n        vector<int> a(n + 1);\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        // Build the run-compressed array A' and mapping rid\n        vector<int> rid(n + 1);\n        vector<int> A;\n        A.reserve(n + 1);\n        A.push_back(-1); // dummy for 1-based\n        int m = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i == 1 || a[i] != a[i - 1]) {\n                // start new run\n                A.push_back(a[i]);\n                m++;\n            }\n            rid[i] = m;\n        }\n        // A[1..m] is the compressed runs\n\n        // Compute next occurrence in A'\n        vector<int> next_pos(m + 2, m + 1);\n        vector<int> last_val(n + 1, 0);\n        for (int i = m; i >= 1; i--) {\n            int v = A[i];\n            if (last_val[v] != 0) {\n                next_pos[i] = last_val[v];\n            } else {\n                next_pos[i] = m + 1; // INF\n            }\n            last_val[v] = i;\n        }\n\n        // Build list of positions with a real next occurrence (next_pos <= m)\n        vector<int> idx;\n        idx.reserve(m);\n        for (int i = 1; i <= m; i++) {\n            if (next_pos[i] <= m) {\n                idx.push_back(i);\n            }\n        }\n        // Sort by next_pos descending\n        sort(idx.begin(), idx.end(), [&](int i, int j) {\n            return next_pos[i] > next_pos[j];\n        });\n\n        // Segment tree to compute thresholds\n        SegTree st1(m);\n        vector<int> thresh(m + 2, m + 1); // threshold INF = m+1\n        int e_ptr = 0;\n        int Lidx = (int)idx.size();\n        for (int p = 0; p < Lidx; p++) {\n            int i = idx[p];\n            int k = next_pos[i];\n            // Insert all events j with next_pos[j] > k\n            while (e_ptr < Lidx && next_pos[idx[e_ptr]] > k) {\n                int j = idx[e_ptr];\n                // at position j, store next_pos[j]\n                st1.update(j, next_pos[j]);\n                e_ptr++;\n            }\n            // Query minimal next[j] among j in (i..k)\n            if (i + 1 <= k - 1) {\n                int qmin = st1.query(i + 1, k - 1);\n                thresh[i] = qmin;\n            } else {\n                thresh[i] = m + 1;\n            }\n        }\n        // For positions with no next, thresh stays m+1\n\n        // Build segment tree for thresholds\n        SegTree st2(m);\n        for (int i = 1; i <= m; i++) {\n            st2.update(i, thresh[i]);\n        }\n\n        // Answer queries\n        while (q--) {\n            int l, r;\n            cin >> l >> r;\n            int L = rid[l], R = rid[r];\n            if (L >= R) {\n                // Single run or empty, always YES\n                cout << \"YES\\n\";\n            } else {\n                // Check if any threshold in [L..R-1] <= R\n                int mn = st2.query(L, R - 1);\n                if (mn <= R) {\n                    cout << \"NO\\n\";\n                } else {\n                    cout << \"YES\\n\";\n                }\n            }\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2030e",
      "PROBLEM_ID": "2030E",
      "PROBLEM_STATEMENT": "Suppose we partition the elements of an array $b$ into any number $k$ of non-empty multisets $S_1, S_2, \\ldots, S_k$, where $k$ is an arbitrary positive integer. Define the score of $b$ as the maximum value of $\\\\operatorname{MEX}(S\\_1)\n\n$$^{\\text{\u2217}}$$\n\noperatorname{MEX}(S\\_2) + \\\\ldots + \\\\operatorname{MEX}(S\\_k)$ over all possible partitions of $b$ for any integer $k$.\n\nEnvy is given an array $a$ of size $n$. Since he knows that calculating the score of $a$ is too easy for you, he instead asks you to calculate the sum of scores of all $2^n - 1$ non-empty subsequences of $a$.$^{\\text{\u2020}}$ Since this answer may be large, please output it modulo $998\\,244\\,353$.\n\n$^{\\\\text{\u2217}}$$\\\\operatorname{MEX}$ of a collection of integers $c\\_1, c\\_2, \\\\ldots, c\\_k$ is defined as the smallest non-negative integer $x$ that does not occur in the collection $c$. For example, $\\\\operatorname{MEX}(\\[0,1,2,2\\]) = 3$ and $\\\\operatorname{MEX}(\\[1,2,2\\]) = 0$\n\n$^{\\text{\u2020}}$A sequence $x$ is a subsequence of a sequence $y$ if $x$ can be obtained from $y$ by deleting several (possibly, zero or all) elements.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the length of $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i < n$)\u00a0\u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the answer, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\n0 0 1\n\n4\n\n0 0 1 1\n\n5\n\n0 0 1 2 2\n\n4\n\n1 1 1 1\n\n```\n\n#### Output #1\n\n```\n11\n26\n53\n0\n```\n\n### Note\n\nIn the first testcase, we must consider seven subsequences:\n\n- $[0]$: The score is $1$.\n- $[0]$: The score is $1$.\n- $[1]$: The score is $0$.\n- $[0,0]$: The score is $2$.\n- $[0,1]$: The score is $2$.\n- $[0,1]$: The score is $2$.\n- $[0,0,1]$: The score is $3$.\n\nThe answer for the first testcase is $1+1+2+2+2+3=11$.\n\nIn the last testcase, all subsequences have a score of $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <vector> \n#include <algorithm> \n#include <map> // Not used in final version, kept for history\n\n// Define MOD constant for modulo operations\nconst long long MOD = 998244353;\n\n// Modular exponentiation: computes (base^exp) % MOD\nlong long power(long long base, long long exp) {\n    long long res = 1;\n    base %= MOD;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return res;\n}\n\n// Modular inverse using Fermat's Little Theorem: computes (n^(MOD-2)) % MOD\n// Assumes MOD is prime and n is not a multiple of MOD.\nlong long modInverse(long long n) {\n    return power(n, MOD - 2);\n}\n\n// Define maximum possible N based on problem constraints\nconst int MAXN_GLOBAL = 200005; \n// Arrays for precomputed factorials, inverse factorials, powers of 2, and their inverses\nlong long fact[MAXN_GLOBAL];\nlong long invFact[MAXN_GLOBAL];\nlong long pow2[MAXN_GLOBAL];\nlong long invpow2[MAXN_GLOBAL];\n\n// Precompute necessary values up to n_max\nvoid precompute_all(int n_max) {\n    // Ensure n_max is non-negative for array indexing\n    if (n_max < 0) n_max = 0; \n    \n    // Precompute factorials\n    fact[0] = 1;\n    for (int i = 1; i <= n_max; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    \n    // Precompute inverse factorials\n    // Compute inverse factorial for n_max first using modular inverse\n    invFact[n_max] = modInverse(fact[n_max]);\n    // Compute inverse factorials downwards using the relation invFact[i] = invFact[i+1] * (i+1)\n    for (int i = n_max - 1; i >= 0; i--) {\n        invFact[i] = (invFact[i + 1] * (i + 1)) % MOD;\n    }\n    \n    // Precompute powers of 2 and their modular inverses\n    pow2[0] = 1;\n    invpow2[0] = 1; \n    long long inv2 = modInverse(2); // Modular inverse of 2\n    for(int i = 1; i <= n_max; ++i) {\n        pow2[i] = (pow2[i-1] * 2) % MOD; // pow2[i] = 2^i mod MOD\n        invpow2[i] = (invpow2[i-1] * inv2) % MOD; // invpow2[i] = (2^i)^(-1) mod MOD\n    }\n}\n\n// Compute nCr % MOD using precomputed factorials and inverse factorials\n// nCr = n! / (r! * (n-r)!)\nlong long nCr_mod(int n, int r) {\n    // Handle invalid cases for r\n    if (r < 0 || r > n) {\n        return 0;\n    }\n    // Compute nCr using modular arithmetic properties\n    return (((fact[n] * invFact[r]) % MOD) * invFact[n - r]) % MOD;\n}\n\n// Global vector to store computed W(C, k) values.\n// Reused across calls to compute_W to avoid reallocations.\nstd::vector<long long> W_vals_global; \n\n// Computes W(C, k) = sum_{p=k}^C nCr(C, p) for k = 1..C\n// Stores results in W_vals_global[1]..W_vals_global[C]\nvoid compute_W(int C) {\n    // If C is 0, W(0, k) = 0 for k >= 1. No computation needed.\n    if (C == 0) {\n         return;\n    }\n    // Ensure the global vector is large enough. Needs indices up to C+1.\n    if (W_vals_global.size() < C + 2) {\n        W_vals_global.resize(C + 2);\n    }\n    \n    // Calculate W(C, k) values backwards using the relation W(C, k) = W(C, k+1) + nCr(C, k)\n    W_vals_global[C + 1] = 0; // Base case: W(C, C+1) = 0\n    W_vals_global[C] = 1; // Base case: W(C, C) = nCr(C, C) = 1\n    for (int k = C - 1; k >= 1; k--) {\n        W_vals_global[k] = (W_vals_global[k + 1] + nCr_mod(C, k)) % MOD;\n        // The sum will always be non-negative since nCr is non-negative and MOD is positive.\n    }\n}\n\nint main() {\n    // Faster I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // Precompute all necessary values up to the maximum possible N over all testcases\n    precompute_all(MAXN_GLOBAL - 1); \n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Size of the array a\n        std::cin >> n;\n        \n        // Use a vector to store counts of each number 0 to n-1. Size n+1 for safety, use indices 0..n-1.\n        std::vector<int> C(n + 1, 0); \n        for (int i = 0; i < n; ++i) {\n            int val;\n            std::cin >> val;\n             // Check if value is within the valid range [0, n-1] as specified.\n             if (val < n) { \n               C[val]++;\n             }\n        }\n\n        long long ANS = 0; // Stores the final answer (total sum of scores)\n        long long E = pow2[n]; // E_j factor in the formula, initially E_{-1} = 2^n\n        // DP state array P_cur[k] stores P_{j-1}(k) = prod_{x=0}^{j-1} W(C_x, k)\n        std::vector<long long> P_cur(n + 1, 0); \n        int M_prev = n; // M_{j-1} = min(C_0, ..., C_{j-1}). Initially, no constraints, so effectively infinity (n is large enough).\n\n        // Check base case: if there are no zeros (C[0] == 0), the score for any subsequence is 0.\n        if (C[0] == 0) {\n            std::cout << 0 << \"\\n\";\n            continue; // Skip to the next test case\n        }\n        \n        // Process the first value, j=0\n        compute_W(C[0]); // Compute W(C[0], k) values\n        int M0 = C[0]; // M_0 = min(infinity, C[0]) = C[0]\n        E = (E * invpow2[C[0]]) % MOD; // Update E to E_0 = 2^n * 2^(-C[0]) = 2^(n-C[0])\n        \n        long long current_sum_P = 0; // Sum of P_0(k) for k=1..M0\n        for (int k = 1; k <= M0; ++k) {\n             // P_0(k) = W(C_0, k). Access W_vals_global safely.\n             P_cur[k] = (k < W_vals_global.size()) ? W_vals_global[k] : 0;\n             current_sum_P = (current_sum_P + P_cur[k]) % MOD;\n        }\n        // Calculate S_0 = E_0 * sum(P_0(k))\n        long long S0 = (E * current_sum_P) % MOD;\n        ANS = (ANS + S0) % MOD; // Add S_0 to total answer\n        M_prev = M0; // Update M_prev for the next iteration (j=1)\n\n        // Dynamic programming loop for j = 1 to n-1\n        for (int j = 1; j < n; ++j) {\n            // Optimization: If minimum count encountered so far (M_prev) is 0, then for any k>=1, P_j(k) will be 0.\n            // All future contributions S_j, S_{j+1}, ... will be 0. We can break early.\n            if (M_prev == 0) break; \n\n            // If count of current value j is 0 (C[j] == 0)\n            if (C[j] == 0) {\n                 // M_j = min(M_prev, C[j]) = min(M_prev, 0) = 0.\n                 M_prev = 0; // Update M_prev to 0\n                 break; // Break the loop as future contributions will be 0.\n            }\n            \n            // Compute W(C[j], k) values\n            compute_W(C[j]); \n            // Calculate M_j = min(M_{j-1}, C[j])\n            int M_j = std::min(M_prev, C[j]);\n            // Update E to E_j = E_{j-1} * 2^(-C[j])\n            E = (E * invpow2[C[j]]) % MOD; \n            \n            current_sum_P = 0; // Sum of P_j(k) for k=1..M_j\n            // Temporary storage for P_next values (P_j(k)). Can optimize memory using two pointers/vectors.\n             std::vector<long long> P_next_vals(M_j + 1, 0); \n\n            // Calculate P_j(k) = P_{j-1}(k) * W(C[j], k) for k=1..M_j\n            for (int k = 1; k <= M_j; ++k) {\n                 // Access W_vals_global safely\n                 long long W_val_k = (k < W_vals_global.size()) ? W_vals_global[k] : 0;\n                 // Calculate P_j(k)\n                 long long P_next_k = (P_cur[k] * W_val_k) % MOD;\n                 P_next_vals[k] = P_next_k; // Store the computed value P_j(k)\n                 // Accumulate sum of P_j(k)\n                 current_sum_P = (current_sum_P + P_next_k) % MOD;\n            }\n            \n            // Calculate S_j = E_j * sum(P_j(k))\n            long long S_j = (E * current_sum_P) % MOD;\n            ANS = (ANS + S_j) % MOD; // Add S_j to total answer\n\n            // Update P_cur for the next iteration (j+1) using the computed P_next_vals (P_j(k))\n            for(int k=1; k<=M_j; ++k) P_cur[k] = P_next_vals[k];\n            // Clear values in P_cur beyond M_j that might remain from previous iteration with larger M_prev\n            for(int k=M_j+1; k<=M_prev; ++k) P_cur[k] = 0; \n\n            M_prev = M_j; // Update M_prev for the next iteration\n        }\n        \n        // Ensure final answer is non-negative and within [0, MOD-1]\n        if (ANS < 0) ANS += MOD;\n        std::cout << ANS << \"\\n\"; // Output the final answer for the test case\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2030d",
      "PROBLEM_ID": "2030D",
      "PROBLEM_STATEMENT": "QED is given a permutation$^{\\text{\u2217}}$ $p$ of length $n$. He also has a string $s$ of length $n$ containing only characters $\\texttt{L}$ and $\\texttt{R}$. QED only likes permutations that are sorted in non-decreasing order. To sort $p$, he can select any of the following operations and perform them any number of times:\n\n- Choose an index $i$ such that $s_i = \\texttt{L}$. Then, swap $p_i$ and $p_{i-1}$. It is guaranteed that $s_1 \\neq \\texttt{L}$.\n- Choose an index $i$ such that $s_i = \\texttt{R}$. Then, swap $p_i$ and $p_{i+1}$. It is guaranteed that $s_n \\neq \\texttt{R}$.\n\nHe is also given $q$ queries. In each query, he selects an index $i$ and changes $s_i$ from $\\texttt{L}$ to $\\texttt{R}$ (or from $\\texttt{R}$ to $\\texttt{L}$). Note that the changes are persistent.\n\nAfter each query, he asks you if it is possible to sort $p$ in non-decreasing order by performing the aforementioned operations any number of times. Note that before answering each query, the permutation $p$ is reset to its original form.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $q$ ($3 \\leq n \\leq 2 \\cdot 10^5$, $1 \\leq q \\leq 2 \\cdot 10^5$)\u00a0\u2013 the length of the permutation and the number of queries.\n\nThe following line contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($1 \\leq p_i \\leq n$, $p$ is a permutation).\n\nThe following line contains $n$ characters $s_1s_2 \\ldots s_n$. It is guaranteed that $s_i$ is either $\\texttt{L}$ or $\\texttt{R}$, $s_1 = \\texttt{R}$, and $s_n = \\texttt{L}$.\n\nThe following $q$ lines contain an integer $i$ ($2 \\leq i \\leq n-1$), denoting that $s_i$ is changed from $\\texttt{L}$ to $\\texttt{R}$ (or from $\\texttt{R}$ to $\\texttt{L}$).\n\nIt is guaranteed that the sum of $n$ and $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each query, output \"YES\" (without quotes) if it is possible, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5 3\n\n1 4 2 5 3\n\nRLRLL\n\n2\n\n4\n\n3\n\n8 5\n\n1 5 2 4 8 3 6 7\n\nRRLLRRRL\n\n4\n\n3\n\n5\n\n3\n\n4\n\n6 2\n\n1 2 3 4 5 6\n\nRLRLRL\n\n4\n\n5\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nYES\nYES\n```\n\n### Note\n\nIn the first testcase, $s = \\texttt{RRRLL}$ after the first query. QED may sort $p$ using the following operations:\n\n- Initially, $p = [1,4,2,5,3]$.\n- Select $i = 2$ and swap $p_2$ with $p_{3}$. Now, $p = [1,2,4,5,3]$.\n- Select $i = 5$ and swap $p_5$ with $p_{4}$. Now, $p = [1,2,4,3,5]$.\n- Select $i = 4$ and swap $p_4$ with $p_{3}$. Now, $p = [1,2,3,4,5]$, which is in non-decreasing order.\n\nIt can be shown that it is impossible to sort the array after all three updates of the first testcase.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <vector> // Ensure vector is included\n\nusing namespace std;\n\n// Structure for Segment Tree Node storing minimum and maximum values in a range\nstruct Node {\n    int min_val;\n    int max_val;\n};\n\n// Global variables to avoid passing them repeatedly\nvector<int> p_glob; // Stores the initial permutation globally\nvector<Node> tree;  // Segment tree built over p_glob\nset<int> barriers; // Set of barrier indices (1-based). A barrier at index k is between p_k and p_{k+1}.\nint bad_segments_count; // Count of segments that violate the sortability condition\nint n_glob; // Global copy of n for easy access in helper functions\n\n// Build segment tree - O(N) time complexity\n// The tree is built recursively. Each node covers a range [start, end].\n// Leaf nodes correspond to single elements of the permutation.\n// Internal nodes store combined min/max from children.\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        // Leaf node represents element at index start (1-based)\n        // Access p_glob using 0-based index start-1\n        tree[node] = {p_glob[start - 1], p_glob[start - 1]};\n    } else {\n        int mid = start + (end - start) / 2;\n        // Recursively build left and right children\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        // Combine results from children: min is min of children's mins, max is max of children's maxs\n        tree[node].min_val = min(tree[2 * node].min_val, tree[2 * node + 1].min_val);\n        tree[node].max_val = max(tree[2 * node].max_val, tree[2 * node + 1].max_val);\n    }\n}\n\n// Query segment tree for range [l, r] (1-based indices) - O(log N) time complexity\n// Returns a Node containing the minimum and maximum values in the queried range.\nNode query(int node, int start, int end, int l, int r) {\n    // If query range is completely outside the node's range [start, end]\n    if (r < start || end < l) {\n        // Return an identity element that won't affect min/max calculations.\n        // min=infinity (use n_glob+1 since values are 1 to n_glob), max=-infinity (use 0 since values >= 1)\n        return {n_glob + 1, 0}; \n    }\n    // If node's range is fully contained within the query range [l, r]\n    if (l <= start && end <= r) {\n        return tree[node]; // Return the precomputed min/max for this node's range\n    }\n    // Otherwise, the query range overlaps partially with the node's range.\n    // Recursively query children and combine their results.\n    int mid = start + (end - start) / 2;\n    Node p1 = query(2 * node, start, mid, l, r);\n    Node p2 = query(2 * node + 1, mid + 1, end, l, r);\n    // Combine results: min is min of children's results, max is max of children's results.\n    return {min(p1.min_val, p2.min_val), max(p1.max_val, p2.max_val)};\n}\n\n// Helper function to check if a segment [l, r] (1-based indices) is \"bad\" - O(log N) time complexity\n// A segment is bad if it cannot possibly contain the sorted values l, l+1, ..., r.\n// This happens if the minimum value in the segment is less than l, or the maximum value is greater than r.\nbool is_segment_bad(int l, int r) {\n    // An empty segment (l > r) is considered valid (not bad).\n    if (l > r) return false; \n    // Query the segment tree for the min and max values in the range [l, r].\n    Node res = query(1, 1, n_glob, l, r);\n    // Check the condition: minimum value must be >= l AND maximum value must be <= r.\n    // The segment is bad if this condition fails.\n    return res.min_val < l || res.max_val > r;\n}\n\n// Function to handle barrier destruction at index k (1-based) - O(log N + log B) time complexity\n// Where B is the number of barriers. log B comes from set operations.\nvoid handle_barrier_destroyed(int k) {\n    // Find the barrier k in the set.\n    auto it_k = barriers.find(k);\n    // If barrier k doesn't exist in the set, it might have been removed already or there's a logic issue.\n    // In a correct sequence of operations, this shouldn't happen unless called twice for the same destruction.\n    if (it_k == barriers.end()) return;\n\n    // Find the barriers immediately before and after k using iterators.\n    auto it_prev = prev(it_k); // Iterator to the barrier before k\n    auto it_next = next(it_k); // Iterator to the barrier after k\n    int k_prev = *it_prev; // Index of the barrier before k (could be sentinel 0)\n    int k_next = *it_next; // Index of the barrier after k (could be sentinel n)\n\n    // Define the two segments that existed before destruction and are now merging.\n    // Segment 1: [k_prev + 1, k]\n    // Segment 2: [k + 1, k_next]\n    int l1 = k_prev + 1;\n    int r1 = k;\n    int l2 = k + 1;\n    int r2 = k_next;\n\n    // Before merging, check if these segments were bad. If so, decrement the global count.\n    if (is_segment_bad(l1, r1)) {\n        bad_segments_count--;\n    }\n    if (is_segment_bad(l2, r2)) {\n        bad_segments_count--;\n    }\n\n    // Remove the barrier k from the set.\n    barriers.erase(it_k); // O(log B)\n\n    // Define the new segment formed by merging the two previous ones.\n    // New segment: [k_prev + 1, k_next]\n    int L = k_prev + 1;\n    int R = k_next;\n\n    // Check if the newly formed merged segment is bad. If so, increment the global count.\n    if (is_segment_bad(L, R)) { // O(log N)\n        bad_segments_count++;\n    }\n}\n\n// Function to handle barrier creation at index k (1-based) - O(log N + log B) time complexity\nvoid handle_barrier_created(int k) {\n    // Check if barrier k already exists. If so, return. This prevents double counting or processing.\n     if (barriers.count(k)) return; // O(log B)\n\n    // A new barrier at k splits an existing segment [L, R] into two.\n    // Find the segment [L, R] that contains indices k and k+1.\n    // This segment is defined by the barriers immediately before and after k.\n    auto it_next = barriers.upper_bound(k); // Find the first barrier index strictly greater than k. O(log B)\n    auto it_prev = prev(it_next); // The barrier immediately before k.\n    int k_prev = *it_prev; // Index of the previous barrier\n    int k_next = *it_next; // Index of the next barrier\n\n    // The segment being split is [L, R] = [k_prev + 1, k_next]\n    int L = k_prev + 1;\n    int R = k_next;\n\n    // Before splitting, check if the original segment [L, R] was bad. If so, decrement count.\n    if (is_segment_bad(L, R)) { // O(log N)\n        bad_segments_count--;\n    }\n    \n    // Add the new barrier k to the set.\n    barriers.insert(k); // O(log B)\n\n    // Define the two new segments created by the split.\n    // Segment 1: [L, k] = [k_prev + 1, k]\n    // Segment 2: [k + 1, R] = [k + 1, k_next]\n    int l1 = L;\n    int r1 = k;\n    int l2 = k + 1;\n    int r2 = R;\n\n    // Check if these new segments are bad. If so, increment the global count for each bad segment.\n    if (is_segment_bad(l1, r1)) { // O(log N)\n        bad_segments_count++;\n    }\n    if (is_segment_bad(l2, r2)) { // O(log N)\n        bad_segments_count++;\n    }\n}\n\nint main() {\n    // Faster I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        int n, q; // Length of permutation and number of queries\n        cin >> n >> q;\n        n_glob = n; // Set global n\n        \n        p_glob.resize(n); // Resize permutation vector\n        for (int i = 0; i < n; ++i) {\n            cin >> p_glob[i]; // Read permutation elements\n        }\n        string s; // Read the string s\n        cin >> s;\n\n        // Build segment tree based on the initial permutation p_glob\n        tree.assign(4 * n + 4, {n + 1, 0}); // Allocate memory for segment tree, initialize nodes safely\n        build(1, 1, n); // O(N)\n\n        // Initialize the set of barriers and the count of bad segments\n        barriers.clear();\n        barriers.insert(0); // Add sentinel barrier before index 1\n        barriers.insert(n); // Add sentinel barrier after index n\n        bad_segments_count = 0;\n\n        // Determine initial barriers based on the string s - O(N log B)\n        for (int k = 1; k < n; ++k) {\n            // A barrier exists at index k (between elements k and k+1) if s_k = 'L' and s_{k+1} = 'R'.\n            // Note: Problem uses 1-based indexing for s, C++ uses 0-based.\n            // So, s_k corresponds to s[k-1] and s_{k+1} corresponds to s[k].\n            if (s[k-1] == 'L' && s[k] == 'R') {\n                 barriers.insert(k); // Insert the 1-based index k\n            }\n        }\n\n        // Perform an initial check of all segments defined by the barriers - O(B log N)\n        auto it = barriers.begin();\n        int prev_k = *it; // Start with the first barrier (sentinel 0)\n        it++;\n        while(it != barriers.end()) {\n             int curr_k = *it; // Current barrier index\n             // The segment is between the previous barrier and the current one: [prev_k + 1, curr_k]\n             int l = prev_k + 1;\n             int r = curr_k;\n             // Check if this segment is bad\n             if (is_segment_bad(l, r)) {\n                 bad_segments_count++; // Increment count if bad\n             }\n             prev_k = curr_k; // Move to the next barrier\n             it++;\n        }\n\n        // Process Q queries - Total time O(Q * (log N + log B))\n        for (int query_idx = 0; query_idx < q; ++query_idx) {\n            int i; // 1-based index of the character in s to flip\n            cin >> i;\n\n            // Check state before flipping s[i-1]\n            // Check if a barrier exists at index i-1 (between i-1 and i)\n            bool barrier_at_i_minus_1_before = false;\n            if (i > 1) { // Barrier at i-1 needs s_{i-1}='L', s_i='R'. In 0-based: s[i-2]=='L', s[i-1]=='R'.\n                barrier_at_i_minus_1_before = (s[i-2] == 'L' && s[i-1] == 'R');\n            }\n            \n            // Check if a barrier exists at index i (between i and i+1)\n            bool barrier_at_i_before = false;\n            if (i < n) { // Barrier at i needs s_i='L', s_{i+1}='R'. In 0-based: s[i-1]=='L', s[i]=='R'.\n                barrier_at_i_before = (s[i-1] == 'L' && s[i] == 'R');\n            }\n\n            // Flip the character s_i (which is s[i-1] in 0-based indexing)\n            s[i-1] = (s[i-1] == 'L' ? 'R' : 'L');\n\n            // Check state after flipping s[i-1]\n            // Check again if a barrier exists at index i-1\n            bool barrier_at_i_minus_1_after = false;\n            if (i > 1) { // Recheck condition with the potentially updated s[i-1]\n                barrier_at_i_minus_1_after = (s[i-2] == 'L' && s[i-1] == 'R');\n            }\n\n            // Check again if a barrier exists at index i\n            bool barrier_at_i_after = false;\n            if (i < n) { // Recheck condition with the potentially updated s[i-1]\n                barrier_at_i_after = (s[i-1] == 'L' && s[i] == 'R');\n            }\n\n            // Update the barrier set and bad_segments_count based on detected changes.\n            // Process changes sequentially. The state updates from the first change affect the second change check's context.\n            \n            if (barrier_at_i_minus_1_before != barrier_at_i_minus_1_after) {\n                if (barrier_at_i_minus_1_after) { // Barrier was created at i-1\n                    handle_barrier_created(i-1);\n                } else { // Barrier was destroyed at i-1\n                    handle_barrier_destroyed(i-1);\n                }\n            }\n            \n            if (barrier_at_i_before != barrier_at_i_after) {\n                if (barrier_at_i_after) { // Barrier was created at i\n                    handle_barrier_created(i);\n                } else { // Barrier was destroyed at i\n                    handle_barrier_destroyed(i);\n                }\n            }\n\n            // After updates, check if there are any bad segments left.\n            // If bad_segments_count is 0, it's possible to sort the permutation.\n            if (bad_segments_count == 0) {\n                cout << \"YES\\n\";\n            } else {\n                cout << \"NO\\n\";\n            }\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2030c",
      "PROBLEM_ID": "2030C",
      "PROBLEM_STATEMENT": "Alice and Bob are playing a game. There is a list of $n$ booleans, each of which is either true or false, given as a binary string $^{\\text{\u2217}}$ of length $n$ (where $\\texttt{1}$ represents true, and $\\texttt{0}$ represents false). Initially, there are no operators between the booleans.\n\nAlice and Bob will take alternate turns placing and or or between the booleans, with Alice going first. Thus, the game will consist of $n-1$ turns since there are $n$ booleans. Alice aims for the final statement to evaluate to true, while Bob aims for it to evaluate to false. Given the list of boolean values, determine whether Alice will win if both players play optimally.\n\nTo evaluate the final expression, repeatedly perform the following steps until the statement consists of a single true or false:\n\n- If the statement contains an and operator, choose any one and replace the subexpression surrounding it with its evaluation.\n- Otherwise, the statement contains an or operator. Choose any one and replace the subexpression surrounding the or with its evaluation.\n\nFor example, the expression true\u00a0or\u00a0false\u00a0and\u00a0false is evaluated as true\u00a0or\u00a0(false\u00a0and\u00a0false) $=$ true\u00a0or\u00a0false $=$ true. It can be shown that the result of any compound statement is unique.\n\n$^{\\text{\u2217}}$A binary string is a string that only consists of characters $\\texttt{0}$ and $\\texttt{1}$\n\n### Input\n\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the length of the string.\n\nThe second line contains a binary string of length $n$, consisting of characters $\\texttt{0}$ and $\\texttt{1}$\u00a0\u2014 the list of boolean values.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each testcase, output \"YES\" (without quotes) if Alice wins, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n11\n\n3\n\n010\n\n12\n\n101111111100\n\n10\n\n0111111011\n\n8\n\n01000010\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nYES\nNO\n```\n\n### Note\n\nIn the first testcase, Alice can place and between the two booleans. The game ends as there are no other places to place operators, and Alice wins because true\u00a0and\u00a0true is true.\n\nIn the second testcase, Alice can place or between the middle true and the left false. Bob can place and between the middle true and the right false. The statement false\u00a0or\u00a0true\u00a0and\u00a0false is false.\n\nNote that these examples may not be the best strategies for either Alice or Bob.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        bool aliceWins = false;\n        // If there's a '1' at either end, Alice can isolate it in one move.\n        if (s[0] == '1' || s[n-1] == '1') {\n            aliceWins = true;\n        }\n        // Or if there are two consecutive '1's anywhere, Alice can win.\n        for (int i = 0; !aliceWins && i+1 < n; i++) {\n            if (s[i] == '1' && s[i+1] == '1') {\n                aliceWins = true;\n            }\n        }\n        cout << (aliceWins ? \"YES\\n\" : \"NO\\n\");\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2030b",
      "PROBLEM_ID": "2030B",
      "PROBLEM_STATEMENT": "For an arbitrary binary string $t$$^{\\\\text{\u2217}}$, let $f(t)$ be the number of non-empty subsequences$^{\\\\text{\u2020}}$ of $t$ that contain only $\\\\mathtt{0}$, and let $g(t)$ be the number of non-empty subsequences of $t$ that contain at least one $\\\\mathtt{1}$.\n\nNote that for $f(t)$ and for $g(t)$, each subsequence is counted as many times as it appears in $t$. E.g., $f(\\mathtt{000}) = 7, g(\\mathtt{100}) = 4$.\n\nWe define the oneness of the binary string $t$ to be $|f(t)-g(t)|$, where for an arbitrary integer $z$, $|z|$ represents the absolute value of $z$.\n\nYou are given a positive integer $n$. Find a binary string $s$ of length $n$ such that its oneness is as small as possible. If there are multiple strings, you can print any of them.\n\n$^{\\text{\u2217}}$A binary string is a string that only consists of characters $\\texttt{0}$ and $\\texttt{1}$.\n\n$^{\\text{\u2020}}$A sequence $a$ is a subsequence of a sequence $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements. For example, subsequences of $\\mathtt{1011101}$ are $\\mathtt{0}$, $\\mathtt{1}$, $\\mathtt{11111}$, $\\mathtt{0111}$, but not $\\mathtt{000}$ nor $\\mathtt{11100}$.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains an integer $n$ ($1 \\leq n \\leq 2\\cdot10^5$)\u00a0\u2014 the length of $s$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot10^5$.\n\n### Output\n\nFor each test case, output $s$ on a new line. If multiple answers exist, output any.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n1\n\n2\n\n3\n\n```\n\n#### Output #1\n\n```\n0\n01\n010\n```\n\n### Note\n\nIn the first test case, for the example output, $f(t)=1$ because there is one subsequence that contains only $\\mathtt{0}$ ($\\mathtt{0}$), and $g(t)=0$ because there are no subsequences that contain at least one $1$. The oneness is $|1-0|=1$. The output $\\mathtt{1}$ is correct as well because its oneness is $|0-1|=1$.\n\nFor the example output of the second test case, $f(t)=1$ because there is one non-empty subsequence that contains only $\\mathtt{0}$, and $g(t)=2$ because there are two non-empty subsequences that contain at least one $\\mathtt{1}$ ($\\mathtt{01}$ and $\\mathtt{1}$). The oneness is thus $|1-2|=1$. It can be shown that $1$ is the minimum possible value of its oneness over all possible binary strings of size $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        if (n == 1) {\n            cout << \"0\" << endl;\n        } else {\n            for (int i = 0; i < n - 1; ++i) {\n                cout << \"0\";\n            }\n            cout << \"1\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2030a",
      "PROBLEM_ID": "2030A",
      "PROBLEM_STATEMENT": "While exploring the jungle, you have bumped into a rare orangutan with a bow tie! You shake hands with the orangutan and offer him some food and water. In return...\n\nThe orangutan has gifted you an array $a$ of length $n$. Using $a$, you will construct two arrays $b$ and $c$, both containing $n$ elements, in the following manner:\n\n- $b_i = \\min(a_1, a_2, \\ldots, a_i)$ for each $1 \\leq i \\leq n$.\n- $c_i = \\max(a_1, a_2, \\ldots, a_i)$ for each $1 \\leq i \\leq n$.\n\nDefine the score of $a$ as $\\sum_{i=1}^n c_i - b_i$ (i.e. the sum of $c_i - b_i$ over all $1 \\leq i \\leq n$). Before you calculate the score, you can shuffle the elements of $a$ however you want.\n\nFind the maximum score that you can get if you shuffle the elements of $a$ optimally.\n\n### Input\n\nThe first line contains $t$ ($1 \\leq t \\leq 100$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 1000$)\u00a0\u2014 the number of elements in $a$.\n\nThe following line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 1000$)\u00a0\u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $1000$.\n\n### Output\n\nFor each test case, output the maximum score that you can get.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n1\n\n69\n\n3\n\n7 6 5\n\n5\n\n1 1 1 2 2\n\n```\n\n#### Output #1\n\n```\n0\n4\n4\n```\n\n### Note\n\nIn the first test case, there is no other way to rearrange $a$. So, $b = [69]$ and $c = [69]$. The only possible score is $69 - 69 = 0$.\n\nIn the second test case, you can rearrange $a$ as $[7, 5, 6]$. Here, $b = [7, 5, 5]$ and $c = [7, 7, 7]$. The score in this case is $(7 - 7) + (7 - 5) + (7 - 5) = 4$. It can be shown this is the maximum possible score.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    int min_val = 1001;\n    int max_val = 0;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        min_val = min(min_val, a[i]);\n        max_val = max(max_val, a[i]);\n    }\n\n    if (n <= 1) {\n        return 0;\n    } else {\n        return (n - 1) * (max_val - min_val);\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        cout << solve() << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2029i",
      "PROBLEM_ID": "2029I",
      "PROBLEM_STATEMENT": "Kevin has recently learned the definition of variance. For an array $a$ of length $n$, the variance of $a$ is defined as follows:\n\n- Let $x=\\dfrac{1}{n}\\displaystyle\\sum_{i=1}^n a_i$, i.e., $x$ is the mean of the array $a$;\n- Then, the variance of $a$ is \n\n$$ V(a)=\\frac{1}{n}\\sum_{i=1}^n(a_i-x)^2. $$\n\nNow, Kevin gives you an array $a$ consisting of $n$ integers, as well as an integer $k$. You can perform the following operation on $a$:\n\n- Select an interval $[l,r]$ ($1\\le l\\le r\\le n$), then for each $l\\le i\\le r$, increase $a_i$ by $k$.\n\nFor each $1\\le p\\le m$, you have to find the minimum possible variance of $a$ after exactly $p$ operations are performed, independently for each $p$.\n\nFor simplicity, you only need to output the answers multiplied by $n^2$. It can be proven that the results are always integers.\n\n### Input\n\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 100$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$ ($1\\le n,m\\le 5000$, $\\color{red}{n\\cdot m\\le 2\\cdot 10^4}$, $1\\le k\\le 10^5$)\u00a0\u2014 the length of the array $a$, the maximum number of operations, and the number you add to $a_i$ each time, respectively.\n\nThe second line contains $n$ integers $a_1,a_2,\\ldots, a_n$ ($1\\le a_i\\le 10^5$)\u00a0\u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n\\cdot m$ over all tests does not exceed $2\\cdot 10^4$.\n\n### Output\n\nFor each test case, output $m$ integers in a single line, the $p$-th integer denoting the minimum possible variance of $a$ when exactly $p$ operations are performed, multiplied by $n^2$.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n3 2 1\n\n1 2 2\n\n3 2 2\n\n1 2 2\n\n10 2 1\n\n10 1 1 1 1 10 1 1 1 1\n\n6 8 2\n\n1 1 4 5 1 3\n\n8 8 7\n\n20 43 24 2 4 3 20 43\n\n8 8 3\n\n20 43 24 2 4 3 20 43\n\n10 12 1\n\n5 3 3 5 4 1 8 1 1 1\n\n13 10 100000\n\n1 2 3 4 5 6 7 8 9 10 11 5 4\n\n10 5 10000\n\n2308 9982 4435 3310 100000 9 7 8100 1919 100000\n\n```\n\n#### Output #1\n\n```\n0 0\n2 2\n1161 1024\n53 21 21 5 5 5 5 5\n10608 6912 4448 3104 1991 1312 535 304\n13248 11184 9375 7815 6447 5319 4383 3687\n385 316 269 224 181 156 124 101 80 56 41 29\n1486 1486 1486 1486 1486 1486 1486 1486 1486 1486\n134618047140 119919447140 107020847140 93922247140 82623647140\n```\n\n### Note\n\nIn the first test case:\n\n- For $p = 1$, you can perform the operation on $[1, 1]$, changing $a$ from $[1, 2, 2]$ to $[2, 2, 2]$. Since all of the elements are equal, the variance is equal to $0$.\n- For $p = 2$, you can perform the operation on $[1, 3]$ and then $[1, 1]$, changing $a$ from $[1, 2, 2]$ to $[2, 3, 3]$ to $[3, 3, 3]$. Since all of the elements are equal, the variance is equal to $0$.\n\nIn the second test case, some possible optimal choices are:\n\n- $p=1$: $[\\underline{1,}\\,2,2]\\to [3,2,2]$;\n- $p=2$: $[1,\\underline{2,2}] \\to [\\underline{1,}\\,4,4] \\to [3,4,4]$.\n\nIn the third test case, some possible optimal choices are:\n\n- $p=1$: $[10,\\underline{1,1,1,1,10,1,1,1,1}]\\to[10,2,2,2,2,11,2,2,2,2]$;\n- $p=2$: $[10,1,1,1,1,10,\\underline{1,1,1,1}] \\to [10,\\underline{1,1,1,1},10,2,2,2,2] \\to [10,2,2,2,2,10,2,2,2,2]$.\n\nIn the eighth test case, the optimal choice for all $p$ is to perform the operation on the whole array $p$ times.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n#define ll long long\n#define lll __int128\nusing namespace std;\nint t,n,m,k,a[5011];lll ans[5011];\nlll d[5011];\nvoid solve(lll x)\n{\n\tfor(int i=1;i<=n;++i)d[i]=a[i];\n\tfor(int p=1;p<=m;++p)\n\t{\n\t\tlll res=1e36;\n\t\tint lst=1,L=-1,R=-1,typ=0;lll sum=0;\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tsum+=(d[i]+k-x)*(d[i]+k-x)-(d[i]-x)*(d[i]-x);\n\t\t\tif(sum>0)lst=i+1,sum=0;\n\t\t\tif(sum<res)res=sum,L=lst,R=i,typ=1;\n\t\t}\n\t\tlst=1;sum=0;\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tsum+=(d[i]-k-x)*(d[i]-k-x)-(d[i]-x)*(d[i]-x);\n\t\t\tif(d[i]==a[i]||sum>0)sum=0,lst=i+1;\n\t\t\tif(sum<res)res=sum,L=lst,R=i,typ=-1;\n\t\t}\n\t\tfor(int i=L;i<=R;++i)d[i]+=typ*k;\n\t\tlll tt=0;\n\t\tfor(int i=1;i<=n;++i)tt+=(d[i]-x)*(d[i]-x);\n\t\tans[p]=min(ans[p],tt);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&t);while(t--)\n\t{\n\t\tscanf(\"%d%d%d\",&n,&m,&k);k*=n;\n\t\tfor(int i=1;i<=n;++i)scanf(\"%d\",a+i),a[i]*=n;\n\t\tfor(int i=1;i<=m;++i)ans[i]=1e36;\n\t\tll avg=0;\n\t\tfor(int i=1;i<=n;++i)avg+=a[i];avg/=n;\n\t\tfor(int i=0;i<=n*m;++i)solve(avg+(lll)i*k/n);\n\t\tfor(int i=1;i<=m;++i)printf(\"%lld \",(ll)(ans[i]/n));putchar(10);\n\t}\n\tfclose(stdin);fclose(stdout);return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2029h",
      "PROBLEM_ID": "2029H",
      "PROBLEM_STATEMENT": "Given is an undirected graph with $n$ vertices and $m$ edges. Each edge connects two vertices $(u, v)$ and has a probability of $\\frac{p}{q}$ of appearing each day.\n\nInitially, vertex $1$ has a message. At the end of the day, a vertex has a message if and only if itself or at least one of the vertices adjacent to it had the message the day before. Note that each day, each edge chooses its appearance independently.\n\nCalculate the expected number of days before all the vertices have the message, modulo $998\\,244\\,353$.\n\n### Input\n\nThe first line contains two integers $n$ and $m$ ($1\\leq n\\leq 21$, $n-1\\leq m\\leq\\frac{n(n-1)}{2}$).\n\nThen $m$ lines follow, each containing four integers $u$, $v$, $p$, and $q$ ($1\\leq u\\neq v\\leq n$, $1\\leq p<q<998\\,244\\,353$, $\\gcd(p,q)=1$)\u00a0\u2014 there is an undirected edge between $u$ and $v$, and it has a probability of appearance of $\\frac{p}{q}$ each day.\n\nIt is guaranteed that there are no self-loops or multiple-edges in the graph and that the graph is connected if all of the edges appear.\n\nAdditional constraint in the input: Let $g\\_{i,j}$ be the probability of appearance of the edge between $i$ and $j$ ($g\\_{i,j}=0$ if there is no edge between $i$ and $j$). It is guaranteed that for any $S\\\\subseteq\\\\{1,2,\\\\ldots,n\\\\}$ ($\\|S\\|\\\\ge 1$), \n\n$$ \\prod_{i\\in S}\\left(\\prod_{j\\in\\{1,2,\\ldots,n\\}\\setminus S}(1-g_{i,j})\\right)\\not\\equiv1\\pmod{998\\,244\\,353}. $$\n\nOutput\n\nPrint a single integer in the only line of the output\u00a0\u2014 the expected number of days, modulo $998\\,244\\,353$.\n\nFormally, let $M = 998\\,244\\,353$. It can be shown that the exact answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\n### Examples\n\n#### Input #1\n\n```\n\n2 1\n\n1 2 1 10\n\n```\n\n#### Output #1\n\n```\n10```\n\n#### Input #2\n\n```\n\n3 3\n\n1 2 1 2\n\n1 3 1 2\n\n2 3 1 2\n\n```\n\n#### Output #2\n\n```\n887328316```\n\n#### Input #3\n\n```\n\n1 0\n\n```\n\n#### Output #3\n\n```\n0```\n\n#### Input #4\n\n```\n\n5 8\n\n1 2 1 11\n\n1 3 2 11\n\n1 4 3 11\n\n1 5 4 11\n\n2 4 5 11\n\n2 5 6 11\n\n3 4 7 11\n\n4 5 8 11\n\n```\n\n#### Output #4\n\n```\n469993557```\n\n#### Input #5\n\n```\n\n21 22\n\n1 2 3 4\n\n2 3 4 5\n\n3 4 5 6\n\n5 6 7 8\n\n6 7 8 9\n\n7 8 9 10\n\n8 9 2 3\n\n9 10 3 4\n\n10 11 4 5\n\n11 12 5 6\n\n12 13 6 7\n\n13 14 7 8\n\n14 15 8 9\n\n15 16 9 10\n\n16 17 2 3\n\n17 18 3 4\n\n18 19 4 5\n\n19 20 5 6\n\n20 21 6 7\n\n1 10 100 1001\n\n15 4 147 220\n\n4 11 1 998244352\n\n```\n\n#### Output #5\n\n```\n299529765```\n\n### Note\n\nIn the first test, the answer is equal to the expected number of days before the only edge in the graph first appears, and that is $\\frac{1}{0.1}=10$.\n\nIn the second test, the answer is equal to $\\frac{20}{9}$ before it is taken modulo $998\\,244\\,353$.\n\nIn the third test, the only vertex already has the message, so the answer is $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define pc __builtin_popcount\n#define ll long long\nusing namespace std;\nconst int MOD=998244353;\nll ksm(ll a,ll b=MOD-2) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }\nint n,m;\nvoid fwt(ll *a,bool op) {\n\tfor(int s=1;s<(1<<n);s<<=1) for(int i=0;i<(1<<n);i+=s<<1) for(int j=i;j<i+s;++j) {\n\t\tif(op) {\n\t\t\tif((a[j+s]+=a[j])>=MOD) a[j+s]-=MOD;\n\t\t} else  {\n\t\t\tif((a[j+s]-=a[j])<0) a[j+s]+=MOD;\n\t\t}\n\t}\n}\nll pr[1<<21],ip[1<<21],co[1<<21],f[1<<20],h[21][1<<20];\nll tg[1<<20],sg[1<<20],fp[21][1<<20],nf[1<<20];\nsigned main() {\n\tscanf(\"%d%d\",&n,&m),--n;\n\tint U=(1<<(n+1))-1;\n\tfor(int s=0;s<(1<<(n+1));++s) pr[s]=ip[s]=co[s]=1;\n\tfor(int i=1,u,v,x,y;i<=m;++i) {\n\t\tscanf(\"%d%d%d%d\",&u,&v,&x,&y);\n\t\tu=(u>1?u-2:n),v=(v>1?v-2:n);\n\t\tll p=(y+MOD-x)*ksm(y)%MOD,iv=ksm(p);\n\t\tpr[1<<u|1<<v]=p,ip[1<<u|1<<v]=iv;\n\t}\n\tfor(int i=0;i<=n;++i) for(int s=0;s<(1<<(n+1));++s) if(s>>i&1) {\n\t\tpr[s]=pr[s]*pr[s^(1<<i)]%MOD,ip[s]=ip[s]*ip[s^(1<<i)]%MOD;\n\t}\n\tfor(int s=0;s<(1<<(n+1));++s) co[s]=pr[U]*ip[s]%MOD*ip[U-s]%MOD;\n\tfor(int s=0;s<(1<<n);++s) fp[pc(s)][s]=pr[s];\n\tfor(int i=0;i<=n;++i) fwt(fp[i],1);\n\ttg[0]=1;\n\tfor(int i=0;i<=n;++i) {\n\t\tmemcpy(sg,tg,sizeof(sg));\n\t\tmemset(nf,0,sizeof(nf));\n\t\tfwt(sg,1),fwt(h[i],0);\n\t\tfor(int s=0;s<(1<<n);++s) if(pc(s)==i) {\n\t\t\tf[s]=(h[i][s]*ip[s|1<<n]+sg[s])%MOD;\n\t\t\tll z=ksm(1+MOD-co[s|1<<n])*f[s]%MOD;\n\t\t\ttg[s]=(tg[s]+(MOD-co[s|1<<n])*z+MOD-f[s])%MOD;\n\t\t\tnf[s]=z*pr[U]%MOD*ip[(1<<n)-1-s]%MOD;\n\t\t}\n\t\tfwt(nf,1);\n\t\tfor(int j=1;i+j<=n;++j) {\n\t\t\tfor(int s=0;s<(1<<n);++s) h[i+j][s]=(h[i+j][s]+nf[s]*fp[j][s])%MOD;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int s=0;s<(1<<n);++s) {\n\t\tans=(ans+f[s]*ksm((1+MOD-co[s|1<<n])%MOD))%MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2029g",
      "PROBLEM_ID": "2029G",
      "PROBLEM_STATEMENT": "There is an array $a$ consisting of $n$ integers. Initially, all elements of $a$ are equal to $0$.\n\nKevin can perform several operations on the array. Each operation is one of the following two types:\n\n- Prefix addition\u00a0\u2014 Kevin first selects an index $x$ ($1\\le x\\le n$), and then for each $1\\le j\\le x$, increases $a_j$ by $1$;\n- Suffix addition\u00a0\u2014 Kevin first selects an index $x$ ($1\\le x\\le n$), and then for each $x\\le j\\le n$, increases $a_j$ by $1$.\n\nIn the country of KDOI, people think that the integer $v$ is balanced. Thus, Iris gives Kevin an array $c$ consisting of $n$ integers and defines the beauty of the array $a$ as follows:\n\n- Initially, set $b=0$;\n- For each $1\\le i\\le n$, if $a_i=v$, add $c_i$ to $b$;\n- The beauty of $a$ is the final value of $b$.\n\nKevin wants to maximize the beauty of $a$ after all the operations. However, he had already performed $m$ operations when he was sleepy. Now, he can perform an arbitrary number (possibly zero) of new operations.\n\nYou have to help Kevin find the maximum possible beauty if he optimally performs the new operations.\n\nHowever, to make sure that you are not just rolling the dice, Kevin gives you an integer $V$, and you need to solve the problem for each $1\\le v\\le V$.\n\n### Input\n\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 1000$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $V$ ($1\\le n, m\\le 2\\cdot 10^5$, $1\\le V\\le 2000$)\u00a0\u2014 the length of the array $a$, the number of initial operations, and the number that Kevin gives you.\n\nThe second line contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1\\le c_i\\le 10^9$)\u00a0\u2014 the elements in the array $c$.\n\nThen $m$ lines follow, the $i$-th line containing a character $op$ and an integer $x$ ($op=\\mathtt{L}$ or $\\mathtt{R}$, $1\\le x\\le n$)\u00a0\u2014 the type of the $i$-th operation and the selected index.\n\n- If $op=\\mathtt{L}$, this operation is a prefix addition on index $x$;\n- If $op=\\mathtt{R}$, this operation is a suffix addition on index $x$.\n\nIt is guaranteed that:\n\n- the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$;\n- the sum of $m$ over all test cases does not exceed $2\\cdot 10^5$;\n- the sum of $V^2$ over all test cases does not exceed $4\\cdot 10^6$.\n\n### Output\n\nFor each test case, output $V$ integers in a single line, the $i$-th integer denoting the maximum possible beauty after Kevin performs some new operations when $v=i$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3 3 2\n\n1 2 4\n\nL 3\n\nR 3\n\nL 1\n\n3 3 2\n\n5 1 4\n\nL 3\n\nR 3\n\nL 1\n\n5 4 5\n\n1 1 1 1 1\n\nL 3\n\nR 2\n\nL 5\n\nL 4\n\n10 12 9\n\n10 9 8 7 6 5 4 3 2 1\n\nL 2\n\nL 4\n\nR 4\n\nR 4\n\nL 6\n\nR 8\n\nL 3\n\nL 2\n\nR 1\n\nR 10\n\nL 8\n\nL 1\n\n1 1 4\n\n1000000000\n\nL 1\n\n```\n\n#### Output #1\n\n```\n2 6\n1 9\n0 1 3 5 5\n0 0 0 6 25 32 35 44 51\n1000000000 1000000000 1000000000 1000000000\n```\n\n### Note\n\nIn the first test case, the array $a$ changes as follows for the initial operations: $[0, 0, 0] \\xrightarrow{\\mathtt{L}\\ 3} [1, 1, 1] \\xrightarrow{\\mathtt{R}\\ 3} [1, 1, 2] \\xrightarrow{\\mathtt{L}\\ 1} [2, 1, 2]$.\n\n- For $v=1$, it is optimal to not perform any new operations, and the beauty is $b=c_2=2$;\n- For $v=2$, it is optimal to perform a prefix addition operation on index $2$. After that, $a$ becomes $[3,2,2]$, and the beauty is $b=c_2+c_3=6$.\n\nIn the second test case, for both $v=1$ and $v=2$, it is optimal to not perform any new operations.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=2e5+2,M=4002;\nint T,n,m,v,c[N],x,s[N];\nll t[M][M],f[M];\nchar op;\nvoid upd(int x,int y,ll z){++x,++y;for(int i=x;i<=v+1;i+=i&-i)for(int j=y;j<=v+1;j+=j&-j)t[i][j]=max(t[i][j],z);}\nll qry(int x,int y){++x,++y;ll z=0;for(int i=x;i;i-=i&-i)for(int j=y;j;j-=j&-j)z=max(z,t[i][j]);return z;}\nsigned main(){\n\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tfor(cin>>T;T--;){\n\t\tcin>>n>>m>>v;\n\t\tfor(int i=1;i<=n;i++)cin>>c[i],s[i]=0;\n\t\twhile(m--)if(cin>>op>>x,op=='L')++s[1],--s[x+1];else++s[x];\n\t\tfor(int i=1;i<=n;i++)s[i]+=s[i-1];\n\t\tvector<pair<int,ll>>g;\n\t\tfor(int i=1,j=i;i<=n;i=j){\n\t\t\tll C=0;\n\t\t\twhile(j<=n&&s[j]==s[i])C+=c[j++];\n\t\t\tif(s[i]<=v)g.push_back({s[i],C});\n\t\t}\n\t\tfor(int i=1;i<=v+1;i++)for(int j=1;j<=v+1;j++)t[i][j]=0;\n\t\tfor(auto i:g){int x=i.first;ll val=i.second;\n\t\t\tfor(int i=0;i+x<=v;i++)f[i]=qry(i,i+x);\n\t\t\tfor(int i=0;i+x<=v;i++)upd(i,i+x,f[i]+val);\n\t\t}\n\t\tfor(int i=1;i<=v;i++)cout<<qry(v,i)<<' ';cout<<'\\n';\n\t}\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2029e",
      "PROBLEM_ID": "2029E",
      "PROBLEM_STATEMENT": "For two integers $x$ and $y$ ($x,y\\ge 2$), we will say that $x$ is a generator of $y$ if and only if $x$ can be transformed to $y$ by performing the following operation some number of times (possibly zero):\n\n- Choose a divisor $d$ ($d\\ge 2$) of $x$, then increase $x$ by $d$.\n\nFor example,\n\n- $3$ is a generator of $8$ since we can perform the following operations: $3 \\xrightarrow{d = 3} 6 \\xrightarrow{d = 2} 8$;\n- $4$ is a generator of $10$ since we can perform the following operations: $4 \\xrightarrow{d = 4} 8 \\xrightarrow{d = 2} 10$;\n- $5$ is not a generator of $6$ since we cannot transform $5$ into $6$ with the operation above.\n\nNow, Kevin gives you an array $a$ consisting of $n$ pairwise distinct integers ($a_i\\ge 2$).\n\nYou have to find an integer $x\\ge 2$ such that for each $1\\le i\\le n$, $x$ is a generator of $a_i$, or determine that such an integer does not exist.\n\n### Input\n\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 10^4$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 10^5$)\u00a0\u2014 the length of the array $a$.\n\nThe second line contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($2\\le a_i\\le 4\\cdot 10^5$)\u00a0\u2014 the elements in the array $a$. It is guaranteed that the elements are pairwise distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single integer $x$\u00a0\u2014 the integer you found. Print $-1$ if there does not exist a valid $x$.\n\nIf there are multiple answers, you may output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\n8 9 10\n\n4\n\n2 3 4 5\n\n2\n\n147 154\n\n5\n\n3 6 8 25 100000\n\n```\n\n#### Output #1\n\n```\n2\n-1\n7\n3\n```\n\n### Note\n\nIn the first test case, for $x=2$:\n\n- $2$ is a generator of $8$, since we can perform the following operations: $2 \\xrightarrow{d = 2} 4 \\xrightarrow{d = 4} 8$;\n- $2$ is a generator of $9$, since we can perform the following operations: $2 \\xrightarrow{d = 2} 4 \\xrightarrow{d = 2} 6 \\xrightarrow{d = 3} 9$.\n- $2$ is a generator of $10$, since we can perform the following operations: $2 \\xrightarrow{d = 2} 4 \\xrightarrow{d = 2} 6 \\xrightarrow{d = 2} 8 \\xrightarrow{d = 2} 10$.\n\nIn the second test case, it can be proven that it is impossible to find a common generator of the four integers.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    const int MAXA = 400000;\n    // Precompute smallest prime factor (spf) for each number up to MAXA\n    static int spf[MAXA + 1];\n    for (int i = 2; i <= MAXA; i++) {\n        if (spf[i] == 0) {\n            // i is prime\n            for (int j = i; j <= MAXA; j += i) {\n                if (spf[j] == 0) {\n                    spf[j] = i;\n                }\n            }\n        }\n    }\n    // spf[x] now holds the smallest prime factor of x; if spf[x] == x, x is prime.\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n\n        // Collect primes in the input\n        vector<int> primes;\n        for (int x : a) {\n            if (spf[x] == x) {\n                primes.push_back(x);\n            }\n        }\n\n        // If there are two or more distinct primes in a[], no single x can generate both\n        if ((int)primes.size() >= 2) {\n            cout << -1 << \"\\n\";\n            continue;\n        }\n\n        // If exactly one prime p in a[], candidate x = p\n        if ((int)primes.size() == 1) {\n            int p = primes[0];\n            bool ok = true;\n            for (int x : a) {\n                if (x == p) {\n                    // trivial, zero operations needed\n                    continue;\n                }\n                // x != p, so x is composite (no other primes in a)\n                // Check if x is reachable from p\n                // Case 1: x divisible by p => reachable by repeated +p steps\n                if (x % p == 0) {\n                    continue;\n                }\n                // Case 2: use smallest prime divisor r of x in last step\n                int r = spf[x];  // smallest prime factor of x\n                // we need x >= 2*p + r\n                if (x >= 2*p + r) {\n                    continue;\n                }\n                // Otherwise unreachable\n                ok = false;\n                break;\n            }\n            if (ok) {\n                cout << p << \"\\n\";\n            } else {\n                cout << -1 << \"\\n\";\n            }\n        }\n        else {\n            // No primes in a[], all are composite => x = 2 always works\n            cout << 2 << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2029c",
      "PROBLEM_ID": "2029C",
      "PROBLEM_STATEMENT": "Hello, Codeforces Forcescode!\n\nKevin used to be a participant of Codeforces. Recently, the KDOI Team has developed a new Online Judge called Forcescode.\n\nKevin has participated in $n$ contests on Forcescode. In the $i$-th contest, his performance rating is $a_i$.\n\nNow he has hacked into the backend of Forcescode and will select an interval $[l,r]$ ($1\\le l\\le r\\le n$), then skip all of the contests in this interval. After that, his rating will be recalculated in the following way:\n\n- Initially, his rating is $x=0$;\n- For each $1\\le i\\le n$, after the $i$-th contest,\n  - If $l\\le i\\le r$, this contest will be skipped, and the rating will remain unchanged;\n  - Otherwise, his rating will be updated according to the following rules:\n    - If $a_i>x$, his rating $x$ will increase by $1$;\n    - If $a_i=x$, his rating $x$ will remain unchanged;\n    - If $a_i<x$, his rating $x$ will decrease by $1$.\n\nYou have to help Kevin to find his maximum possible rating after the recalculation if he chooses the interval $[l,r]$ optimally. Note that Kevin has to skip at least one contest.\n\n### Input\n\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 5\\cdot 10^4$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 3\\cdot 10^5$)\u00a0\u2014 the number of contests.\n\nThe second line contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1\\le a_i\\le n$)\u00a0\u2014 the performance ratings in the contests.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximum possible rating after the recalculation if Kevin chooses the interval optimally.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n6\n\n1 2 3 4 5 6\n\n7\n\n1 2 1 1 1 3 4\n\n1\n\n1\n\n9\n\n9 9 8 2 4 4 3 5 3\n\n10\n\n1 2 3 4 1 3 2 1 1 10\n\n```\n\n#### Output #1\n\n```\n5\n4\n0\n4\n5\n```\n\n### Note\n\nIn the first test case, Kevin must skip at least one contest. If he chooses any interval of length $1$, his rating after the recalculation will be equal to $5$.\n\nIn the second test case, Kevin's optimal choice is to select the interval $[3,5]$. During the recalculation, his rating changes as follows:\n\n\n\n$$ 0 \\xrightarrow{a_1=1} 1 \\xrightarrow{a_2=2} 2 \\xrightarrow{\\mathtt{skip}} 2 \\xrightarrow{\\mathtt{skip}} 2 \\xrightarrow{\\mathtt{skip}} 2 \\xrightarrow{a_6=3} 3 \\xrightarrow{a_7=4} 4 $$\n\nIn the third test case, Kevin must skip the only contest, so his rating will remain at the initial value of $0$.\n\nIn the fourth test case, Kevin's optimal choice is to select the interval $[7,9]$. During the recalculation, his rating changes as follows:\n\n\n\n$$ 0 \\xrightarrow{a_1=9} 1 \\xrightarrow{a_2=9} 2 \\xrightarrow{a_3=8} 3 \\xrightarrow{a_4=2} 2 \\xrightarrow{a_5=4} 3 \\xrightarrow{a_6=4} 4 \\xrightarrow{\\mathtt{skip}} 4 \\xrightarrow{\\mathtt{skip}} 4 \\xrightarrow{\\mathtt{skip}} 4 $$\n\nIn the fifth test case, Kevin's optimal choice is to select the interval $[5,9]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    const int NEG_INF = -1000000000;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        // dp0: best x when skip not started\n        // dp1: best x when skip is ongoing\n        // dp2: best x when skip has finished\n        int dp0 = 0;\n        int dp1 = NEG_INF;\n        int dp2 = NEG_INF;\n        for (int i = 0; i < n; i++) {\n            int x0 = dp0, x1 = dp1, x2 = dp2;\n            // Process normal contest for dp0\n            int ndp0 = x0 + (a[i] > x0 ? 1 : (a[i] < x0 ? -1 : 0));\n            // Skip this contest: either continue skipping or start skipping now\n            int ndp1 = max(x1, x0);\n            // Finish skipping (or already finished) and process contest\n            int ndp2 = NEG_INF;\n            if (x2 != NEG_INF) {\n                int v2 = x2 + (a[i] > x2 ? 1 : (a[i] < x2 ? -1 : 0));\n                ndp2 = max(ndp2, v2);\n            }\n            if (x1 != NEG_INF) {\n                int v1 = x1 + (a[i] > x1 ? 1 : (a[i] < x1 ? -1 : 0));\n                ndp2 = max(ndp2, v1);\n            }\n            dp0 = ndp0;\n            dp1 = ndp1;\n            dp2 = ndp2;\n        }\n        int answer = max(dp1, dp2);\n        cout << answer << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2028f",
      "PROBLEM_ID": "2028F",
      "PROBLEM_STATEMENT": "Note that the memory limit is unusual.\n\nThe Cheshire Cat has a riddle for Alice: given $n$ integers $a\\_1, a\\_2, \\\\ldots, a\\_n$ and a target $m$, is there a way to insert $+$ and $\\\\times$ into the circles of the expression \n\n$$a_1 \\circ a_2 \\circ \\cdots \\circ a_n = m$$\n\nto make it true? We follow the usual order of operations: $\\times$ is done before $+$.\n\nAlthough Alice is excellent at chess, she is not good at math. Please help her so she can find a way out of Wonderland!\n\n### Input\n\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n, m$ ($1\\le n\\le 2\\cdot 10^5$; $1\\le m\\le 10^4$)\u00a0\u2014 the number of integers and the target, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0\\le a_i\\le 10^4$)\u00a0\u2014 the elements of the array $a$.\n\nThe sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output \"YES\" without quotes if it is possible to get the target by inserting $+$ or $\\times$ and \"NO\" otherwise.\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n5 4\n\n2 1 1 1 2\n\n5 5\n\n2 1 1 1 2\n\n5 6\n\n2 1 1 1 2\n\n5 7\n\n2 1 1 1 2\n\n5 8\n\n2 1 1 1 2\n\n5 6\n\n2 0 2 2 3\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nYES\nYES\nNO\nYES\n```\n\n### Note\n\nPossible solutions for the first four test cases are shown below. \n\n$$\\begin{align*} 2 \\times 1 + 1 \\times 1 \\times 2 &= 4 \\\\ 2 \\times 1 + 1 + 1 \\times 2 &= 5 \\\\ 2 \\times 1 + 1 + 1 + 2 &= 6 \\\\ 2 + 1 + 1 + 1 + 2 &= 7 \\\\ \\end{align*}$$\n\nIt is impossible to get a result of $8$ in the fifth test case.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <cstdio>\n#include <bitset>\n\nstd::bitset<10086> f[15],F,G;\n\nint memo[15],tp,a[15],q[231231],h,t;\n\nint main()\n{\n\tint T;scanf(\"%d\",&T);while(T--){\n\t\tfor(tp=1;tp<15;++tp) memo[tp]=tp;\n\t\t--tp;f[q[h=t=0]=memo[tp--]].reset();\n\t\tF.reset();G.reset();F[0]=f[q[h]][0]=1;\n\t\tint n,m;scanf(\"%d%d\",&n,&m);\n\t\twhile(n--){int x;scanf(\"%d\",&x);switch(x){\n\t\t\tcase 0:G=f[q[t]]=F;break;\n\t\t\tcase 1:F|=(f[q[t]]|=f[q[t]]<<1);break;\n\t\t\tdefault:{\n\t\t\t\tint c=memo[tp--],s=x,i=t;a[c]=x;f[c]=G;\n\t\t\t\twhile(i>=h&&s<=m) f[c]|=f[q[i]]<<s,s*=a[q[i--]];\n\t\t\t\tF|=f[c];q[++t]=c;while(h<=i) memo[++tp]=q[h++];\n\t\t\t}\n\t\t}}\n\t\tputs(f[q[t]][m]?\"Yes\":\"No\");\n\t}\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2028e",
      "PROBLEM_ID": "2028E",
      "PROBLEM_STATEMENT": "Alice is at the bottom of the rabbit hole! The rabbit hole can be modeled as a tree$^{\\text{\u2217}}$ which has an exit at vertex $1$, and Alice starts at some vertex $v$. She wants to get out of the hole, but unfortunately, the Queen of Hearts has ordered her execution.\n\nEach minute, a fair coin is flipped. If it lands heads, Alice gets to move to an adjacent vertex of her current location, and otherwise, the Queen of Hearts gets to pull Alice to an adjacent vertex of the Queen's choosing. If Alice ever ends up on any of the non-root leaves$^{\\text{\u2020}}$ of the tree, Alice loses.\n\nAssuming both of them move optimally, compute the probability that Alice manages to escape for every single starting vertex $1\\le v\\le n$. Since these probabilities can be very small, output them modulo $998\\,244\\,353$.\n\nFormally, let $M = 998\\,244\\,353$. It can be shown that the exact answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\n$^{\\text{\u2217}}$A tree is a connected simple graph which has $n$ vertices and $n-1$ edges.\n\n$^{\\text{\u2020}}$A leaf is a vertex that is connected to exactly one edge.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2\\le n\\le 2\\cdot 10^5$) \u2014 the number of vertices in the tree.\n\nThe $i$-th of the next $n - 1$ lines contains two integers $x_i$ and $y_i$ ($1 \\le x_i, y_i \\le n$ and $x_i \\neq y_i$) \u2014 the edges of the tree. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n$ integers on one line \u2014 the probabilities of Alice escaping starting from vertex $1, 2, \\ldots, n$. Since these probabilities can be very small, output them modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5\n\n1 2\n\n1 3\n\n2 4\n\n3 5\n\n9\n\n1 2\n\n2 3\n\n4 5\n\n5 6\n\n7 8\n\n8 9\n\n2 4\n\n5 7\n\n```\n\n#### Output #1\n\n```\n1 499122177 499122177 0 0\n1 499122177 0 332748118 166374059 0 443664157 720954255 0\n```\n\n### Note\n\nFor the first test case:\n\n1. Alice escapes from the root (vertex $1$) by definition with probability $1$.\n2. Alice immediately loses from vertices $4$ and $5$ since they are leaves.\n3. From the other two vertices, Alice escapes with probability $\\frac 12$ since the Queen will pull her to the leaves.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MAXN = 200000 + 5;\nconst int MOD = 998244353;\n\n// Precomputed modular inverses up to MAXN\nint inv[MAXN + 5];\n\nint add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\nint subi(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    return a;\n}\nint mul(ll a, ll b) {\n    ll r = (a * b) % MOD;\n    return int(r);\n}\nint modexp(int a, ll e = MOD - 2) {\n    ll r = 1, x = a;\n    while (e) {\n        if (e & 1) r = (r * x) % MOD;\n        x = (x * x) % MOD;\n        e >>= 1;\n    }\n    return int(r);\n}\n\nvector<int> adj[MAXN], children[MAXN];\nint parentArr[MAXN], depthArr[MAXN];\nint distToLeaf[MAXN], heavyChild[MAXN];\nint Pval[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    // Precompute inverses\n    inv[1] = 1;\n    for (int i = 2; i <= MAXN; i++) {\n        // Fermat's little theorem inversion in O(1) recurrence\n        inv[i] = MOD - ll(MOD / i) * inv[MOD % i] % MOD;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        // clear adjacency and children\n        for (int i = 1; i <= n; i++) {\n            adj[i].clear();\n            children[i].clear();\n            heavyChild[i] = -1;\n        }\n        // read tree\n        for (int i = 0; i < n - 1; i++) {\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        // BFS from root=1 to orient tree and build children[]\n        vector<int> order;\n        order.reserve(n);\n        {\n            deque<int> dq;\n            dq.push_back(1);\n            parentArr[1] = 0;\n            depthArr[1] = 0;\n            while (!dq.empty()) {\n                int v = dq.front();\n                dq.pop_front();\n                order.push_back(v);\n                for (int u: adj[v]) {\n                    if (u == parentArr[v]) continue;\n                    parentArr[u] = v;\n                    depthArr[u] = depthArr[v] + 1;\n                    children[v].push_back(u);\n                    dq.push_back(u);\n                }\n            }\n        }\n        // Compute distToLeaf[v]: minimal distance from v to any leaf in its subtree\n        for (int idx = n - 1; idx >= 0; idx--) {\n            int v = order[idx];\n            if (children[v].empty()) {\n                distToLeaf[v] = 0;\n            } else {\n                int best = INT_MAX;\n                for (int c: children[v]) {\n                    if (distToLeaf[c] < best)\n                        best = distToLeaf[c];\n                }\n                distToLeaf[v] = best + 1;\n            }\n        }\n        // Compute heavyChild[v]: child c with minimal distToLeaf[c]\n        for (int v: order) {\n            if (children[v].empty()) {\n                heavyChild[v] = -1;\n            } else {\n                int best = children[v][0], bd = distToLeaf[best];\n                for (int c: children[v]) {\n                    if (distToLeaf[c] < bd) {\n                        bd = distToLeaf[c];\n                        best = c;\n                    }\n                }\n                heavyChild[v] = best;\n            }\n        }\n        // Heavy-path decomposition DP\n        // Iterative stack of heavy-path heads\n        vector<int> st;\n        st.reserve(n);\n        vector<int> pathList;\n        pathList.reserve(n);\n        // Initialize probability for root\n        Pval[1] = 1;\n        st.push_back(1);\n        while (!st.empty()) {\n            int head = st.back();\n            st.pop_back();\n            // build the heavy path from head downwards\n            pathList.clear();\n            int v = head;\n            while (true) {\n                pathList.push_back(v);\n                int hc = heavyChild[v];\n                if (hc < 0) break;\n                v = hc;\n            }\n            int L = int(pathList.size()) - 1; // number of edges in path\n            if (head == 1) {\n                // boundary: P(head)=1, P(tail)=0\n                // P(i) = 1 - i/L  => (L-i)/L\n                // L>=1 always if n>=2\n                int invL = (L > 0 ? inv[L] : 0);\n                // head is index 0, Pval[1] already set =1\n                for (int i = 1; i <= L; i++) {\n                    // P at index i = (L - i) / L\n                    int vtx = pathList[i];\n                    Pval[vtx] = mul(L - i, invL);\n                }\n            } else {\n                // boundary: P(par) known, P(tail)=0\n                // P(i) = P(par) * (L-i)/(L+1)\n                int parv = parentArr[head];\n                int Ppar = Pval[parv];\n                int denom = L + 1;\n                int invD = inv[denom];\n                for (int i = 0; i <= L; i++) {\n                    int vtx = pathList[i];\n                    int coef = (L - i);\n                    Pval[vtx] = mul(mul(Ppar, coef), invD);\n                }\n            }\n            // push light children heads\n            for (int x: pathList) {\n                for (int c: children[x]) {\n                    if (c != heavyChild[x]) {\n                        st.push_back(c);\n                    }\n                }\n            }\n        }\n        // Output\n        for (int i = 1; i <= n; i++) {\n            cout << Pval[i] << (i == n ? '\\n' : ' ');\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2028d",
      "PROBLEM_ID": "2028D",
      "PROBLEM_STATEMENT": "Alice is playing cards with the Queen of Hearts, King of Hearts, and Jack of Hearts. There are $n$ different types of cards in their card game. Alice currently has a card of type $1$ and needs a card of type $n$ to escape Wonderland. The other players have one of each kind of card.\n\nIn this card game, Alice can trade cards with the three other players. Each player has different preferences for the $n$ types of cards, which can be described by permutations$^{\\text{\u2217}}$ $q$, $k$, and $j$ for the Queen, King, and Jack, respectively.\n\nA player values card $a$ more than card $b$ if for their permutation $p$, $p_a > p_b$. Then, this player is willing to trade card $b$ to Alice in exchange for card $a$. Alice's preferences are straightforward: she values card $a$ more than card $b$ if $a > b$, and she will also only trade according to these preferences.\n\nDetermine if Alice can trade up from card $1$ to card $n$ subject to these preferences, and if it is possible, give a possible set of trades to do it.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($2\\le n\\le 2\\cdot 10^5$) \u2014 the number of card types.\n\nThe next three lines contain the preferences of the Queen, King, and Jack respectively. Each of these lines contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($1\\le p_i\\le n$)\u00a0\u2014 a permutation corresponding to the player's preferences.\n\nThe sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, on the first line output a single string \"YES\" or \"NO\" (without the quotes) denoting whether Alice can trade up to card $n$.\n\nIf the first line was \"YES\", then on the next line output $k$ \u2014 the number of trades Alice will make. On the next $k$ lines output space separated a character $c\\in \\{\\texttt{q}, \\texttt{k}, \\texttt{j}\\}$ and integer $x$, denoting that Alice trades with player $c$ to get card $x$. It must be the case that on the $k$'th line, $x = n$. If there are multiple solutions, print any of them.\n\nYou can output this answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses. The same goes for the character $c$ denoting the player in the trade ($\\texttt{Q}, \\texttt{K}, \\texttt{J}$ will all be accepted alongside their lowercase variants).\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n3\n\n1 3 2\n\n2 1 3\n\n1 2 3\n\n4\n\n2 3 1 4\n\n1 2 3 4\n\n1 4 2 3\n\n```\n\n#### Output #1\n\n```\nYES\n2\nk 2\nq 3\nNO\n```\n\n### Note\n\nIn the first testcase, Alice can trade with the King to get card $2$. She can then trade with the Queen to get card $3$.\n\nIn the second testcase, even though Alice can trade with the Queen to get card $3$, with the King to get card $2$, and then with the Jack to get card $4$, this is not a valid solution since it doesn't respect Alice's preferences. We can show that there is no way for Alice to get to card $4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <vector> // Ensure vector is included\n\nusing namespace std;\n\n// Use -1 to represent negative infinity, as preference values are positive integers >= 1\nconst int INF_VAL = -1; \n\n// Node structure for segment tree\n// Stores the maximum preference value found in its range and the card index that achieves this maximum.\nstruct Node {\n    int max_val = INF_VAL; // Maximum preference value\n    int idx = 0; // Card index (1 to N) achieving max_val. 0 indicates invalid/empty node.\n};\n\n// Combine function for segment tree nodes. Merges results from left and right children.\n// Returns the node with the higher max_val. If values are equal, this implementation favors the left child \n// (which corresponds to potentially lower card indices, although exact tie-breaking depends on tree structure).\n// Any valid tie-breaking is fine as per problem statement asking for *any* valid path.\nNode combine(const Node& left, const Node& right) {\n    if (left.max_val >= right.max_val) {\n        return left;\n    } else {\n        return right;\n    }\n}\n\n// Segment tree class supporting point updates and range maximum queries.\n// Designed for 1-based indexing for elements (cards) and tree nodes.\nclass SegTree {\nprivate:\n    vector<Node> tree; // Stores the segment tree nodes\n    int N; // The maximum card index (problem size)\n    int tree_sz; // Base level size of the tree (power of 2 >= N)\n\n    // Recursive helper function for point update operation.\n    // node: current node index in tree vector (1-based)\n    // start, end: range covered by current node\n    // idx: index of the element to update (1 to N)\n    // val: new preference value for card 'card_idx'\n    // card_idx: the card index (1 to N) itself, stored along with the value\n    void update_recursive(int node, int start, int end, int idx, int val, int card_idx) {\n        if (start == end) { // Leaf node reached\n            tree[node] = {val, card_idx}; // Update leaf value and associated card index\n            return;\n        }\n        int mid = start + (end - start) / 2; // Find midpoint to decide which child to recurse into\n        if (idx <= mid) { // Update is in left child's range\n            update_recursive(2 * node, start, mid, idx, val, card_idx);\n        } else { // Update is in right child's range\n            update_recursive(2 * node + 1, mid + 1, end, idx, val, card_idx);\n        }\n        // After child update, recompute current node's value by combining children\n        tree[node] = combine(tree[2 * node], tree[2 * node + 1]);\n    }\n\n    // Recursive helper function for range maximum query operation.\n    // node: current node index\n    // start, end: range covered by current node\n    // L, R: query range (element indices 1 to N)\n    Node query_recursive(int node, int start, int end, int L, int R) {\n        // If current node's range is completely outside query range [L, R]\n        if (R < start || end < L) {\n             return {INF_VAL, 0}; // Return identity node signifying no overlap\n        }\n        // If current node's range is completely within query range [L, R]\n        if (L <= start && end <= R) {\n            return tree[node]; // Return this node's value\n        }\n        // Current node's range partially overlaps. Query children and combine results.\n        int mid = start + (end - start) / 2;\n        Node p1 = query_recursive(2 * node, start, mid, L, R); // Query left child\n        Node p2 = query_recursive(2 * node + 1, mid + 1, end, L, R); // Query right child\n        return combine(p1, p2); // Combine results\n    }\n\npublic:\n    // Constructor: initializes segment tree for 'n' elements (cards 1 to n)\n    SegTree(int n) {\n        N = n;\n        tree_sz = 1;\n        while(tree_sz < N) tree_sz *= 2; // Calculate required power-of-2 size\n        // Allocate memory for tree nodes. Size is 2 * tree_sz for 1-based node indexing.\n        tree.assign(2 * tree_sz, {INF_VAL, 0}); \n    }\n\n    // Public interface for updating the value at index 'idx' (1-based card index)\n    void update(int idx, int val, int card_idx) {\n         if (idx < 1 || idx > N) return; // Basic bounds check for card index\n         // Start recursive update from root node 1, covering range [1, tree_sz]\n         update_recursive(1, 1, tree_sz, idx, val, card_idx);\n    }\n\n    // Public interface for range maximum query over range [L, R] (1-based card indices)\n    Node query(int L, int R) {\n        // Validate query range\n        if (L > R || L < 1 || R < 1) return {INF_VAL, 0};\n        // Adjust query range to be within [1, N], the valid range of card indices\n        L = max(L, 1); \n        R = min(R, N); \n        if (L > R) return {INF_VAL, 0}; // Check again if range became invalid after adjustments\n\n        // Start recursive query from root node 1, covering range [1, tree_sz]\n        return query_recursive(1, 1, tree_sz, L, R);\n    }\n};\n\n// Structure to represent a trade made by Alice\nstruct Trade {\n    char player; // Player ('q', 'k', 'j') Alice traded with\n    int card; // The card Alice received in the trade\n};\n\n// Function to solve a single test case\nvoid solve() {\n    int n; // Number of card types\n    cin >> n;\n    vector<int> q(n + 1), k(n + 1), j(n + 1); // Store preference values (1-based index)\n    // Read preferences for Queen, King, Jack\n    for (int i = 1; i <= n; ++i) cin >> q[i];\n    for (int i = 1; i <= n; ++i) cin >> k[i];\n    for (int i = 1; i <= n; ++i) cin >> j[i];\n\n    // Create three segment trees, one for each player's preference permutation\n    SegTree tree_q(n);\n    SegTree tree_k(n);\n    SegTree tree_j(n);\n\n    // parent[i] stores {source_card_idx, player_char} indicating how card 'i' was obtained\n    // {0, '-'} signifies unreachable or the start node (card 1)\n    vector<pair<int, char>> parent(n + 1, {0, '-'}); \n    \n    // Initialize state: Alice starts with card 1. Mark card 1 as reachable in all trees.\n    // Update sets the preference value and card index for card 1.\n    tree_q.update(1, q[1], 1);\n    tree_k.update(1, k[1], 1);\n    tree_j.update(1, j[1], 1);\n    \n    // Iterate through potential cards 'b' Alice could obtain, from 2 to N\n    for (int b = 2; b <= n; ++b) {\n        // Query for the maximum preference value achieved by any reachable card 'a' < 'b' for each player\n        Node res_q = tree_q.query(1, b - 1);\n        Node res_k = tree_k.query(1, b - 1);\n        Node res_j = tree_j.query(1, b - 1);\n\n        int source_card = 0; // The card Alice would trade away (if a trade is possible)\n        char source_player = '-'; // The player Alice would trade with\n\n        // Check if Queen would trade card 'b' for some reachable card 'a'.\n        // Check Condition: max Q preference among reachable 'a' < 'b' must be greater than Q preference for 'b'.\n        // The check `res_q.idx != 0` ensures that a valid reachable card 'a' was actually found by the query.\n        if (res_q.idx != 0 && res_q.max_val > q[b]) { \n            source_card = res_q.idx; // 'a' is the card with max Q preference found\n            source_player = 'q';\n        } \n        // Check King similarly\n        else if (res_k.idx != 0 && res_k.max_val > k[b]) {\n            source_card = res_k.idx;\n            source_player = 'k';\n        } \n        // Check Jack similarly\n        else if (res_j.idx != 0 && res_j.max_val > j[b]) {\n            source_card = res_j.idx;\n            source_player = 'j';\n        }\n\n        // If a valid trade is found (source_card != 0)\n        if (source_card != 0) {\n            // Mark card 'b' as reachable by updating its status in the segment trees\n            // This makes 'b' available as a source card for future trades.\n            tree_q.update(b, q[b], b);\n            tree_k.update(b, k[b], b);\n            tree_j.update(b, j[b], b);\n            \n            // Record the parent information (trade details) for path reconstruction\n            parent[b] = {source_card, source_player};\n        }\n    }\n\n    // After checking all cards up to N, determine if the target card 'n' is reachable\n    if (parent[n].first != 0) { // Non-zero first element indicates 'n' has a predecessor, hence reachable.\n        cout << \"YES\" << endl;\n        vector<Trade> path; // To store the sequence of trades\n        int curr = n; // Start backtracking from card 'n'\n        // Reconstruct path using parent pointers until card 1 is reached (parent[1].first is 0)\n        while (parent[curr].first != 0) { \n            path.push_back({parent[curr].second, curr}); // Add trade to path\n            curr = parent[curr].first; // Move to the previous card in the path\n        }\n        reverse(path.begin(), path.end()); // Reverse path to get chronological order of trades\n        \n        cout << path.size() << endl; // Print number of trades\n        for (const auto& trade : path) {\n            // Print each trade: player character and the card Alice received\n            cout << trade.player << \" \" << trade.card << endl; \n        }\n    } else {\n        // Card 'n' was not reachable\n        cout << \"NO\" << endl;\n    }\n}\n\n// Main function: handles test cases and fast I/O setup\nint main() {\n    ios_base::sync_with_stdio(false); // Disable synchronization with C stdio for faster I/O\n    cin.tie(NULL); // Untie cin from cout\n    \n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        solve(); // Process each test case\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2027e2",
      "PROBLEM_ID": "2027E2",
      "PROBLEM_STATEMENT": "This is the hard version of this problem. The only difference is that you need to output the number of choices of games where Bob wins in this version, where the number of stones in each pile are not fixed. You must solve both versions to be able to hack.\n\nAlice and Bob are playing a familiar game where they take turns removing stones from $n$ piles. Initially, there are $x_i$ stones in the $i$-th pile, and it has an associated value $a_i$. A player can take $d$ stones away from the $i$-th pile if and only if both of the following conditions are met:\n\n- $1 \\le d \\le a_i$, and\n- $x \\, \\& \\, d = d$, where $x$ is the current number of stones in the $i$-th pile and $\\&$ denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND).\n\nThe player who cannot make a move loses, and Alice goes first.\n\nYou're given the $a_i$ values of each pile, but the number of stones in the $i$-th pile has not been determined yet. For the $i$-th pile, $x_i$ can be any integer between $1$ and $b_i$, inclusive. That is, you can choose an array $x_1, x_2, \\ldots, x_n$ such that the condition $1 \\le x_i \\le b_i$ is satisfied for all piles.\n\nYour task is to count the number of games where Bob wins if both players play optimally. Two games are considered different if the number of stones in any pile is different, i.e., the arrays of $x$ differ in at least one position.\n\nSince the answer can be very large, please output the result modulo $10^9 + 7$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains $n$ ($1 \\le n \\le 10^4$)\u00a0\u2014 the number of piles.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i < 2^{30}$).\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i < 2^{30}$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^4$.\n\n### Output\n\nOutput a single integer, the number of games where Bob wins, modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n3\n\n1 2 3\n\n3 2 2\n\n1\n\n13\n\n45\n\n5\n\n5 4 7 8 6\n\n4 4 5 5 5\n\n4\n\n6 4 8 8\n\n12 13 14 12\n\n3\n\n92856133 46637598 12345678\n\n29384774 73775896 87654321\n\n2\n\n65 12\n\n110 31\n\n4\n\n677810235 275091182 428565855 720629731\n\n74522416 889934149 3394714 230851724\n\n```\n\n#### Output #1\n\n```\n4\n4\n0\n6552\n722019507\n541\n665443265\n```\n\n### Note\n\nIn the first test case, no matter which values of $x_2$ and $x_3$ we choose, the second and third piles will always be chosen exactly once before no more stones can be taken from them. If $x_1 = 2$, then no stones can be taken from it, so Bob will make the last move. If $x_1 = 1$ or $x_1 = 3$, then exactly one move can be made on that pile, so Alice will make the last move. So Bob wins when $x = [2, 1, 1]$ or $x = [2, 1, 2]$ or $x = [2, 2, 1]$ or $x = [2, 2, 2]$.\n\nIn the second test case, Bob wins when $x_1 = 14$ or $x_1 = 30$ by removing $14 - k$ stones, where $k$ is the number of stones Alice removes on her turn. Bob also wins when $x_1 = 16$ or $x_1 = 32$ since Alice does not have any moves to begin with.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>pi;\n#define fi first\n#define se second\nconst int N=10005,mod=1e9+7;\nint n,a[N],b[N];\nll f[N][32],g[32],h[31][31][4][3][2];\nvoid calc(int x,int y) {\n    memset(h,0,sizeof(h)),memset(g,0,sizeof(g)),h[30][0][2][0][0]=1;\n    for(int i=29;~i;i--) {\n        int a=(x>>i&1),b=(y>>i&1);\n        for(int j=0;j<30-i;j++)for(int k=0;k<4;k++)for(int l=0;l<3;l++) {\n            for(int p=0;p<2;p++)if(h[i+1][j][k][l][p]) {\n                if(b)h[i][j][k|1][l][p|a]+=h[i+1][j][k][l][p];\n                else h[i][j][k][l][p|a]+=h[i+1][j][k][l][p];\n                if(!p&&!a)continue;\n                if(b||k%2)h[i][j+1][k&((!j)*2|1)][l==1?2:l][p]+=h[i+1][j][k][l][p];\n                else h[i][j?j+1:0][k][!j?0:(!l?1:2)][p]+=h[i+1][j][k][l][p];\n            }\n        }\n    }\n    for(int i=0;i<=30;i++)for(int j=0;j<4;j++)for(int k=0;k<3;k++)for(int l=0;l<2;l++)if(h[0][i][j][k][l]) {\n        if(!i||k==1)g[0]+=h[0][i][j][k][l];\n        else if((j&2)&&i%2==0)g[i-2]+=h[0][i][j][k][l];\n        else g[i]+=h[0][i][j][k][l];\n    }g[0]--;\n}\nvoid solve() {\n    cin>>n,f[0][0]=1;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    for(int i=1;i<=n;i++) {\n        cin>>b[i],calc(b[i],a[i]);\n        for(int j=0;j<32;j++){f[i][j]=0;for(int k=0;k<32;k++)f[i][j]=(f[i][j]+f[i-1][j^k]*g[k])%mod;}\n    }\n    cout<<f[n][0]<<'\\n';\n}\nint main() {\n\tios::sync_with_stdio(0),cin.tie(0);\n\tint tt;cin>>tt;\n    while(tt--)solve();\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2027d2",
      "PROBLEM_ID": "2027D2",
      "PROBLEM_STATEMENT": "This is the hard version of this problem. The only difference is that you need to also output the number of optimal sequences in this version. You must solve both versions to be able to hack.\n\nYou're given an array $a$ of length $n$, and an array $b$ of length $m$ ($b_i > b_{i+1}$ for all $1 \\le i < m$). Initially, the value of $k$ is $1$. Your aim is to make the array $a$ empty by performing one of these two operations repeatedly:\n\n- Type $1$\u00a0\u2014 If the value of $k$ is less than $m$ and the array $a$ is not empty, you can increase the value of $k$ by $1$. This does not incur any cost.\n- Type $2$\u00a0\u2014 You remove a non-empty prefix of array $a$, such that its sum does not exceed $b_k$. This incurs a cost of $m - k$.\n\nYou need to minimize the total cost of the operations to make array $a$ empty. If it's impossible to do this through any sequence of operations, output $-1$. Otherwise, output the minimum total cost of the operations, and the number of sequences of operations which yield this minimum cost modulo $10^9 + 7$.\n\nTwo sequences of operations are considered different if you choose a different type of operation at any step, or the size of the removed prefix is different at any step.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 3 \\cdot 10^5$, $\\boldsymbol{1 \\le n \\cdot m \\le 3 \\cdot 10^5}$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nThe third line of each test case contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le 10^9$).\n\nIt is also guaranteed that $b_i > b_{i+1}$ for all $1 \\le i < m$.\n\nIt is guaranteed that the sum of $\\boldsymbol{n \\cdot m}$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, if it's possible to make $a$ empty, then output two integers. The first should be the minimum total cost of the operations, and the second should be the number of sequences of operations which achieve this minimum cost, modulo $10^9 + 7$.\n\nIf there is no possible sequence of operations which makes $a$ empty, then output a single integer $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4 2\n\n9 3 4 3\n\n11 7\n\n1 2\n\n20\n\n19 18\n\n10 2\n\n2 5 2 1 10 3 2 9 9 6\n\n17 9\n\n10 11\n\n2 2 2 2 2 2 2 2 2 2\n\n20 18 16 14 12 10 8 6 4 2 1\n\n1 6\n\n10\n\n32 16 8 4 2 1\n\n```\n\n#### Output #1\n\n```\n1 3\n-1\n2 11\n10 42\n4 1\n```\n\n### Note\n\nIn the first test case, there are $3$ optimal sequences of operations which yield a total cost of $1$:\n\n- All $3$ sequences begin with a type $2$ operation, removing the prefix $[9]$ to make $a = [3, 4, 3]$, incurring a cost of $1$. Then, we perform a type $1$ operation to increase the value of $k$ by $1$. All subsequent operations now incur a cost of $0$.\n- One sequence continues by removing the prefixes $[3, 4]$ then $[3]$.\n- Another sequence continues by removing the prefixes $[3]$ then $[4, 3]$.\n- Another sequence continues by removing the prefixes $[3]$ then $[4]$ then $[3]$.\n\nIn the second test case, it's impossible to remove any prefix of the array since $a_1 > b_1$, so array $a$ cannot be made empty by any sequence of operations.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\n// Use long long for costs, potentially large values\nusing ll = long long;\n\n// Use constant for INF and MOD\n// Using 2e18 since maximum cost can be N*(M-1), roughly 9e10 which fits long long.\nconst ll INF = 2e18; \nconst int MOD = 1e9 + 7;\n\n// Node structure for segment tree storing minimum cost and count of ways\nstruct Node {\n    ll min_cost;\n    int count;\n\n    // Default constructor initializes to infinity cost, 0 ways\n    Node() : min_cost(INF), count(0) {}\n    // Parameterized constructor\n    Node(ll mc, int c) : min_cost(mc), count(c) {}\n};\n\n// Merge function for combining results from segment tree nodes\n// It finds the minimum cost and sums counts if costs are equal\nNode merge(Node left, Node right) {\n    if (left.min_cost < right.min_cost) {\n        return left;\n    } else if (right.min_cost < left.min_cost) {\n        return right;\n    } else {\n        // If costs are equal and not INF, sum counts modulo MOD\n        if (left.min_cost == INF) return Node(INF, 0); // Both are INF\n        // Add counts modulo MOD\n        return Node(left.min_cost, (left.count + right.count) % MOD);\n    }\n}\n\n// Segment tree update function\n// Updates the value at tree index `idx` (0-based)\n// `tree` is the segment tree vector, `tree_actual_size` is its power-of-2 base size\n// `node_idx`, `node_l`, `node_r` define the current node in recursion\nvoid update_tree(vector<Node>& tree, int tree_actual_size, int idx, Node val, int node_idx, int node_l, int node_r) {\n    // Check if index `idx` is outside the range [node_l, node_r] this node is responsible for\n     if (idx < node_l || idx > node_r) return; \n\n    // If we reached a leaf node\n    if (node_l == node_r) {\n         // Update the leaf node value if it's the target index\n         if (node_l == idx) { \n              tree[node_idx] = val;\n         }\n        return;\n    }\n\n    // Recursive step: determine which child to go to\n    int mid = node_l + (node_r - node_l) / 2;\n    if (idx <= mid) { // Go left\n        update_tree(tree, tree_actual_size, idx, val, 2 * node_idx, node_l, mid);\n    } else { // Go right\n        update_tree(tree, tree_actual_size, idx, val, 2 * node_idx + 1, mid + 1, node_r);\n    }\n    // Update the current node by merging results from its children\n    tree[node_idx] = merge(tree[2 * node_idx], tree[2 * node_idx + 1]);\n}\n\n// Segment tree query function\n// Queries the range `[l, r]` (0-based tree indices)\n// `tree` is the segment tree vector, `tree_actual_size` its base size\n// `node_idx`, `node_l`, `node_r` define the current node in recursion\nNode query_tree(const vector<Node>& tree, int tree_actual_size, int l, int r, int node_idx, int node_l, int node_r) {\n    // If query range is completely outside the current node's range\n    if (r < node_l || l > node_r || node_l > node_r) { \n        return Node(INF, 0); // Return identity element (INF cost)\n    }\n    // If current node's range is completely within the query range\n    if (l <= node_l && node_r <= r) {\n        return tree[node_idx]; // Return this node's value\n    }\n    \n    // Recursive step: query children and merge results\n    int mid = node_l + (node_r - node_l) / 2;\n    Node res_l = query_tree(tree, tree_actual_size, l, r, 2 * node_idx, node_l, mid);\n    Node res_r = query_tree(tree, tree_actual_size, l, r, 2 * node_idx + 1, mid + 1, node_r);\n    return merge(res_l, res_r); // Merge results from children\n}\n\n// Main logic function for each test case\nvoid solve() {\n    int n;\n    ll m_ll; // Use long long for m as input can be large\n    cin >> n >> m_ll;\n    int m = (int) m_ll; // Cast m to int for loops and indexing\n\n    vector<ll> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    vector<ll> b(m + 1); // Use 1-based indexing for b array\n    for (int i = 1; i <= m; ++i) {\n        cin >> b[i];\n    }\n\n    // Precompute prefix sums of array 'a'\n    vector<ll> P(n + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        P[i + 1] = P[i] + a[i];\n    }\n\n    // Early exit check: If the first element `a[0]` is greater than `b[1]`, \n    // it can never be removed since `b_k` is non-increasing with `k`.\n    if (n > 0 && a[0] > b[1]) {\n        cout << -1 << endl;\n        return;\n    }\n\n    // DP table: dp[i][k] stores {min_cost, count} for processing suffix a[i...n-1] (0-based)\n    // starting with value k. Problem uses 1-based indexing for array `a`, so dp state `i` corresponds to `a[i...n]`.\n    // Size `n+2` to handle indices up to `n+1` (base case).\n    vector<vector<Node>> dp(n + 2, vector<Node>(m + 1, Node(INF, 0)));\n    \n    // Storage for M segment trees, one for each k value.\n    vector<vector<Node>> trees_storage(m + 1);\n    // Stores the actual power-of-2 size for each segment tree's base.\n    vector<int> tree_actual_sizes(m+1); \n    \n    // The segment tree will cover indices corresponding to DP states `i` from 1 to n+1.\n    // Map problem state index `j` (1 to n+1) to segment tree index `j-1` (0 to n).\n    // Requires N = n+1 leaves in the segment tree.\n    int seg_tree_N = n + 1; \n\n    // Initialize DP base case and segment trees for each k\n    for(int k = 1; k <= m; ++k) {\n        // Base case: Processing an empty suffix (state n+1) costs 0, and there's 1 way (do nothing).\n        dp[n + 1][k] = Node(0, 1);\n        \n        // Determine power-of-2 size for segment tree\n        int current_tree_size = 1;\n        while(current_tree_size < seg_tree_N) current_tree_size *= 2;\n        // Allocate memory for segment tree nodes\n        trees_storage[k].assign(2 * current_tree_size, Node(INF, 0));\n        tree_actual_sizes[k] = current_tree_size;\n        \n        // Initialize segment tree with the base case value at the corresponding index.\n        // Problem state index n+1 maps to tree index n.\n        // Segment tree is 1-indexed for nodes, range is [0, tree_actual_size - 1].\n        update_tree(trees_storage[k], tree_actual_sizes[k], n, dp[n + 1][k], 1, 0, tree_actual_sizes[k] - 1); \n    }\n\n    // Fill DP table using bottom-up approach (i from n down to 1)\n    for (int i = n; i >= 1; --i) {\n        // Calculate DP states for k from m down to 1\n        for (int k = m; k >= 1; --k) {\n            \n            // Option 1: Use Type 1 operation - Increase k by 1 (if k < m).\n            // Cost is 0. The state becomes (i, k+1). Result is dp[i][k+1].\n            Node Res1 = (k < m) ? dp[i][k + 1] : Node(INF, 0); // If k=m, cannot increase.\n\n            // Option 2: Use Type 2 operation - Remove a prefix a[i...j-1] (1-based indices).\n            // Sum S = P[j-1] - P[i-1]. Condition S <= b[k]. Cost is m-k.\n            // State becomes (j, k). Find minimum cost among valid choices of j.\n            \n            ll current_P_i_minus_1 = P[i - 1]; // Prefix sum up to index i-1.\n            ll target_sum_limit = b[k] + current_P_i_minus_1; // Max allowed prefix sum value P[j-1].\n            \n            // Find the largest valid `j` such that P[j-1] <= target_sum_limit.\n            // `upper_bound` finds the first element P[idx] > target_sum_limit starting search from index i.\n            // The iterator `it` points to this element.\n            auto it = upper_bound(P.begin() + i, P.end(), target_sum_limit); \n            // `distance(P.begin(), it)` gives the index `idx` in P such that P[idx] is the first value > target_sum_limit.\n            // The valid range for `j` (problem index) is `[i+1, idx]`. So `j_max` is `idx`.\n            int j_max = distance(P.begin(), it); \n\n            Node Res2;\n            // Check if any valid prefix removal exists (need j >= i+1, so j_max must be at least i+1).\n            if (j_max < i + 1) { \n                 Res2 = Node(INF, 0); // No valid prefix removal possible.\n            } else {\n                 // Query the segment tree for state k over the range of possible next states `j`.\n                 // Problem state indices range [i+1, j_max]. Maps to tree indices [i, j_max-1].\n                 Node query_result = query_tree(trees_storage[k], tree_actual_sizes[k], i, j_max - 1, 1, 0, tree_actual_sizes[k] - 1);\n\n                 // If query returned INF cost, means no reachable states in range have finite cost.\n                 if (query_result.min_cost == INF) {\n                     Res2 = Node(INF, 0);\n                 } else {\n                     // Calculate total cost for this option: (cost of operation) + (min cost from next state).\n                     Res2.min_cost = (ll)(m - k) + query_result.min_cost;\n                     // Check for potential overflow towards INF value. This is crucial.\n                     if (Res2.min_cost < 0 || Res2.min_cost > INF) Res2.min_cost = INF; \n                     Res2.count = query_result.count; // Number of ways is inherited from the minimum cost states found.\n                 }\n            }\n\n            // Combine results from Option 1 (increase k) and Option 2 (remove prefix)\n            // The final dp[i][k] takes the minimum cost and sums ways if costs are equal.\n            dp[i][k] = merge(Res1, Res2);\n        }\n        \n        // After computing all dp[i][k] for the fixed `i`, update all M segment trees.\n        // This makes the results for state `i` available for future calculations (for smaller `i`).\n        for(int k=1; k<=m; ++k) {\n            // Update the segment tree for state k at tree index i-1 (corresponding to problem state i).\n            update_tree(trees_storage[k], tree_actual_sizes[k], i-1, dp[i][k], 1, 0, tree_actual_sizes[k] - 1);\n        }\n    }\n\n    // The final answer is the result for the initial state (i=1, k=1).\n    if (dp[1][1].min_cost >= INF) { // Check >= INF to be safe in case cost exactly equals INF.\n        cout << -1 << endl; // If minimum cost is INF, it's impossible.\n    } else {\n        // Output minimum cost and number of ways modulo MOD.\n        cout << dp[1][1].min_cost << \" \" << dp[1][1].count << endl;\n    }\n}\n\nint main() {\n    // Fast I/O settings\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        solve(); // Solve each test case\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2027d1",
      "PROBLEM_ID": "2027D1",
      "PROBLEM_STATEMENT": "This is the easy version of this problem. The only difference is that you only need to output the minimum total cost of operations in this version. You must solve both versions to be able to hack.\n\nYou're given an array $a$ of length $n$, and an array $b$ of length $m$ ($b_i > b_{i+1}$ for all $1 \\le i < m$). Initially, the value of $k$ is $1$. Your aim is to make the array $a$ empty by performing one of these two operations repeatedly:\n\n- Type $1$\u00a0\u2014 If the value of $k$ is less than $m$ and the array $a$ is not empty, you can increase the value of $k$ by $1$. This does not incur any cost.\n- Type $2$\u00a0\u2014 You remove a non-empty prefix of array $a$, such that its sum does not exceed $b_k$. This incurs a cost of $m - k$.\n\nYou need to minimize the total cost of the operations to make array $a$ empty. If it's impossible to do this through any sequence of operations, output $-1$. Otherwise, output the minimum total cost of the operations.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 3 \\cdot 10^5$, $\\boldsymbol{1 \\le n \\cdot m \\le 3 \\cdot 10^5}$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nThe third line of each test case contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le 10^9$).\n\nIt is also guaranteed that $b_i > b_{i+1}$ for all $1 \\le i < m$.\n\nIt is guaranteed that the sum of $\\boldsymbol{n \\cdot m}$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, if it's possible to make $a$ empty, then output the minimum total cost of the operations.\n\nIf there is no possible sequence of operations which makes $a$ empty, then output a single integer $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4 2\n\n9 3 4 3\n\n11 7\n\n1 2\n\n20\n\n19 18\n\n10 2\n\n2 5 2 1 10 3 2 9 9 6\n\n17 9\n\n10 11\n\n2 2 2 2 2 2 2 2 2 2\n\n20 18 16 14 12 10 8 6 4 2 1\n\n1 6\n\n10\n\n32 16 8 4 2 1\n\n```\n\n#### Output #1\n\n```\n1\n-1\n2\n10\n4\n```\n\n### Note\n\nIn the first test case, one optimal sequence of operations which yields a total cost of $1$ is as follows:\n\n- Perform an operation of type $2$. Choose the prefix to be $[9]$. This incurs a cost of $1$.\n- Perform an operation of type $1$. The value of $k$ is now $2$. This incurs no cost.\n- Perform an operation of type $2$. Choose the prefix to be $[3, 4]$. This incurs a cost of $0$.\n- Perform an operation of type $2$. Choose the prefix to be $[3]$. This incurs a cost of $0$.\n- The array $a$ is now empty, and the total cost of all operations is $1$.\n\nIn the second test case, it's impossible to remove any prefix of the array since $a_1 > b_1$, so array $a$ cannot be made empty by any sequence of operations.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <map>\n#include <functional> // Needed for std::function for completeness, though not strictly used here\n\nusing namespace std;\n\n// Define long long for potentially large costs and prefix sums\ntypedef long long ll;\n\n// Use a sufficiently large value for infinity. \n// Needs to be larger than max possible cost (n * m could be up to 3e5 * 3e5? No, n*m <= 3e5. Max cost N*M is okay. Max prefix sum up to N*1e9 = 3e14. Needs LL.)\n// Max cost could be N * M = 3e5 * 3e5 ~ 9e10 if N,M are large? Constraint is n*m <= 3e5. \n// Max cost is roughly n * m (max ops * max cost/op). If n=3e5, m=1, cost is N*(M-1) = 3e5*0 = 0? No, cost is m-k. Max k=m. Min k=1. Max cost is m-1.\n// Max total cost might be n*(m-1), could be 3e5 * 3e5? No, N*M constraint. Let N=sqrt(3e5), M=sqrt(3e5). N~550. N*(M-1) ~ 550*550 ~ 3e5. Fits LL.\n// Let's use 4e18 which is safe for additions as well.\nconst ll INF = 4e18; \n\n// Structure for segment tree node, storing the minimum value in its range\nstruct SegTreeNode {\n    ll min_val;\n};\n\n// Global variable for the number of leaves in the segment tree,\n// determined by the number of unique prefix sums after coordinate compression.\nint N_leaves; \n\n// Segment tree build function (recursive)\n// Initializes nodes with INF. Operates on a specific tree vector `tree_k`.\n// `node`: current node index (1-based).\n// `L`, `R`: range of leaf indices covered by this node.\nvoid build_k(vector<SegTreeNode>& tree_k, int node, int L, int R) {\n    // Basic bounds check to prevent out-of-bounds access\n    if (node >= tree_k.size()) return; \n\n    if (L == R) { // Leaf node\n        tree_k[node] = {INF}; // Initialize leaf with infinity\n        return;\n    }\n    \n    int M = L + (R - L) / 2; // Midpoint for splitting range\n    // Recursively build left and right children\n    build_k(tree_k, 2 * node, L, M);\n    build_k(tree_k, 2 * node + 1, M + 1, R);\n    \n    // Combine results: current node's minimum is the minimum of its children\n    tree_k[node].min_val = INF; // Start with INF\n    // Check child bounds before accessing\n    if (2 * node < tree_k.size()) \n        tree_k[node].min_val = min(tree_k[node].min_val, tree_k[2 * node].min_val);\n    if (2 * node + 1 < tree_k.size()) \n        tree_k[node].min_val = min(tree_k[node].min_val, tree_k[2 * node + 1].min_val);\n}\n\n// Segment tree update function (recursive)\n// Updates the leaf corresponding to 'pos' (compressed index) with the minimum of its current value and 'val'.\n// Propagates the change up the tree.\nvoid update_k(vector<SegTreeNode>& tree_k, int node, int L, int R, int pos, ll val) {\n    // Bounds check\n     if (node >= tree_k.size()) return; \n\n    if (L == R) { // Leaf node reached\n        tree_k[node].min_val = min(tree_k[node].min_val, val); // Update with minimum\n        return;\n    }\n    \n    int M = L + (R - L) / 2; // Midpoint\n    // Recurse into the appropriate child\n    if (pos <= M) { \n        update_k(tree_k, 2 * node, L, M, pos, val);\n    } else { \n        update_k(tree_k, 2 * node + 1, M + 1, R, pos, val);\n    }\n    \n    // Update current node's value based on its children after the recursive update\n    tree_k[node].min_val = INF; // Recompute minimum\n    if (2 * node < tree_k.size()) \n        tree_k[node].min_val = min(tree_k[node].min_val, tree_k[2 * node].min_val);\n    if (2 * node + 1 < tree_k.size()) \n        tree_k[node].min_val = min(tree_k[node].min_val, tree_k[2 * node + 1].min_val);\n}\n\n// Segment tree query function (recursive)\n// Returns the minimum value in the range [qL, qR] (query range of compressed indices).\nll query_k(const vector<SegTreeNode>& tree_k, int node, int L, int R, int qL, int qR) {\n    // Check if node index is valid, if node range is completely outside query range, or if query range is invalid\n    if (node >= tree_k.size() || R < qL || L > qR || qL > qR) { \n        return INF; // Return infinity if no overlap or invalid query/node\n    }\n    // Check if node range is fully contained within query range\n    if (qL <= L && R <= qR) {\n        return tree_k[node].min_val; // Return the precomputed minimum for this node\n    }\n\n    int M = L + (R - L) / 2; // Midpoint\n    ll left_min = INF, right_min = INF;\n\n    // Recursively query the left and right children\n    left_min = query_k(tree_k, 2 * node, L, M, qL, qR);\n    right_min = query_k(tree_k, 2 * node + 1, M + 1, R, qL, qR);\n\n    // Return the minimum result found in the relevant children\n    return min(left_min, right_min);\n}\n\nvoid solve() {\n    int n;\n    ll m_ll; // Use long long for m, as it's used in cost calculation m-k\n    cin >> n >> m_ll;\n    int m = (int)m_ll; // Cast m to int for loop bounds etc., original ll needed for cost\n\n    vector<ll> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<ll> b(m + 1); // Use 1-based indexing for b array as per problem\n    for (int i = 1; i <= m; ++i) {\n        cin >> b[i];\n    }\n\n    // Calculate prefix sums of array a\n    vector<ll> S(n + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        S[i + 1] = S[i] + a[i];\n    }\n\n    // Coordinate compression for prefix sums to handle potentially large values\n    vector<ll> unique_S = S; // Copy prefix sums\n    sort(unique_S.begin(), unique_S.end()); // Sort\n    // Remove duplicates\n    unique_S.erase(unique(unique_S.begin(), unique_S.end()), unique_S.end()); \n    \n    // Map original prefix sum values to their compressed indices (0 to N_leaves-1)\n    map<ll, int> S_to_idx; \n    for (int i = 0; i < unique_S.size(); ++i) {\n        S_to_idx[unique_S[i]] = i;\n    }\n    \n    N_leaves = unique_S.size(); // Number of unique prefix sums determines segment tree leaves\n    \n    // Determine the size needed for the segment tree array (a power of 2 >= N_leaves)\n    int N_pow2 = 1;\n    while(N_pow2 < N_leaves) N_pow2 *= 2;\n    // Total nodes in the segment tree array (using 1-based indexing typically requires 2*N_pow2)\n    int tree_total_nodes = 2 * N_pow2; \n\n    // Initialize m segment trees, one for each possible value of k\n    vector<vector<SegTreeNode>> trees(m + 1, vector<SegTreeNode>(tree_total_nodes));\n\n    // Build each segment tree, initializing all node values to INF\n    for(int k = 1; k <= m; ++k) {\n        // The range [0, N_pow2-1] covers all possible leaf indices needed.\n        build_k(trees[k], 1, 0, N_pow2 - 1); \n    }\n\n    // DP table: dp[i][k] stores the minimum cost to remove the prefix a[1...i] \n    // such that the current value of k is exactly k after the removal.\n    vector<vector<ll>> dp(n + 1, vector<ll>(m + 1, INF));\n    \n    // Base case: 0 elements removed (prefix of length 0). The cost is 0.\n    // From this state, we can use Type 1 operations (cost 0) to reach any k >= 1.\n    for (int k = 1; k <= m; ++k) {\n        dp[0][k] = 0; // Minimum cost to remove 0 elements ending with value k is 0\n        // Update the segment tree for k: state (j=0, k) has cost 0. S[0]=0.\n        update_k(trees[k], 1, 0, N_pow2 - 1, S_to_idx[S[0]], 0);\n    }\n\n    // Fill the DP table iteratively\n    for (int i = 1; i <= n; ++i) { // Iterate through prefix lengths i from 1 to n\n        for (int k = 1; k <= m; ++k) { // Iterate through possible k values from 1 to m\n            \n            // Option 1: Transition from state (i, k-1) using a Type 1 operation (increase k).\n            // This happens after removing prefix a[1...i] using some k', then potentially increasing k.\n            ll cost1 = INF;\n            if (k > 1) {\n                cost1 = dp[i][k - 1]; // Cost does not increase for Type 1 operation\n            }\n\n            // Option 2: Transition from a previous state (j, k) using a Type 2 operation.\n            // This means we removed prefix a[1...j] ending with k, then removed a[j+1...i] using k.\n            // Condition: sum(a[j+1...i]) <= b[k]  =>  S[i] - S[j] <= b[k]  =>  S[j] >= S[i] - b[k].\n            ll min_prev_cost = INF;\n            ll threshold = S[i] - b[k]; // Minimum required value for S[j]\n            \n            // Find the compressed index corresponding to the threshold value.\n            // We need the smallest index `idx_T` such that `unique_S[idx_T] >= threshold`.\n            auto it = lower_bound(unique_S.begin(), unique_S.end(), threshold);\n            int idx_T = distance(unique_S.begin(), it); // `lower_bound` gives iterator, distance gives index\n\n            // If such a prefix sum S[j] exists (idx_T is within the bounds of unique_S indices)\n            if (idx_T < N_leaves) { \n                 // Query the segment tree for 'k' to find the minimum cost among all valid previous states (j, k).\n                 // The query range is [idx_T, N_leaves-1], covering all compressed indices >= idx_T.\n                 min_prev_cost = query_k(trees[k], 1, 0, N_pow2 - 1, idx_T, N_leaves - 1);\n            }\n\n            ll cost2 = INF;\n            // If a valid previous state (j, k) was found (min_prev_cost is not INF)\n            if (min_prev_cost != INF) {\n                 cost2 = min_prev_cost + (m_ll - k); // Add the cost of the Type 2 operation (m-k)\n            }\n\n            // The minimum cost to reach state (i, k) is the minimum of the two options.\n            dp[i][k] = min(cost1, cost2);\n        }\n        \n        // After computing dp[i][k] for all k for the current prefix length i,\n        // update the segment trees. This makes the costs for states ending at index i \n        // available for future calculations (for i' > i).\n        for (int k = 1; k <= m; ++k) {\n            // Only update if a valid path (cost != INF) to state (i, k) was found.\n            if (dp[i][k] != INF) {\n                 // Update segment tree 'k' at the compressed index corresponding to S[i] \n                 // with the calculated minimum cost dp[i][k].\n                 update_k(trees[k], 1, 0, N_pow2 - 1, S_to_idx[S[i]], dp[i][k]);\n            }\n        }\n    }\n\n    // The final answer is the minimum cost to remove the entire array (prefix a[1...n]).\n    // This can be achieved ending with any value of k.\n    ll final_ans = INF;\n    for (int k = 1; k <= m; ++k) {\n        final_ans = min(final_ans, dp[n][k]); // Find minimum across all possible final k values\n    }\n\n    // Output the result\n    if (final_ans == INF) {\n        cout << -1 << \"\\n\"; // If INF, it's impossible to clear the array\n    } else {\n        cout << final_ans << \"\\n\"; // Otherwise, output the minimum cost\n    }\n}\n\nint main() {\n    // Optimize standard I/O operations for speed\n    ios_base::sync_with_stdio(false); \n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        solve(); // Solve each test case\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2027b",
      "PROBLEM_ID": "2027B",
      "PROBLEM_STATEMENT": "Stalin Sort is a humorous sorting algorithm designed to eliminate elements which are out of place instead of bothering to sort them properly, lending itself to an $\\mathcal{O}(n)$ time complexity.\n\nIt goes as follows: starting from the second element in the array, if it is strictly smaller than the previous element (ignoring those which have already been deleted), then delete it. Continue iterating through the array until it is sorted in non-decreasing order. For example, the array $[1, 4, 2, 3, 6, 5, 5, 7, 7]$ becomes $[1, 4, 6, 7, 7]$ after a Stalin Sort.\n\nWe define an array as vulnerable if you can sort it in non-increasing order by repeatedly applying a Stalin Sort to any of its subarrays$^{\\text{\u2217}}$, as many times as is needed.\n\nGiven an array $a$ of $n$ integers, determine the minimum number of integers which must be removed from the array to make it vulnerable.\n\n$^{\\text{\u2217}}$An array $a$ is a subarray of an array $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 500$)\u00a0\u2014 the number of test cases. This is followed by descriptions of the test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2000$)\u00a0\u2014 the size of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of integers which must be removed from the array to make it vulnerable.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n7\n\n3 6 4 9 2 5 2\n\n5\n\n5 4 4 2 2\n\n8\n\n2 2 4 4 6 6 10 10\n\n1\n\n1000\n\n9\n\n6 8 9 10 12 9 7 5 4\n\n7\n\n300000000 600000000 400000000 900000000 200000000 400000000 200000000\n\n```\n\n#### Output #1\n\n```\n2\n0\n6\n0\n4\n2\n```\n\n### Note\n\nIn the first test case, the optimal answer is to remove the numbers $3$ and $9$. Then we are left with $a = [6, 4, 2, 5, 2]$. To show this array is vulnerable, we can first apply a Stalin Sort on the subarray $[4, 2, 5]$ to get $a = [6, 4, 5, 2]$ and then apply a Stalin Sort on the subarray $[6, 4, 5]$ to get $a = [6, 2]$, which is non-increasing.\n\nIn the second test case, the array is already non-increasing, so we don't have to remove any integers.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic int16_t LessCount[2005][2005];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    if (!(cin >> t)) return 0;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<long long> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        // Precompute LessCount[i][j]: for i<j, count of k in (i,j) with a[k] < a[i]\n        for (int i = 0; i < n; i++) {\n            int ct = 0;\n            for (int j = i + 1; j < n; j++) {\n                LessCount[i][j] = ct;\n                if (a[j] < a[i]) {\n                    ct++;\n                }\n            }\n        }\n        // Precompute tailCover[j]: count of k>j with a[k] < a[j]\n        vector<int> tailCover(n);\n        for (int j = 0; j < n; j++) {\n            int ct = 0;\n            for (int k = j + 1; k < n; k++) {\n                if (a[k] < a[j]) ct++;\n            }\n            tailCover[j] = ct;\n        }\n        // DP: dp[j] = max covered count in [p1..j], ending with j in S_post\n        vector<int> dp(n, 0);\n        int bestClosure = 0;\n        for (int j = 0; j < n; j++) {\n            // start new sequence at j\n            dp[j] = 1;\n            // extend from any i<j with a[i] >= a[j]\n            for (int i = 0; i < j; i++) {\n                if (a[i] >= a[j]) {\n                    // dp[i] covers up to i, plus covered in (i,j), plus j itself\n                    int val = dp[i] + LessCount[i][j] + 1;\n                    if (val > dp[j]) dp[j] = val;\n                }\n            }\n            // closure size if sequence ends at j: dp[j] + tail coverage after j\n            int closureSize = dp[j] + tailCover[j];\n            if (closureSize > bestClosure) bestClosure = closureSize;\n        }\n        // Minimum pre-deletions = total n - max covered\n        int answer = n - bestClosure;\n        cout << answer << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2027a",
      "PROBLEM_ID": "2027A",
      "PROBLEM_STATEMENT": "You are coloring an infinite square grid, in which all cells are initially white. To do this, you are given $n$ stamps. Each stamp is a rectangle of width $w_i$ and height $h_i$.\n\nYou will use each stamp exactly once to color a rectangle of the same size as the stamp on the grid in black. You cannot rotate the stamp, and for each cell, the stamp must either cover it fully or not cover it at all. You can use the stamp at any position on the grid, even if some or all of the cells covered by the stamping area are already black.\n\nWhat is the minimum sum of the perimeters of the connected regions of black squares you can obtain after all the stamps have been used?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$).\n\nThe $i$-th of the next $n$ lines contains two integers $w_i$ and $h_i$ ($1 \\le w_i, h_i \\le 100$).\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum sum of the perimeters of the connected regions of black squares you can obtain after all the stamps have been used.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n5\n\n1 5\n\n2 4\n\n3 3\n\n4 2\n\n5 1\n\n3\n\n2 2\n\n1 1\n\n1 2\n\n1\n\n3 2\n\n3\n\n100 100\n\n100 100\n\n100 100\n\n4\n\n1 4\n\n2 3\n\n1 5\n\n3 2\n\n```\n\n#### Output #1\n\n```\n20\n8\n10\n400\n16\n```\n\n### Note\n\nIn the first test case, the stamps can be used as shown on the left. Each stamp is highlighted in its own color for clarity.\n\n![](https://espresso.codeforces.com/e5cb3a60d3f4edae5433009de214eeef86376690.png)\n\nAfter all these stamps are used, there is one black region (as shown on the right), and its perimeter is $20$. It can be shown that there is no way of using the stamps that yields a lower total perimeter.\n\nIn the second test case, the second and third stamps can be used entirely inside the first one, so the minimum perimeter is equal to $8$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<pair<int, int>> stamps(n);\n        int max_w = 0, max_h = 0;\n        int sum_perimeter = 0;\n        for (int i = 0; i < n; ++i) {\n            int w, h;\n            cin >> w >> h;\n            stamps[i] = {w, h};\n            max_w = max(max_w, w);\n            max_h = max(max_h, h);\n            sum_perimeter += 2 * (w + h);\n        }\n        int larger_perimeter = 2 * (max_w + max_h);\n        int min_perimeter = min(sum_perimeter, larger_perimeter);\n        cout << min_perimeter << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2026f",
      "PROBLEM_ID": "2026F",
      "PROBLEM_STATEMENT": "In the Bermart chain of stores, a variety of ice cream is sold. Each type of ice cream has two parameters: price and tastiness.\n\nInitially, there is one store numbered $1$, which sells nothing. You have to process $q$ queries of the following types:\n\n- $1~x$\u00a0\u2014 a new store opens, that sells the same types of ice cream as store $x$. It receives the minimum available positive index. The order of the types of ice cream in the new store is the same as in store $x$.\n- $2~x~p~t$\u00a0\u2014 a type of ice cream with price $p$ and tastiness $t$ becomes available in store $x$.\n- $3~x$\u00a0\u2014 a type of ice cream that was available the longest (appeared the earliest) in store $x$ is removed.\n- $4~x~p$\u00a0\u2014 for store $x$, find the maximum total tastiness of a subset of types of ice cream that are sold there, such that the total price does not exceed $p$ (each type can be used in the subset no more than once).\n\n### Input\n\nThe first line contains a single integer $q$ ($1 \\le q \\le 3 \\cdot 10^4$)\u00a0\u2014 the number of queries.\n\nEach of the following $q$ lines contains a query in the format described in the statement:\n\n- $1~x$;\n- $2~x~p~t$ ($1 \\le p, t \\le 2000$);\n- $3~x$;\n- $4~x~p$ ($1 \\le p \\le 2000$).\n\nAdditional constraints on the input data:\n\n- $x$ in each query does not exceed the current number of stores (that is, $1$ plus the number of type $1$ queries);\n- query type $3$ is not applied to a store that has no types of ice cream;\n- there is at least one query of type $4$.\n\n### Output\n\nFor each query of type $4$, output a single integer\u00a0\u2014 for store $x$, find the maximum total tastiness of a subset of types of ice cream that are sold there, such that the total price does not exceed $p$ (each type can be used in the subset no more than once).\n\n### Example\n\n#### Input #1\n\n```\n\n12\n\n2 1 5 7\n\n2 1 3 4\n\n4 1 4\n\n4 1 8\n\n4 1 2\n\n1 1\n\n2 2 4 10\n\n4 1 9\n\n4 2 9\n\n3 1\n\n4 1 9\n\n4 2 9\n\n```\n\n#### Output #1\n\n```\n4\n11\n0\n11\n17\n4\n17\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nconst int S=2e3;\nconst int N=3e4+5;\nint n;\nstruct no{\n\tint op,p,t,id;\n};\nvector<no> a[N];\nstruct NO{\n\tint p,t;\n};\nstruct ST{\n\tint f[N][S+5],top;\n\tNO a[N];\n\tvoid pop(){top--;}\n\tvoid push(int cs,int w){\n\t\ttop++;a[top]={cs,w};\n\t\tmemcpy(f[top],f[top-1],sizeof(f[0]));\n\t\tfor(int i=S;i>=cs;i--) f[top][i]=max(f[top][i],f[top][i-cs]+w);\n\t\tfor(int i=1;i<=S;i++) f[top][i]=max(f[top][i],f[top][i-1]);\n\t}\n}s1,s2;\nint res[N];\nvoid pop(ST &s1,ST &s2){\n\tif(!s1.top){\n\t\tint d1=(s2.top+1)/2,d2=s2.top;\n\t\tfor(int i=d1;i>=1;i--) s1.push(s2.a[i].p,s2.a[i].t);\n\t\ts2.top=0;\n\t\tfor(int i=d1+1;i<=d2;i++) s2.push(s2.a[i].p,s2.a[i].t);\n\t}\n}\nvoid dfs(int u){\n\tfor(auto &tmp:a[u]){\n\t\tint op=tmp.op,p=tmp.p,t=tmp.t,id=tmp.id;\n\t\tif(op==1) dfs(p);\n\t\telse if(op==2) s2.push(p,t);\n\t\telse if(op==3){\n\t\t\tpop(s1,s2);\n\t\t\ttmp.p=s1.a[s1.top].p;\n\t\t\ttmp.t=s1.a[s1.top].t;\n\t\t\ts1.pop();\n\t\t}\n\t\telse{\n\t\t\tint ans=0;\n\t\t\tfor(int i=0;i<=p;i++) ans=max(ans,s1.f[s1.top][i]+s2.f[s2.top][p-i]);\n\t\t\tres[id]=ans;\n\t\t}\n\t}\n\treverse(a[u].begin(),a[u].end());\n\tfor(auto tmp:a[u]){\n\t\tint op=tmp.op,p=tmp.p,t=tmp.t;\n\t\tif(op==2) pop(s2,s1),s2.pop();\n\t\telse if(op==3) s1.push(p,t);\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tmemset(res,-1,sizeof(res));\n\tcin>>n;\n\tint now=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint op,x,p=0,t=0;cin>>op>>x;\n\t\tif(op==1){p=++now;}\n\t\telse if(op==2) cin>>p>>t;\n\t\telse if(op==4) cin>>p;\n\t\ta[x].push_back({op,p,t,i});\n\t}\n\tdfs(1);\n\tfor(int i=1;i<=n;i++) if(~res[i]) cout<<res[i]<<'\\n';\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2026e",
      "PROBLEM_ID": "2026E",
      "PROBLEM_STATEMENT": "Given an integer array $a$ of size $n$.\n\nLet's define the value of the array as its size minus the number of set bits in the bitwise OR of all elements of the array.\n\nFor example, for the array $[1, 0, 1, 2]$, the bitwise OR is $3$ (which contains $2$ set bits), and the value of the array is $4-2=2$.\n\nYour task is to calculate the maximum possible value of some subsequence of the given array.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i < 2^{60}$).\n\n### Output\n\nFor each test case, print the maximum possible value of some subsequence of the given array.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\n0 0 0\n\n4\n\n1 0 1 2\n\n1\n\n5\n\n8\n\n7 1 48 14 13 8 7 6\n\n```\n\n#### Output #1\n\n```\n3\n2\n0\n3\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int to, cap, rev;\n};\n\nstruct MaxFlow {\n    int N;\n    vector<vector<Edge>> G;\n    vector<int> level, iter;\n\n    MaxFlow(int n) : N(n), G(n), level(n), iter(n) {}\n\n    // add edge u->v with capacity c\n    void add_edge(int u, int v, int c) {\n        G[u].push_back(Edge{v, c, (int)G[v].size()});\n        G[v].push_back(Edge{u, 0, (int)G[u].size() - 1});\n    }\n\n    // build level graph via BFS\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (auto &e : G[u]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[u] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    // send flow in level graph by DFS\n    int dfs(int u, int t, int f) {\n        if (u == t) return f;\n        for (int &i = iter[u]; i < (int)G[u].size(); ++i) {\n            Edge &e = G[u][i];\n            if (e.cap > 0 && level[u] < level[e.to]) {\n                int ret = dfs(e.to, t, min(f, e.cap));\n                if (ret > 0) {\n                    e.cap -= ret;\n                    G[e.to][e.rev].cap += ret;\n                    return ret;\n                }\n            }\n        }\n        return 0;\n    }\n\n    // compute max flow from s to t\n    int max_flow(int s, int t) {\n        int flow = 0, inf_flow = numeric_limits<int>::max();\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) break;\n            fill(iter.begin(), iter.end(), 0);\n            int f;\n            while ((f = dfs(s, t, inf_flow)) > 0) {\n                flow += f;\n            }\n        }\n        return flow;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<unsigned long long> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n\n        // We construct a flow network to solve a maximum closure problem:\n        // nodes: source (0), elements [1..n], bits [n+1..n+60], sink (n+61)\n        const int B = 60;\n        int src = 0;\n        int elem_offset = 1;\n        int bit_offset = elem_offset + n;\n        int sink = bit_offset + B;\n        int N = sink + 1;\n\n        MaxFlow mf(N);\n        // INF capacity for \"infinite\" edges\n        int INF_CAP = n + 1;  // > 1 ensures closure constraint\n\n        // source -> element edges (gain +1 for each element)\n        for (int i = 0; i < n; i++) {\n            mf.add_edge(src, elem_offset + i, 1);\n            // element -> bit edges with infinite capacity\n            for (int b = 0; b < B; b++) {\n                if ((a[i] >> b) & 1ULL) {\n                    mf.add_edge(elem_offset + i, bit_offset + b, INF_CAP);\n                }\n            }\n        }\n        // bit -> sink edges (cost 1 for each activated bit)\n        for (int b = 0; b < B; b++) {\n            mf.add_edge(bit_offset + b, sink, 1);\n        }\n\n        // max flow = cost of minimum cut = sum(pos_weights) - max_closure_value\n        int flow = mf.max_flow(src, sink);\n        int answer = n - flow;  // sum of element weights = n\n        cout << answer << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2026d",
      "PROBLEM_ID": "2026D",
      "PROBLEM_STATEMENT": "You are given a sequence of integers $[a_1, a_2, \\dots, a_n]$. Let $s(l,r)$ be the sum of elements from $a_l$ to $a_r$ (i.\u2009e. $s(l,r) = \\sum\\limits_{i=l}^{r} a_i$).\n\nLet's construct another sequence $b$ of size $\\frac{n(n+1)}{2}$ as follows: $b = [s(1,1), s(1,2), \\dots, s(1,n), s(2,2), s(2,3), \\dots, s(2,n), s(3,3), \\dots, s(n,n)]$.\n\nFor example, if $a = [1, 2, 5, 10]$, then $b = [1, 3, 8, 18, 2, 7, 17, 5, 15, 10]$.\n\nYou are given $q$ queries. During the $i$-th query, you are given two integers $l_i$ and $r_i$, and you have to calculate $\\sum \\limits_{j=l_i}^{r_i} b_j$.\n\n### Input\n\nThe first line contains one integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10 \\le a_i \\le 10$).\n\nThe third line contains one integer $q$ ($1 \\le q \\le 3 \\cdot 10^5$).\n\nThen $q$ lines follow, the $i$-th of them contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le \\frac{n(n+1)}{2}$).\n\n### Output\n\nPrint $q$ integers, the $i$-th of which should be equal to $\\sum \\limits_{j=l_i}^{r_i} b_j$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1 2 5 10\n\n15\n\n1 1\n\n1 2\n\n1 3\n\n1 4\n\n1 5\n\n1 10\n\n5 10\n\n6 10\n\n2 8\n\n3 4\n\n3 10\n\n3 8\n\n5 6\n\n5 5\n\n1 8\n\n```\n\n#### Output #1\n\n```\n1\n4\n12\n30\n32\n86\n56\n54\n60\n26\n82\n57\n9\n2\n61\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nsigned main() {\n    int n;\n    cin >> n;\n    vector<int> a(n + 1);\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    vector<int> sum1(n + 1), sum2(n + 1);\n    for (int i = 1; i <= n; i++) {\n        sum1[i] = sum1[i - 1] + a[i];\n        sum2[i] = sum2[i - 1] + sum1[i];\n    }\n    vector<int> duan(n + 1);\n    for (int i = 1; i <= n; i++) duan[i] = sum2[n] - sum2[i - 1] - (n - i + 1) * sum1[i - 1];\n    for (int i = 1; i <= n; i++) duan[i] += duan[i - 1];\n    int q;\n    cin >> q;\n    while (q--) {\n        int l, r;\n        cin >> l >> r;\n        auto calc = [&](int x) -> int {\n            int le = 0, ri = n;\n            while (le <= ri) {\n                int mid = (le + ri) >> 1;\n                if (mid * n - mid * (mid - 1) / 2 <= x) le = mid + 1;\n                else ri = mid - 1;\n            }\n            int mid = le - 1;\n            int res = duan[mid];\n            int shen = x - (mid * n - mid * (mid - 1) / 2);\n            mid++;\n            if (shen) {\n                res += sum2[mid + shen - 1] - sum2[mid - 1] - shen * sum1[mid - 1];\n            }\n            return res;\n        };\n        cout << calc(r) - calc(l - 1) << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2026c",
      "PROBLEM_ID": "2026C",
      "PROBLEM_STATEMENT": "There is a shop that sells action figures near Monocarp's house. A new set of action figures will be released shortly; this set contains $n$ figures, the $i$-th figure costs $i$ coins and is available for purchase from day $i$ to day $n$.\n\nFor each of the $n$ days, Monocarp knows whether he can visit the shop.\n\nEvery time Monocarp visits the shop, he can buy any number of action figures which are sold in the shop (of course, he cannot buy an action figure that is not yet available for purchase). If Monocarp buys at least two figures during the same day, he gets a discount equal to the cost of the most expensive figure he buys (in other words, he gets the most expensive of the figures he buys for free).\n\nMonocarp wants to buy exactly one $1$-st figure, one $2$-nd figure, ..., one $n$-th figure from the set. He cannot buy the same figure twice. What is the minimum amount of money he has to spend?\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n- the first line contains one integer $n$ ($1 \\le n \\le 4 \\cdot 10^5$) \u2014 the number of figures in the set (and the number of days);\n- the second line contains a string $s$ ($|s| = n$, each $s_i$ is either 0 or 1). If Monocarp can visit the shop on the $i$-th day, then $s_i$ is 1; otherwise, $s_i$ is 0.\n\nAdditional constraints on the input:\n\n- in each test case, $s_n$ is 1, so Monocarp is always able to buy all figures during the $n$-th day;\n- the sum of $n$ over all test cases does not exceed $4 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print one integer \u2014 the minimum amount of money Monocarp has to spend.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n1\n\n6\n\n101101\n\n7\n\n1110001\n\n5\n\n11111\n\n```\n\n#### Output #1\n\n```\n1\n8\n18\n6\n```\n\n### Note\n\nIn the first test case, Monocarp buys the $1$-st figure on the $1$-st day and spends $1$ coin.\n\nIn the second test case, Monocarp can buy the $1$-st and the $3$-rd figure on the $3$-rd day, the $2$-nd and the $4$-th figure on the $4$-th day, and the $5$-th and the $6$-th figure on the $6$-th day. Then, he will spend $1+2+5=8$ coins.\n\nIn the third test case, Monocarp can buy the $2$-nd and the $3$-rd figure on the $3$-rd day, and all other figures on the $7$-th day. Then, he will spend $1+2+4+5+6 = 18$ coins.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        ll n;\n        cin >> n;\n        string s;\n        cin >> s;\n\n        // Collect days where Monocarp can visit the shop\n        vector<int> vis;\n        vis.reserve(n);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '1') {\n                vis.push_back(i + 1);\n            }\n        }\n\n        int m = vis.size();\n        // f[i] = number of visits with day >= 2*(i+1)\n        vector<ll> f(m);\n        int p = 0;\n        for (int i = 1; i <= m; i++) {\n            ll thr = 2LL * i;\n            while (p < m && vis[p] < thr) {\n                p++;\n            }\n            // remaining from p..m-1 are >= thr\n            f[i - 1] = (ll)(m - p);\n        }\n\n        // Compute the maximum number K of discounts we can take\n        ll H = LLONG_MAX;\n        int Kmax = 0;\n        for (int i = 1; i <= m; i++) {\n            // g = f[i-1] + (i-1)\n            ll g = f[i - 1] + (i - 1);\n            H = min(H, g);\n            if (H >= i) {\n                Kmax = i;\n            }\n        }\n\n        // Sum of the Kmax largest visit-days (these are the free ones)\n        ll sum_top_k = 0;\n        for (int cnt = 0; cnt < Kmax; cnt++) {\n            sum_top_k += vis[m - 1 - cnt];\n        }\n\n        // Total cost without discounts\n        ll total = n * (n + 1LL) / 2;\n        // Subtract the sum of free figures\n        ll answer = total - sum_top_k;\n        cout << answer << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2026a",
      "PROBLEM_ID": "2026A",
      "PROBLEM_STATEMENT": "You are given a coordinate plane and three integers $X$, $Y$, and $K$. Find two line segments $AB$ and $CD$ such that\n\n1. the coordinates of points $A$, $B$, $C$, and $D$ are integers;\n2. $0 \\le A_x, B_x, C_x, D_x \\le X$ and $0 \\le A_y, B_y, C_y, D_y \\le Y$;\n3. the length of segment $AB$ is at least $K$;\n4. the length of segment $CD$ is at least $K$;\n5. segments $AB$ and $CD$ are perpendicular: if you draw lines that contain $AB$ and $CD$, they will cross at a right angle.\n\nNote that it's not necessary for segments to intersect. Segments are perpendicular as long as the lines they induce are perpendicular.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 5000$)\u00a0\u2014 the number of test cases. Next, $t$ cases follow.\n\nThe first and only line of each test case contains three integers $X$, $Y$, and $K$ ($1 \\le X, Y \\le 1000$; $1 \\le K \\le 1414$).\n\nAdditional constraint on the input: the values of $X$, $Y$, and $K$ are chosen in such a way that the answer exists.\n\n### Output\n\nFor each test case, print two lines. The first line should contain $4$ integers $A_x$, $A_y$, $B_x$, and $B_y$\u00a0\u2014 the coordinates of the first segment.\n\nThe second line should also contain $4$ integers $C_x$, $C_y$, $D_x$, and $D_y$\u00a0\u2014 the coordinates of the second segment.\n\nIf there are multiple answers, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1 1 1\n\n3 4 1\n\n4 3 3\n\n3 4 4\n\n```\n\n#### Output #1\n\n```\n0 0 1 0\n0 0 0 1\n2 4 2 2\n0 1 1 1\n0 0 1 3\n1 2 4 1\n0 1 3 4\n0 3 3 0\n```\n\n### Note\n\nThe answer for the first test case is shown below:\n\n![](https://espresso.codeforces.com/8ff10475ccf3403c6de83da01703883f8a912f68.png) The answer for the second test case: ![](https://espresso.codeforces.com/f5d07d5cf35872fb3871f0fdbc299a6bf02f4c41.png) The answer for the third test case: ![](https://espresso.codeforces.com/8bb04be50b98e98df8bafec057d0479b6f4fcde0.png) The answer for the fourth test case: ![](https://espresso.codeforces.com/9cf56bcca6e135737bc885eecb651d8ca3e5adcf.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <cstdio>\n\nint main() {\n\n  long t;\n  scanf(\"%ld\", &t);\n  while (t--) {\n    long x, y, k;\n    scanf(\"%ld %ld %ld\", &x, &y, &k);\n    long m = (x < y ? x : y);\n    printf(\"0 0 %ld %ld\n0 %ld %ld 0\n\", m, m, m, m);\n  }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2025f",
      "PROBLEM_ID": "2025F",
      "PROBLEM_STATEMENT": "You are given an array $a$, consisting of $n$ integers (numbered from $1$ to $n$). Initially, they are all zeroes.\n\nYou have to process $q$ queries. The $i$-th query consists of two different integers $x_i$ and $y_i$. During the $i$-th query, you have to choose an integer $p$ (which is either $x_i$ or $y_i$) and an integer $d$ (which is either $1$ or $-1$), and assign $a_p = a_p + d$.\n\nAfter each query, every element of $a$ should be a non-negative integer.\n\nProcess all queries in such a way that the sum of all elements of $a$ after the last query is the minimum possible.\n\n### Input\n\nThe first line contains two integers $n$ and $q$ ($2 \\le n \\le 3 \\cdot 10^5$; $1 \\le q \\le 3 \\cdot 10^5$) \u2014 the number of elements in $a$ and the number of queries, respectively.\n\nThen $q$ lines follow. The $i$-th of these lines contains two integers $x_i$ and $y_i$ ($1 \\le x_i, y_i \\le n$; $x_i \\ne y_i$) \u2014 the description of the $i$-th query.\n\n### Output\n\nFor each query, print a line containing two characters:\n\n- the first character should be x if you choose $p=x_i$, or y if you choose $p=y_i$;\n- the second character should be + if you choose $d=1$, or - if you choose $d=-1$.\n\nIf there are multiple answers, print any of them.\n\n### Examples\n\n#### Input #1\n\n```\n\n3 4\n\n1 2\n\n3 2\n\n3 1\n\n1 2\n\n```\n\n#### Output #1\n\n```\ny+\nx+\nx-\ny-\n```\n\n#### Input #2\n\n```\n\n4 4\n\n1 2\n\n2 3\n\n3 4\n\n3 2\n\n```\n\n#### Output #2\n\n```\ny+\ny+\nx-\ny-\n```\n\n#### Input #3\n\n```\n\n4 2\n\n2 1\n\n4 3\n\n```\n\n#### Output #3\n\n```\ny+\nx+\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct DSU {\n    int n;\n    vector<int> p;\n    DSU(int n): n(n), p(n+1) { for(int i=1;i<=n;i++) p[i]=i; }\n    int find(int x){ return p[x]==x?x:p[x]=find(p[x]); }\n    void unite(int x, int y){\n        x = find(x); y = find(y);\n        if(x==y) return;\n        p[y] = x;\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n    vector<int> x(q+1), y(q+1);\n    for(int i=1;i<=q;i++){\n        cin >> x[i] >> y[i];\n    }\n    // DSU to find components\n    DSU dsu(n);\n    for(int i=1;i<=q;i++){\n        dsu.unite(x[i], y[i]);\n    }\n    // count edges per component\n    vector<int> compEdgeCnt(n+1, 0);\n    for(int i=1;i<=q;i++){\n        int r = dsu.find(x[i]);\n        compEdgeCnt[r]++;\n    }\n    // target parity p[v]: for each comp with odd #edges, pick one v (the rep) to have p=1\n    vector<char> p(n+1, 0);\n    for(int v=1; v<=n; v++){\n        if(dsu.find(v)==v && (compEdgeCnt[v] & 1)){\n            p[v] = 1;\n        }\n    }\n    // build adjacency\n    vector<vector<pair<int,int>>> adj(n+1);\n    adj.reserve(n+1);\n    for(int i=1;i<=q;i++){\n        adj[x[i]].emplace_back(y[i], i);\n        adj[y[i]].emplace_back(x[i], i);\n    }\n    vector<char> used(q+1, 0);\n    vector<char> visited(n+1, 0);\n    vector<char> cur(n+1, 0);\n    vector<int> head(q+1, 0);\n\n    // Frame: if idx >= 0 => node frame, v and idx valid; if idx < 0 => event frame, v=parent, u child, e edge idx valid in u.\n    struct Frame { int v, idx, u, e; };\n    vector<Frame> st;\n    st.reserve(n + q);\n\n    // DFS each component\n    for(int start = 1; start <= n; start++){\n        if(!visited[start] && !adj[start].empty()){\n            visited[start] = 1;\n            st.push_back({start, 0, 0, 0});\n            while(!st.empty()){\n                Frame &f = st.back();\n                if(f.idx < 0){\n                    // orientation event frame\n                    int v = f.v, u = f.u, e = f.e;\n                    if(cur[u] != p[u]){\n                        head[e] = u;\n                        cur[u] ^= 1;\n                    } else {\n                        head[e] = v;\n                        cur[v] ^= 1;\n                    }\n                    st.pop_back();\n                } else {\n                    int v = f.v;\n                    int &i = f.idx;\n                    if(i >= (int)adj[v].size()){\n                        // done scanning neighbors\n                        st.pop_back();\n                    } else {\n                        auto pr = adj[v][i++];\n                        int u2 = pr.first;\n                        int e = pr.second;\n                        if(used[e]) continue;\n                        used[e] = 1;\n                        if(!visited[u2]){\n                            visited[u2] = 1;\n                            // push event marker\n                            st.push_back({v, -1, u2, e});\n                            // push child frame\n                            st.push_back({u2, 0, 0, 0});\n                        } else {\n                            // immediate orientation\n                            if(cur[u2] != p[u2]){\n                                head[e] = u2;\n                                cur[u2] ^= 1;\n                            } else {\n                                head[e] = v;\n                                cur[v] ^= 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Now head[i] is the chosen endpoint for edge i (one of x[i] or y[i]).\n    // For each node v, we alternate plus/minus on its occurrences.\n    vector<int> occ(n+1, 0);\n    // Prepare output\n    // Two characters per query\n    string out;\n    out.reserve(q*3);\n    for(int i=1;i<=q;i++){\n        int v = head[i];\n        occ[v]++;\n        char sign = (occ[v] & 1) ? '+' : '-';\n        char which = (v == x[i] ? 'x' : 'y');\n        out.push_back(which);\n        out.push_back(sign);\n        out.push_back('\\n');\n    }\n\n    cout << out;\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2025e",
      "PROBLEM_ID": "2025E",
      "PROBLEM_STATEMENT": "In the most popular card game in Berland, a deck of $n \\times m$ cards is used. Each card has two parameters: suit and rank. Suits in the game are numbered from $1$ to $n$, and ranks are numbered from $1$ to $m$. There is exactly one card in the deck for each combination of suit and rank.\n\nA card with suit $a$ and rank $b$ can beat a card with suit $c$ and rank $d$ in one of two cases:\n\n- $a = 1$, $c \\ne 1$ (a card of suit $1$ can beat a card of any other suit);\n- $a = c$, $b > d$ (a card can beat any other card of the same suit but of a lower rank).\n\nTwo players play the game. Before the game starts, they receive exactly half of the deck each. The first player wins if for every card of the second player, he can choose his card that can beat it, and there is no card that is chosen twice (i.\u2009e. there exists a matching of the first player's cards with the second player's cards such that in each pair the first player's card beats the second player's card). Otherwise, the second player wins.\n\nYour task is to calculate the number of ways to distribute the cards so that the first player wins. Two ways are considered different if there exists a card such that in one way it belongs to the first player and in the other way it belongs to the second player. The number of ways can be very large, so print it modulo $998244353$.\n\n### Input\n\nThe only line contains two integers $n$ and $m$ ($1 \\le n, m \\le 500$).\n\nAdditional constraint on the input: $m$ is even.\n\n### Output\n\nPrint a single integer\u00a0\u2014 the number of ways to distribute the cards so that the first player wins, taken modulo $998244353$.\n\n### Examples\n\n#### Input #1\n\n```\n\n1 4\n\n```\n\n#### Output #1\n\n```\n2\n```\n\n#### Input #2\n\n```\n\n2 2\n\n```\n\n#### Output #2\n\n```\n2\n```\n\n#### Input #3\n\n```\n\n3 6\n\n```\n\n#### Output #3\n\n```\n1690\n```\n\n#### Input #4\n\n```\n\n5 4\n\n```\n\n#### Output #4\n\n```\n568\n```\n\n#### Input #5\n\n```\n\n500 500\n\n```\n\n#### Output #5\n\n```\n84693741\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const int MOD = 998244353;\n\n// Fast exponentiation modulo MOD\nlong long modpow(long long a, long long e = MOD-2) {\n    long long res = 1 % MOD;\n    a %= MOD;\n    while (e > 0) {\n        if (e & 1) res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        e >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    // m is even by problem statement\n    int d = m / 2;\n\n    // Precompute factorials and inverse factorials up to m\n    vector<long long> fact(m+1), invfact(m+1);\n    fact[0] = 1;\n    for (int i = 1; i <= m; i++) fact[i] = fact[i-1] * i % MOD;\n    invfact[m] = modpow(fact[m]);\n    for (int i = m; i >= 1; i--) invfact[i-1] = invfact[i] * i % MOD;\n\n    // Binomial C(m, k)\n    auto comb = [&](int mm, int k) -> long long {\n        if (k < 0 || k > mm) return 0;\n        return fact[mm] * invfact[k] % MOD * invfact[mm - k] % MOD;\n    };\n\n    // Compute ballot numbers B[m][y] for suit>=2:\n    // B(y) = (m - 2y +1)/(m - y +1) * C(m, y)\n    vector<long long> b(d+1);\n    for (int y = 0; y <= d; y++) {\n        // numerator = m - 2y + 1\n        long long num = (long long)(m - 2*y + 1);\n        if (num < 0) num = (num % MOD + MOD) % MOD; \n        else num %= MOD;\n        // denom = m - y + 1\n        int den = m - y + 1;\n        long long c = comb(m, y);\n        // ballot number\n        b[y] = num * modpow(den) % MOD * c % MOD;\n    }\n\n    // Build reversed base polynomial b_rev of length d+1\n    // b_rev[k] = b[d - k]\n    vector<long long> base(d+1);\n    for (int k = 0; k <= d; k++) {\n        base[k] = b[d - k];\n    }\n\n    // Polynomial multiplication truncated to degree <= d\n    auto poly_mul = [&](const vector<long long>& A, const vector<long long>& B) {\n        int na = (int)A.size();\n        int nb = (int)B.size();\n        // result size up to d+1\n        vector<long long> C(d+1, 0LL);\n        for (int i = 0; i < na; i++) {\n            if (!A[i]) continue;\n            long long ai = A[i];\n            int lim = min(d - i, nb - 1);\n            for (int j = 0; j <= lim; j++) {\n                // i + j <= d\n                C[i + j] = (C[i + j] + ai * B[j]) % MOD;\n            }\n        }\n        return C;\n    };\n\n    // Exponentiate base polynomial to exponent (n-1) modulo z^(d+1)\n    int expo = n - 1;\n    vector<long long> res(d+1, 0LL);\n    res[0] = 1;  // res = 1\n\n    vector<long long> pw = base;\n    while (expo > 0) {\n        if (expo & 1) {\n            res = poly_mul(res, pw);\n        }\n        expo >>= 1;\n        if (expo > 0) {\n            pw = poly_mul(pw, pw);\n        }\n    }\n    // Now res[k] = coefficient of z^k in b_rev^(n-1)\n\n    // Precompute H[x] for suit1: H[x] = (2x - m +1)/(x+1) * C(m,x) for x >= m/2\n    vector<long long> H(m+1, 0LL);\n    for (int x = d; x <= m; x++) {\n        // numerator = 2x - m + 1\n        long long num = (long long)(2*x - m + 1);\n        num = (num % MOD + MOD) % MOD;\n        int den = x + 1;\n        long long c = comb(m, x);\n        H[x] = num * modpow(den) % MOD * c % MOD;\n    }\n\n    // Final answer: sum_{i=0..d} H[d+i] * res[i]\n    long long answer = 0;\n    for (int i = 0; i <= d; i++) {\n        int x = d + i;\n        // res[i] corresponds to DP_rev[i]\n        answer = (answer + H[x] * res[i]) % MOD;\n    }\n\n    cout << answer << \"\\n\";\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2025b",
      "PROBLEM_ID": "2025B",
      "PROBLEM_STATEMENT": "Recently, akshiM met a task that needed binomial coefficients to solve. He wrote a code he usually does that looked like this:\n\n```\nfor (int n = 0; n < N; n++) { // loop over n from 0 to N-1 (inclusive)\n\nC\\[n\\]\\[0\\] = 1;\n\nC\\[n\\]\\[n\\] = 1;\n\nfor (int k = 1; k < n; k++) // loop over k from 1 to n-1 (inclusive)\n\nC\\[n\\]\\[k\\] = C\\[n\\]\\[k - 1\\] + C\\[n - 1\\]\\[k - 1\\];\n\n}\n\n```\n\nUnfortunately, he made an error, since the right formula is the following:\n\n```\nC\\[n\\]\\[k\\] = C\\[n - 1\\]\\[k\\] + C\\[n - 1\\]\\[k - 1\\]\n\n```\n\nBut his team member keblidA is interested in values that were produced using the wrong formula. Please help him to calculate these coefficients for $t$ various pairs $(n_i, k_i)$. Note that they should be calculated according to the first (wrong) formula.\n\nSince values $C[n_i][k_i]$ may be too large, print them modulo $10^9 + 7$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^5$)\u00a0\u2014 the number of pairs. Next, $t$ pairs are written in two lines.\n\nThe second line contains $t$ integers $n_1, n_2, \\dots, n_t$ ($2 \\le n_i \\le 10^5$).\n\nThe third line contains $t$ integers $k_1, k_2, \\dots, k_t$ ($1 \\le k_i < n_i$).\n\n### Output\n\nPrint $t$ integers $C[n_i][k_i]$ modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n2 5 5 100000 100000 100000 100000\n\n1 2 3 1 33333 66666 99999\n\n```\n\n#### Output #1\n\n```\n2\n4\n8\n2\n326186014\n984426998\n303861760\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nlong long power(long long base, long long exp) {\n    long long res = 1;\n    base %= 1000000007;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % 1000000007;\n        base = (base * base) % 1000000007;\n        exp /= 2;\n    }\n    return res;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    vector<int> n(t), k(t);\n    for (int i = 0; i < t; ++i) {\n        cin >> n[i];\n    }\n    for (int i = 0; i < t; ++i) {\n        cin >> k[i];\n    }\n    for (int i = 0; i < t; ++i) {\n        cout << power(2, k[i]) << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2024b",
      "PROBLEM_ID": "2024B",
      "PROBLEM_STATEMENT": "There is a vending machine that sells lemonade. The machine has a total of $n$ slots. You know that initially, the $i$-th slot contains $a_i$ cans of lemonade. There are also $n$ buttons on the machine, each button corresponds to a slot, with exactly one button corresponding to each slot. Unfortunately, the labels on the buttons have worn off, so you do not know which button corresponds to which slot.\n\nWhen you press the button corresponding to the $i$-th slot, one of two events occurs:\n\n- If there is a can of lemonade in the $i$-th slot, it will drop out and you will take it. At this point, the number of cans in the $i$-th slot decreases by $1$.\n- If there are no cans of lemonade left in the $i$-th slot, nothing will drop out.\n\nAfter pressing, the can drops out so quickly that it is impossible to track from which slot it fell. The contents of the slots are hidden from your view, so you cannot see how many cans are left in each slot. The only thing you know is the initial number of cans in the slots: $a_1, a_2, \\ldots, a_n$.\n\nDetermine the minimum number of button presses needed to guarantee that you receive at least $k$ cans of lemonade.\n\nNote that you can adapt your strategy during the button presses based on whether you received a can or not. It is guaranteed that there are at least $k$ cans of lemonade in total in the machine. In other words, $k \\leq a_1 + a_2 + \\ldots + a_n$.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 2 \\cdot 10^5$, $1 \\leq k \\leq 10^9$)\u00a0\u2014 the number of slots in the machine and the required number of cans of lemonade.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the number of cans in the slots.\n\nIt is guaranteed that $k \\leq a_1 + a_2 + \\ldots + a_n$, meaning there are at least $k$ cans of lemonade in the machine.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the minimum number of button presses needed to guarantee that you receive at least $k$ cans of lemonade.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2 1\n\n1 1\n\n2 2\n\n1 2\n\n3 4\n\n2 1 3\n\n10 50\n\n1 1 3 8 8 9 12 13 27 27\n\n2 1000000000\n\n1000000000 500000000\n\n```\n\n#### Output #1\n\n```\n1\n2\n5\n53\n1000000000\n```\n\n### Note\n\nIn the first test case, we can simply press the first button and receive one can of lemonade.\n\nIn the second test case, we can press each button once and guarantee that we receive $2$ cans of lemonade. Note that if we simply press one button twice, we might not be lucky, and that button could correspond to the first slot, in which case we would only receive $1$ can of lemonade for two presses.\n\nIn the third test case, one of the optimal strategies is as follows:\n\nPress the first button twice. After the first press, a can of lemonade will definitely drop out. Then there are two options:\n\n- If no can of lemonade drops after the second press, we know that this button must correspond to the second slot, since $a_2 = 1$ and $a_1, a_3 > 1$. Then we can press the second button twice and the third button once. Since $a_1, a_3 \\geq 2$, we will definitely receive three cans of lemonade for these three presses. Thus, after $5$ presses, we will have $4$ cans of lemonade.\n- If a can of lemonade drops after the second press, we can make one press on the second button and one press on the third button. After each of these presses, we will definitely receive a can of lemonade. Thus, after $4$ presses, we will have $4$ cans of lemonade.\n\nIt can be shown that it is impossible to guarantee receiving $4$ cans of lemonade with only $4$ presses, so the answer is $5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        ll k;\n        cin >> n >> k;\n        vector<ll> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        sort(a.begin(), a.end());\n\n        // prefix sums of a[]\n        vector<ll> pref(n);\n        pref[0] = a[0];\n        for (int i = 1; i < n; i++) {\n            pref[i] = pref[i-1] + a[i];\n        }\n\n        // C(h) = sum_i min(a[i], h) must be >= k\n        ll lo = 1, hi = a[n-1];\n        while (lo < hi) {\n            ll mid = lo + (hi - lo) / 2;\n            // find first index idx so that a[idx] >= mid\n            int idx = int(lower_bound(a.begin(), a.end(), mid) - a.begin());\n            // sum of min(a[i], mid)\n            // for i < idx: a[i] < mid, contribute a[i]\n            // for i >= idx: contribute mid\n            ll sumMin = (idx > 0 ? pref[idx-1] : 0LL) + (ll)(n - idx) * mid;\n            if (sumMin >= k) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n\n        ll h = lo;\n        // count of a[i] < h\n        int cntLess = int(lower_bound(a.begin(), a.end(), h) - a.begin());\n        // answer = k + (number of slots with capacity < h)\n        ll answer = k + cntLess;\n        cout << answer << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2024a",
      "PROBLEM_ID": "2024A",
      "PROBLEM_STATEMENT": "Alice has $a$ coins. She can open a bank deposit called \"Profitable\", but the minimum amount required to open this deposit is $b$ coins.\n\nThere is also a deposit called \"Unprofitable\", which can be opened with any amount of coins. Alice noticed that if she opens the \"Unprofitable\" deposit with $x$ coins, the minimum amount required to open the \"Profitable\" deposit decreases by $2x$ coins. However, these coins cannot later be deposited into the \"Profitable\" deposit.\n\nHelp Alice determine the maximum number of coins she can deposit into the \"Profitable\" deposit if she first deposits some amount of coins (possibly $0$) into the \"Unprofitable\" deposit. If Alice can never open the \"Profitable\" deposit, output $0$.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nA single line of each test case contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$) \u2014 the number of coins Alice has and the initial minimum amount required to open the \"Profitable\" deposit.\n\n### Output\n\nFor each test case, output a single integer \u2014 the maximum number of coins that Alice can deposit into the \"Profitable\" deposit. If Alice can never open the \"Profitable\" deposit, output $0$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n10 5\n\n7 9\n\n5 100\n\n1 1\n\n1 2\n\n```\n\n#### Output #1\n\n```\n10\n5\n0\n1\n0\n```\n\n### Note\n\nIn the first test case, $a \\ge b$, so Alice can immediately open the \"Profitable\" deposit with all $10$ coins.\n\nIn the second test case, Alice can open the \"Unprofitable\" deposit with $2$ coins. Then she will have $5$ coins left, but the minimum amount required to open the \"Profitable\" deposit will decrease by $4$ coins, making it equal to $5$ coins. Thus, Alice will be able to open the \"Profitable\" deposit with $5$ coins.\n\nIn the third test case, Alice will not be able to open the \"Profitable\" deposit.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int a, b;\n        cin >> a >> b;\n        if (a >= b) {\n            cout << a << endl;\n        } else {\n            if (b <= 2 * a && (b - a) <= (b / 2)) {\n                cout << 2 * a - b << endl;\n            } else {\n                cout << 0 << endl;\n            }\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2023f",
      "PROBLEM_ID": "2023F",
      "PROBLEM_STATEMENT": "In a desert city with a hilly landscape, the city hall decided to level the road surface by purchasing a dump truck. The road is divided into $n$ sections, numbered from $1$ to $n$ from left to right. The height of the surface in the $i$-th section is equal to $a_i$. If the height of the $i$-th section is greater than $0$, then the dump truck must take sand from the $i$-th section of the road, and if the height of the $i$-th section is less than $0$, the dump truck must fill the pit in the $i$-th section of the road with sand. It is guaranteed that the initial heights are not equal to $0$.\n\nWhen the dump truck is in the $i$-th section of the road, it can either take away $x$ units of sand, in which case the height of the surface in the $i$-th section will decrease by $x$, or it can fill in $x$ units of sand (provided that it currently has at least $x$ units of sand in its bed), in which case the height of the surface in the $i$-th section of the road will increase by $x$.\n\nThe dump truck can start its journey from any section of the road. Moving to an adjacent section on the left or right takes $1$ minute, and the time for loading and unloading sand can be neglected. The dump truck has an infinite capacity and is initially empty.\n\nYou need to find the minimum time required for the dump truck to level the sand so that the height in each section becomes equal to $0$. Note that after all movements, the dump truck may still have sand left in its bed. You need to solve this problem independently for the segments numbered from $l_i$ to $r_i$. Sand outside the segment cannot be used.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\le n, q \\le 3 \\cdot 10^5$) \u2014 the number of sections and the number of queries.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-10^9 \\le a_i \\le 10^9$, $a_i \\neq 0$) \u2014 the initial height in each section.\n\nThe $i$-th of the following $q$ lines contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$) \u2014 the boundaries of the segment of sections for which the minimum time needs to be determined.\n\nIt is guaranteed that the sum of $n$ over all test cases and the sum of $q$ over all test cases do not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each query, output the minimum time required to level the sand in the segment $[l_i, r_i]$, or $-1$ if it is impossible.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1 1\n\n-179\n\n1 1\n\n5 3\n\n-2 2 -1 3 -1\n\n2 4\n\n1 5\n\n1 3\n\n7 1\n\n1 1 1 -4 1 1 1\n\n1 7\n\n7 2\n\n2 -2 2 -2 1 2 -1\n\n1 7\n\n2 7\n\n4 4\n\n1000000000 1000000000 999999999 -1000000000\n\n2 4\n\n3 4\n\n2 3\n\n1 3\n\n```\n\n#### Output #1\n\n```\n-1\n2\n5\n-1\n8\n6\n6\n2\n-1\n1\n2\n```\n\n### Note\n\nIn the first test case, $179$ units of sand need to be added to the only section. However, there is nowhere to take it from, so this is impossible.\n\nIn the second test case:\n\n- In the first query, the dump truck can start its journey at the second section. It can take $2$ units of sand, after which the height in the second section will become $0$. Then the dump truck can move to the third section. It can pour $1$ unit of sand there, after which the height in the third section will become $0$. Then the dump truck can move to the fourth section. There it can take $3$ units of sand, after which the height in the fourth section will become $0$. In total, the dump truck will spend $2$ minutes on movements.\n- In the second query, the dump truck can start its journey at the fourth section. It can take $3$ units of sand, after which the height in the fourth section will become $0$. Then the dump truck can move to the fifth section. It can pour $1$ unit of sand there, after which the height in the fifth section will become $0$. Then the dump truck can move back to the fourth section and then to the third. It can pour $1$ unit of sand there, after which the height in the third section will become $0$. Then the dump truck can move to the second section. It can take $2$ units of sand. Then it can move to the first section. It can pour $2$ units of sand there, after which the height in the first section will become $0$. In total, the dump truck will spend $5$ minutes on movements.\n- In the third query, the dump truck will not be able to make the height in each section equal to $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=3e5+5; \nstruct info {\n\tint su,mx,lx,rx;\n\tinline friend info operator +(const info &u,const info &v) {\n\t\treturn {u.su+v.su,max({u.mx,v.mx,u.rx+v.lx}),max(u.lx,u.su+v.lx),max(v.rx,v.su+u.rx)};\n\t}\n};\nstruct zKyGt1 {\n\tinfo tr[1<<20];\n\tint N;\n\tvoid init(int n) {\n\t\tfor(N=1;N<=n;N<<=1);\n\t\tfor(int i=1;i<2*N;++i) tr[i]={0,0,0,0};\n\t\tfor(int i=1;i<=n;++i) tr[i+N]={-1,0,-1,-1};\n\t\tfor(int i=N-1;i;--i) tr[i]=tr[i<<1]+tr[i<<1|1];\n\t}\n\tvoid upd(int x) {\n\t\tfor(tr[x+=N]={1,1,1,1},x>>=1;x;x>>=1) tr[x]=tr[x<<1]+tr[x<<1|1];\n\t}\n\tint qry(int l,int r) {\n\t\tinfo sl={0,0,0,0},sr={0,0,0,0};\n\t\tfor(l+=N-1,r+=N+1;l^r^1;l>>=1,r>>=1) {\n\t\t\tif(~l&1) sl=sl+tr[l^1];\n\t\t\tif(r&1) sr=tr[r^1]+sr;\n\t\t}\n\t\treturn (sl+sr).mx;\n\t}\n}\tT;\nll a[MAXN],s[MAXN];\nint n,m,l[MAXN],r[MAXN],ans[MAXN];\nvector <int> qy[MAXN];\nvoid sol() {\n\tT.init(n);\n\tvector <int> id;\n\tfor(int i=1;i<=n;++i) qy[i].clear(),s[i]=s[i-1]+a[i];\n\tfor(int i=1;i<=m;++i) if(l[i]<r[i]) qy[l[i]].push_back(i);\n\tfor(int i=0;i<=n;++i) id.push_back(i);\n\tsort(id.begin(),id.end(),[&](int i,int j){ return s[i]^s[j]?s[i]>s[j]:i>j; });\n\tfor(int i:id) {\n\t\tif(i>0) T.upd(i);\n\t\tfor(auto q:qy[i+1]) {\n\t\t\tans[q]=min(ans[q],2*(r[q]-l[q])-T.qry(l[q],r[q]-1));\n\t\t}\n\t}\n}\nvoid solve() {\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i) cin>>a[i];\n\tfor(int i=1;i<=m;++i) cin>>l[i]>>r[i],ans[i]=2*(r[i]-l[i]);\n\tsol();\n\treverse(a+1,a+n+1);\n\tfor(int i=1;i<=m;++i) swap(l[i],r[i]),l[i]=n-l[i]+1,r[i]=n-r[i]+1;\n\tsol();\n\tfor(int i=1;i<=m;++i) cout<<(s[r[i]]<s[l[i]-1]?-1:ans[i])<<\"\\n\";\n}\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0),cout.tie(0);\n\tint _; cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2023b",
      "PROBLEM_ID": "2023B",
      "PROBLEM_STATEMENT": "It is already the year $3024$, ideas for problems have long run out, and the olympiad now takes place in a modified individual format. The olympiad consists of $n$ problems, numbered from $1$ to $n$. The $i$-th problem has its own score $a_i$ and a certain parameter $b_i$ ($1 \\le b_i \\le n$).\n\nInitially, the testing system gives the participant the first problem. When the participant is given the $i$-th problem, they have two options:\n\n- They can submit the problem and receive $a_i$ points;\n- They can skip the problem, in which case they will never be able to submit it.\n\nThen, the testing system selects the next problem for the participant from problems with indices $j$, such that:\n\n- If he submitted the $i$-th problem, it looks at problems with indices $j < i$;\n- If he skipped the $i$-th problem, it looks at problems with indices $j \\leq b_i$.\n\nAmong these problems, it selects the problem with the maximum index that it has not previously given to the participant (he has neither submitted nor skipped it before). If there is no such problem, then the competition for the participant ends, and their result is equal to the sum of points for all submitted problems. In particular, if the participant submits the first problem, then the competition for them ends. Note that the participant receives each problem at most once.\n\nProkhor has prepared thoroughly for the olympiad, and now he can submit any problem. Help him determine the maximum number of points he can achieve.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^5$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 4 \\cdot 10^5$) \u2014 the number of problems in the olympiad.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the scores of the problems.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq n$) \u2014 the parameters of the problems.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $4 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the maximum number of points that Prokhor can achieve.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n15 16\n\n2 1\n\n5\n\n10 10 100 100 1000\n\n3 4 1 1 1\n\n3\n\n100 49 50\n\n3 2 2\n\n4\n\n100 200 300 1000\n\n2 3 4 1\n\n```\n\n#### Output #1\n\n```\n16\n200\n100\n1000\n```\n\n### Note\n\nIn the first test case, Prokhor can skip the first problem; then he will receive the problem with index $b_1 = 2$. Prokhor can submit it and receive $a_2 = 16$ points. After that, the competition will end because Prokhor has already received all problems. Note that if Prokhor submits the first problem, he will receive $a_1 = 15$ points, but the competition will end immediately.\n\nIn the second test case, Prokhor can skip the first problem; then he will receive the problem with index $b_1 = 3$. Prokhor can submit it and receive $a_3 = 100$ points. After that, Prokhor will receive the second problem, which he can skip to receive the problem with index $b_2 = 4$. Prokhor can submit the fourth problem and receive another $a_4 = 100$ points. After that, the competition ends because Prokhor has already received all problems with indices not exceeding $4$. Thus, Prokhor will receive a total of $200$ points.\n\nIn the third test case, Prokhor can submit the first problem and receive $100$ points, after which the competition will end immediately.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct DSU_Next {\n    vector<int> p;\n    DSU_Next(int n = 0) { init(n); }\n    void init(int n) { p.resize(n + 2); iota(p.begin(), p.end(), 0); }\n    int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }\n    void erase(int x) { p[x] = find(x + 1); }          // remove x from the set\n};\n\nusing ll = long long;\nconst ll INF = (1LL << 62);\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        vector<ll> a(n + 1);\n        for (int i = 1; i <= n; ++i) cin >> a[i];\n        vector<int> b(n + 1);\n        for (int i = 1; i <= n; ++i) cin >> b[i];\n\n        /* prefix sums of scores */\n        vector<ll> pref(n + 1, 0);\n        for (int i = 1; i <= n; ++i) pref[i] = pref[i - 1] + a[i];\n\n        /* Dijkstra on borders 1..n */\n        vector<ll> dist(n + 1, INF);\n        dist[1] = 0;\n        using Pair = pair<ll, int>;                    // (distance, vertex)\n        priority_queue<Pair, vector<Pair>, greater<Pair>> pq;\n        pq.emplace(0, 1);\n\n        DSU_Next dsu(n);\n\n        while (!pq.empty()) {\n            auto [d, R] = pq.top(); pq.pop();\n            if (d != dist[R]) continue;                // outdated\n            int idx = dsu.find(1);                     // first unprocessed index\n            while (idx <= R) {\n                ll nd = d + a[idx];\n                int v = b[idx];\n                if (nd < dist[v]) {\n                    dist[v] = nd;\n                    pq.emplace(nd, v);\n                }\n                dsu.erase(idx);                        // mark processed\n                idx = dsu.find(idx);                   // next unprocessed\n            }\n        }\n\n        /* compute answer */\n        ll ans = 0;\n        for (int R = 1; R <= n; ++R)\n            if (dist[R] < INF)\n                ans = max(ans, pref[R] - dist[R]);\n        cout << ans << '\\n';\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2022e2",
      "PROBLEM_ID": "2022E2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. In this version, it is guaranteed that $q \\leq 10^5$. You can make hacks only if both versions of the problem are solved.\n\nAn integer grid $A$ with $p$ rows and $q$ columns is called beautiful if:\n\n- All elements of the grid are integers between $0$ and $2^{30}-1$, and\n- For any subgrid, the XOR of the values at the corners is equal to $0$. Formally, for any four integers $i_1$, $i_2$, $j_1$, $j_2$ ($1 \\le i_1 < i_2 \\le p$; $1 \\le j_1 < j_2 \\le q$), $A_{i_1, j_1} \\oplus A_{i_1, j_2} \\oplus A_{i_2, j_1} \\oplus A_{i_2, j_2} = 0$, where $\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nThere is a partially filled integer grid $G$ with $n$ rows and $m$ columns where only $k$ cells are filled. Polycarp wants to know how many ways he can assign integers to the unfilled cells so that the grid is beautiful.\n\nHowever, Monocarp thinks that this problem is too easy. Therefore, he will perform $q$ updates on the grid. In each update, he will choose an unfilled cell and assign an integer to it. Note that these updates are persistent. That is, changes made to the grid will apply when processing future updates.\n\nFor each of the $q + 1$ states of the grid, the initial state and after each of the $q$ queries, determine the number of ways Polycarp can assign integers to the unfilled cells so that the grid is beautiful. Since this number can be very large, you are only required to output their values modulo $10^9+7$.\n\n### Input\n\nThe first line contains $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains four integers $n$, $m$, $k$ and $q$ ($2 \\le n, m \\le 10^5$; $0 \\le k, q \\leq 10^5$)\u00a0\u2014 the number of rows, the number of columns, the number of fixed cells, and the number of updates.\n\nThe following $k$ lines contain three integers $r$, $c$ and $v$ ($1 \\le r \\le n, 1 \\le c \\le m$; $0 \\le v < 2^{30}$) indicating that $G_{r, c}$ is assigned the integer $v$.\n\nThe following $q$ lines contain three integers $r$, $c$ and $v$ ($1 \\le r \\le n, 1 \\le c \\le m$; $0 \\le v < 2^{30}$) indicating that $G_{r, c}$ is assigned the integer $v$.\n\nIt is guaranteed that the pairs $(r,c)$ over all assignments are distinct.\n\nIt is guaranteed that the sum of $n$, $m$, $k$ and $q$ over all test cases does not exceed $10^5$ respectively.\n\n### Output\n\nFor each test case, output $q + 1$ lines. The $i$-th line of output should contain the answer of the $i$-th state of the grid modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3 3 8 1\n\n2 1 6\n\n3 2 12\n\n1 2 6\n\n2 2 0\n\n1 3 10\n\n1 1 0\n\n2 3 12\n\n3 1 10\n\n3 3 1\n\n2 5 2 0\n\n1 1 10\n\n1 2 30\n\n2 5 0 2\n\n1 1 10\n\n1 2 30\n\n```\n\n#### Output #1\n\n```\n1\n0\n489373567\n651321892\n769740174\n489373567\n```\n\n### Note\n\nIn the first test case of the example, we initially have the following grid:\n\n$0\n\n$$6$$\n\n10\n\n$$6$$\n\n0\n\n$$12$$\n\n10\n\n$$12$$\n\nIt can be proven that the only valid value for tile $(3, 3)$ is $0$, so the first answer is $1$. For the second query, the grid does not satisfy the condition, and thus the answer is $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Required for std::iota\n#include <tuple> // Required for std::tuple\n#include <vector> // Standard library vector\n\n// Modular exponentiation function\n// Computes (base^exp) % modulus\n// Uses binary exponentiation (also known as exponentiation by squaring)\nlong long power_mod(long long base, long long exp, long long modulus) {\n    long long res = 1;\n    base %= modulus;\n    // Handle base=0 case. If exp=0, 0^0 is typically 1. If exp > 0, 0^exp is 0.\n    // In this problem, base is 2, so base=0 case is not relevant.\n    // But handling it generally:\n    if (base == 0) return (exp == 0) ? 1 : 0; \n    while (exp > 0) {\n        // If exp is odd, multiply base with result\n        if (exp % 2 == 1) res = (res * base) % modulus;\n        // Square the base and halve the exponent\n        base = (base * base) % modulus;\n        exp /= 2;\n    }\n    return res;\n}\n\n// Define maximum number of nodes for DSU parent and diff arrays\n// The total number of nodes is n + m. Constraints state n, m <= 10^5.\n// So n+m can be up to 2*10^5. Use 1-based indexing for nodes.\nconst int MAX_N_PLUS_M = 200005; \n\n// Disjoint Set Union (DSU) structure definition\n// This DSU variant maintains XOR differences along paths using path compression.\nstruct DSU {\n    std::vector<int> parent;\n    // diff[i] stores the XOR sum difference between node i and its parent: value[i] ^ value[parent[i]]\n    std::vector<int> diff; \n\n    // Default constructor needed for global array initialization.\n    DSU(int N = 0) { \n        if (N > 0) {\n           init(N); // Initialize if size is provided\n        }\n    }\n    \n    // Initialize or reset DSU structure for N nodes\n    void init(int N) {\n         // Resize vectors if needed. Using resize ensures capacity is at least N+1.\n         if (parent.size() < N + 1) {\n             parent.resize(N + 1);\n             diff.resize(N + 1);\n         }\n         // Initialize parent[i] = i for nodes 1 to N\n         std::iota(parent.begin() + 1, parent.begin() + N + 1, 1);\n         // Initialize diff[i] = 0 for nodes 1 to N\n         std::fill(diff.begin() + 1, diff.begin() + N + 1, 0);\n    }\n\n    // Find operation with path compression and path XOR sum calculation\n    // Returns {root, path_XOR_sum}, where path_XOR_sum is value[i] ^ value[root]\n    std::pair<int, int> find(int i) {\n        // Base case: if i is the root of its component\n        if (parent[i] == i) {\n            return {i, 0}; \n        }\n        // Recursive call to find the root of the parent\n        // Path compression happens after the recursive call returns\n        auto [root, root_diff] = find(parent[i]); \n        \n        // Update diff[i]: This now represents value[i] ^ value[root]\n        // The logic: The current diff[i] = value[i] ^ value[parent[i]].\n        // The returned root_diff = value[parent[i]] ^ value[root].\n        // XORing these gives (value[i] ^ value[parent[i]]) ^ (value[parent[i]] ^ value[root]) = value[i] ^ value[root].\n        diff[i] ^= root_diff; \n        // Path compression: point i directly to the root\n        parent[i] = root; \n        return {root, diff[i]};\n    }\n\n    // Unite operation\n    // Merges the sets containing nodes u and v based on the constraint value[u] ^ value[v] = val\n    // Returns true if a merge occurred, false otherwise (if already in same component)\n    // Sets inconsistent_flag to true if the constraint conflicts with existing structure in the component\n    bool unite(int u, int v, int val, bool& inconsistent_flag) {\n        // Find roots and path XOR sums for u and v\n        auto [root_u, diff_u] = find(u); // diff_u = value[u] ^ value[root_u]\n        auto [root_v, diff_v] = find(v); // diff_v = value[v] ^ value[root_v]\n\n        // If u and v are in different components, merge them\n        if (root_u != root_v) {\n            // Merge root_v into root_u (standard practice often involves rank/size, but simple merge works)\n            parent[root_v] = root_u;\n            // Calculate the required diff for the new parent link: diff[root_v] = value[root_v] ^ value[parent[root_v]] = value[root_v] ^ value[root_u]\n            // We know: value[u] ^ value[v] = val (given constraint)\n            // Substituting path XOR sums: (value[root_u] ^ diff_u) ^ (value[root_v] ^ diff_v) = val\n            // Rearranging to find value[root_u] ^ value[root_v]: value[root_u] ^ value[root_v] = val ^ diff_u ^ diff_v\n            diff[root_v] = val ^ diff_u ^ diff_v;\n            return true; // Merge successful\n        } else {\n            // If u and v are already in the same component, check for consistency\n            // The existing structure implies: value[u] ^ value[v] = diff_u ^ diff_v\n            // The new constraint requires: value[u] ^ value[v] = val\n            // Check if these are compatible\n            if ((diff_u ^ diff_v) != val) {\n                // If not compatible, mark this bit position as inconsistent\n                inconsistent_flag = true; \n            }\n            return false; // No merge happened\n        }\n    }\n};\n\n// Global array of DSU structures, one for each of the 30 bits\nDSU dsu_arr[30]; \n// Global array to track inconsistency for each bit position\nbool inconsistent[30]; \n// Global counter for total successful merges across all bit positions\nlong long total_merges = 0;\n// Global counter for the number of bit positions found to be inconsistent\nint num_inconsistent = 0;\n\n// Function to add a constraint (r, c, v) to the system\n// Updates all 30 DSU structures based on the bits of v\nvoid add_constraint(int r, int c, int v, int n) {\n    int node_u = r; // Node index for row r (1-based)\n    int node_v = n + c; // Node index for column c (1-based, shifted by n)\n    \n    // Process the constraint for each bit position from 0 to 29\n    for (int b = 0; b < 30; ++b) {\n        // If this bit position is already known inconsistent, skip further processing for it\n        if (inconsistent[b]) continue; \n        \n        int bit_val = (v >> b) & 1; // Extract the b-th bit of v\n        // Temporary flag to detect inconsistency from the current unite call\n        bool current_inconsistency_detected = false; \n        \n        // Perform the unite operation for the b-th bit DSU structure\n        bool merged = dsu_arr[b].unite(node_u, node_v, bit_val, current_inconsistency_detected);\n\n        // If inconsistency was detected by unite\n        if (current_inconsistency_detected) {\n             // Check if this is the first time inconsistency is detected for bit b\n             if (!inconsistent[b]) { \n                 inconsistent[b] = true; // Mark bit b as inconsistent\n                 num_inconsistent++; // Increment the global count of inconsistent bits\n             }\n        } else if (merged) {\n             // If the unite operation resulted in a merge (sets were different)\n            total_merges++; // Increment the global count of successful merges\n        }\n        // If sets were already the same and consistent, do nothing.\n    }\n}\n\nint main() {\n    // Optimize C++ standard streams\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n, m, k, q; // Grid dimensions, initial fixed cells, number of updates\n        std::cin >> n >> m >> k >> q;\n\n        // Store initial constraints\n        std::vector<std::tuple<int, int, int>> initial_constraints(k);\n        for (int i = 0; i < k; ++i) {\n            std::cin >> std::get<0>(initial_constraints[i]) >> std::get<1>(initial_constraints[i]) >> std::get<2>(initial_constraints[i]);\n        }\n        \n        // Store updates\n        std::vector<std::tuple<int, int, int>> updates(q);\n        for (int i = 0; i < q; ++i) {\n            std::cin >> std::get<0>(updates[i]) >> std::get<1>(updates[i]) >> std::get<2>(updates[i]);\n        }\n\n        int N_nodes = n + m; // Total nodes in DSU (n rows + m columns)\n        // Initialize/Reset global state for the current test case\n        for(int b=0; b<30; ++b) {\n            dsu_arr[b].init(N_nodes); // Initialize each DSU structure\n            inconsistent[b] = false; // Reset inconsistency flags\n        }\n        total_merges = 0; // Reset total merges count\n        num_inconsistent = 0; // Reset inconsistent bits count\n\n        // Process the initial k constraints\n        for (int i = 0; i < k; ++i) {\n            add_constraint(std::get<0>(initial_constraints[i]), std::get<1>(initial_constraints[i]), std::get<2>(initial_constraints[i]), n);\n        }\n\n        // Define moduli for calculations\n        long long M = 1000000000 + 6; // Modulus for the exponent (phi(P))\n        long long P = 1000000000 + 7; // Modulus for the final answer\n\n        // Loop through states: initial state (i=0) and after each update (i=1 to q)\n        for (int i = 0; i <= q; ++i) {\n             // If any bit position is inconsistent, no valid grid completions exist\n             if (num_inconsistent > 0) {\n                 std::cout << 0 << \"\\n\";\n             } else {\n                 // Calculate the exponent E - 30\n                 // Total components E = sum(Cb) = sum(N_nodes - Mb) = 30*N_nodes - sum(Mb) = 30*N_nodes - total_merges\n                 long long exp_val = 30LL * N_nodes - total_merges - 30;\n                 \n                 // Compute the exponent modulo M = 10^9 + 6\n                 // Ensure the result is non-negative using (exp_val % M + M) % M\n                 long long mod_exp = (exp_val % M + M) % M;\n                 \n                 // Compute 2^mod_exp mod P and print the result\n                 std::cout << power_mod(2, mod_exp, P) << \"\\n\";\n             }\n             \n             // If it's not the last iteration, apply the i-th update for the next state\n             if (i < q) {\n                 add_constraint(std::get<0>(updates[i]), std::get<1>(updates[i]), std::get<2>(updates[i]), n);\n             }\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2022e1",
      "PROBLEM_ID": "2022E1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. In this version, it is guaranteed that $q = 0$. You can make hacks only if both versions of the problem are solved.\n\nAn integer grid $A$ with $p$ rows and $q$ columns is called beautiful if:\n\n- All elements of the grid are integers between $0$ and $2^{30}-1$, and\n- For any subgrid, the XOR of the values at the corners is equal to $0$. Formally, for any four integers $i_1$, $i_2$, $j_1$, $j_2$ ($1 \\le i_1 < i_2 \\le p$; $1 \\le j_1 < j_2 \\le q$), $A_{i_1, j_1} \\oplus A_{i_1, j_2} \\oplus A_{i_2, j_1} \\oplus A_{i_2, j_2} = 0$, where $\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nThere is a partially filled integer grid $G$ with $n$ rows and $m$ columns where only $k$ cells are filled. Polycarp wants to know how many ways he can assign integers to the unfilled cells so that the grid is beautiful.\n\nHowever, Monocarp thinks that this problem is too easy. Therefore, he will perform $q$ updates on the grid. In each update, he will choose an unfilled cell and assign an integer to it. Note that these updates are persistent. That is, changes made to the grid will apply when processing future updates.\n\nFor each of the $q + 1$ states of the grid, the initial state and after each of the $q$ queries, determine the number of ways Polycarp can assign integers to the unfilled cells so that the grid is beautiful. Since this number can be very large, you are only required to output their values modulo $10^9+7$.\n\n### Input\n\nThe first line contains $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains four integers $n$, $m$, $k$ and $q$ ($2 \\le n, m \\le 10^5$; $0 \\le k \\le 10^5$; $q = 0$)\u00a0\u2014 the number of rows, the number of columns, the number of fixed cells, and the number of updates.\n\nThe following $k$ lines contain three integers $r$, $c$ and $v$ ($1 \\le r \\le n, 1 \\le c \\le m$; $0 \\le v < 2^{30}$)\u00a0\u2014 indicating that $G_{r, c}$ is assigned the integer $v$.\n\nThe following $q$ lines contain three integers $r$, $c$ and $v$ ($1 \\le r \\le n, 1 \\le c \\le m$; $0 \\le v < 2^{30}$)\u00a0\u2014 indicating that $G_{r, c}$ is assigned the integer $v$.\n\nIt is guaranteed that the pairs $(r,c)$ over all assignments are distinct.\n\nIt is guaranteed that the sum of $n$, $m$, $k$ and $q$ over all test cases does not exceed $10^5$ respectively.\n\n### Output\n\nFor each test case, output $q + 1$ lines. The $i$-th line of output should contain the answer of the $i$-th state of the grid modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n3 3 8 0\n\n2 1 6\n\n3 2 12\n\n1 2 6\n\n2 2 0\n\n1 3 10\n\n1 1 0\n\n2 3 12\n\n3 1 10\n\n2 5 2 0\n\n1 1 10\n\n1 2 30\n\n```\n\n#### Output #1\n\n```\n1\n489373567\n```\n\n### Note\n\nIn the first test case of the example, we have the following grid:\n\n$0\n\n$$6$$\n\n10\n\n$$6$$\n\n0\n\n$$12$$\n\n10\n\n$$12$$\n\nIt can be proven that the only valid value for tile $(3, 3)$ is $0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Required for std::iota\n\n// Define the modulo constant\nconst int MOD = 1e9 + 7;\n\n// DSU (Disjoint Set Union) structure with path compression and XOR distance tracking.\n// This structure helps maintain connected components and check consistency of XOR constraints.\nstruct DSU {\n    std::vector<int> parent; // parent[i] stores the parent of node i in the DSU tree\n    // dist[i] stores the XOR sum of edge weights along the path from node i to its parent.\n    // After path compression during find(i), dist[i] will eventually store value[i] ^ value[root], where root = find(i).\n    std::vector<int> dist; \n    int components; // Stores the current number of connected components\n    bool consistent; // Flag to track if the constraints processed so far are consistent\n\n    // Constructor initializes DSU for n elements (nodes 1 to n).\n    DSU(int n) {\n        parent.resize(n + 1);\n        // Initialize each element as its own parent (representing n components initially).\n        std::iota(parent.begin(), parent.end(), 0); \n        // Initialize distances to 0, as value[i] ^ value[parent[i]=i] = value[i] ^ value[i] = 0.\n        dist.assign(n + 1, 0); \n        // Initially, there are n components.\n        components = n; \n        // Assume constraints are consistent initially.\n        consistent = true; \n    }\n\n    // Find operation finds the root of the set containing node i.\n    // It performs path compression and updates distances along the path.\n    int find(int i) {\n        // If i is the root of its set, return i.\n        if (parent[i] == i) {\n            return i;\n        }\n        // Store the current parent before path compression potentially changes it.\n        int current_parent = parent[i];\n        // Recursively find the root of the parent.\n        int root = find(current_parent);\n        // Update distance: dist[i] accumulates the XOR sum along the path to the root.\n        // The property maintained is that after find(i), dist[i] = value[i] ^ value[root].\n        // This update ensures this property: dist[i] now represents the XOR sum from i to the new parent (root),\n        // which is calculated using the old dist[i] (i to current_parent) and the updated dist[current_parent] (current_parent to root).\n        dist[i] ^= dist[current_parent]; \n        // Path compression: Set parent of i directly to the root.\n        parent[i] = root;\n        return root;\n    }\n\n    // Union operation merges the sets containing nodes i and j.\n    // It's based on an edge constraint: value[i] ^ value[j] = edge_weight.\n    void unite(int i, int j, int edge_weight) {\n        // If inconsistency has already been detected, do nothing further.\n        if (!consistent) return; \n\n        // Find the roots of the sets containing i and j. This also performs path compression.\n        int root_i = find(i);\n        int root_j = find(j);\n\n        // If i and j are already in the same set (same root).\n        if (root_i == root_j) {\n            // Check for consistency. After the find operations:\n            // dist[i] = value[i] ^ value[root_i]\n            // dist[j] = value[j] ^ value[root_j]\n            // Since root_i == root_j, we XOR these equations:\n            // dist[i] ^ dist[j] = (value[i] ^ value[root_i]) ^ (value[j] ^ value[root_j]) = value[i] ^ value[j]\n            // The constraint requires value[i] ^ value[j] == edge_weight.\n            // So, we must check if dist[i] ^ dist[j] == edge_weight.\n            if ((dist[i] ^ dist[j]) != edge_weight) {\n                // If the constraint is violated, mark the DSU state as inconsistent.\n                consistent = false; \n            }\n        } else { // If i and j are in different sets, merge them.\n            // Standard DSU merge: make root_i a child of root_j.\n            parent[root_i] = root_j;\n            // Update the distance for the new child root_i.\n            // We need dist[root_i] to store value[root_i] ^ value[root_j].\n            // From the constraint value[i] ^ value[j] = edge_weight, substitute using DSU properties:\n            // (value[root_i] ^ dist[i]) ^ (value[root_j] ^ dist[j]) = edge_weight\n            // Rearranging gives: value[root_i] ^ value[root_j] = edge_weight ^ dist[i] ^ dist[j].\n            dist[root_i] = dist[i] ^ dist[j] ^ edge_weight;\n            // Merging two components reduces the total number of components by one.\n            components--; \n        }\n    }\n};\n\n// Modular exponentiation function: computes (base^exp) % MOD efficiently.\nlong long power(long long base, long long exp) {\n    long long res = 1;\n    base %= MOD; // Ensure base is within modulo range.\n    while (exp > 0) {\n        // If exponent is odd, multiply result with current base.\n        if (exp % 2 == 1) res = (res * base) % MOD;\n        // Square the base and halve the exponent.\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return res;\n}\n\n// Structure to store grid constraints: {row, column, value}.\nstruct Constraint {\n    int r, c, v;\n};\n\nint main() {\n    // Use faster I/O operations.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t; // Number of test cases.\n    std::cin >> t;\n    while (t--) {\n        int n, m, k, q; // Grid dimensions (n rows, m columns), initial constraints count (k), updates count (q).\n        std::cin >> n >> m >> k >> q;\n        \n        // Store the k initial constraints.\n        std::vector<Constraint> constraints(k);\n        for (int i = 0; i < k; ++i) {\n            std::cin >> constraints[i].r >> constraints[i].c >> constraints[i].v;\n        }\n        \n        // This is the easy version of the problem, where q=0 is guaranteed.\n        // We only need to compute the answer for the initial state of the grid.\n        \n        long long total_components_sum = 0; // Accumulates the sum of component counts over all 30 bits.\n        bool possible = true; // Flag indicating if the grid constraints are consistent across all bits.\n\n        // Iterate over each bit position p from 0 to 29 (for values up to 2^30 - 1).\n        for (int p = 0; p < 30; ++p) {\n            // Initialize a new DSU structure for this bit. It has n+m nodes:\n            // Nodes 1 to n represent rows R1 to Rn.\n            // Nodes n+1 to n+m represent columns C1 to Cm.\n            DSU dsu(n + m); \n            \n            // Process all k initial constraints for the current bit p.\n            for (const auto& constraint : constraints) {\n                int r = constraint.r; // Row index (1-based).\n                int c = constraint.c; // Column index (1-based).\n                int v = constraint.v; // Assigned value.\n                // Extract the p-th bit of the value v. This is the weight for the constraint equation.\n                int weight = (v >> p) & 1; \n                // Apply the constraint X_r ^ Y_c = weight using DSU.\n                // This corresponds to an edge between row node r and column node n + c with weight.\n                dsu.unite(r, n + c, weight);\n                // If inconsistency is detected within this bit's constraints, stop processing for this bit.\n                 if (!dsu.consistent) { \n                    break;\n                }\n            }\n\n            // If the DSU detected inconsistency for bit p, the total number of ways is 0.\n            if (!dsu.consistent) {\n                possible = false; // Mark overall inconsistency.\n                break; // No need to check further bits.\n            }\n            // If consistent for this bit, add the number of connected components to the total sum.\n            // Each component contributes one degree of freedom for this bit.\n            total_components_sum += dsu.components;\n        }\n\n        // After checking all bits, output the final result.\n        if (!possible) {\n            // If constraints were inconsistent for any bit, output 0.\n            std::cout << 0 << \"\\n\"; \n        } else {\n            // The number of ways to fill the grid is 2^(total_components_sum - 30).\n            // The -30 accounts for the freedom to choose the XOR constant C.\n            long long exponent = total_components_sum - 30;\n            // The exponent should theoretically be non-negative if 'possible' is true.\n             if (exponent < 0) {\n                 // This case should not happen based on the theory that total_components_sum >= 30 if possible.\n                 // Output 0 defensively in case of any edge case or reasoning error.\n                 std::cout << 0 << \"\\n\";\n             } else {\n                 // Calculate 2^exponent modulo MOD and print the result.\n                 std::cout << power(2, exponent) << \"\\n\";\n             }\n        }\n        \n         // In the easy version, q=0, so this loop for updates does not run.\n         // Include reading loop just in case input format requires consuming these lines.\n         for (int i = 0; i < q; ++i) {\n             int r_q, c_q, v_q;\n             std::cin >> r_q >> c_q >> v_q; // Read query details (r, c, v).\n             // Placeholder for update logic (needed only for the hard version).\n         }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2022c",
      "PROBLEM_ID": "2022C",
      "PROBLEM_STATEMENT": "We all steal a little bit. But I have only one hand, while my adversaries have two.\n\n\u00c1lvaro Obreg\u00f3n\n\n\u00c1lvaro and Jos\u00e9 are the only candidates running for the presidency of Tepito, a rectangular grid of $2$ rows and $n$ columns, where each cell represents a house. It is guaranteed that $n$ is a multiple of $3$.\n\nUnder the voting system of Tepito, the grid will be split into districts, which consist of any $3$ houses that are connected$^{\\text{\u2217}}$. Each house will belong to exactly one district.\n\nEach district will cast a single vote. The district will vote for \u00c1lvaro or Jos\u00e9 respectively if at least $2$ houses in that district select them. Therefore, a total of $\\frac{2n}{3}$ votes will be cast.\n\nAs \u00c1lvaro is the current president, he knows exactly which candidate each house will select. If \u00c1lvaro divides the houses into districts optimally, determine the maximum number of votes he can get.\n\n$^{\\text{\u2217}}$A set of cells is connected if there is a path between any $2$ cells that requires moving only up, down, left and right through cells in the set.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($3 \\le n \\le 10^5$; $n$ is a multiple of $3$)\u00a0\u2014 the number of columns of Tepito.\n\nThe following two lines each contain a string of length $n$. The $i$-th line contains the string $s_i$, consisting of the characters $\\texttt{A}$ and $\\texttt{J}$. If $s_{i,j}=\\texttt{A}$, the house in the $i$-th row and $j$-th column will select \u00c1lvaro. Otherwise if $s_{i,j}=\\texttt{J}$, the house will select Jos\u00e9.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximum number of districts \u00c1lvaro can win by optimally dividing the houses into districts.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3\n\nAAA\n\nAJJ\n\n6\n\nJAJAJJ\n\nJJAJAJ\n\n6\n\nAJJJAJ\n\nAJJAAA\n\n9\n\nAJJJJAJAJ\n\nJAAJJJJJA\n\n```\n\n#### Output #1\n\n```\n2\n2\n3\n2\n```\n\n### Note\n\nThe image below showcases the optimal arrangement of districts \u00c1lvaro can use for each test case in the example.\n\n![](https://espresso.codeforces.com/201cafe7ad173f25765de51cfc513d2eb124be57.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Maximum total columns (sum over all test cases <= 1e5, \n// but any single n <= 1e5).\nstatic const int MAXN = 100000 + 5;\n\n// dp[pos][mask]: maximum wins from column pos..n-1 with current occupancy mask.\n// mask is 6-bit: bits 0,1 for (row0,row1) at col=pos;\n//                bits 2,3 for (row0,row1) at col=pos+1;\n//                bits 4,5 for (row0,row1) at col=pos+2.\nstatic int dp[MAXN+2][64];\n// shape_w[b][j][pos]: for reference row b (0=top,1=bottom), shape j=0..3 at column pos,\n//   weight = 1 if shape covers >=2 'A's, else 0.\nstatic unsigned char shape_w[2][4][MAXN+2];\n\n// Pre-defined shape masks and dx_max for the 4 shapes per row-reference.\n// shape_masks[b][j] is the 6-bit mask of the shape relative to column pos.\nstatic const int shape_masks[2][4] = {\n    // b=0 (reference = top row)\n    { \n      // j=0: horizontal in top row: bits (0,2,4)\n      (1<<0)|(1<<2)|(1<<4),   // 21\n      // j=1: L double at c, single at (c+1,top)\n      (1<<0)|(1<<1)|(1<<2),   // 7\n      // j=2: L double at c, single at (c+1,bottom)\n      (1<<0)|(1<<1)|(1<<3),   // 11\n      // j=3: L double at (c+1), single at (c,top)\n      (1<<0)|(1<<2)|(1<<3)    // 13\n    },\n    // b=1 (reference = bottom row)\n    {\n      // j=0: horizontal in bottom row: bits (1,3,5)\n      (1<<1)|(1<<3)|(1<<5),   // 42\n      // j=1: L double at c, single at (c+1,bottom)\n      (1<<1)|(1<<0)|(1<<3),   // 11\n      // j=2: L double at c, single at (c+1,top)\n      (1<<1)|(1<<0)|(1<<2),   // 7\n      // j=3: L double at (c+1), single at (c,bottom)\n      (1<<1)|(1<<2)|(1<<3)    // 14\n    }\n};\n// Maximum column-offset used by each of the 4 shapes.\nstatic const int shape_dx_max[4] = {2,1,1,1};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        string s0, s1;\n        cin >> s0 >> s1;\n\n        // Precompute shape weights for each position and each shape j, for b=0,1.\n        // shape is only valid at pos if pos+dx_max[j] < n.\n        for(int pos = 0; pos < n; ++pos){\n            int max_off = n - 1 - pos;\n            for(int b = 0; b < 2; ++b){\n                for(int j = 0; j < 4; ++j){\n                    if(shape_dx_max[j] > max_off){\n                        // shape goes out of grid to the right\n                        shape_w[b][j][pos] = 0;\n                    } else {\n                        // count 'A's in the 3 cells of this shape\n                        int cntA = 0;\n                        int m = shape_masks[b][j];\n                        // iterate bits of m\n                        int mm = m;\n                        while(mm){\n                            int bit = mm & -mm;\n                            int bitpos = __builtin_ctz(mm);\n                            mm ^= bit;\n                            int dx  = (bitpos >> 1);\n                            int row = (bitpos & 1);\n                            if(row == 0){\n                                // top row\n                                if(s0[pos + dx] == 'A') ++cntA;\n                            } else {\n                                // bottom row\n                                if(s1[pos + dx] == 'A') ++cntA;\n                            }\n                        }\n                        shape_w[b][j][pos] = (cntA >= 2 ? 1 : 0);\n                    }\n                }\n            }\n        }\n\n        // Initialize dp at pos = n: no columns left, only mask=0 is valid (score 0).\n        const int NINF = -1000000000;\n        for(int mask = 0; mask < 64; ++mask){\n            dp[n][mask] = (mask == 0 ? 0 : NINF);\n        }\n\n        // Fill dp from pos = n-1 down to 0\n        for(int pos = n - 1; pos >= 0; --pos){\n            // For each mask at this pos\n            // We iterate masks in descending order so that transitions within the same pos\n            // (mask -> mask|something > mask) refer to already computed states.\n            for(int mask = 63; mask >= 0; --mask){\n                int &res = dp[pos][mask];\n                res = NINF;\n                // If both cells at col 'pos' are already covered, advance to next column\n                if((mask & 3) == 3){\n                    // shift mask right by 2 bits\n                    int nm = (mask >> 2);\n                    // bits for dx=2,3,4,5 shift to 0..3, bits 4,5 become zero\n                    res = dp[pos+1][nm];\n                } else {\n                    // find which row at col=pos is free: row0 if bit0==0 else row1\n                    int b = ((mask & 1) == 0 ? 0 : 1);\n                    // try the 4 shapes for this reference row\n                    int limit = n - 1 - pos;\n                    for(int j = 0; j < 4; ++j){\n                        if(shape_dx_max[j] > limit) continue;\n                        int m = shape_masks[b][j];\n                        if(mask & m) continue; // overlap\n                        int cand = shape_w[b][j][pos] + dp[pos][mask | m];\n                        if(cand > res) res = cand;\n                    }\n                }\n            }\n        }\n\n        // The answer is dp[0][0]\n        cout << dp[0][0] << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2022b",
      "PROBLEM_ID": "2022B",
      "PROBLEM_STATEMENT": "Karel is a salesman in a car dealership. The dealership has $n$ different models of cars. There are $a_i$ cars of the $i$-th model. Karel is an excellent salesperson and can convince customers to buy up to $x$ cars (of Karel's choice), as long as the cars are from different models.\n\nDetermine the minimum number of customers Karel has to bring in to sell all the cars.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 5 \\cdot 10^5$; $1 \\le x \\le 10$)\u00a0\u2014 the number of different models of cars and the maximum number of cars Karel can convince a customer to buy.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the number of cars of each model.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the minimum possible number of customers needed to sell all the cars.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 2\n\n3 1 2\n\n3 3\n\n2 1 3\n\n5 3\n\n2 2 1 9 2\n\n7 4\n\n2 5 3 3 5 2 5\n\n```\n\n#### Output #1\n\n```\n3\n3\n9\n7\n```\n\n### Note\n\nFor the first case, Karel only needs to lure in $3$ customers. He will convince the customers to buy the following models of cars:\n\n- Customer $1$ buys $2$ cars with model $1$ and $3$.\n- Customer $2$ buys $2$ cars with model $1$ and $2$.\n- Customer $3$ buys $2$ cars with model $1$ and $3$.\n\nFor the second case, Karel only needs to lure in $3$ customers. He will convince the customers to buy the following models of cars:\n\n- Customer $1$ buys $2$ cars with model $1$ and $3$.\n- Customer $2$ buys $3$ cars with model $1$, $2$ and $3$.\n- Customer $3$ buys $1$ car with model $3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int t;\n    cin >> t;\n    while(t--){\n        int n, x;\n        cin >> n >> x;\n        vector<long long> a(n);\n        long long total_cars = 0;\n        long long max_cars = 0;\n        for(int i = 0; i < n; ++i){\n            cin >> a[i];\n            total_cars += a[i];\n            max_cars = max(max_cars, a[i]);\n        }\n        // Compute ceil(total_cars / x)\n        long long customers_needed = (total_cars + x - 1) / x;\n        long long ans = max(customers_needed, max_cars);\n        cout << ans << \"\\n\";\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2022a",
      "PROBLEM_ID": "2022A",
      "PROBLEM_STATEMENT": "Ya vamos llegando a P\u00e9eeenjamoo \u266b\u266b\u266b\n\nThere are $n$ families travelling to P\u00e9njamo to witness Mexico's largest-ever \"walking a chicken on a leash\" marathon. The $i$-th family has $a_i$ family members. All families will travel using a single bus consisting of $r$ rows with $2$ seats each.\n\nA person is considered happy if:\n\n- Another family member is seated in the same row as them, or\n- They are sitting alone in their row (with an empty seat next to them).\n\nDetermine the maximum number of happy people in an optimal seating arrangement. Note that everyone must be seated in the bus.\n\nIt is guaranteed that all family members will fit on the bus. Formally, it is guaranteed that $\\displaystyle\\sum_{i=1}^{n}a_i \\le 2r$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $r$ ($1 \\le n \\le 100$; $1 \\le r \\le 500$)\u00a0\u2014 the number of families and the number of rows in the bus.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10$)\u00a0\u2014 the number of family members in each family.\n\n### Output\n\nFor each test case, output the maximum number of happy people in an optimal seating arrangement.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 3\n\n2 3 1\n\n3 3\n\n2 2 2\n\n4 5\n\n1 1 2 2\n\n4 5\n\n3 1 1 3\n\n```\n\n#### Output #1\n\n```\n4\n6\n6\n6\n```\n\n### Note\n\nIn the first test case, the two members of the first family can sit together in the first row, while the two members of the second family can sit together in the second row. The remaining member of the second family can sit in the third row along with a member of the third family. This seating arrangement is shown below, where the $4$ happy people are colored green.\n\n$\\color{green}{1}\n\n$$\\color{green}{1}$$\n\ncolor{green}{2}\n\n$$\\color{green}{2}$$\n\n2$$3$\n\nIn the second test case, a possible seating arrangement with $6$ happy people is shown below.\n\n$\\color{green}{3}\n\n$$\\color{green}{3}$$\n\ncolor{green}{1}\n\n$$\\color{green}{1}$$\n\ncolor{green}{2}$$\\color{green}{2}$\n\nIn the third test case, a possible seating arrangement with $6$ happy people is shown below.\n\n$\\color{green}{4}\n\n$$\\color{green}{4}$$\n\ncolor{green}{}\n\n$$\\color{green}{2}$$\n\ncolor{green}{3}\n\n$$\\color{green}{3}$$\n\ncolor{green}{1}\n\n$$\\color{green}{}$$\n\ncolor{green}{}$$\\color{green}{}$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, r;\n        cin >> n >> r;\n        \n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        \n        int pairs = 0;\n        int unpaired = 0;\n        \n        for (int i = 0; i < n; i++) {\n            pairs += a[i] / 2;\n            unpaired += a[i] % 2;\n        }\n        \n        int happyFromPairs = 2 * pairs;\n        int rowsLeft = r - pairs;\n        int happyFromUnpaired = min(unpaired, max(2 * rowsLeft - unpaired, 0));\n        \n        int totalHappy = happyFromPairs + happyFromUnpaired;\n        \n        cout << totalHappy << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2021e3",
      "PROBLEM_ID": "2021E3",
      "PROBLEM_STATEMENT": "This is the extreme version of the problem. In the three versions, the constraints on $n$ and $m$ are different. You can make hacks only if all the versions of the problem are solved.\n\nPak Chanek is setting up internet connections for the village of Khuntien. The village can be represented as a connected simple graph with $n$ houses and $m$ internet cables connecting house $u_i$ and house $v_i$, each with a latency of $w_i$.\n\nThere are $p$ houses that require internet. Pak Chanek can install servers in at most $k$ of the houses. The houses that need internet will then be connected to one of the servers. However, since each cable has its latency, the latency experienced by house $s_i$ requiring internet will be the maximum latency of the cables between that house and the server it is connected to.\n\nFor each $k = 1,2,\\ldots,n$, help Pak Chanek determine the minimum total latency that can be achieved for all the houses requiring internet.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains 3 integers $n$, $m$, $p$ ($2 \\le n \\le 2 \\cdot 10^5$; $n-1 \\le m \\le 2 \\cdot 10^5$; $1 \\le p \\le n$)\u00a0\u2014 the number of houses, the number of cables, and the number of houses that need internet.\n\nThe second line of each test case contains $p$ integers $s_1, s_2, \\ldots, s_p$ ($1 \\le s_i \\le n$)\u00a0\u2014 the houses that need internet. It is guaranteed that all elements of $s$ are distinct.\n\nThe $i$-th of the next $m$ lines of each test case contains three integers $u_i$, $v_i$, and $w_i$ ($1 \\le u_i < v_i \\le n$; $1 \\le w_i \\le 10^9$)\u00a0\u2014 the internet cable connecting house $u_i$ and house $v_i$ with latency of $w_i$. It is guaranteed that the given edges form a connected simple graph.\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ do not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n$ integers: the minimum total latency that can be achieved for all the houses requiring internet for each $k = 1,2,\\ldots,n$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n9 8 5\n\n2 5 6 8 9\n\n1 2 1\n\n1 3 2\n\n3 4 10\n\n4 5 3\n\n4 6 5\n\n1 7 10\n\n7 8 4\n\n7 9 2\n\n3 3 2\n\n3 1\n\n1 2 1\n\n2 3 3\n\n1 3 2\n\n```\n\n#### Output #1\n\n```\n34 19 9 4 0 0 0 0 0\n2 0 0\n```\n\n### Note\n\nIn the first test case for $k=3$, a possible optimal solution is to install servers at vertices $2$, $6$ and $8$ and obtain the following latency:\n\n- $\\text{latency}(2) = 0$\n- $\\text{latency}(5) = \\max(3, 5) = 5$\n- $\\text{latency}(6) = 0$\n- $\\text{latency}(8) = 0$\n- $\\text{latency}(9) = \\max(2, 4) = 4$\n\nSo the total latency is $9$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAXN = 200000;\nconst int MAX2N = 400000 + 5;\n\nint ds[MAX2N];             // DSU parent\nint lch[MAX2N], rch[MAX2N]; // children in Kruskal tree\nint weight_edge[MAX2N];     // weight at internal node\nint sz_special[MAX2N];      // number of special leaves in subtree\nll cost1[MAX2N];            // minimal cost with one server in subtree\nbool is_special[MAXN + 5];  // marks special leaves\n\n// Find with path compression\nint findDS(int x) {\n    int r = x;\n    while (ds[r] != r) r = ds[r];\n    int y;\n    while (ds[x] != x) {\n        y = ds[x];\n        ds[x] = r;\n        x = y;\n    }\n    return r;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m, p;\n        cin >> n >> m >> p;\n        vector<int> specials(p);\n        for (int i = 0; i < p; i++) {\n            cin >> specials[i];\n            is_special[specials[i]] = true;\n        }\n\n        // Initialize DSU and Kruskal-tree data up to 2*n\n        int maxNodes = 2 * n;\n        for (int i = 1; i <= maxNodes; i++) {\n            ds[i] = i;\n            lch[i] = rch[i] = 0;\n            weight_edge[i] = 0;\n            sz_special[i] = 0;\n            cost1[i] = 0;\n        }\n\n        // Read edges\n        struct Edge { int u, v, w; };\n        vector<Edge> edges(m);\n        for (int i = 0; i < m; i++) {\n            cin >> edges[i].u >> edges[i].v >> edges[i].w;\n        }\n        sort(edges.begin(), edges.end(),\n             [](auto &a, auto &b) { return a.w < b.w; });\n\n        // Build Kruskal tree\n        int tot = n;  // current total nodes in Kruskal tree\n        for (auto &e : edges) {\n            int ru = findDS(e.u);\n            int rv = findDS(e.v);\n            if (ru != rv) {\n                ++tot;\n                weight_edge[tot] = e.w;\n                lch[tot] = ru;\n                rch[tot] = rv;\n                ds[ru] = tot;\n                ds[rv] = tot;\n                ds[tot] = tot;\n            }\n        }\n        // The root of the Kruskal tree covers all, find via any special\n        int root = findDS(specials[0]);\n\n        // DP bottom-up to compute sz_special, cost1, and benefits\n        vector<ll> benefits;\n        benefits.reserve(p ? p - 1 : 0);\n        for (int u = 1; u <= tot; u++) {\n            if (u <= n) {\n                // Leaf: special or not\n                sz_special[u] = is_special[u] ? 1 : 0;\n                cost1[u] = 0;\n            } else {\n                // Internal node\n                int a = lch[u], b = rch[u];\n                int sa = sz_special[a], sb = sz_special[b];\n                sz_special[u] = sa + sb;\n                if (sz_special[u] > 0) {\n                    // one server in this cluster\n                    ll c1 = cost1[a] + (ll)sb * weight_edge[u];\n                    ll c2 = cost1[b] + (ll)sa * weight_edge[u];\n                    cost1[u] = min(c1, c2);\n                } else {\n                    cost1[u] = 0;\n                }\n                // benefit of splitting this cluster into its two child clusters\n                if (sa > 0 && sb > 0) {\n                    ll without_split = cost1[u];\n                    ll with_split = cost1[a] + cost1[b];\n                    ll ben = without_split - with_split;\n                    // ben should be >= 0\n                    benefits.push_back(ben);\n                }\n            }\n        }\n\n        // Sort benefits descending\n        sort(benefits.begin(), benefits.end(), greater<ll>());\n        int B = (int)benefits.size(); // should be p-1\n\n        // Prefix sums of benefits\n        vector<ll> pref(B + 1, 0);\n        for (int i = 1; i <= B; i++) {\n            pref[i] = pref[i - 1] + benefits[i - 1];\n        }\n\n        // Output answers for k = 1..n\n        // f(1) = cost1[root] - pref[0]\n        // f(k) = cost1[root] - pref[k-1] for k<=p\n        // f(k) = 0 for k>p\n        ll base = cost1[root];\n        for (int k = 1; k <= n; k++) {\n            ll ans;\n            if (k <= p) {\n                ans = base - pref[k - 1];\n            } else {\n                ans = 0;\n            }\n            cout << ans << (k < n ? ' ' : '\\n');\n        }\n\n        // Clear special marks\n        for (int s : specials) {\n            is_special[s] = false;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2021e2",
      "PROBLEM_ID": "2021E2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. In the three versions, the constraints on $n$ and $m$ are different. You can make hacks only if all the versions of the problem are solved.\n\nPak Chanek is setting up internet connections for the village of Khuntien. The village can be represented as a connected simple graph with $n$ houses and $m$ internet cables connecting house $u_i$ and house $v_i$, each with a latency of $w_i$.\n\nThere are $p$ houses that require internet. Pak Chanek can install servers in at most $k$ of the houses. The houses that need internet will then be connected to one of the servers. However, since each cable has its latency, the latency experienced by house $s_i$ requiring internet will be the maximum latency of the cables between that house and the server it is connected to.\n\nFor each $k = 1,2,\\ldots,n$, help Pak Chanek determine the minimum total latency that can be achieved for all the houses requiring internet.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2000$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, $p$ ($2 \\le n \\le 5000$; $n-1 \\le m \\le 5000$; $1 \\le p \\le n$)\u00a0\u2014 the number of houses, the number of cables, and the number of houses that need internet.\n\nThe second line of each test case contains $p$ integers $s_1, s_2, \\ldots, s_p$ ($1 \\le s_i \\le n$)\u00a0\u2014 the houses that need internet. It is guaranteed that all elements of $s$ are distinct.\n\nThe $i$-th of the next $m$ lines of each test case contains three integers $u_i$, $v_i$, and $w_i$ ($1 \\le u_i < v_i \\le n$; $1 \\le w_i \\le 10^9$)\u00a0\u2014 the internet cable connecting house $u_i$ and house $v_i$ with latency of $w_i$. It is guaranteed that the given edges form a connected simple graph.\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ do not exceed $5000$.\n\n### Output\n\nFor each test case, output $n$ integers: the minimum total latency that can be achieved for all the houses requiring internet for each $k = 1,2,\\ldots,n$.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n9 8 5\n\n2 5 6 8 9\n\n1 2 1\n\n1 3 2\n\n3 4 10\n\n4 5 3\n\n4 6 5\n\n1 7 10\n\n7 8 4\n\n7 9 2\n\n3 3 2\n\n3 1\n\n1 2 1\n\n2 3 3\n\n1 3 2\n\n```\n\n#### Output #1\n\n```\n34 19 9 4 0 0 0 0 0\n2 0 0\n```\n\n### Note\n\nIn the first test case for $k=3$, a possible optimal solution is to install servers at vertices $2$, $6$ and $8$ and obtain the following latency:\n\n- $\\text{latency}(2) = 0$\n- $\\text{latency}(5) = \\max(3, 5) = 5$\n- $\\text{latency}(6) = 0$\n- $\\text{latency}(8) = 0$\n- $\\text{latency}(9) = \\max(2, 4) = 4$\n\nSo the total latency is $9$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\n// We will build the MST of the graph, then form the corresponding\n// \"cluster tree\" (also known as the maximum\u2010edge\u2010on\u2010path or ultrametric tree).\n// On that binary tree we do a bottom\u2010up DP computing, for each node v and\n// for each possible number of centers i placed in v's subtree, the minimum\n// total latency to serve all required houses in that subtree by those i centers.\n//\n// Let dp[v][i] = minimal cost to cover all service\u2010houses in subtree v\n// using i centers placed anywhere in that subtree.  At an internal node v\n// merging children a,b with merge\u2010weight w, we combine child DPs:\n//\n//   dp[v][i] = min_{iA+iB=i} dp[a][iA] + dp[b][iB]\n//                 + (iA>0 && iB==0 ? demandsInB * w : 0)\n//                 + (iB>0 && iA==0 ? demandsInA * w : 0)\n//\n// where demandsInA and demandsInB are the counts of service\u2010houses in\n// a's and b's subtrees.  Leaves (houses) have dp[leaf][0]=0 and\n// dp[leaf][1]=0 (placing a center there costs zero, whether it's\n// a service\u2010house or not).\n//\n// Finally, the root's dp[root][k] for k=1..n are the answers for each k.\n//\n// Complexity: O(n^2) per test in the worst case, which is fine for n \u22645000\n// (sum of n over all tests \u22645000).  \n\nstatic const long long INF = (long long)9e18;\n\nint n, m, p;\n// DSU arrays and cluster\u2010tree storage up to 2*n\u22121 nodes\nstatic int parentDSU[10005];\nstatic int Lch[10005], Rch[10005];\nstatic long long wtNode[10005];\nstatic int demandCount[10005];\nstatic bool isService[5005];\n\n// Find with path compression\nint findDSU(int x) {\n    if (parentDSU[x] == x) return x;\n    return parentDSU[x] = findDSU(parentDSU[x]);\n}\n\n// Solve DP on the cluster tree rooted at v:\nvector<long long> solveDP(int v) {\n    // If leaf, we can place 0 or 1 center here, cost=0\n    if (v <= n) {\n        vector<long long> dp(2, 0LL);\n        return dp;\n    }\n    // Internal: merge children\n    int a = Lch[v], b = Rch[v];\n    vector<long long> dpA = solveDP(a);\n    vector<long long> dpB = solveDP(b);\n    int szA = dpA.size(), szB = dpB.size();\n    int total = szA + szB - 1;\n    vector<long long> dp(total, INF);\n    long long w = wtNode[v];\n    int dA = demandCount[a], dB = demandCount[b];\n    for (int iA = 0; iA < szA; iA++) {\n        if (dpA[iA] >= INF) continue;\n        for (int iB = 0; iB < szB; iB++) {\n            if (dpB[iB] >= INF) continue;\n            long long c = dpA[iA] + dpB[iB];\n            // If all centers are in A and none in B, B's demands pay w\n            if (iA > 0 && iB == 0) c += 1LL * dB * w;\n            // If all centers are in B and none in A, A's demands pay w\n            if (iB > 0 && iA == 0) c += 1LL * dA * w;\n            int i = iA + iB;\n            if (c < dp[i]) dp[i] = c;\n        }\n    }\n    return dp;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        cin >> n >> m >> p;\n        // Read service\u2010houses\n        fill(isService + 1, isService + n + 1, false);\n        for (int i = 0; i < p; i++) {\n            int s;\n            cin >> s;\n            isService[s] = true;\n        }\n        // Read edges\n        struct Edge { int u, v; long long w; };\n        vector<Edge> edges(m);\n        for (int i = 0; i < m; i++) {\n            cin >> edges[i].u >> edges[i].v >> edges[i].w;\n        }\n        sort(edges.begin(), edges.end(),\n             [&](const Edge &a, const Edge &b){\n                 return a.w < b.w;\n             });\n\n        // Initialize DSU and cluster\u2010tree arrays\n        int maxNodes = 2*n; // we will use up to 2*n\u22121\n        for (int i = 1; i <= maxNodes; i++) {\n            parentDSU[i] = i;\n            Lch[i] = Rch[i] = 0;\n            wtNode[i] = 0;\n            demandCount[i] = 0;\n        }\n        for (int i = 1; i <= n; i++) {\n            demandCount[i] = isService[i] ? 1 : 0;\n        }\n        // Build the MST and at each union create a new cluster node\n        int curID = n;\n        for (auto &e: edges) {\n            int ru = findDSU(e.u), rv = findDSU(e.v);\n            if (ru != rv) {\n                ++curID;\n                wtNode[curID] = e.w;\n                Lch[curID] = ru;\n                Rch[curID] = rv;\n                demandCount[curID] = demandCount[ru] + demandCount[rv];\n                parentDSU[ru] = curID;\n                parentDSU[rv] = curID;\n                parentDSU[curID] = curID;\n            }\n        }\n        int root = curID;\n\n        // Run the DP on the cluster\u2010tree\n        vector<long long> dpRoot = solveDP(root);\n        // dpRoot[k] is the minimal total latency with k centers\n        // It has size n+1 (indices 0..n).\n        // We output dpRoot[1..n].\n        for (int k = 1; k <= n; k++) {\n            long long ans = (k < (int)dpRoot.size() ? dpRoot[k] : 0LL);\n            cout << ans << (k == n ? \"\\n\" : \" \");\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2021d",
      "PROBLEM_ID": "2021D",
      "PROBLEM_STATEMENT": "Pak Chanek has a friend who runs a drink stall in a canteen. His friend will sell drinks for $n$ days, numbered from day $1$ to day $n$. There are also $m$ types of drinks, numbered from $1$ to $m$.\n\nThe profit gained from selling a drink on a particular day can vary. On day $i$, the projected profit from selling drink of type $j$ is $A_{i, j}$. Note that $A_{i, j}$ can be negative, meaning that selling the drink would actually incur a loss.\n\nPak Chanek wants to help his friend plan the sales over the $n$ days. On day $i$, Pak Chanek must choose to sell at least one type of drink. Furthermore, the types of drinks sold on a single day must form a subarray. In other words, in each day, Pak Chanek will select $i$ and $j$ such that $1 \\leq i \\leq j \\leq m$. Then all types of drinks between $i$ and $j$ (inclusive) will be sold.\n\nHowever, to ensure that customers from the previous day keep returning, the selection of drink types sold on day $i$ ($i>1$) must meet the following conditions:\n\n- At least one drink type sold on day $i$ must also have been sold on day $i-1$.\n- At least one drink type sold on day $i$ must not have been sold on day $i-1$.\n\nThe daily profit is the sum of the profits from all drink types sold on that day. The total profit from the sales plan is the sum of the profits over $n$ days. What is the maximum total profit that can be achieved if Pak Chanek plans the sales optimally?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n \\leq 2 \\cdot 10^5$; $3 \\leq m \\leq 2 \\cdot 10^5$; $n \\cdot m \\leq 2 \\cdot 10^5$)\u00a0\u2014 the number of rows and columns in a grid.\n\nThe next $n$ lines of each test case contain $m$ integers each, where the $i$-th line contains the integers $A_{i,1} A_{i,2}, \\ldots, A_{i,m}$ ($-10^9 \\leq A_{i,j} \\leq 10^9$)\u00a0\u2014 project profits of each drink type on the $i$-th day.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer: the maximum profit that Pak Chanek can achieve.\n\n### Example\n\n#### Input #1\n\n```\n\n1\n\n3 6\n\n79 20 49 5 -1000 500\n\n-105 9 109 24 -98 -499\n\n14 47 12 39 23 50\n\n```\n\n#### Output #1\n\n```\n475\n```\n\n### Note\n\nHere is Pak Chanek's optimal plan:\n\n![](https://espresso.codeforces.com/ccb42f0d02306295b68f615cb77d068a6269d1d6.png)![](https://espresso.codeforces.com/9d9f5b0cf524cb68580876216c9aab01fbf55f0d.png)![](https://espresso.codeforces.com/d3d6b12faf0449759658f9d1f0e6525a52bf3d93.png)\n\n- On day $1$, Pak Chanek sells drink types $1$ to $3$. Generating a profit of $79+20+49 = 148$.\n- On day $2$, Pak Chanek sells drink types $2$ to $4$. Generating a profit of $9+109+24 = 142$\n- On day $3$, Pak Chanek sells drink types $1$ to $6$. Generating a profit of $185$.\n\nSo, the total profit of Pak Chanek's plan is $148 + 142 + 185 = 475$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long NEG_INF = LLONG_MIN / 2;\nconst int MAXM = 200000 + 5;\n\nlong long start_prev[MAXM], end_prev[MAXM];\nlong long start_cur[MAXM], end_cur[MAXM];\nlong long P[MAXM], SufMaxP[MAXM], SufMaxQ1[MAXM], SufMaxQ2[MAXM];\nlong long PrefMinP[MAXM], PrefMaxC1[MAXM], PrefMaxC2[MAXM];\nint Arow[MAXM];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n\n        // --- Day 1 initialization ---\n        // Read row 1\n        P[0] = 0;\n        for (int j = 1; j <= m; j++) {\n            cin >> Arow[j];\n            P[j] = P[j-1] + Arow[j];\n        }\n        // Suffix max of P\n        SufMaxP[m+1] = NEG_INF;\n        for (int j = m; j >= 1; j--) {\n            SufMaxP[j] = max(P[j], SufMaxP[j+1]);\n        }\n        // start_prev[l] = max_{r>=l} (P[r] - P[l-1])\n        for (int l = 1; l <= m; l++) {\n            start_prev[l] = SufMaxP[l] - P[l-1];\n        }\n        // Prefix min of P\n        PrefMinP[0] = 0;\n        for (int j = 1; j <= m; j++) {\n            PrefMinP[j] = min(PrefMinP[j-1], P[j]);\n        }\n        // end_prev[r] = max_{l<=r} (P[r] - P[l-1])\n        for (int r = 1; r <= m; r++) {\n            end_prev[r] = P[r] - PrefMinP[r-1];\n        }\n\n        // --- Days 2..n ---\n        for (int day = 2; day <= n; day++) {\n            // Read current row\n            P[0] = 0;\n            for (int j = 1; j <= m; j++) {\n                cin >> Arow[j];\n                P[j] = P[j-1] + Arow[j];\n            }\n            // Compute suffix-max of P\n            SufMaxP[m+1] = NEG_INF;\n            for (int j = m; j >= 1; j--) {\n                SufMaxP[j] = max(P[j], SufMaxP[j+1]);\n            }\n\n            // Compute start_cur via left-extension (dpL)\n            // SufMaxQ1[j] = max over x >= j of ( start_prev[x] + SufMaxP[x] )\n            SufMaxQ1[m+1] = NEG_INF;\n            for (int j = m; j >= 1; j--) {\n                long long v = start_prev[j] + SufMaxP[j];\n                SufMaxQ1[j] = max(SufMaxQ1[j+1], v);\n            }\n            // start_cur[l] = SufMaxQ1[l+1] - P[l-1]\n            for (int l = 1; l <= m; l++) {\n                start_cur[l] = SufMaxQ1[l+1] - P[l-1];\n            }\n\n            // Compute start_cur via right-extension (dpR)\n            // SufMaxQ2[j] = max over y >= j of ( end_prev[y] + SufMaxP[y+1] )\n            SufMaxQ2[m+1] = NEG_INF;\n            for (int j = m; j >= 1; j--) {\n                long long sp = SufMaxP[j+1];\n                long long v = (sp == NEG_INF ? NEG_INF : end_prev[j] + sp);\n                SufMaxQ2[j] = max(SufMaxQ2[j+1], v);\n            }\n            // Combine into start_cur\n            for (int l = 1; l <= m; l++) {\n                long long v = SufMaxQ2[l] - P[l-1];\n                if (v > start_cur[l]) start_cur[l] = v;\n            }\n\n            // Prepare prefix-min of P for end_cur calculations\n            PrefMinP[0] = 0;\n            for (int j = 1; j <= m; j++) {\n                PrefMinP[j] = min(PrefMinP[j-1], P[j]);\n            }\n\n            // Compute end_cur via left-extension (dpL)\n            // PrefMaxC1[j] = max_{2 <= x <= j} ( start_prev[x] - PrefMinP[x-2] )\n            PrefMaxC1[0] = NEG_INF;\n            for (int j = 1; j <= m; j++) {\n                long long c1 = NEG_INF;\n                if (j >= 2) {\n                    c1 = start_prev[j] - PrefMinP[j-2];\n                }\n                PrefMaxC1[j] = (j == 1 ? c1 : max(PrefMaxC1[j-1], c1));\n            }\n            // end_cur[r] = P[r] + PrefMaxC1[r]\n            for (int r = 1; r <= m; r++) {\n                long long v = PrefMaxC1[r];\n                if (v == NEG_INF) end_cur[r] = NEG_INF;\n                else end_cur[r] = P[r] + v;\n            }\n\n            // Compute end_cur via right-extension (dpR)\n            // PrefMaxC2[j] = max_{1 <= y <= j} ( end_prev[y] - PrefMinP[y-1] )\n            PrefMaxC2[0] = NEG_INF;\n            for (int j = 1; j <= m; j++) {\n                long long c2 = end_prev[j] - PrefMinP[j-1];\n                PrefMaxC2[j] = max(PrefMaxC2[j-1], c2);\n            }\n            // Combine into end_cur: end_cur[r] = max(end_cur[r], P[r] + PrefMaxC2[r-1])\n            for (int r = 1; r <= m; r++) {\n                long long bestR = NEG_INF;\n                if (r >= 2 && PrefMaxC2[r-1] != NEG_INF) {\n                    bestR = P[r] + PrefMaxC2[r-1];\n                }\n                if (bestR > end_cur[r]) end_cur[r] = bestR;\n            }\n\n            // Move current to previous for next day\n            for (int j = 1; j <= m; j++) {\n                start_prev[j] = start_cur[j];\n                end_prev[j]   = end_cur[j];\n            }\n        }\n\n        // The answer is the maximum start_prev over [1..m]\n        long long answer = NEG_INF;\n        for (int j = 1; j <= m; j++) {\n            if (start_prev[j] > answer) {\n                answer = start_prev[j];\n            }\n        }\n        cout << answer << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2021c2",
      "PROBLEM_ID": "2021C2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. In the two versions, the constraints on $q$ and the time limit are different. In this version, $0 \\leq q \\leq 2 \\cdot 10^5$. You can make hacks only if all the versions of the problem are solved.\n\nA team consisting of $n$ members, numbered from $1$ to $n$, is set to present a slide show at a large meeting. The slide show contains $m$ slides.\n\nThere is an array $a$ of length $n$. Initially, the members are standing in a line in the order of $a_1, a_2, \\ldots, a_n$ from front to back. The slide show will be presented in order from slide $1$ to slide $m$. Each section will be presented by the member at the front of the line. After each slide is presented, you can move the member at the front of the line to any position in the lineup (without changing the order of the rest of the members). For example, suppose the line of members is $[\\color{red}{3},1,2,4]$. After member $3$ presents the current slide, you can change the line of members into either $[\\color{red}{3},1,2,4]$, $[1,\\color{red}{3},2,4]$, $[1,2,\\color{red}{3},4]$ or $[1,2,4,\\color{red}{3}]$.\n\nThere is also an array $b$ of length $m$. The slide show is considered good if it is possible to make member $b_i$ present slide $i$ for all $i$ from $1$ to $m$ under these constraints.\n\nHowever, your annoying boss wants to make $q$ updates to the array $b$. In the $i$-th update, he will choose a slide $s_i$ and a member $t_i$ and set $b_{s_i} := t_i$. Note that these updates are persistent, that is changes made to the array $b$ will apply when processing future updates.\n\nFor each of the $q+1$ states of array $b$, the initial state and after each of the $q$ updates, determine if the slideshow is good.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$ and $q$ ($1 \\le n, m \\le 2 \\cdot 10^5$; $0 \\leq q \\leq 2 \\cdot 10^5$)\u00a0\u2014 the number of members and the number of sections.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the initial order of the members from front to back. It is guaranteed that each integer from $1$ to $n$ appears exactly once in $a$.\n\nThe third line of each test case contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le n$)\u00a0\u2014 the members who should present each section.\n\nEach of the next $q$ lines contains two integers $s_i$ and $t_i$ ($1 \\le s_i \\le m$, $1 \\le t_i \\le n$)\u00a0\u2014 parameters of an update.\n\nIt is guaranteed that the sum of $n$, the sum of $m$ and the sum of $q$ over all test cases do not exceed $2 \\cdot 10^5$ respectively.\n\n### Output\n\nFor each test case, output $q+1$ lines corresponding to the $q+1$ states of the array $b$. Output \"YA\" if the slide show is good, and \"TIDAK\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yA\", \"Ya\", \"ya\", and \"YA\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4 2 2\n\n1 2 3 4\n\n1 1\n\n1 2\n\n1 1\n\n3 6 2\n\n1 2 3\n\n1 1 2 3 3 2\n\n3 3\n\n2 2\n\n4 6 2\n\n3 1 4 2\n\n3 1 1 2 3 4\n\n3 4\n\n4 2\n\n```\n\n#### Output #1\n\n```\nYA\nTIDAK\nYA\nYA\nTIDAK\nYA\nTIDAK\nYA\nYA\n```\n\n### Note\n\nFor the first test case, you do not need to move the members as both slides are presented by member $1$, who is already at the front of the line. After that, set $b_1 := 2$, now slide $1$ must be presented by member $2$ which is impossible as member $1$ will present slide $1$ first. Then, set $b_1 = 1$, the $b$ is the same as the initial $b$, making a good presentation possible.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m, q;\n        cin >> n >> m >> q;\n        vector<int> a(n+1);\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        // position of each member in array a\n        vector<int> pos_in_a(n+1);\n        for (int i = 1; i <= n; i++) {\n            pos_in_a[a[i]] = i;\n        }\n        // read b\n        vector<int> b(m+1);\n        for (int i = 1; i <= m; i++) {\n            cin >> b[i];\n        }\n        // occurrences of each member in b\n        vector< set<int> > occ(n+1);\n        for (int i = 1; i <= m; i++) {\n            occ[b[i]].insert(i);\n        }\n        // INF for \"never occurs\"\n        int INF = m + 1;\n        // first occurrence of each member\n        vector<int> first_occ(n+1);\n        for (int p = 1; p <= n; p++) {\n            if (occ[p].empty()) first_occ[p] = INF;\n            else first_occ[p] = *occ[p].begin();\n        }\n        // build c array: c[i] = first occurrence of a[i]\n        vector<int> c(n+1);\n        for (int i = 1; i <= n; i++) {\n            c[i] = first_occ[a[i]];\n        }\n        // compute initial bad count: bad at i if c[i] > c[i+1]\n        int fail = 0;\n        for (int i = 1; i < n; i++) {\n            if (c[i] > c[i+1]) fail++;\n        }\n        // output initial answer\n        cout << (fail == 0 ? \"YA\\n\" : \"TIDAK\\n\");\n\n        // process queries\n        while (q--) {\n            int s, t;\n            cin >> s >> t;\n            int old = b[s];\n            if (old != t) {\n                int pos_old = pos_in_a[old];\n                int pos_new = pos_in_a[t];\n                // collect affected bad indices\n                vector<int> idxs;\n                idxs.reserve(4);\n                auto add_idx = [&](int i){\n                    if (i >= 1 && i < n) idxs.push_back(i);\n                };\n                add_idx(pos_old - 1);\n                add_idx(pos_old);\n                add_idx(pos_new - 1);\n                add_idx(pos_new);\n                sort(idxs.begin(), idxs.end());\n                idxs.erase(unique(idxs.begin(), idxs.end()), idxs.end());\n                // store old badness\n                vector<pii> kv;\n                kv.reserve(idxs.size());\n                for (int i : idxs) {\n                    int ob = (c[i] > c[i+1]) ? 1 : 0;\n                    kv.emplace_back(i, ob);\n                }\n                // update occ and first for old\n                int old_first_old = first_occ[old];\n                occ[old].erase(s);\n                int new_first_old = occ[old].empty() ? INF : *occ[old].begin();\n                first_occ[old] = new_first_old;\n                c[pos_old] = new_first_old;\n                // update occ and first for new t\n                int old_first_new = first_occ[t];\n                occ[t].insert(s);\n                int new_first_new = *occ[t].begin();\n                first_occ[t] = new_first_new;\n                c[pos_new] = new_first_new;\n                // recompute badness and adjust fail\n                for (auto &p : kv) {\n                    int i = p.first;\n                    int ob = p.second;\n                    int nb = (c[i] > c[i+1]) ? 1 : 0;\n                    fail += (nb - ob);\n                }\n                // apply change to b\n                b[s] = t;\n            }\n            // output answer after this query\n            cout << (fail == 0 ? \"YA\\n\" : \"TIDAK\\n\");\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2021c1",
      "PROBLEM_ID": "2021C1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. In the two versions, the constraints on $q$ and the time limit are different. In this version, $q=0$. You can make hacks only if all the versions of the problem are solved.\n\nA team consisting of $n$ members, numbered from $1$ to $n$, is set to present a slide show at a large meeting. The slide show contains $m$ slides.\n\nThere is an array $a$ of length $n$. Initially, the members are standing in a line in the order of $a_1, a_2, \\ldots, a_n$ from front to back. The slide show will be presented in order from slide $1$ to slide $m$. Each section will be presented by the member at the front of the line. After each slide is presented, you can move the member at the front of the line to any position in the lineup (without changing the order of the rest of the members). For example, suppose the line of members is $[\\color{red}{3},1,2,4]$. After member $3$ presents the current slide, you can change the line of members into either $[\\color{red}{3},1,2,4]$, $[1,\\color{red}{3},2,4]$, $[1,2,\\color{red}{3},4]$ or $[1,2,4,\\color{red}{3}]$.\n\nThere is also an array $b$ of length $m$. The slide show is considered good if it is possible to make member $b_i$ present slide $i$ for all $i$ from $1$ to $m$ under these constraints.\n\nHowever, your annoying boss wants to make $q$ updates to the array $b$. In the $i$-th update, he will choose a slide $s_i$ and a member $t_i$ and set $b_{s_i} := t_i$. Note that these updates are persistent, that is changes made to the array $b$ will apply when processing future updates.\n\nFor each of the $q+1$ states of array $b$, the initial state and after each of the $q$ updates, determine if the slideshow is good.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$ and $q$ ($1 \\le n, m \\le 2 \\cdot 10^5$; $q=0$)\u00a0\u2014 the number of members, the number of sections and the number of updates.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the initial order of the members from front to back. It is guaranteed that each integer from $1$ to $n$ appears exactly once in $a$.\n\nThe third line of each test case contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le n$)\u00a0\u2014 the members who should present each section.\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ over all test cases do not exceed $2 \\cdot 10^5$ respectively.\n\n### Output\n\nFor each test case, output $q+1$ lines corresponding to the $q+1$ states of the array $b$. Output \"YA\" if the slide show is good, and \"TIDAK\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yA\", \"Ya\", \"ya\", and \"YA\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n4 2 0\n\n1 2 3 4\n\n1 1\n\n3 6 0\n\n1 2 3\n\n1 1 2 3 3 2\n\n4 6 0\n\n3 1 4 2\n\n3 1 1 2 3 4\n\n```\n\n#### Output #1\n\n```\nYA\nYA\nTIDAK\n```\n\n### Note\n\nFor the first test case, you do not need to move the members as both slides are presented by member $1$, who is already at the front of the line.\n\nFor the second test case, the following is a possible way to move members so that the presentation is good:\n\n1. $[1,2,3]$, do not move member $1$.\n2. $[1,2,3]$, move member $1$ after member $3$.\n3. $[2,3,1]$, move member $2$ after member $3$.\n4. $[3,2,1]$, do not move member $3$.\n5. $[3,2,1]$, move member $3$ after member $1$.\n6. $[2,1,3]$, do not move member $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q; // q is always 0 in this problem version\n    vector<int> a(n), b(m);\n\n    // position[i] stores initial position of member i (1-based indexing)\n    vector<int> position(n + 1);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        position[a[i]] = i;\n    }\n\n    for (int i = 0; i < m; i++) \n        cin >> b[i];\n\n    // earliest_slide[i] = earliest slide member i needs to present\n    vector<int> earliest_slide(n, m + 1);\n\n    for (int i = m - 1; i >= 0; i--) {\n        int presenter = b[i];\n        int idx = position[presenter];\n        if (earliest_slide[idx] > i + 1)\n            earliest_slide[idx] = i + 1;\n    }\n\n    // Check if the earliest_slide is non-decreasing from left (front) to right (back)\n    bool good = true;\n    for (int i = 1; i < n; i++) {\n        if (earliest_slide[i] < earliest_slide[i - 1]) {\n            good = false;\n            break;\n        }\n    }\n\n    cout << (good ? \"YA\\n\" : \"TIDAK\\n\");\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n        solve();\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2021b",
      "PROBLEM_ID": "2021B",
      "PROBLEM_STATEMENT": "You are given an array $a$ of $n$ positive integers and an integer $x$. You can do the following two-step operation any (possibly zero) number of times:\n\n1. Choose an index $i$ ($1 \\leq i \\leq n$).\n2. Increase $a_i$ by $x$, in other words $a_i := a_i + x$.\n\nFind the maximum value of the $\\operatorname{MEX}$ of $a$ if you perform the operations optimally.\n\nThe $\\operatorname{MEX}$ (minimum excluded value) of an array is the smallest non-negative integer that is not in the array. For example:\n\n- The $\\operatorname{MEX}$ of $[2,2,1]$ is $0$ because $0$ is not in the array.\n- The $\\operatorname{MEX}$ of $[3,1,0,1]$ is $2$ because $0$ and $1$ are in the array but $2$ is not.\n- The $\\operatorname{MEX}$ of $[0,3,1,2]$ is $4$ because $0$, $1$, $2$ and $3$ are in the array but $4$ is not.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 2 \\cdot 10^5$; $1 \\le x \\le 10^9$)\u00a0\u2014 the length of the array and the integer to be used in the operation.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$)\u00a0\u2014 the given array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer: the maximum $\\operatorname{MEX}$ of $a$ if you perform the operations optimally.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n6 3\n\n0 3 2 1 5 2\n\n6 2\n\n1 3 4 1 0 2\n\n4 5\n\n2 5 10 3\n\n```\n\n#### Output #1\n\n```\n4\n6\n0\n```\n\n### Note\n\nIn the first test case, the $\\operatorname{MEX}$ of $a$ is $4$ without performing any operations, which is the maximum.\n\nIn the second test case, the $\\operatorname{MEX}$ of $a$ is $5$ without performing any operations. If we perform two operations both with $i=1$, we will have the array $a=[5,3,4,1,0,2]$. Then, the $\\operatorname{MEX}$ of $a$ will become $6$, which is the maximum.\n\nIn the third test case, the $\\operatorname{MEX}$ of $a$ is $0$ without performing any operations, which is the maximum.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n// Function to solve a single test case\nvoid solve() {\n    int n;          // Number of elements in the array\n    long long x;    // Value to add in operations\n    std::cin >> n >> x;\n    \n    // Use a map to group elements by their residue modulo x.\n    // The key is the residue (long long because x can be up to 10^9).\n    // The value is a vector storing the elements having that residue (long long because a_i can be up to 10^9).\n    std::map<long long, std::vector<long long>> groups;\n    \n    // Read array elements and populate the groups map\n    for (int i = 0; i < n; ++i) {\n        long long a_i;\n        std::cin >> a_i;\n        // Calculate the residue of a_i modulo x.\n        // Since the problem statement says a_i are positive integers and example includes 0,\n        // we assume a_i are non-negative integers. For non-negative a_i, a_i % x is always in [0, x-1].\n        groups[a_i % x].push_back(a_i);\n    }\n    \n    // Sort the elements within each group (residue class) in ascending order.\n    // This allows us to easily find the smallest available element for a given residue\n    // when we implement the greedy strategy.\n    for (auto it = groups.begin(); it != groups.end(); ++it) {\n        // 'it' is an iterator to a pair<long long, vector<long long>>.\n        // 'it->second' accesses the vector associated with the current residue key.\n        std::sort(it->second.begin(), it->second.end());\n    }\n    \n    // Use a map to keep track of the index of the next available element for each residue group.\n    // Key: residue (long long)\n    // Value: index in the sorted vector for that residue (int is sufficient as index is at most n).\n    std::map<long long, int> ptr;\n    // No explicit initialization is needed for the 'ptr' map values. Accessing a key\n    // that doesn't exist via operator[] default-constructs the value; for int, this is 0.\n    // This correctly points to the first element initially.\n\n    long long mex = 0; // Start checking for MEX from 0. Use long long type for safety, although mex <= N.\n    \n    // Greedily try to achieve the largest possible MEX.\n    // We iterate through potential MEX values starting from 0.\n    // For each value `mex`, we check if it can be included in the array potentially using an operation.\n    while (true) {\n        // Calculate the required residue for the current potential MEX value `mex`.\n        long long r = mex % x; \n        \n        // Find the group of elements corresponding to residue `r`.\n        auto group_it = groups.find(r);\n        \n        // Check if a group for residue `r` exists and if there are still unused elements in it.\n        // `ptr[r]` stores the index of the next element to consider in the sorted vector `groups[r]`.\n        // If `group_it == groups.end()`, there are no elements with residue `r` at all.\n        // If `ptr[r] >= group_it->second.size()`, all elements with residue `r` have already been used.\n        if (group_it == groups.end() || ptr[r] >= group_it->second.size()) {\n            // In either case, we cannot find an element that can be potentially transformed into `mex`.\n            // Therefore, `mex` is the smallest non-negative integer that cannot be included.\n            // This is the maximum achievable MEX. We break the loop.\n            break; \n        }\n        \n        // If we are here, there is at least one available element with the required residue `r`.\n        // Get the smallest available element for this residue. It's located at index `ptr[r]`\n        // in the sorted vector `group_it->second`.\n        long long current_val = group_it->second[ptr[r]];\n        \n        // Check if this element `current_val` can be used to represent `mex`.\n        // An element `a_i` can be transformed into a value `v` if `v >= a_i` and `v % x == a_i % x`.\n        // Here, we want to check if `current_val` can become `mex`.\n        // We already know `current_val % x == r` and `mex % x == r`, so the residue condition holds.\n        // We only need to check if `current_val <= mex`.\n        if (current_val <= mex) {\n             // If `current_val <= mex`, it means `current_val` can be transformed into `mex`\n             // by adding `x` zero or more times (specifically, `(mex - current_val) / x` times).\n             // We greedily decide to use this element `current_val` to satisfy the requirement for `mex`.\n             ptr[r]++; // Mark this element as used by advancing the pointer for its residue group.\n             mex++;    // We successfully covered `mex`. Increment `mex` to check the next integer.\n        } else {\n             // If `current_val > mex`, then `current_val` cannot be used to represent `mex`\n             // because the operation only increases values (`v >= a_i` is required).\n             // Since `current_val` is the *smallest* available element with residue `r`,\n             // no other available element in this residue group can represent `mex` either \n             // (as they are all greater than or equal to `current_val`).\n             // Therefore, we cannot represent `mex`. The current `mex` value is the maximum possible MEX.\n             break;\n        }\n    }\n    \n    // Output the final `mex` value, which represents the maximum MEX achievable.\n    std::cout << mex << \"\\n\";\n}\n\n// Main function to handle multiple test cases\nint main() {\n    // Optimize standard I/O operations for faster execution.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        solve(); // Solve each test case individually\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2020f",
      "PROBLEM_ID": "2020F",
      "PROBLEM_STATEMENT": "Let $n$ and $d$ be positive integers. We build the the divisor tree $T_{n,d}$ as follows:\n\n- The root of the tree is a node marked with number $n$. This is the $0$-th layer of the tree.\n- For each $i$ from $0$ to $d - 1$, for each vertex of the $i$-th layer, do the following. If the current vertex is marked with $x$, create its children and mark them with all possible distinct divisors$^\\dagger$ of $x$. These children will be in the $(i+1)$-st layer.\n- The vertices on the $d$-th layer are the leaves of the tree.\n\nFor example, $T_{6,2}$ (the divisor tree for $n = 6$ and $d = 2$) looks like this:\n\n![](https://espresso.codeforces.com/78c70e79ff2523fff4760665c9512ce7f9360607.png)\n\nDefine $f(n,d)$ as the number of leaves in $T_{n,d}$.\n\nGiven integers $n$, $k$, and $d$, please compute $\\sum\\limits_{i=1}^{n} f(i^k,d)$, modulo $10^9+7$.\n\n$^\\dagger$ In this problem, we say that an integer $y$ is a divisor of $x$ if $y \\ge 1$ and there exists an integer $z$ such that $x = y \\cdot z$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains three integers $n$, $k$, and $d$ ($1 \\le n \\le 10^9$, $1 \\le k,d \\le 10^5$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^9$.\n\n### Output\n\nFor each test case, output $\\sum\\limits_{i=1}^{n} f(i^k,d)$, modulo $10^9+7$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n6 1 1\n\n1 3 3\n\n10 1 2\n\n```\n\n#### Output #1\n\n```\n14\n1\n53\n```\n\n### Note\n\nIn the first test case, $n = 6$, $k = 1$, and $d = 1$. Thus, we need to find the total number of leaves in the divisor trees $T_{1,1}$, $T_{2,1}$, $T_{3,1}$, $T_{4,1}$, $T_{5,1}$, $T_{6,1}$.\n\n- $T_{1,1}$ has only one leaf, which is marked with $1$.\n- $T_{2,1}$ has two leaves, marked with $1$ and $2$.\n- $T_{3,1}$ has two leaves, marked with $1$ and $3$.\n- $T_{4,1}$ has three leaves, marked with $1$, $2$, and $4$.\n- $T_{5,1}$ has two leaves, marked with $1$ and $5$.\n- $T_{6,1}$ has four leaves, marked with $1$, $2$, $3$, and $6$.\n\nThe total number of leaves is $1 + 2 + 2 + 3 + 2 + 4 = 14$.\n\nIn the second test case, $n = 1$, $k = 3$, $d = 3$. Thus, we need to find the number of leaves in $T_{1,3}$, because $1^3 = 1$. This tree has only one leaf, so the answer is $1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7;\nll n,k,d,jc[5000010],C[50];\nll inv(ll x){\n\tll y=mod-2,ans=1;\n\twhile(y){\n\t\tif(y&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nll p[35000],cnt;\nbool check[35000];\nvoid get_prime(){\n\tp[0]=1;\n\tfor(int i=2;i<35000;i++){\n\t\tif(!check[i]) p[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*p[j]<35000;j++){\n\t\t\tcheck[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n}\nll w[70000],tot,g[70000],sqr;\nint pos(int x){return x<=sqr?x:tot-n/x+1;}\nvoid get_g(){\n\tsqr=sqrt(n),tot=0;\n\tfor(int i=1;i<=sqr;i++) w[++tot]=i;\n\tfor(int i=sqr;i>=1;i--) if(i*i!=n) w[++tot]=n/i;\n\tfor(int i=1;i<=tot;i++) g[i]=w[i]-1;\n\tfor(int i=1;p[i]*p[i]<=n;i++){\n\t\tfor(int j=tot;w[j]>=p[i]*p[i];j--)\n\t\tg[j]-=g[pos(w[j]/p[i])]-g[p[i-1]];\n\t}\n}\nll s(ll x,ll y){\n\tif(p[y]>=x) return 0;\n\tll ans=(g[pos(x)]-g[p[y]])*C[1]%mod;\n\tfor(int i=y+1;p[i]*p[i]<=x;i++)\n\tfor(ll j=1,u=p[i];u<=x;j++,u*=p[i])\n\tans+=C[j]*(s(x/u,i)+(j>1))%mod;\n\treturn ans%mod;\n}\nint main(){\n\tjc[0]=1;for(int i=1;i<5000000;i++) jc[i]=jc[i-1]*i%mod;\n\tget_prime();\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tscanf(\"%lld%lld%lld\",&n,&k,&d);\n\t\tfor(int i=1;i<=30;i++) C[i]=jc[i*k+d]*inv(jc[i*k]*jc[d]%mod)%mod;\n\t\tget_g();\n\t\tprintf(\"%lld\\n\",(s(n,0)+1)%mod);\n\t}\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2020e",
      "PROBLEM_ID": "2020E",
      "PROBLEM_STATEMENT": "You are given an array of $n$ integers $a_1,a_2,\\ldots,a_n$. You are also given an array $p_1, p_2, \\ldots, p_n$.\n\nLet $S$ denote the random multiset (i.\u00a0e., it may contain equal elements) constructed as follows:\n\n- Initially, $S$ is empty.\n- For each $i$ from $1$ to $n$, insert $a_i$ into $S$ with probability $\\frac{p_i}{10^4}$. Note that each element is inserted independently.\n\nDenote $f(S)$ as the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all elements of $S$. Please calculate the expected value of $(f(S))^2$. Output the answer modulo $10^9 + 7$.\n\nFormally, let $M = 10^9 + 7$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le 1023$).\n\nThe third line of each test case contains $n$ integers $p_1,p_2,\\ldots,p_n$ ($1 \\le p_i \\le 10^4$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the expected value of $(f(S))^2$, modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n1 2\n\n5000 5000\n\n2\n\n1 1\n\n1000 2000\n\n6\n\n343 624 675 451 902 820\n\n6536 5326 7648 2165 9430 5428\n\n1\n\n1\n\n10000\n\n```\n\n#### Output #1\n\n```\n500000007\n820000006\n280120536\n1\n```\n\n### Note\n\nIn the first test case, $a = [1, 2]$ and each element is inserted into $S$ with probability $\\frac{1}{2}$, since $p_1 = p_2 = 5000$ and $\\frac{p_i}{10^4} = \\frac{1}{2}$. Thus, there are $4$ outcomes for $S$, each happening with the same probability of $\\frac{1}{4}$:\n\n- $S = \\varnothing$. In this case, $f(S) = 0$, $(f(S))^2 = 0$.\n- $S = \\{1\\}$. In this case, $f(S) = 1$, $(f(S))^2 = 1$.\n- $S = \\{2\\}$. In this case, $f(S) = 2$, $(f(S))^2 = 4$.\n- $S = \\{1,2\\}$. In this case, $f(S) = 1 \\oplus 2 = 3$, $(f(S))^2 = 9$.\n\nHence, the answer is $0 \\cdot \\frac{1}{4} + 1 \\cdot \\frac{1}{4} + 4\\cdot \\frac{1}{4} + 9 \\cdot \\frac{1}{4} = \\frac{14}{4} = \\frac{7}{2} \\equiv 500\\,000\\,007 \\pmod{10^9 + 7}$.\n\nIn the second test case, $a = [1, 1]$, $a_1$ is inserted into $S$ with probability $0.1$, while $a_2$ is inserted into $S$ with probability $0.2$. There are $3$ outcomes for $S$:\n\n- $S = \\varnothing$. In this case, $f(S) = 0$, $(f(S))^2 = 0$. This happens with probability $(1-0.1) \\cdot (1-0.2) = 0.72$.\n- $S = \\{1\\}$. In this case, $f(S) = 1$, $(f(S))^2 = 1$. This happens with probability $(1-0.1) \\cdot 0.2 + 0.1 \\cdot (1-0.2) = 0.26$.\n- $S = \\{1, 1\\}$. In this case, $f(S) = 0$, $(f(S))^2 = 0$. This happens with probability $0.1 \\cdot 0.2 = 0.02$.\n\nHence, the answer is $0 \\cdot 0.72 + 1 \\cdot 0.26 + 0 \\cdot 0.02 = 0.26 = \\frac{26}{100} \\equiv 820\\,000\\,006 \\pmod{10^9 + 7}$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n\n// Define the modulus\nconst long long MOD = 1000000007;\n\n/**\n * @brief Computes (base^exp) % MOD efficiently using binary exponentiation.\n * \n * @param base The base of the power.\n * @param exp The exponent.\n * @return (base^exp) % MOD.\n */\nlong long power(long long base, long long exp) {\n    long long res = 1;\n    base %= MOD; // Ensure base is within modulo range\n    while (exp > 0) {\n        // If exponent is odd, multiply result with base\n        if (exp % 2 == 1) res = (res * base) % MOD;\n        // Square the base and halve the exponent\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return res;\n}\n\n/**\n * @brief Computes the modular multiplicative inverse of n modulo MOD using the Extended Euclidean Algorithm.\n * Assumes MOD is a prime number.\n * \n * @param n The number to find the inverse for.\n * @return The modular inverse of n modulo MOD. Returns -1 if n is not invertible (e.g., n=0).\n */\nlong long modInverse(long long n) {\n    long long m = MOD; // Use the global constant MOD\n    long long m0 = m; // Store original modulus\n    long long y = 0, x = 1; // Initialize coefficients for Bezout's identity\n\n    // Reduce n modulo m\n    n %= m;\n    // Ensure n is non-negative\n    if (n < 0) n += m;\n    \n    // Handle the edge case where n is 0 (not invertible)\n    if (n == 0) return -1; \n\n    long long n_orig = n; // Keep original n for the final check\n\n    // Extended Euclidean Algorithm loop\n    while (n > 1) {\n        // If m becomes 0, it means GCD is not 1 (should not happen if m is prime and n != 0)\n        if (m == 0) {\n             return -1; // Error: something went wrong\n         }\n        long long q = n / m; // Quotient\n        long long t = m;     // Temporary variable to store m\n\n        // Update m to the remainder: m = n % m\n        // Using subtraction form to avoid potential issues with negative results from % operator across different languages/platforms\n        m = n - q * m; \n        \n        n = t;          // Update n\n        t = y;          // Temporary variable for y coefficient\n\n        // Update y and x coefficients\n        y = x - q * y;\n        x = t;\n    }\n\n    // Make x positive and within the range [0, m0-1]\n    x %= m0;\n    if (x < 0) x += m0;\n    \n    // Optional safety check: Verify if the computed x is indeed the inverse.\n    // This check is useful during debugging but can be commented out for performance in contests.\n    // #ifndef NDEBUG // Only include check in debug builds\n    // if ((n_orig * x) % m0 != 1) {\n    //      fprintf(stderr, \"Modular inverse check failed for n=%lld\\n\", n_orig);\n    //      return -1; // Indicates failure\n    // }\n    // #endif\n\n    return x; // Return the computed modular inverse\n}\n\nint main() {\n    // Optimize standard I/O operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // Precompute the modular inverse of 10000. \n    // The probabilities are given as p_i / 10000.\n    long long INV10K = modInverse(10000);\n    // Basic check if inverse calculation was successful\n    if (INV10K == -1) {\n         fprintf(stderr, \"Failed to compute modular inverse of 10000\\n\");\n         return 1; // Exit indicating error\n    }\n\n    // Precompute powers of 2 modulo MOD up to 2^18 (since max k+l = 9+9=18)\n    std::vector<long long> pow2(20);\n    pow2[0] = 1; // 2^0 = 1\n    for (int i = 1; i < 20; ++i) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD; // Compute 2^i = 2^(i-1) * 2\n    }\n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Size of the array\n        std::cin >> n;\n        std::vector<int> a(n); // Array of integers\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n        }\n        std::vector<long long> p(n); // Array of probabilities numerator part\n        std::vector<long long> q(n); // Array of probabilities q_i = p_i / 10000\n        std::vector<long long> nq(n); // Array of probabilities 1 - q_i\n        for (int i = 0; i < n; ++i) {\n            std::cin >> p[i];\n            // Calculate probability q_i = p_i * (10000^-1) mod MOD\n            q[i] = (p[i] * INV10K) % MOD;\n            // Calculate probability 1 - q_i mod MOD\n            nq[i] = (1 - q[i] + MOD) % MOD; // Add MOD to handle potential negative result before taking modulo\n        }\n\n        long long total_expected_value = 0; // Initialize total expected value\n\n        // Iterate over all pairs of bit positions (k, l). Since max a_i = 1023, we need bits 0..9.\n        for (int k = 0; k < 10; ++k) {\n            for (int l = 0; l < 10; ++l) {\n                // Initialize DP state. dp[bk][bl] stores the probability that the k-th bit XOR sum is bk\n                // and the l-th bit XOR sum is bl after considering elements up to current index.\n                long long dp[2][2]; \n                dp[0][0] = 1; // Initially, both XOR sums are 0 with probability 1.\n                dp[0][1] = 0;\n                dp[1][0] = 0;\n                dp[1][1] = 0;\n\n                // Process each element a_i and its probability q_i\n                for (int i = 0; i < n; ++i) {\n                    // Extract k-th and l-th bits of the current number a[i]\n                    int ak = (a[i] >> k) & 1;\n                    int al = (a[i] >> l) & 1;\n                    \n                    // Temporary storage for the next DP state to avoid overwriting values needed for current step calculation\n                    long long next_dp[2][2] = {{0, 0}, {0, 0}};\n\n                    // Iterate over all possible previous states (bk_prev, bl_prev)\n                    for (int bk_prev = 0; bk_prev < 2; ++bk_prev) {\n                        for (int bl_prev = 0; bl_prev < 2; ++bl_prev) {\n                            // If the probability of the previous state is 0, skip calculations\n                            if (dp[bk_prev][bl_prev] == 0) continue;\n\n                            // Case 1: Element a[i] is NOT included in the set S.\n                            // This happens with probability nq[i] = 1 - q[i].\n                            // The XOR sums remain unchanged (bk_prev, bl_prev).\n                            next_dp[bk_prev][bl_prev] = (next_dp[bk_prev][bl_prev] + dp[bk_prev][bl_prev] * nq[i]) % MOD;\n\n                            // Case 2: Element a[i] IS included in the set S.\n                            // This happens with probability q[i].\n                            // The XOR sums update: (bk_prev XOR ak, bl_prev XOR al).\n                            int bk_next = bk_prev ^ ak;\n                            int bl_next = bl_prev ^ al;\n                            next_dp[bk_next][bl_next] = (next_dp[bk_next][bl_next] + dp[bk_prev][bl_prev] * q[i]) % MOD;\n                        }\n                    }\n                    \n                    // Update the DP state with the computed next state probabilities\n                    dp[0][0] = next_dp[0][0];\n                    dp[0][1] = next_dp[0][1];\n                    dp[1][0] = next_dp[1][0];\n                    dp[1][1] = next_dp[1][1];\n                }\n\n                // After processing all n elements, dp[1][1] holds the probability P(X[k]=1 and X[l]=1)\n                long long P_kl_11 = dp[1][1];\n                \n                // Calculate the contribution of this pair of bits (k, l) to the total expected value: P(X[k]=1, X[l]=1) * 2^(k+l)\n                long long term = (P_kl_11 * pow2[k + l]) % MOD;\n                // Add this term to the total expected value\n                total_expected_value = (total_expected_value + term) % MOD;\n            }\n        }\n        \n        // Output the final computed total expected value modulo MOD\n        std::cout << total_expected_value << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2020d",
      "PROBLEM_ID": "2020D",
      "PROBLEM_STATEMENT": "One fine evening, Alice sat down to play the classic game \"Connect the Dots\", but with a twist.\n\nTo play the game, Alice draws a straight line and marks $n$ points on it, indexed from $1$ to $n$. Initially, there are no arcs between the points, so they are all disjoint. After that, Alice performs $m$ operations of the following type:\n\n- She picks three integers $a_i$, $d_i$ ($1 \\le d_i \\le 10$), and $k_i$.\n- She selects points $a_i, a_i+d_i, a_i+2d_i, a_i+3d_i, \\ldots, a_i+k_i\\cdot d_i$ and connects each pair of these points with arcs.\n\nAfter performing all $m$ operations, she wants to know the number of connected components$^\\dagger$ these points form. Please help her find this number.\n\n$^\\dagger$ Two points are said to be in one connected component if there is a path between them via several (possibly zero) arcs and other points.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 2 \\cdot 10^5$, $1 \\le m \\le 2 \\cdot 10^5$).\n\nThe $i$-th of the following $m$ lines contains three integers $a_i$, $d_i$, and $k_i$ ($1 \\le a_i \\le a_i + k_i\\cdot d_i \\le n$, $1 \\le d_i \\le 10$, $0 \\le k_i \\le n$).\n\nIt is guaranteed that both the sum of $n$ and the sum of $m$ over all test cases do not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the number of connected components.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n10 2\n\n1 2 4\n\n2 2 4\n\n100 1\n\n19 2 4\n\n100 3\n\n1 2 5\n\n7 2 6\n\n17 2 31\n\n```\n\n#### Output #1\n\n```\n2\n96\n61\n```\n\n### Note\n\nIn the first test case, there are $n = 10$ points. The first operation joins the points $1$, $3$, $5$, $7$, and $9$. The second operation joins the points $2$, $4$, $6$, $8$, and $10$. There are thus two connected components: $\\{1, 3, 5, 7, 9\\}$ and $\\{2, 4, 6, 8, 10\\}$.\n\nIn the second test case, there are $n = 100$ points. The only operation joins the points $19$, $21$, $23$, $25$, and $27$. Now all of them form a single connected component of size $5$. The other $95$ points form single-point connected components. Thus, the answer is $1 + 95 = 96$.\n\nIn the third test case, there are $n = 100$ points. After the operations, all odd points from $1$ to $79$ will be in one connected component of size $40$. The other $60$ points form single-point connected components. Thus, the answer is $1 + 60 = 61$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\n// Disjoint Set Union (DSU) structure using path compression and union by size.\nstruct DSU {\n    std::vector<int> parent; // Stores the parent of each element. Root elements are their own parents.\n    std::vector<int> sz;     // Stores the size of the component (tree) rooted at each element. Only valid for root nodes.\n    int num_components;      // Tracks the total number of disjoint sets (connected components).\n\n    // Constructor initializes the DSU structure for n elements, indexed from 1 to n.\n    DSU(int n) {\n        // Resize parent and size vectors to hold information for n elements + index 0 (unused).\n        parent.resize(n + 1);\n        // std::iota fills the parent array such that parent[i] = i initially for i from 0 to n.\n        // This means each element is initially in its own set.\n        std::iota(parent.begin(), parent.end(), 0); \n        // Assign size 1 to each element's component initially. Index 0 is also initialized but unused.\n        sz.assign(n + 1, 1);\n        // The initial number of components is n, as each point is separate.\n        num_components = n; \n    }\n\n    // Find operation: Returns the representative (root) of the set containing x.\n    // Implements path compression for efficiency.\n    int find(int x) {\n        // If x is the root of its tree, return x.\n        if (parent[x] == x) {\n            return x;\n        }\n        // Recursively find the root of the tree x belongs to.\n        // Update parent[x] to point directly to the root (path compression).\n        return parent[x] = find(parent[x]); \n    }\n\n    // Unite operation: Merges the sets containing elements x and y.\n    // Implements union by size heuristic for efficiency.\n    // Returns true if x and y were in different sets and are now merged, false otherwise.\n    bool unite(int x, int y) {\n        // Find the roots of the sets containing x and y.\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        // Only unite if x and y are currently in different sets.\n        if (rootX != rootY) {\n            // Union by size: Attach the smaller tree to the root of the larger tree.\n            if (sz[rootX] < sz[rootY]) {\n                // Swap rootX and rootY so that rootX always represents the larger or equal size tree.\n                std::swap(rootX, rootY); \n            }\n            // Make the root of the smaller tree (rootY) a child of the root of the larger tree (rootX).\n            parent[rootY] = rootX; \n            // Update the size of the merged tree rooted at rootX.\n            sz[rootX] += sz[rootY]; \n            // Decrease the total number of components by one since two components have merged.\n            num_components--; \n            return true; // Indicate that a merge occurred.\n        }\n        return false; // Indicate that x and y were already in the same set.\n    }\n};\n\n// Structure to represent an interval [start, end].\n// Used here to denote the range of points covered by an operation: a_i to a_i + k_i*d_i.\nstruct Interval {\n    int start;\n    int end;\n};\n\n// Comparator function for sorting intervals.\n// Sorts primarily by start point, and secondarily by end point if start points are equal.\nbool compareIntervals(const Interval& a, const Interval& b) {\n    if (a.start != b.start) {\n        return a.start < b.start;\n    }\n    return a.end < b.end; \n}\n\nint main() {\n    // Optimize input/output operations.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t; // Number of test cases.\n    std::cin >> t;\n    while (t--) {\n        int n; // Number of points on the line.\n        int m; // Number of operations.\n        std::cin >> n >> m;\n        \n        // Store the operations grouped by the difference 'd'.\n        // Since d is small (1 <= d <= 10), a vector of vectors is efficient.\n        // ops_by_d[d] will store all intervals corresponding to operations with difference d.\n        std::vector<std::vector<Interval>> ops_by_d(11); // Size 11 to use indices 1 through 10.\n        for (int i = 0; i < m; ++i) {\n            int a, d, k;\n            std::cin >> a >> d >> k;\n            // An operation involves points a, a+d, ..., a+k*d.\n            // We represent this range by the interval [a, a + k*d].\n            // The problem guarantees 0 <= k. If k=0, the interval is [a, a].\n            if (k >= 0) { // Check k non-negative just to be safe, though constraints guarantee it.\n                 ops_by_d[d].push_back({a, a + k * d});\n            }\n        }\n\n        // Initialize the DSU structure for n points.\n        DSU dsu(n);\n\n        // Process operations for each possible difference d from 1 to 10.\n        for (int d = 1; d <= 10; ++d) {\n            // If there are no operations with this difference d, continue to the next d.\n            if (ops_by_d[d].empty()) {\n                continue;\n            }\n            \n            // Group the intervals for the current difference 'd' based on the remainder 'a mod d'.\n            // All points a, a+d, ..., a+k*d have the same remainder modulo d.\n            std::vector<std::vector<Interval>> ops_by_rem(d); // Size d for remainders 0 to d-1.\n            for (const auto& interval : ops_by_d[d]) {\n                 // The start point `a` determines the remainder group. Since a >= 1, a % d is in [0, d-1].\n                 ops_by_rem[interval.start % d].push_back(interval);\n            }\n\n            // Process the intervals for each remainder group r from 0 to d-1.\n            for (int r = 0; r < d; ++r) {\n                // If there are no operations for this specific remainder r, skip.\n                if (ops_by_rem[r].empty()) {\n                    continue;\n                }\n\n                // Get a reference to the vector of intervals for the current (d, r) pair.\n                std::vector<Interval>& current_intervals = ops_by_rem[r];\n                \n                // Sort the intervals based on their start points. This is crucial for the merging step.\n                std::sort(current_intervals.begin(), current_intervals.end(), compareIntervals);\n\n                // Merge overlapping intervals and perform DSU unions for points within merged intervals.\n                // Initialize the first merged interval using the first sorted interval.\n                int current_L = current_intervals[0].start;\n                int current_R = current_intervals[0].end;\n\n                // Iterate through the rest of the sorted intervals starting from the second one.\n                for (size_t j = 1; j < current_intervals.size(); ++j) {\n                    int next_start = current_intervals[j].start;\n                    int next_end = current_intervals[j].end;\n\n                    // Check if the next interval overlaps with the current merged interval [current_L, current_R].\n                    // Overlap occurs if the next interval starts at or before the current merged interval ends (next_start <= current_R).\n                    if (next_start <= current_R) { \n                        // If they overlap, extend the end of the merged interval to encompass the next interval.\n                        current_R = std::max(current_R, next_end);\n                    } else { \n                        // If there's a gap (next_start > current_R), the current merged interval [current_L, current_R] is complete.\n                        // Process this completed interval: Unite adjacent points in the arithmetic progression within this range.\n                        for (int p = current_L + d; p <= current_R; p += d) {\n                            // Unite point p with the preceding point in the progression (p-d).\n                            dsu.unite(p - d, p);\n                        }\n                        // Start a new merged interval with the current interval that caused the gap.\n                        current_L = next_start;\n                        current_R = next_end;\n                    }\n                }\n                \n                // After iterating through all intervals for this (d, r), the last merged interval [current_L, current_R] needs to be processed.\n                 for (int p = current_L + d; p <= current_R; p += d) {\n                     // Unite point p with p-d.\n                    dsu.unite(p - d, p);\n                }\n            }\n        }\n\n        // After processing all operations for all d and r, the DSU structure contains the final component information.\n        // Output the total number of connected components.\n        std::cout << dsu.num_components << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2020c",
      "PROBLEM_ID": "2020C",
      "PROBLEM_STATEMENT": "You are given three non-negative integers $b$, $c$, and $d$.\n\nPlease find a non-negative integer $a \\in [0, 2^{61}]$ such that $(a\\, |\\, b)-(a\\, \\&\\, c)=d$, where $|$ and $\\&$ denote the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR) and the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), respectively.\n\nIf such an $a$ exists, print its value. If there is no solution, print a single integer $-1$. If there are multiple solutions, print any of them.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe only line of each test case contains three positive integers $b$, $c$, and $d$ ($0 \\le b, c, d \\le 10^{18}$).\n\n### Output\n\nFor each test case, output the value of $a$, or $-1$ if there is no solution. Please note that $a$ must be non-negative and cannot exceed $2^{61}$.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2 2\n\n4 2 6\n\n10 2 14\n\n```\n\n#### Output #1\n\n```\n0\n-1\n12\n```\n\n### Note\n\nIn the first test case, $(0\\,|\\,2)-(0\\,\\&\\,2)=2-0=2$. So, $a = 0$ is a correct answer.\n\nIn the second test case, no value of $a$ satisfies the equation.\n\nIn the third test case, $(12\\,|\\,10)-(12\\,\\&\\,2)=14-0=14$. So, $a = 12$ is a correct answer.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nusing namespace std;\n\nlong long solve(long long b, long long c, long long d) {\n    long long a = 0;\n    int borrow = 0;\n    \n    for (int i = 0; i < 61; ++i) {\n        long long bit = 1LL << i;\n        bool b_i = (b & bit) != 0;\n        bool c_i = (c & bit) != 0;\n        bool d_i = (d & bit) != 0;\n        \n        // Try both possible values for a[i]\n        bool a_i_0_valid = false;\n        bool a_i_1_valid = false;\n        \n        // Check if a[i] = 0 is valid\n        bool or_0 = b_i;        // (a OR b)[i] for a[i] = 0\n        bool and_0 = 0;         // (a AND c)[i] for a[i] = 0\n        bool result_0 = (or_0 - and_0 - borrow) & 1;\n        a_i_0_valid = (result_0 == d_i);\n        \n        // Check if a[i] = 1 is valid\n        bool or_1 = 1;          // (a OR b)[i] for a[i] = 1\n        bool and_1 = c_i;       // (a AND c)[i] for a[i] = 1\n        bool result_1 = (or_1 - and_1 - borrow) & 1;\n        a_i_1_valid = (result_1 == d_i);\n        \n        if (!a_i_0_valid && !a_i_1_valid) {\n            return -1; // No solution\n        }\n        \n        // Choose a[i] and update a\n        bool a_i = a_i_0_valid ? 0 : 1;\n        if (a_i_0_valid && a_i_1_valid) {\n            a_i = 0; // Prefer a[i] = 0 if both are valid\n        }\n        a |= bit * a_i;\n        \n        // Update borrow for the next bit\n        bool next_borrow = false;\n        if (a_i == 0) {\n            next_borrow = (or_0 < and_0 + borrow);\n        } else {\n            next_borrow = (or_1 < and_1 + borrow);\n        }\n        borrow = next_borrow;\n    }\n    \n    // Final verification\n    if (((a | b) - (a & c)) == d) {\n        return a;\n    }\n    return -1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long b, c, d;\n        cin >> b >> c >> d;\n        \n        cout << solve(b, c, d) << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2020a",
      "PROBLEM_ID": "2020A",
      "PROBLEM_STATEMENT": "You are given two integers $n$ and $k$.\n\nIn one operation, you can subtract any power of $k$ from $n$. Formally, in one operation, you can replace $n$ by $(n-k^x)$ for any non-negative integer $x$.\n\nFind the minimum number of operations required to make $n$ equal to $0$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$ and $k$ ($1 \\le n, k \\le 10^9$).\n\n### Output\n\nFor each test case, output the minimum number of operations on a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n5 2\n\n3 5\n\n16 4\n\n100 3\n\n6492 10\n\n10 1\n\n```\n\n#### Output #1\n\n```\n2\n3\n1\n4\n21\n10\n```\n\n### Note\n\nIn the first test case, $n = 5$ and $k = 2$. We can perform the following sequence of operations:\n\n1. Subtract $2^0 = 1$ from $5$. The current value of $n$ becomes $5 - 1 = 4$.\n2. Subtract $2^2 = 4$ from $4$. The current value of $n$ becomes $4 - 4 = 0$.\n\nIt can be shown that there is no way to make $n$ equal to $0$ in less than $2$ operations. Thus, $2$ is the answer.\n\nIn the second test case, $n = 3$ and $k = 5$. We can perform the following sequence of operations:\n\n1. Subtract $5^0 = 1$ from $3$. The current value of $n$ becomes $3 - 1 = 2$.\n2. Subtract $5^0 = 1$ from $2$. The current value of $n$ becomes $2 - 1 = 1$.\n3. Subtract $5^0 = 1$ from $1$. The current value of $n$ becomes $1 - 1 = 0$.\n\nIt can be shown that there is no way to make $n$ equal to $0$ in less than $3$ operations. Thus, $3$ is the answer.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        if (k == 1) {\n            cout << n << endl;\n        } else {\n            int operations = 0;\n            while (n > 0) {\n                operations += n % k;\n                n /= k;\n            }\n            cout << operations << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2019b",
      "PROBLEM_ID": "2019B",
      "PROBLEM_STATEMENT": "[Shirobon - FOX](https://soundcloud.com/shirobon/fox?in=mart_207/sets/fav)\n\n\u2800\n\nYou are given $n$ points on the $x$ axis, at increasing positive integer coordinates $x_1 < x_2 < \\ldots < x_n$.\n\nFor each pair $(i, j)$ with $1 \\leq i < j \\leq n$, you draw the segment $[x_i, x_j]$. The segments are closed, i.e., a segment $[a, b]$ contains the points $a, a+1, \\ldots, b$.\n\nYou are given $q$ queries. In the $i$-th query, you are given a positive integer $k_i$, and you have to determine how many points with integer coordinates are contained in exactly $k_i$ segments.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $q$ ($2 \\le n \\le 10^5$, $1 \\le q \\le 10^5$)\u00a0\u2014 the number of points and the number of queries.\n\nThe second line of each test case contains $n$ integers $x_1, x_2, \\ldots, x_n$ ($1 \\leq x_1 < x_2 < \\ldots < x_n \\leq 10^9$)\u00a0\u2014 the coordinates of the $n$ points.\n\nThe third line of each test case contains $q$ integers $k_1, k_2, \\ldots, k_q$ ($1 \\leq k_i \\leq 10^{18}$)\u00a0\u2014 the parameters of the $q$ queries.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $q$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single line with $q$ integers: the $i$-th integer is the answer to the $i$-th query.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2\n\n101 200\n\n2 1\n\n6 15\n\n1 2 3 5 6 7\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n\n5 8\n\n254618033 265675151 461318786 557391198 848083778\n\n6 9 15 10 6 9 4 4294967300\n\n```\n\n#### Output #1\n\n```\n0 100\n0 0 0 0 2 0 0 0 3 0 2 0 0 0 0\n291716045 0 0 0 291716045 0 301749698 0\n```\n\n### Note\n\nIn the first example, you only draw the segment $[101, 200]$. No point is contained in exactly $2$ segments, and the $100$ points $101, 102, \\ldots, 200$ are contained in exactly $1$ segment.\n\nIn the second example, you draw $15$ segments: $[1, 2], [1, 3], [1, 5], [1, 6], [1, 7], [2, 3], [2, 5], [2, 6], [2, 7], [3, 5], [3, 6], [3, 7], [5, 6], [5, 7], [6, 7]$. Points $1, 7$ are contained in exactly $5$ segments; points $2, 4, 6$ are contained in exactly $9$ segments; points $3, 5$ are contained in exactly $11$ segments.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, q;\n        cin >> n >> q;\n        \n        vector<long long> x(n);\n        for (int i = 0; i < n; i++) {\n            cin >> x[i];\n        }\n        \n        vector<long long> k(q);\n        for (int i = 0; i < q; i++) {\n            cin >> k[i];\n        }\n        \n        // Store coverage and the number of points with that coverage\n        map<long long, long long> count;\n        \n        // Calculate coverage for input points\n        for (int i = 0; i < n; i++) {\n            long long coverage = (i * 1LL * (n - i - 1)) + (n - 1);\n            count[coverage]++;\n        }\n        \n        // Calculate coverage for points between consecutive input points\n        for (int i = 0; i < n - 1; i++) {\n            long long coverage = (i + 1) * 1LL * (n - i - 1);\n            long long gap_length = x[i + 1] - x[i] - 1;\n            count[coverage] += gap_length;\n        }\n        \n        // Output the answers\n        for (int i = 0; i < q; i++) {\n            cout << (count.find(k[i]) != count.end() ? count[k[i]] : 0) << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2018e2",
      "PROBLEM_ID": "2018E2",
      "PROBLEM_STATEMENT": "[Ken Arai - COMPLEX](https://soundcloud.com/diatomichail2/complex)\n\n\u2800\n\nThis is the hard version of the problem. In this version, the constraints on $n$ and the time limit are higher. You can make hacks only if both versions of the problem are solved.\n\nA set of (closed) segments is complex if it can be partitioned into some subsets such that\n\n- all the subsets have the same size; and\n- a pair of segments intersects if and only if the two segments are in the same subset.\n\nYou are given $n$ segments $[l_1, r_1], [l_2, r_2], \\ldots, [l_n, r_n]$. Find the maximum size of a complex subset of these segments.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$)\u00a0\u2014 the number of segments.\n\nThe second line of each test case contains $n$ integers $l_1, l_2, \\ldots, l_n$ ($1 \\le l_i \\le 2n$)\u00a0\u2014 the left endpoints of the segments.\n\nThe third line of each test case contains $n$ integers $r_1, r_2, \\ldots, r_n$ ($l_i \\leq r_i \\le 2n$)\u00a0\u2014 the right endpoints of the segments.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer: the maximum size of a complex subset of the given segments.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n1 2 3\n\n5 4 6\n\n5\n\n1 2 3 6 8\n\n5 4 7 9 10\n\n5\n\n3 1 4 1 5\n\n7 2 6 5 10\n\n```\n\n#### Output #1\n\n```\n3\n4\n4\n```\n\n### Note\n\nIn the first test case, all pairs of segments intersect, therefore it is optimal to form a single group containing all of the three segments.\n\nIn the second test case, there is no valid partition for all of the five segments. A valid partition with four segments is the following: $\\{\\{ [1, 5], [2, 4] \\}, \\{ [6, 9], [8, 10] \\}\\}$.\n\nIn the third test case, it is optimal to make a single group containing all the segments except the second.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=6e5+5;\nint t,n,ans,pre[N],val[N],fa[N],f[N];\nstruct node{\n\tint l,r;\n}a[N];\nbool operator<(node a,node b)\n{\n\treturn a.r<b.r;\n}\nint find(int x)\n{\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\nint cal(int w)\n{\n\tint mx=0,ret=0;\n\tfor(int i=1;i<=2*n;i++)fa[i]=i,pre[i]=i-1,val[i]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[i].l<=mx)continue;\n\t\tint x=find(a[i].l);\n\t\tval[x]++,val[a[i].r+1]--;\n\t\twhile(val[x]>=0)\n\t\t{\n\t\t\tint y=pre[x];\n\t\t\tif(y<=mx)break;\n\t\t\tpre[x]=pre[y],val[x]+=val[y],fa[y]=find(y+1);\n\t\t}\n\t\tif(val[find(mx+1)]==w)ret++,mx=a[i].r,val[mx+1]=0;\n\t}\n\treturn ret;\n}\nvoid solve(int l,int r)\n{\n\tif(l+1==r)return;\n\tif(f[l]==f[r])\n\t{\n\t\tfor(int i=l;i<=r;i++)f[i]=f[l];\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tf[mid]=cal(mid),solve(l,mid),solve(mid,r);\n}\nsigned main()\n{\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tans=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i].l);\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i].r);\n\t\tsort(a+1,a+n+1);\n\t\tf[1]=cal(1),f[n]=cal(n),solve(1,n);\n\t\tfor(int i=1;i<=n;i++)ans=max(ans,i*f[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2018e1",
      "PROBLEM_ID": "2018E1",
      "PROBLEM_STATEMENT": "[Ken Arai - COMPLEX](https://soundcloud.com/diatomichail2/complex)\n\n\u2800\n\nThis is the easy version of the problem. In this version, the constraints on $n$ and the time limit are lower. You can make hacks only if both versions of the problem are solved.\n\nA set of (closed) segments is complex if it can be partitioned into some subsets such that\n\n- all the subsets have the same size; and\n- a pair of segments intersects if and only if the two segments are in the same subset.\n\nYou are given $n$ segments $[l_1, r_1], [l_2, r_2], \\ldots, [l_n, r_n]$. Find the maximum size of a complex subset of these segments.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^4$)\u00a0\u2014 the number of segments.\n\nThe second line of each test case contains $n$ integers $l_1, l_2, \\ldots, l_n$ ($1 \\le l_i \\le 2n$)\u00a0\u2014 the left endpoints of the segments.\n\nThe third line of each test case contains $n$ integers $r_1, r_2, \\ldots, r_n$ ($l_i \\leq r_i \\le 2n$)\u00a0\u2014 the right endpoints of the segments.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^4$.\n\n### Output\n\nFor each test case, output a single integer: the maximum size of a complex subset of the given segments.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n1 2 3\n\n5 4 6\n\n5\n\n1 2 3 6 8\n\n5 4 7 9 10\n\n5\n\n3 1 4 1 5\n\n7 2 6 5 10\n\n```\n\n#### Output #1\n\n```\n3\n4\n4\n```\n\n### Note\n\nIn the first test case, all pairs of segments intersect, therefore it is optimal to form a single group containing all of the three segments.\n\nIn the second test case, there is no valid partition for all of the five segments. A valid partition with four segments is the following: $\\{\\{ [1, 5], [2, 4] \\}, \\{ [6, 9], [8, 10] \\}\\}$.\n\nIn the third test case, it is optimal to make a single group containing all the segments except the second.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=6e5+5;\nint t,n,ans,pre[N],val[N],fa[N],f[N];\nstruct node{\n\tint l,r;\n}a[N];\nbool operator<(node a,node b)\n{\n\treturn a.r<b.r;\n}\nint find(int x)\n{\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\nint cal(int w)\n{\n\tint mx=0,ret=0;\n\tfor(int i=1;i<=2*n;i++)fa[i]=i,pre[i]=i-1,val[i]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[i].l<=mx)continue;\n\t\tint x=find(a[i].l);\n\t\tval[x]++,val[a[i].r+1]--;\n\t\twhile(val[x]>=0)\n\t\t{\n\t\t\tint y=pre[x];\n\t\t\tif(y<=mx)break;\n\t\t\tpre[x]=pre[y],val[x]+=val[y],fa[y]=find(y+1);\n\t\t}\n\t\tif(val[find(mx+1)]==w)ret++,mx=a[i].r,val[mx+1]=0;\n\t}\n\treturn ret;\n}\nvoid solve(int l,int r)\n{\n\tif(l+1==r)return;\n\tif(f[l]==f[r])\n\t{\n\t\tfor(int i=l;i<=r;i++)f[i]=f[l];\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tf[mid]=cal(mid),solve(l,mid),solve(mid,r);\n}\nsigned main()\n{\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tans=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i].l);\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i].r);\n\t\tsort(a+1,a+n+1);\n\t\tf[1]=cal(1),f[n]=cal(n),solve(1,n);\n\t\tfor(int i=1;i<=n;i++)ans=max(ans,i*f[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2018c",
      "PROBLEM_ID": "2018C",
      "PROBLEM_STATEMENT": "[t+pazolite, ginkiha, Hommarju - Paved Garden](https://soundcloud.com/fractalex-gd/ginkiha-paved-garden-little)\n\n\u2800\n\nYou are given a tree with $n$ nodes, rooted at node $1$. In this problem, a leaf is a non-root node with degree $1$.\n\nIn one operation, you can remove a leaf and the edge adjacent to it (possibly, new leaves appear). What is the minimum number of operations that you have to perform to get a tree, also rooted at node $1$, where all the leaves are at the same distance from the root?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\leq n \\leq 5 \\cdot 10^5$)\u00a0\u2014 the number of nodes.\n\nEach of the next $n-1$ lines contains two integers $u$, $v$ ($1 \\leq u, v \\leq n$, $u \\neq v$), describing an edge that connects $u$ and $v$. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer: the minimum number of operations needed to achieve your goal.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n7\n\n1 2\n\n1 3\n\n2 4\n\n2 5\n\n4 6\n\n4 7\n\n7\n\n1 2\n\n1 3\n\n1 4\n\n2 5\n\n3 6\n\n5 7\n\n15\n\n12 9\n\n1 6\n\n6 14\n\n9 11\n\n8 7\n\n3 5\n\n13 5\n\n6 10\n\n13 15\n\n13 6\n\n14 12\n\n7 2\n\n8 1\n\n1 4\n\n```\n\n#### Output #1\n\n```\n2\n2\n5\n```\n\n### Note\n\nIn the first two examples, the tree is as follows:\n\n![](https://espresso.codeforces.com/a428c7bdf3ba5490a44914a039d11603cfb1c9df.png)\n\nIn the first example, by removing edges $(1, 3)$ and $(2, 5)$, the resulting tree has all leaves (nodes $6$ and $7$) at the same distance from the root (node $1$), which is $3$. The answer is $2$, as it is the minimum number of edges that need to be removed to achieve the goal.\n\nIn the second example, removing edges $(1, 4)$ and $(5, 7)$ results in a tree where all leaves (nodes $4$ and $5$) are at the same distance from the root (node $1$), which is $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Not used directly, but could be useful in other contexts\n#include <algorithm> // For std::max\n\nusing namespace std;\n\n// Using global variables for simplicity in competitive programming context.\n// These could be encapsulated in a class or struct if preferred.\nvector<vector<int>> adj;       // Adjacency list representation of the tree\nvector<int> dist_from_root;    // Stores distance of each node from the root (node 1)\nvector<int> max_depth_subtree; // Stores the maximum distance from root 1 to any node in the subtree rooted at u\nvector<int> counts;            // Used as a difference array to compute the sizes S_D efficiently\nint N;                         // Number of nodes in the tree\n\n/**\n * @brief Performs Depth First Search starting from node u.\n * \n * Computes the distance of each node from the root (node 1).\n * Computes the maximum distance from the root to any node in the subtree rooted at u.\n * Updates the difference array `counts` based on the computed distances.\n * \n * @param u The current node being visited.\n * @param p The parent of the current node u in the DFS traversal (to avoid cycles).\n * @param current_dist The distance of the current node u from the root (node 1).\n */\nvoid dfs(int u, int p, int current_dist) {\n    // Set the distance of the current node from the root\n    dist_from_root[u] = current_dist;\n    // Initialize the maximum depth in the subtree rooted at u with its own distance.\n    // This handles the case where u is a leaf or the deepest node in its subtree.\n    max_depth_subtree[u] = current_dist; \n\n    // Iterate through all neighbors of the current node u\n    for (int v : adj[u]) {\n        // Check if the neighbor v is not the parent p to avoid going back up the tree\n        if (v != p) { \n            // Recursively call DFS for the child node v\n            dfs(v, u, current_dist + 1);\n            // After the recursive call returns, update the maximum depth in u's subtree.\n            // It's the maximum of its current value and the maximum depth found in the child v's subtree.\n            max_depth_subtree[u] = max(max_depth_subtree[u], max_depth_subtree[v]);\n        }\n    }\n\n    // Post-order step: This code executes after visiting all children of u.\n    // A node u can be part of the final tree T'_D if its distance satisfies dist_from_root[u] <= D <= max_depth_subtree[u].\n    // This means node u contributes 1 to the size S_D for all D in the range [dist_from_root[u], max_depth_subtree[u]].\n    // We use the difference array technique to efficiently track these contributions for all D simultaneously.\n    \n    // Increment the count at the start index of the range.\n    counts[dist_from_root[u]]++; \n    \n    // Decrement the count at the index immediately after the end index of the range.\n    // This ensures that node u's contribution is only counted for depths up to max_depth_subtree[u].\n    // We access index max_depth_subtree[u] + 1. This index is safe because `counts` has size N+2.\n    // The maximum value of max_depth_subtree[u] is N-1 (in a path graph), so the maximum index accessed here is N.\n    counts[max_depth_subtree[u] + 1]--; \n}\n\nint main() {\n    // Optimize standard I/O operations for faster execution\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        cin >> N; // Read the number of nodes for the current test case\n\n        // Initialize data structures for the current test case.\n        // Use N+1 size for 1-based node indexing.\n        adj.assign(N + 1, vector<int>());\n        // Read N-1 edges and build the adjacency list.\n        for (int i = 0; i < N - 1; ++i) {\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        // Initialize vectors to store distances, max depths, and the difference array counts.\n        dist_from_root.assign(N + 1, 0);\n        max_depth_subtree.assign(N + 1, 0);\n        // Use N+2 size for `counts` array. This safely accommodates index N+1 which might be accessed.\n        // Indices 0 to N+1 are valid.\n        counts.assign(N + 2, 0); \n\n        // Perform DFS starting from root node 1. \n        // The root has a dummy parent 0 and distance 0.\n        dfs(1, 0, 0); \n\n        // Compute prefix sums on the `counts` array.\n        // After this loop, counts[i] will store the actual size S_i.\n        // S_i represents the number of nodes in the maximal valid subtree T'_i\n        // where all leaves are at depth i.\n        // We iterate up to index N because the maximum possible depth is N-1,\n        // and updates might affect counts[N]. counts[N+1] accumulates decrements for ranges ending at N.\n        for (int i = 1; i <= N; ++i) { \n             counts[i] += counts[i - 1];\n        }\n\n        // Find the maximum size S_D among all possible target depths D.\n        // The possible depths D range from 0 (only root node 1 remains) up to N-1 (maximum possible depth in a tree with N nodes).\n        int max_size = 0;\n        // We check depths D from 0 up to N. counts[i] holds the size S_i.\n        // Iterating up to N includes all relevant depths (0 to N-1). counts[N] will typically be 0 unless the tree is a path of length N-1.\n        for (int i = 0; i <= N; ++i) { \n            max_size = max(max_size, counts[i]);\n        }\n        \n        // The problem asks for the minimum number of operations (removals).\n        // This is equal to the total number of nodes N minus the maximum size of a valid resulting tree found.\n        cout << N - max_size << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2018b",
      "PROBLEM_ID": "2018B",
      "PROBLEM_STATEMENT": "[Djjaner - Speedbreaker](https://soundcloud.com/luciano-ferrari-151560131/speedbreaker)\n\n\u2800\n\nThere are $n$ cities in a row, numbered $1, 2, \\ldots, n$ left to right.\n\n- At time $1$, you conquer exactly one city, called the starting city.\n- At time $2, 3, \\ldots, n$, you can choose a city adjacent to the ones conquered so far and conquer it.\n\nYou win if, for each $i$, you conquer city $i$ at a time no later than $a_i$. A winning strategy may or may not exist, also depending on the starting city. How many starting cities allow you to win?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of cities.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the deadlines for conquering the cities.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer: the number of starting cities that allow you to win.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n6\n\n6 3 3 3 5 5\n\n6\n\n5 6 4 1 4 5\n\n9\n\n8 6 4 2 1 3 5 7 9\n\n```\n\n#### Output #1\n\n```\n3\n0\n1\n```\n\n### Note\n\nIn the first test case, cities $2$, $3$, and $4$ are good starting cities.\n\nIn the second test case, there are no good starting cities.\n\nIn the third test case, the only good starting city is city $5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <set>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <climits>\n#include <queue>\n#include <numeric>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <unordered_set>\n\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//\n#define ll long long\n#define p pair<int,int>\n//#define pl pair<ll, ll>\n#define pb push_back\n#define pq priority_queue<ll>\n#define tu tuple<int,int,int>\n#define tl tuple<ll,ll,int>\n//#define int ll\n#define mod1 998244353\n#define mod2 1000000007\n//#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\n\nint nmax = 2e5 + 5;\nusing namespace std;\n \nlong long nChoosek( long long n, long long k )\n{\n    if (k > n) return 0;\n    if (k * 2 > n) k = n-k;\n    if (k == 0) return 1;\n \n    long long result = n;\n    for( int i = 2; i <= k; ++i ) {\n        result *= (n-i+1);\n        result /= i;\n    }\n    return result;\n}\n \n \nlong long power(long long a, long long b, long long m){\n    if (b==0) return 1;\n    if (b==1) return a%m;\n    \n    long long temp=power(a,b/2,m)%m;\n    if (b%2) return (temp*temp*a)%m;\n    else return (temp*temp)%m;\n}\n \nll ceil(ll a, ll b){\n    if (a%b) a+=b-(a%b);\n    return a/b;\n}\n \nll gcd(ll a, ll b){\n    while (b!=0){\n        ll x=a%b;\n        a=b;\n        b=x;\n    }\n    return a;\n}\n \nint good_mod(int a,int b){\n    if (a%b==0) return b;\n    return a%b;\n    \n}\n \nll min(ll a, ll b){\n    if (a<=b) return a;\n    return b;\n}\n \n\nll max(ll a, ll b){\n    if (a>=b) return a;\n    return b;\n}\n\nint sign(int x){\n    if (x==0) return 0;\n    else if (x>0) return 1;\n    else return -1;\n}\n\nint bin_count(int x){\n    int c=0;\n    while (x){\n        x=(x&(x-1));\n        c++;\n    }\n    return c;\n}\n\nint len_count(ll x){\n    int answer=0;\n    while (x){\n        x>>=1;\n        answer++;\n    }\n    return answer;\n}\n\nstruct Comp{\n    \n    bool operator()(const tl&a, const tl&b) const{\n        return (get<1>(a) <get<1>(b));\n    }\n};\n\nll mod_exp(ll a, ll po){\n    ll mul=a;\n    a=1;\n    while (po){\n        if (po&(1)) a*=mul;\n        po=po>>1;\n        mul=mul*mul;\n        mul%=mod1;\n        a%=mod1;\n    }\n    \n    return a;\n}\n\nvector<int> times;\n\nint main(){\n    int t,n,x;\n    cin>>t;\n    while (t--){\n        cin>>n;\n       \n        times.clear();\n        for (int i=0; i<n; i++){\n            cin>>x;\n            times.pb(x);\n        }\n        \n        vector<int> sel(n,0);\n        int i=0;\n        int j=n-1;\n        x=n;\n        while (i<=j){\n            if (times[i]>times[j]){\n                sel[i]=x;\n                i++;\n            }\n            else{\n                sel[j]=x;\n                j--;\n            }\n            x--;\n        }\n        \n        int l=0;\n        int r=n-1;\n        \n        for (int i=0; i<n; i++){\n            l=max(l,i-(times[i]-1));\n            r=min(r,i+(times[i]-1));\n        }\n        \n        bool flag=true;\n        for (int i=0; i<n; i++){\n            if (sel[i]>times[i]) flag=false;\n        }\n        \n        if (flag){\n            cout<<r-l+1<<endl;\n        }\n        else{\n            cout<<0<<endl;\n        }\n    \n    }\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2014h",
      "PROBLEM_ID": "2014H",
      "PROBLEM_STATEMENT": "At such times archery was always the main sport of the day, for the Nottinghamshire yeomen were the best hand at the longbow in all merry England, but this year the Sheriff hesitated...\n\nSheriff of Nottingham has organized a tournament in archery. It's the final round and Robin Hood is playing against Sheriff!\n\nThere are $n$ targets in a row numbered from $1$ to $n$. When a player shoots target $i$, their score increases by $a_i$ and the target $i$ is destroyed. The game consists of turns and players alternate between whose turn it is. Robin Hood always starts the game, then Sheriff and so on. The game continues until all targets are destroyed. Both players start with score $0$.\n\nAt the end of the game, the player with most score wins and the other player loses. If both players have the same score, it's a tie and no one wins or loses. In each turn, the player can shoot any target that wasn't shot before. Both play optimally to get the most score possible.\n\nSheriff of Nottingham has a suspicion that he might lose the game! This cannot happen, you must help Sheriff. Sheriff will pose $q$ queries, each specifying $l$ and $r$. This means that the game would be played only with targets $l, l+1, \\dots, r$, as others would be removed by Sheriff before the game starts.\n\nFor each query $l$, $r$, determine whether the Sheriff can not lose the game when only considering the targets $l, l+1, \\dots, r$.\n\n### Input\n\nThe first line of input contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$, $q$ ($1 \\le n,q \\le 2\\cdot10^5$)\u00a0\u2014 the number of targets and the queries Sheriff will pose.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^6$)\u00a0\u2014 the points for hitting each target.\n\nThen follow $q$ lines, each with two integers $l$ and $r$ ($1 \\le l \\le r \\le n$)\u00a0\u2014 the range of the targets that is considered for each query.\n\nIt is guaranteed that the sum of both $n$ and $q$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each query, output \"YES\", if the Sheriff does not lose the game when only considering the targets $l, l+1, \\dots, r$, and \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n3 3\n\n1 2 2\n\n1 2\n\n1 3\n\n2 3\n\n5 3\n\n2 1 2 1 1\n\n1 2\n\n1 3\n\n4 5\n\n```\n\n#### Output #1\n\n```\nNO\nNO\nYES\nNO\nNO\nYES\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <map>\n#include <random>\n#include <chrono> // Required for seeding rng\n\n// Use a good 64-bit Mersenne Twister random number generator\n// Seed it once using the current time for potentially better randomness across test cases.\nstd::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n\n// Function to generate a random 64-bit unsigned integer hash value\nunsigned long long generate_random_long() {\n    // Generate a random unsigned long long value.\n    unsigned long long val = 0;\n    // Ensure the hash value is non-zero. While the chance of rng() returning 0 is 1/2^64 (extremely small),\n    // a zero hash could theoretically cause issues if not handled (e.g., XORing with 0 doesn't change anything).\n    // Looping until non-zero guarantees correctness.\n    while(val == 0) { \n       val = rng();\n    }\n    return val;\n}\n\n// Map to store assigned hash values for distinct scores.\n// We reuse this map object but clear it for each test case to ensure hashes are context-specific.\nstd::map<int, unsigned long long> value_hashes;\n\nint main() {\n    // Faster I/O operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Number of test cases\n    std::cin >> t;\n    \n    while (t--) {\n        int n; // Number of targets\n        int q; // Number of queries\n        std::cin >> n >> q;\n        \n        std::vector<int> a(n); // Stores scores for each target\n        \n        // Clear the hash map for the current test case. This ensures value hashes are independent between test cases.\n        value_hashes.clear(); \n        \n        // Vector `b` will store the random hash corresponding to the score `a[i]`.\n        std::vector<unsigned long long> b(n); \n        \n        // Read scores and assign hashes\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n            // If the score `a[i]` hasn't been seen before in this test case, assign it a new random hash.\n            if (value_hashes.find(a[i]) == value_hashes.end()) {\n                value_hashes[a[i]] = generate_random_long();\n            }\n            // Store the hash for `a[i]` in the `b` vector.\n            b[i] = value_hashes[a[i]];\n        }\n        \n        // Calculate prefix XOR sums for the hash values.\n        // prefix_xor_sums[i] will store the XOR sum of b[0]...b[i-1].\n        // prefix_xor_sums[0] is initialized to 0.\n        std::vector<unsigned long long> prefix_xor_sums(n + 1, 0);\n        for (int i = 0; i < n; ++i) {\n            prefix_xor_sums[i+1] = prefix_xor_sums[i] ^ b[i];\n        }\n        \n        // Process each query\n        for (int k = 0; k < q; ++k) {\n            int l, r; // Query range (1-based indexing)\n            std::cin >> l >> r; \n            \n            // Calculate the number of targets in the range [l, r].\n            int m = r - l + 1;\n            \n            // The game analysis showed that Sheriff can only potentially not lose if the number of targets 'm' is even.\n            if (m % 2 != 0) {\n                // If 'm' is odd, Robin Hood always takes one more target than the Sheriff.\n                // Because all scores are positive (a_i >= 1), Robin Hood's score will be strictly greater. Sheriff loses.\n                 std::cout << \"NO\\n\";\n            } else {\n                // If 'm' is even, Sheriff does not lose if and only if the multiset of scores {a_l, ..., a_r}\n                // consists of pairs of equal values. This means every distinct score value must appear an even number of times.\n                // We check this condition using the property that the XOR sum of hashes for the range [l, r] must be 0.\n                // The XOR sum of hashes b[l-1]...b[r-1] (0-based indexing for b) can be computed using prefix XOR sums:\n                // range_xor = prefix_xor_sums[r] ^ prefix_xor_sums[l-1].\n                // If range_xor is 0, it means (with very high probability) all counts are even.\n                if ((prefix_xor_sums[r] ^ prefix_xor_sums[l-1]) == 0) {\n                    // All distinct values appear an even number of times. Sheriff ties or wins.\n                    std::cout << \"YES\\n\";\n                } else {\n                    // At least one distinct value appears an odd number of times. Sheriff loses.\n                     std::cout << \"NO\\n\";\n                }\n            }\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2014g",
      "PROBLEM_ID": "2014G",
      "PROBLEM_STATEMENT": "What is done is done, and the spoilt milk cannot be helped.\n\nLittle John is as little as night is day \u2014 he was known to be a giant, at possibly $2.1$ metres tall. It has everything to do with his love for milk.\n\nHis dairy diary has $n$ entries, showing that he acquired $a_i$ pints of fresh milk on day $d_i$. Milk declines in freshness with time and stays drinkable for a maximum of $k$ days. In other words, fresh milk acquired on day $d_i$ will be drinkable between days $d_i$ and $d_i+k-1$ inclusive.\n\nEvery day, Little John drinks drinkable milk, up to a maximum of $m$ pints. In other words, if there are less than $m$ pints of milk, he will drink them all and not be satisfied; if there are at least $m$ pints of milk, he will drink exactly $m$ pints and be satisfied, and it's a milk satisfaction day.\n\nLittle John always drinks the freshest drinkable milk first.\n\nDetermine the number of milk satisfaction days for Little John.\n\n### Input\n\nThe first line of the input contains a single integer $t$ ($1\\leq t \\leq 10^4$), the number of test cases.\n\nThe first line of each test case consists of three integers $n$, $m$, $k$ ($1\\le n$, $m$, $k \\le 10^5$), the number of diary entries, the maximum pints needed for a milk satisfaction day, and the duration of milk's freshness.\n\nThen follow $n$ lines of each test case, each with two integers $d_i$ and $a_i$ ($1\\le d_i$, $a_i \\le 10^6$), the day on which the milk was acquired and the number of pints acquired. They are sorted in increasing values of $d_i$, and all values of $d_i$ are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer, the number of milk satisfaction days.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1 1 3\n\n1 5\n\n2 3 3\n\n1 5\n\n2 7\n\n4 5 2\n\n1 9\n\n2 6\n\n4 9\n\n5 6\n\n5 2 4\n\n4 7\n\n5 3\n\n7 1\n\n11 2\n\n12 1\n\n4 1 3\n\n5 10\n\n9 4\n\n14 8\n\n15 3\n\n5 5 5\n\n8 9\n\n10 7\n\n16 10\n\n21 5\n\n28 9\n\n```\n\n#### Output #1\n\n```\n3\n3\n4\n5\n10\n6\n```\n\n### Note\n\nIn the first test case, $5$ pints of milk are good for $3$ days before spoiling.\n\nIn the second test case, the following will happen:\n\n- On day $1$, he will receive $5$ pints of milk and drink $3$ of them (leaving $2$ pints from day $1$);\n- On day $2$, he will receive $7$ pints of milk and drink $3$ of them (leaving $2$ pints from day $1$ and $4$ pints from day $2$);\n- On day $3$, he will drink $3$ pints from day $2$ (leaving $2$ pints from day $1$ and $1$ pint from day $2$);\n- On day $4$, the milk acquired on day $1$ will spoil, and he will drink $1$ pint from day $2$ (no more milk is left).",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <utility> // For std::pair\n#include <iterator> // For std::next used with reverse iterator erase\n\nusing namespace std;\n\n// Define long long type for large numbers to avoid overflow with milk amounts and potentially large satisfaction days count\ntypedef long long ll;\n\n// Function to solve a single test case\nvoid solve() {\n    int n; // Number of diary entries\n    ll m; // Pints needed for satisfaction per day\n    ll k; // Freshness duration in days (inclusive range [d_i, d_i + k - 1])\n    cin >> n >> m >> k;\n\n    // Store diary entries (day, pints)\n    vector<pair<int, ll>> entries(n);\n    // Use a set to collect unique event days. Events are:\n    // 1. Acquisition of milk on day d_i\n    // 2. Spoilage of milk on day d_i + k (first day it's unavailable)\n    set<int> event_point_set;\n    for (int i = 0; i < n; ++i) {\n        cin >> entries[i].first >> entries[i].second;\n        // Add acquisition day as an event point\n        event_point_set.insert(entries[i].first);\n        // Add spoilage day as an event point. \n        event_point_set.insert(entries[i].first + k); \n    }\n\n    // Convert set of event points to a sorted vector for sequential processing\n    vector<int> event_days(event_point_set.begin(), event_point_set.end());\n\n    // Map to store available milk batches: key is acquisition day, value is remaining pints.\n    // std::map keeps keys sorted, allowing efficient access to freshest milk (largest key).\n    map<int, ll> available_milk; \n    // Total available milk pints across all batches, maintained for quick checks.\n    ll total_milk = 0;\n    // Counter for the number of milk satisfaction days.\n    ll satisfaction_days = 0;\n    \n    // Index to track the current diary entry being processed from the input vector `entries`.\n    // Since entries are sorted by acquisition day, we can process them linearly.\n    int entry_idx = 0; \n\n    // Iterate through the sorted event days. Each iteration processes events ON `current_day`\n    // and then simulates consumption for the interval UNTIL the `next_event_day`.\n    for (size_t i = 0; i < event_days.size(); ++i) {\n        int current_day = event_days[i];\n\n        // --- Process events occurring ON current_day ---\n\n        // 1. Process Spoilage: Check if milk acquired k days ago spoils today.\n        // Milk acquired on day `d'` spoils on day `d' + k`. So check for `d' = current_day - k`.\n        int spoiled_acquisition_day = current_day - k;\n        // Check if milk from `spoiled_acquisition_day` exists in our tracked available milk.\n        // Added a check `spoiled_acquisition_day >= 0` just for safety, though d_i >= 1 implies it.\n        if (spoiled_acquisition_day >= 0) { \n            auto it_spoil = available_milk.find(spoiled_acquisition_day);\n            if (it_spoil != available_milk.end()) {\n                // If found, subtract its remaining amount from `total_milk` and remove the batch entry.\n                total_milk -= it_spoil->second;\n                available_milk.erase(it_spoil);\n            }\n        }\n\n        // 2. Process Acquisition: Check if new milk is acquired today.\n        // We use `entry_idx` to check the next entry from the sorted input `entries`.\n        if (entry_idx < n && entries[entry_idx].first == current_day) {\n             // Add the new milk batch. The key is the acquisition day `current_day`.\n             // Problem guarantees distinct d_i, so no need to check if key already exists.\n             available_milk[current_day] = entries[entry_idx].second;\n             // Update the total milk count.\n             total_milk += entries[entry_idx].second;\n             // Move to the next diary entry for future checks.\n             entry_idx++;\n        }\n\n        // --- Simulate consumption over the interval [current_day, next_event_day - 1] ---\n\n        // Calculate the length `L` of the interval starting from `current_day` up to the day \n        // before the next event day `event_days[i+1]`.\n        ll L = 0; // Interval length in days\n        if (i + 1 < event_days.size()) {\n            // Interval length is the difference between the next event day and the current day.\n            L = event_days[i+1] - current_day;\n        }\n        // If L is 0, it means the next event is on the very next day, or this is the last event day.\n        // The simulation logic below only runs for L > 0.\n\n        // If the interval has positive length (L > 0) and there is milk available (`total_milk > 0`)\n        if (L > 0 && total_milk > 0) {\n            \n            // Calculate how many full satisfaction days are possible with the current `total_milk`.\n            // Each satisfaction day requires `m` pints.\n            ll days_can_satisfy = 0;\n            // Problem constraints guarantee m >= 1, so m > 0 is always true. No need for check m > 0.\n            days_can_satisfy = total_milk / m;\n            \n            // The actual number of satisfaction days in this interval is limited by its length `L`.\n            ll actual_satisfaction_days = min((ll)L, days_can_satisfy);\n            // Add these days to the total count.\n            satisfaction_days += actual_satisfaction_days;\n\n            // Calculate the total amount of milk `C` consumed over the interval days.\n            // This is the minimum of the total available milk and the maximum possible consumption (L * m).\n            ll C = min(total_milk, (ll)L * m);\n            \n            // If any milk is consumed (C > 0)\n            if (C > 0) {\n                 // Consume `C` pints from `available_milk`, prioritizing the freshest batches (largest acquisition day).\n                 ll consumed_in_loop = 0; // Track amount consumed within this loop to ensure correctness.\n                 \n                 // Use a reverse iterator to iterate from the freshest milk batch (largest key) downwards.\n                 auto it = available_milk.rbegin();\n                 while (consumed_in_loop < C && it != available_milk.rend()) {\n                      ll available_pints = it->second; // Pints available in the current batch\n                      // Determine how much to consume from this batch: minimum of remaining needed `C - consumed_in_loop` and available `available_pints`.\n                      ll consume_now = min(C - consumed_in_loop, available_pints);\n    \n                      // Update the pints remaining in this batch.\n                      it->second -= consume_now;\n                      // Update the total amount consumed so far in this loop pass.\n                      consumed_in_loop += consume_now;\n    \n                      // If this batch is fully consumed (0 pints left), remove it from the map.\n                      if (it->second == 0) {\n                          // Standard C++ idiom to erase element using a reverse iterator and correctly advance it.\n                          it = decltype(it)(available_milk.erase(next(it).base())); \n                      } else {\n                          // Otherwise, move the iterator to the next element (older batch).\n                          ++it;\n                      }\n                 }\n                 // After consuming from batches, update the overall `total_milk` count.\n                 total_milk -= C; \n            }\n        }\n    }\n\n    // Output the final total count of satisfaction days.\n    cout << satisfaction_days << \"\\n\";\n}\n\n// Main function to handle multiple test cases\nint main() {\n    // Optimize C++ standard streams for faster Input/Output.\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        solve(); // Solve each test case by calling the solve function.\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2014f",
      "PROBLEM_ID": "2014F",
      "PROBLEM_STATEMENT": "\"Why, master,\" quoth Little John, taking the bags and weighing them in his hand, \"here is the chink of gold.\"\n\nThe folk hero Robin Hood has been troubling Sheriff of Nottingham greatly. Sheriff knows that Robin Hood is about to attack his camps and he wants to be prepared.\n\nSheriff of Nottingham built the camps with strategy in mind and thus there are exactly $n$ camps numbered from $1$ to $n$ and $n-1$ trails, each connecting two camps. Any camp can be reached from any other camp. Each camp $i$ has initially $a_i$ gold.\n\nAs it is now, all camps would be destroyed by Robin. Sheriff can strengthen a camp by subtracting exactly $c$ gold from each of its neighboring camps and use it to build better defenses for that camp. Strengthening a camp doesn't change its gold, only its neighbors' gold. A camp can have negative gold.\n\nAfter Robin Hood's attack, all camps that have been strengthened survive the attack, all others are destroyed.\n\nWhat's the maximum gold Sheriff can keep in his surviving camps after Robin Hood's attack if he strengthens his camps optimally?\n\nCamp $a$ is neighboring camp $b$ if and only if there exists a trail connecting $a$ and $b$. Only strengthened camps count towards the answer, as others are destroyed.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nEach test case begins with two integers $n$, $c$ ($1 \\le n \\le 2\\cdot10^5, 1 \\le c \\le 10^9$)\u00a0\u2014 the number of camps and the gold taken from each neighboring camp for strengthening.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\dots,a_n$ ($-10^9 \\le a_i \\le 10^9$)\u00a0\u2014 the initial gold of each camp.\n\nThen follow $n-1$ lines, each with integers $u$, $v$ ($1 \\le u, v \\le n$, $u \\ne v$)\u00a0\u2014 meaning that there is a trail between $u$ and $v$.\n\nThe sum of $n$ over all test cases doesn't exceed $2\\cdot10^5$.\n\nIt is guaranteed that any camp is reachable from any other camp.\n\n### Output\n\nOutput a single integer, the maximum gold Sheriff of Nottingham can keep in his surviving camps after Robin Hood's attack.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3 1\n\n2 3 1\n\n1 2\n\n2 3\n\n3 1\n\n3 6 3\n\n1 2\n\n2 3\n\n3 1\n\n-2 -3 -1\n\n1 2\n\n2 3\n\n6 1\n\n5 -4 3 6 7 3\n\n4 1\n\n5 1\n\n3 5\n\n3 6\n\n1 2\n\n8 1\n\n3 5 2 7 8 5 -3 -4\n\n7 3\n\n1 8\n\n4 3\n\n3 5\n\n7 6\n\n8 7\n\n2 1\n\n```\n\n#### Output #1\n\n```\n3\n8\n0\n17\n26\n```\n\n### Note\n\nIn the first test case, it is optimal to strengthen the second base. The final gold at each base is $[1,3,0]$.\n\nIn the second test case, it is optimal to strengthen all bases. The final gold at each base is $[2,4,2]$.\n\nIn the third test case, it is optimal to not strengthen any base.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int t;\n    cin >> t;\n    for (int test = 0; test < t; test++) {\n        int n, c;\n        cin >> n >> c;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        vector<vector<int>> adj(n + 1); // 1-based indexing\n        for (int i = 0; i < n - 1; i++) {\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        vector<long long> dp0(n + 1, 0);\n        vector<long long> dp1(n + 1, 0);\n\n        stack<tuple<int, int, bool>> st;\n        st.push(make_tuple(1, -1, false));\n\n        while (!st.empty()) {\n            auto [u, parent, is_processed] = st.top();\n            st.pop();\n\n            if (!is_processed) {\n                st.push(make_tuple(u, parent, true));\n                for (int v : adj[u]) {\n                    if (v != parent) {\n                        st.push(make_tuple(v, u, false));\n                    }\n                }\n            } else {\n                dp0[u] = 0;\n                dp1[u] = a[u - 1]; // a is 0-based, u is 1-based\n\n                for (int v : adj[u]) {\n                    if (v == parent) continue;\n\n                    dp0[u] += max(dp0[v], dp1[v]);\n\n                    long long option1 = dp1[v] - 2LL * c;\n                    long long option2 = dp0[v];\n                    dp1[u] += max(option1, option2);\n                }\n            }\n        }\n\n        long long ans = max(dp0[1], dp1[1]);\n        cout << ans << \"\\n\";\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2014d",
      "PROBLEM_ID": "2014D",
      "PROBLEM_STATEMENT": "Impress thy brother, yet fret not thy mother.\n\nRobin's brother and mother are visiting, and Robin gets to choose the start day for each visitor.\n\nAll days are numbered from $1$ to $n$. Visitors stay for $d$ continuous days, all of those $d$ days must be between day $1$ and $n$ inclusive.\n\nRobin has a total of $k$ risky 'jobs' planned. The $i$-th job takes place between days $l_i$ and $r_i$ inclusive, for $1 \\le i \\le k$. If a job takes place on any of the $d$ days, the visit overlaps with this job (the length of overlap is unimportant).\n\nRobin wants his brother's visit to overlap with the maximum number of distinct jobs, and his mother's the minimum.\n\nFind suitable start days for the visits of Robin's brother and mother. If there are multiple suitable days, choose the earliest one.\n\n### Input\n\nThe first line of the input contains a single integer $t$ ($1\\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case consists of three integers $n$, $d$, $k$ ($1 \\le n \\le 10^5, 1 \\le d, k \\le n$)\u00a0\u2014 the number of total days, duration of the visits, and the number of jobs.\n\nThen follow $k$ lines of each test case, each with two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$)\u00a0\u2014 the start and end day of each job.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output two integers, the best starting days of Robin's brother and mother respectively. Both visits must fit between day $1$ and $n$ inclusive.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n2 1 1\n\n1 2\n\n4 1 2\n\n1 2\n\n2 4\n\n7 2 3\n\n1 2\n\n1 3\n\n6 7\n\n5 1 2\n\n1 2\n\n3 5\n\n9 2 1\n\n2 8\n\n9 2 4\n\n7 9\n\n4 8\n\n1 3\n\n2 3\n\n```\n\n#### Output #1\n\n```\n1 1\n2 1\n1 4\n1 1\n1 1\n3 4\n```\n\n### Note\n\nIn the first test case, the only job fills all $2$ days, both should visit on day $1$.\n\nIn the second test case, day $2$ overlaps with $2$ jobs and day $1$ overlaps with only $1$.\n\nIn the third test case, Robert visits for days $[1,2]$, Mrs. Hood visits for days $[4,5]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--){\n        long long n, d, k;\n        cin >> n >> d >> k;\n        // Initialize count_l and count_r\n        // Using vectors with n+2 size to accommodate 1-based indexing\n        vector<long long> count_l(n+2, 0);\n        vector<long long> count_r(n+2, 0);\n        for(long long i=0;i<k;i++){\n            long long l, r;\n            cin >> l >> r;\n            count_l[l]++;\n            count_r[r]++;\n        }\n        // Compute prefix sums\n        vector<long long> prefix_l(n+2, 0);\n        vector<long long> prefix_r(n+2, 0);\n        for(long long i=1;i<=n;i++){\n            prefix_l[i] = prefix_l[i-1] + count_l[i];\n            prefix_r[i] = prefix_r[i-1] + count_r[i];\n        }\n        // Iterate over possible start days\n        // s ranges from 1 to n-d+1\n        // Initialize max and min with appropriate values\n        long long max_overlap = -1;\n        long long s_max = 1;\n        long long min_overlap = k+1;\n        long long s_min = 1;\n        if(n < d){\n            // No possible visit, but according to constraints d <=n\n            // So this case shouldn't occur\n            // But to handle safely:\n            max_overlap = 0;\n            s_max = 1;\n            min_overlap = 0;\n            s_min = 1;\n        }\n        else{\n            for(long long s=1; s<=n-d+1; s++){\n                long long e = s + d -1;\n                long long overlap = prefix_l[e] - prefix_r[s-1];\n                if(overlap > max_overlap){\n                    max_overlap = overlap;\n                    s_max = s;\n                }\n                // For min, need to track the smallest s with the smallest overlap\n                if(overlap < min_overlap){\n                    min_overlap = overlap;\n                    s_min = s;\n                }\n            }\n        }\n        cout << s_max << \" \" << s_min << \"\\n\";\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2014c",
      "PROBLEM_ID": "2014C",
      "PROBLEM_STATEMENT": "In Sherwood, we judge a man not by his wealth, but by his merit.\n\nLook around, the rich are getting richer, and the poor are getting poorer. We need to take from the rich and give to the poor. We need Robin Hood!\n\nThere are $n$ people living in the town. Just now, the wealth of the $i$-th person was $a_i$ gold. But guess what? The richest person has found an extra pot of gold!\n\nMore formally, find an $a_j=max(a_1, a_2, \\dots, a_n)$, change $a_j$ to $a_j+x$, where $x$ is a non-negative integer number of gold found in the pot. If there are multiple maxima, it can be any one of them.\n\nA person is unhappy if their wealth is strictly less than half of the average wealth$^{\\text{\u2217}}$.\n\nIf strictly more than half of the total population $n$ are unhappy, Robin Hood will appear by popular demand.\n\nDetermine the minimum value of $x$ for Robin Hood to appear, or output $-1$ if it is impossible.\n\n$^{\\text{\u2217}}$The average wealth is defined as the total wealth divided by the total population $n$, that is, $\\frac{\\sum a_i}{n}$, the result is a real number.\n\n### Input\n\nThe first line of input contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 2\\cdot10^5$)\u00a0\u2014 the total population.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^6$)\u00a0\u2014 the wealth of each person.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the minimum number of gold that the richest person must find for Robin Hood to appear. If it is impossible, output $-1$ instead.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1\n\n2\n\n2\n\n2 19\n\n3\n\n1 3 20\n\n4\n\n1 2 3 4\n\n5\n\n1 2 3 4 5\n\n6\n\n1 2 1 1 1 25\n\n```\n\n#### Output #1\n\n```\n-1\n-1\n0\n15\n16\n0\n```\n\n### Note\n\nIn the first test case, it is impossible for a single person to be unhappy.\n\nIn the second test case, there is always $1$ happy person (the richest).\n\nIn the third test case, no additional gold are required, so the answer is $0$.\n\nIn the fourth test case, after adding $15$ gold, the average wealth becomes $\\frac{25}{4}$, and half of this average is $\\frac{25}{8}$, resulting in $3$ people being unhappy.\n\nIn the fifth test case, after adding $16$ gold, the average wealth becomes $\\frac{31}{5}$, resulting in $3$ people being unhappy.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nbool check(vector<ll>& a, ll x, int n) {\n    int maxIdx = max_element(a.begin(), a.end()) - a.begin();\n    ll sum = 0;\n    for(int i = 0; i < n; i++) {\n        sum += a[i];\n    }\n    sum += x; // Add x to the total sum\n    \n    double avg = (double)sum / n;\n    int unhappy = 0;\n    \n    for(int i = 0; i < n; i++) {\n        ll wealth = a[i];\n        if(i == maxIdx) wealth += x;\n        if(wealth < avg/2) unhappy++;\n    }\n    \n    return unhappy > n/2;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    \n    if(n == 1 || n == 2) {\n        cout << -1 << \"\\n\";\n        return;\n    }\n    \n    // Binary search on x\n    ll left = 0, right = 1e18;\n    ll ans = -1;\n    \n    while(left <= right) {\n        ll mid = left + (right - left) / 2;\n        if(check(a, mid, n)) {\n            ans = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    cout << ans << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2014b",
      "PROBLEM_ID": "2014B",
      "PROBLEM_STATEMENT": "In Sherwood, the trees are our shelter, and we are all children of the forest.\n\nThe Major Oak in Sherwood is known for its majestic foliage, which provided shelter to Robin Hood and his band of merry men and women.\n\nThe Major Oak grows $i^i$ new leaves in the $i$-th year. It starts with $1$ leaf in year $1$.\n\nLeaves last for $k$ years on the tree. In other words, leaves grown in year $i$ last between years $i$ and $i+k-1$ inclusive.\n\nRobin considers even numbers lucky. Help Robin determine whether the Major Oak will have an even number of leaves in year $n$.\n\n### Input\n\nThe first line of the input contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nEach test case consists of two integers $n$, $k$ ($1 \\le n \\le 10^9$, $1 \\le k \\le n$)\u00a0\u2014 the requested year and the number of years during which the leaves remain.\n\n### Output\n\nFor each test case, output one line, \"YES\" if in year $n$ the Major Oak will have an even number of leaves and \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1 1\n\n2 1\n\n2 2\n\n3 2\n\n4 4\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nNO\nNO\nYES\n```\n\n### Note\n\nIn the first test case, there is only $1$ leaf.\n\nIn the second test case, $k=1$, so in the $2$-nd year there will be $2^2=4$ leaves.\n\nIn the third test case, $k=2$, so in the $2$-nd year there will be $1+2^2=5$ leaves.\n\nIn the fourth test case, $k=2$, so in the $3$-rd year there will be $2^2 + 3^3 = 4 + 27 = 31$ leaves.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isEvenLeaves(int n, int k) {\n    int start = n - k + 1;\n    int end = n;\n    \n    int evenCount = (end / 2) - ((start - 1) / 2);\n    int oddCount = k - evenCount;\n    \n    // Each odd contributes 1, so the total parity depends on the number of odds\n    // Sum is even if the number of odd contributions is even\n    return (oddCount % 2) == 0;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        if (isEvenLeaves(n, k)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2014a",
      "PROBLEM_ID": "2014A",
      "PROBLEM_STATEMENT": "There is a little bit of the outlaw in everyone, and a little bit of the hero too.\n\nThe heroic outlaw Robin Hood is famous for taking from the rich and giving to the poor.\n\nRobin encounters $n$ people starting from the $1$-st and ending with the $n$-th. The $i$-th person has $a_i$ gold. If $a_i \\ge k$, Robin will take all $a_i$ gold, and if $a_i=0$, Robin will give $1$ gold if he has any. Robin starts with $0$ gold.\n\nFind out how many people Robin gives gold to.\n\n### Input\n\nThe first line of the input contains a single integer $t$ ($1\\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$, $k$ ($1 \\le n \\le 50, 1 \\le k \\le 100$)\u00a0\u2014 the number of people and the threshold at which Robin Hood takes the gold.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 100$)\u00a0\u2014 the gold of each person.\n\n### Output\n\nFor each test case, output a single integer, the number of people that will get gold from Robin Hood.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 2\n\n2 0\n\n3 2\n\n3 0 0\n\n6 2\n\n0 3 0 0 0 0\n\n2 5\n\n5 4\n\n```\n\n#### Output #1\n\n```\n1\n2\n3\n0\n```\n\n### Note\n\nIn the first test case, Robin takes $2$ gold from the first person and gives a gold to the second person.\n\nIn the second test case, Robin takes $3$ gold and gives $1$ gold to each of the next $2$ people.\n\nIn the third test case, Robin takes $3$ gold and so only gives gold to $3$ other people.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    \n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    \n    int robinGold = 0;  // Robin's current gold\n    int giftCount = 0;  // Number of people who receive gold\n    \n    // Process each person\n    for (int i = 0; i < n; i++) {\n        if (a[i] >= k) {\n            // Take all gold if person has >= k gold\n            robinGold += a[i];\n        } else if (a[i] == 0 && robinGold > 0) {\n            // Give 1 gold if person has 0 gold and Robin has gold\n            robinGold--;\n            giftCount++;\n        }\n    }\n    \n    cout << giftCount << \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2013f1",
      "PROBLEM_ID": "2013F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. In this version, $\\mathbf{u = v}$. You can make hacks only if both versions of the problem are solved.\n\nAlice and Bob are playing a fun game on a tree. This game is played on a tree with $n$ vertices, numbered from $1$ to $n$. Recall that a tree with $n$ vertices is an undirected connected graph with $n - 1$ edges.\n\nAlice and Bob take turns, with Alice going first. Each player starts at some vertex.\n\nOn their turn, a player must move from the current vertex to a neighboring vertex that has not yet been visited by anyone. The first player who cannot make a move loses.\n\nYou are given two vertices $u$ and $v$. Represent the simple path from vertex $u$ to $v$ as an array $p_1, p_2, p_3, \\ldots, p_m$, where $p_1 = u$, $p_m = v$, and there is an edge between $p_i$ and $p_{i + 1}$ for all $i$ ($1 \\le i < m$).\n\nYou need to determine the winner of the game if Alice starts at vertex $1$ and Bob starts at vertex $p_j$ for each $j$ (where $1 \\le j \\le m$).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of vertices in the tree.\n\nEach of the following $n - 1$ lines contains two integers $a$ and $b$ ($1 \\le a, b \\le n$), denoting an undirected edge between vertices $a$ and $b$. It is guaranteed that these edges form a tree.\n\nThe last line of each test case contains two integers $u$ and $v$ ($2 \\le u, v \\le n$, $\\mathbf{u = v}$).\n\nIt is guaranteed that the path from $u$ to $v$ does not pass through vertex $1$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $m$ lines.\n\nIn the $i$-th line, print the winner of the game if Alice starts at vertex $1$ and Bob starts at vertex $p_i$. Print \"Alice\" (without quotes) if Alice wins, or \"Bob\" (without quotes) otherwise.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n3\n\n1 2\n\n2 3\n\n2 2\n\n3\n\n1 2\n\n2 3\n\n3 3\n\n6\n\n1 2\n\n1 3\n\n2 4\n\n2 5\n\n1 6\n\n4 4\n\n```\n\n#### Output #1\n\n```\nBob\nAlice\nAlice\n```\n\n### Note\n\n![](https://espresso.codeforces.com/70e2519179e33349716846c2c5f4c4b2ac3f9c21.png)Tree from the first and second examples.\n\nIn the first test case, the path will be ($2,2$). Bob starts at vertex $2$, Alice will not be able to move anywhere on her first turn and will lose.\n\nIn the second test case, the path will be ($3,3$). Bob starts at vertex $3$, Alice will move to vertex $2$, and Bob will have no remaining vertices to visit and will lose.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <set>\n\nusing namespace std;\n\nbool solve_game(int alice_pos, int bob_pos, vector<bool>& visited, const vector<vector<int>>& adj, bool is_alice_turn) {\n    if (is_alice_turn) {\n        bool can_move = false;\n        for (int neighbor : adj[alice_pos]) {\n            if (!visited[neighbor]) {\n                can_move = true;\n                break;\n            }\n        }\n        if (!can_move) {\n            return false; // Alice loses\n        }\n        for (int next_pos : adj[alice_pos]) {\n            if (!visited[next_pos]) {\n                visited[next_pos] = true;\n                if (!solve_game(next_pos, bob_pos, visited, adj, false)) {\n                    visited[next_pos] = false; // backtrack\n                    return true; // Alice wins\n                }\n                visited[next_pos] = false; // backtrack\n            }\n        }\n        return false; // No winning move for Alice\n    } else {\n        bool can_move = false;\n        for (int neighbor : adj[bob_pos]) {\n            if (!visited[neighbor]) {\n                can_move = true;\n                break;\n            }\n        }\n        if (!can_move) {\n            return false; // Bob loses\n        }\n        for (int next_pos : adj[bob_pos]) {\n            if (!visited[next_pos]) {\n                visited[next_pos] = true;\n                if (!solve_game(alice_pos, next_pos, visited, adj, true)) {\n                    visited[next_pos] = false; // backtrack\n                    return true; // Bob wins\n                }\n                visited[next_pos] = false; // backtrack\n            }\n        }\n        return false; // No winning move for Bob\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<vector<int>> adj(n + 1);\n        for (int i = 0; i < n - 1; ++i) {\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        int u, v_val;\n        cin >> u >> v_val;\n        vector<int> path = {u};\n        for (int start_bob_node : path) {\n            vector<bool> visited(n + 1, false);\n            visited[1] = true;\n            visited[start_bob_node] = true;\n            if (solve_game(1, start_bob_node, visited, adj, true)) {\n                cout << \"Alice\" << endl;\n            } else {\n                cout << \"Bob\" << endl;\n            }\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2013d",
      "PROBLEM_ID": "2013D",
      "PROBLEM_STATEMENT": "Zhan, tired after the contest, gave the only task that he did not solve during the contest to his friend, Sungat. However, he could not solve it either, so we ask you to try to solve this problem.\n\nYou are given an array $a_1, a_2, \\ldots, a_n$ of length $n$. We can perform any number (possibly, zero) of operations on the array.\n\nIn one operation, we choose a position $i$ ($1 \\leq i \\leq n - 1$) and perform the following action:\n\n- $a_i := a_i - 1$, and $a_{i+1} := a_{i+1} + 1$.\n\nFind the minimum possible value of $\\max(a_1, a_2, \\ldots, a_n) - \\min(a_1, a_2, \\ldots, a_n)$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^{12}$).\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer: the minimum possible value of $\\max(a_1, a_2, \\ldots, a_n) - \\min(a_1, a_2, \\ldots, a_n)$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n1\n\n3\n\n1 2 3\n\n4\n\n4 1 2 3\n\n4\n\n4 2 3 1\n\n5\n\n5 14 4 10 2\n\n```\n\n#### Output #1\n\n```\n0\n2\n1\n1\n3\n```\n\n### Note\n\nIn the third testcase, you can perform the operation twice with $i = 1$.\n\nAfter that, the array is $a = [2, 3, 2, 3]$, and $\\max(2, 3, 2, 3) - \\min(2, 3, 2, 3) = 3 - 2 = 1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) { cin >> a[i]; }\n    auto pre = a, suf = a;\n    for (int i = 1; i < n; i++) { pre[i] += pre[i - 1]; }\n    for (int i = n - 2; i >= 0; i--) { suf[i] += suf[i + 1]; }\n\n    for (int i = 0; i < n; i++) { pre[i] /= (i + 1); }\n    for (int i = 0; i < n; i++) { suf[i] = (suf[i] + (n - i - 1)) / (n - i); }\n\n    cout << abs(*max_element(suf.begin(), suf.end()) - *min_element(pre.begin(), pre.end())) << endl;\n}\n\nint32_t main() {\n    cin.tie(0)->sync_with_stdio(0);\n    int tc = 1;\n    cin >> tc;\n    while (tc--) solve();\n}\n\n/*\ndiff: add front\nmove i, gather ai\nif elem < avg, min = curr\nmaybe back?\nsort elems\nto eq high/small:\nif high @end or low @front, can't do much\n1e12\ntry inc next by past avg?\nmax: avg so far or curr if >\nmin: curr or fwd avg if <\n! floor/ceil\nmin diff b/w vals?\n*/\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2013b",
      "PROBLEM_ID": "2013B",
      "PROBLEM_STATEMENT": "Eralim, being the mafia boss, manages a group of $n$ fighters. Fighter $i$ has a rating of $a_i$.\n\nEralim arranges a tournament of $n - 1$ battles, in each of which two not yet eliminated fighters $i$ and $j$ ($1 \\le i < j \\le n$) are chosen, and as a result of the battle, fighter $i$ is eliminated from the tournament, and the rating of fighter $j$ is reduced by the rating of fighter $i$. That is, $a_j$ is decreased by $a_i$. Note that fighter $j$'s rating can become negative. The fighters indexes do not change.\n\nEralim wants to know what maximum rating the last remaining fighter can preserve if he chooses the battles optimally.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of fighters.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the ratings of the fighters.\n\nThe sum of $n$ over all testcases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each testcase, output a single integer\u00a0\u2014 the maximum rating that the last remaining fighter can preserve.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n2 1\n\n3\n\n2 2 8\n\n4\n\n1 2 4 3\n\n5\n\n1 2 3 4 5\n\n5\n\n3 2 4 5 4\n\n```\n\n#### Output #1\n\n```\n-1\n8\n2\n7\n8\n```\n\n### Note\n\nIn the first example, you can arrange a fight between fighters with indices $1$ and $2$, where the fighter with index $2$ will win. The rating of the last fighter, that is, the fighter with index $2$, will be $1 - 2 = -1$.\n\nIn the second example, you can first conduct a fight between fighters with indices $1$ and $2$, where the fighter with index $2$ will win, and then conduct a fight between fighters with indices $2$ and $3$, where the fighter with index $3$ will win.\n\nThe rating of the fighter with index $2$ after the first fight will be $2 - 2 = 0$. The rating of the fighter with index $3$ after the second fight will be $8 - 0 = 8$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream> // Include the standard input/output library for operations like cin and cout\n#include <vector>   // Include the vector library for using dynamic arrays (std::vector)\n#include <numeric>  // Include the numeric library, potentially useful for operations like std::accumulate (though not used in this final version)\n\nint main() {\n    // Optimize standard I/O operations for faster execution.\n    // std::ios_base::sync_with_stdio(false) unties C++ standard streams from C standard streams.\n    // std::cin.tie(NULL) unties cin from cout, preventing automatic flushing of cout before cin operations.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Declare an integer variable 't' to store the number of test cases\n    std::cin >> t; // Read the number of test cases from standard input\n    \n    // Loop 't' times to process each test case\n    while (t--) {\n        int n; // Declare an integer variable 'n' to store the number of fighters in the current test case\n        std::cin >> n; // Read the number of fighters from standard input\n        \n        // Declare a vector 'a' of size 'n' to store the ratings of the fighters.\n        // Use 'long long' as the data type for vector elements. This is important because:\n        // 1. Individual ratings can be up to 10^9.\n        // 2. The sum of ratings can be up to n * 10^9, which for n = 2*10^5 can reach 2*10^14.\n        //    This value exceeds the capacity of a standard 32-bit integer. 'long long' provides 64 bits.\n        std::vector<long long> a(n);\n        \n        // Declare a variable 'sum' of type 'long long' to store the sum of all ratings. Initialize it to 0.\n        long long sum = 0;\n        \n        // Loop through each fighter to read their rating and add it to the sum.\n        // The loop runs from i = 0 to n-1, covering all elements in the 0-indexed vector 'a'.\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i]; // Read the rating of the i-th fighter (0-indexed) into the vector\n            sum += a[i];      // Add the rating to the running total sum\n        }\n        \n        // Calculate the maximum possible final rating of the last remaining fighter.\n        // Based on the analysis, the optimal strategy leads to a final rating equal to:\n        // (Total Sum of initial ratings) - 2 * (Initial Rating of Fighter n-1).\n        // The problem uses 1-based indexing for fighters (1 to n). Fighter n-1 corresponds to index n-2 in our 0-based vector 'a'.\n        // For example, if n=5, fighters are 1, 2, 3, 4, 5. Fighter n-1 is fighter 4. In vector 'a', this is a[3], which is a[5-2].\n        // The problem constraints state n >= 2, ensuring that n-2 is always a valid non-negative index (0 or greater).\n        long long max_rating = sum - 2 * a[n - 2];\n        \n        // Print the calculated maximum rating to standard output, followed by a newline character.\n        std::cout << max_rating << \"\\n\";\n    }\n    \n    // Return 0 to indicate successful program execution.\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2013a",
      "PROBLEM_ID": "2013A",
      "PROBLEM_STATEMENT": "Today, a club fair was held at \"NSPhM\". In order to advertise his pastry club, Zhan decided to demonstrate the power of his blender.\n\nTo demonstrate the power of his blender, Zhan has $n$ fruits.\n\nThe blender can mix up to $x$ fruits per second.\n\nIn each second, Zhan can put up to $y$ fruits into the blender. After that, the blender will blend $\\min(x, c)$ fruits, where $c$ is the number of fruits inside the blender. After blending, blended fruits are removed from the blender.\n\nHelp Zhan determine the minimum amount of time required for Zhan to blend all fruits.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($0 \\le n \\le 10^9$)\u00a0\u2014 the number of fruits Zhan has.\n\nThe second line of each test case contains two integers $x$ and $y$ ($1 \\le x, y \\le 10^9$)\u00a0\u2014 the number of fruits the blender can blend per second and the number of fruits Zhan can put into the blender per second.\n\n### Output\n\nFor each testcase, output a single integer\u00a0\u2014 the minimum number of seconds to blend all fruits.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n5\n\n3 4\n\n3\n\n1 2\n\n6\n\n4 3\n\n100\n\n4 3\n\n9\n\n3 3\n\n```\n\n#### Output #1\n\n```\n2\n3\n2\n34\n3\n```\n\n### Note\n\nIn the first example, you can first put $2$ fruits in the blender. After that, the blender will mix these $2$ fruits, and in the end, there will be $0$ fruits left in the blender. Then you can put $3$ fruits into the blender, after which the blender will mix these $3$ fruits.\n\nIn the second example, you can put $1$ fruit into the blender $3$ times.\n\nIn the third example, you can first put $3$ fruits into the blender, then add another $3$ fruits.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        long long n;\n        cin >> n;\n        long long x, y;\n        cin >> x >> y;\n        if (n == 0) {\n            cout << 0 << endl;\n        } else {\n            long long m = min(x, y);\n            long long result = (n + m - 1) / m;\n            cout << result << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2008h",
      "PROBLEM_ID": "2008H",
      "PROBLEM_STATEMENT": "Sakurako will soon take a test. The test can be described as an array of integers $n$ and a task on it:\n\nGiven an integer $x$, Sakurako can perform the following operation any number of times:\n\n- Choose an integer $i$ ($1\\le i\\le n$) such that $a_i\\ge x$;\n- Change the value of $a_i$ to $a_i-x$.\n\nUsing this operation any number of times, she must find the minimum possible median$^{\\text{\u2217}}$ of the array $a$.\n\nSakurako knows the array but does not know the integer $x$. Someone let it slip that one of the $q$ values of $x$ will be in the next test, so Sakurako is asking you what the answer is for each such $x$.\n\n$^{\\text{\u2217}}$The median of an array of length $n$ is the element that stands in the middle of the sorted array (at the $\\frac{n+2}{2}$-th position for even $n$, and at the $\\frac{n+1}{2}$-th for odd)\n\n### Input\n\nThe first line contains one integer $t$ ($1\\le t\\le 10^4$) \u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1\\le n,q\\le 10^5$) \u00a0\u2014 the number of elements in the array and the number of queries.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1\\le a_i\\le n$) \u00a0\u2014 the elements of the array.\n\nThe following $q$ lines each contain one integer $x$ ($1\\le x\\le n$).\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $10^5$. The same guarantee applies to the sum of $q$ across all test cases.\n\n### Output\n\nFor each test case, output $q$ integers \u00a0\u2014 the answer for each query.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n5 5\n\n1 2 3 4 5\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6 3\n\n1 2 6 4 1 3\n\n2\n\n1\n\n5\n\n```\n\n#### Output #1\n\n```\n0 1 1 1 2\n1 0 2\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\n \n#define INF 0x3f\n#define all(a) a.begin(), a.end()\n#define all1(a) a.begin()+1, a.end()\n \nconst int MOD = 1e9+7;\n \ntypedef unsigned long long ULL;\ntypedef long long LL;\n \ntypedef vector<LL> vll;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef pair<LL, list<vector<LL>>::iterator> P;\ntypedef tuple<int, int, int> T;\nbool debug = false;\n \nvector<vector<int>> dirs4 = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\nvector<vector<int>> dirs8 = {{1, -2}, {-1, -2}, {1, 2}, {-1, 2}, {2, -1}, {2, 1}, {-2, -1}, {-2, 1}};\nstring dirChars = \"DULR\";\nmap<char, vector<int>> dirMap;\n \n \nvector<vector<int>> dirs2 = {{-1, 0}, {0, -1}};\n \n\nconst LL SEED=chrono::steady_clock::now().time_since_epoch().count();\nmt19937_64 rng(SEED);\ninline LL rnd(LL l=0,LL r=INF)\n{return uniform_int_distribution<LL>(l,r)(rng);}\n\n// usage rnd(0, 1e18)\n\nLL gcd(LL a, LL b) {\n    if (b==0) \n        return a;\n    \n    a%=b;\n    return gcd(b,a);\n}\n \nLL roundup(LL a, LL b) {\n    if (a % b == 0)\n        return a / b;\n \n    return a/b+1;\n}\n \nvoid print(vector<int> & v, int idx = 0) {\n    for (int i = idx; i < v.size(); i++) {\n        cout << v[i] << \" \";\n    }\n    cout << endl;\n}\n \nvoid print(vector<LL> & v, int idx = 0) {\n    for (int i = idx; i < v.size(); i++) {\n        cout << v[i] << \" \";\n    }\n    cout << endl;\n}\n \nLL modPow(LL a, LL b) {\n    if (a == 1 || b == 0)\n        return 1;\n \n    LL res = modPow(a, b/2);\n    if (b % 2 == 0) {\n        return res * res % MOD;\n    } else {\n        return res * res % MOD * a % MOD;\n    }\n}\n \nLL A(LL m, LL n) { // pick n from n\n    LL res = 1;\n \n    for (LL i = m, j = 0; j < n; i--, j++) {\n        res = (res * i);\n    }\n \n    return res;\n}\n \nLL inv(LL x) {\n    return modPow(x, MOD-2) % MOD;\n}\n \n \nLL C(LL m, LL n) { // pick n from m\n    LL res = 1;\n \n    for (LL i = m, j = 0; j < n; i--, j++) {\n        res = (res * i) % MOD;\n    }\n \n    for (LL i = 1; i <= n; i++) {\n        res = res * inv(i) % MOD;\n    }\n    \n    // cout << \"C\" << m << \" \" << n << \" => \" << res << endl;\n    return res;\n}\n \nvoid printYN(bool ok) {\n    if (ok) \n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\n\nint main() {\n    \n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    srand((unsigned) time(NULL));\n \n    #ifndef ONLINE_JUDGE\n       freopen(\"input.txt\", \"r\", stdin);\n       freopen(\"output.txt\", \"w\", stdout);\n    #endif   \n       \n    int t;\n    cin >> t;\n    if (t == 10000) {\n        // debug = true;\n    }\n\n    for (int tc = 1; tc <= t; tc++) {\n        LL n, q;\n        cin >> n >> q;\n\n        vll v(n+1);\n        for (int i = 1; i <= n; i++) {\n            LL x;\n            cin >> x;\n            v[x]++;\n        }\n\n        vll preSum(n+1);\n        for (int i = 1; i <= n; i++) {\n            preSum[i] = preSum[i-1] + v[i];\n        }\n\n        vll ans(n+1);\n        LL k;\n        if (n%2 == 1) {\n            k = (n+1)/2;\n        } else {\n            k = (n+2)/2;\n        }\n        for (int i = 2; i <= n; i++) {\n            LL l = 0, r = n;\n            LL res = -1;\n            while (l <= r) {\n                LL mid = l + r >> 1;\n\n                LL cnt = 0;\n                for (int j = 0; j <= n; j += i) {\n                    if (j > 0)\n                        cnt += preSum[min(n,j+mid)] - preSum[j-1];\n                    else\n                        cnt += preSum[min(n,j+mid)];\n                }\n\n                if (cnt < k) {\n                    l = mid+1;\n                } else {\n                    res = mid;\n                    r = mid-1;\n                }\n\n            }\n\n            ans[i] = res;\n\n        }\n\n        for (int i = 1; i <= q; i++) {\n            LL x; \n            cin >> x;\n\n            cout << ans[x] << \" \"; \n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2008g",
      "PROBLEM_ID": "2008G",
      "PROBLEM_STATEMENT": "Sakurako has prepared a task for you:\n\nShe gives you an array of $n$ integers and allows you to choose $i$ and $j$ such that $i \\neq j$ and $a_i \\ge a_j$, and then assign $a_i = a_i - a_j$ or $a_i = a_i + a_j$. You can perform this operation any number of times for any $i$ and $j$, as long as they satisfy the conditions.\n\nSakurako asks you what is the maximum possible value of $mex\\_k$$^{\\\\text{\u2217}}$ of the array after any number of operations.\n\n$^{\\\\text{\u2217}}$$mex\\_k$ is the $k$-th non-negative integer that is absent in the array. For example, $mex\\_1(\\\\{1,2,3 \\\\})=0$, since $0$ is the first element that is not in the array, and $mex\\_2(\\\\{0,2,4 \\\\})=3$, since $3$ is the second element that is not in the array.\n\n### Input\n\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$) \u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1\\le n\\le 2\\cdot 10^5,1\\le k\\le 10^9$) \u00a0\u2014 the number of elements in the array and the value $k$ for $mex_k$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots,a_n$ ($1\\le a_i\\le 10^9$) \u00a0\u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output the maximum $mex_k$ that can be achieved through the operations.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1 3\n\n3\n\n2 10\n\n1 1\n\n3 1\n\n1 2 3\n\n3 2\n\n1 2 4\n\n4 5\n\n2 2 2 16\n\n4 5\n\n2 2 2 3\n\n```\n\n#### Output #1\n\n```\n2\n11\n3\n4\n8\n8\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Required for std::gcd in C++17, or use custom implementation\n#include <algorithm> // Required for std::min, std::swap, std::abs\n#include <cmath> // Required for std::abs with long long\n\n/**\n * @brief Calculates the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm.\n * \n * @param a First non-negative integer.\n * @param b Second non-negative integer.\n * @return long long The GCD of a and b.\n */\nlong long calculate_gcd(long long a, long long b) {\n    // Ensure inputs are non-negative. std::abs works for long long.\n    a = std::abs(a);\n    b = std::abs(b);\n    // Euclidean algorithm\n    while (b) {\n        a %= b;\n        std::swap(a, b);\n    }\n    // When b becomes 0, a holds the GCD.\n    return a;\n}\n\n/**\n * @brief Calculates the count of elements in the target set {0, g, 2g, ..., (n-1)g} that are strictly less than X.\n * The target set represents the smallest achievable values using the operations, assuming n >= 2.\n * \n * @param X The upper bound (exclusive).\n * @param n The number of elements in the array (size of the target set).\n * @param g The greatest common divisor of the initial array elements.\n * @return long long The count of elements in the target set {0, g, ..., (n-1)g} that are < X.\n */\nlong long P(long long X, int n, long long g) {\n    // If X is 0 or negative, no non-negative elements are strictly less than X.\n    if (X <= 0) return 0; \n    \n    // Based on problem constraints (a_i >= 1), g must be >= 1.\n    // The check `if (g == 0)` is theoretically unnecessary but included for robustness.\n    // If g were 0, the only achievable value potentially is 0.\n    if (g == 0) { \n        // Check if 0 is considered part of the set (n>=1 implies it can be generated if n>=2).\n        // If n=1, 0 is not generated. If n>=2, 0 can be generated.\n        // Let's assume P(X) requires g >= 1 context as per problem setup.\n        // In case g=0 was possible, it indicates all initial a_i were 0. \n        // If initial a_i are 0, then operations might not be possible depending on a_i >= a_j interpretation.\n        // Stick to problem constraints: g >= 1.\n         return 0; // Should not be reached under problem constraints.\n    }\n    \n    // Calculate the count of non-negative multiples m*g such that m*g < X.\n    // This is equivalent to finding the count of integers m >= 0 such that m < X/g.\n    // The non-negative integers m satisfying this are 0, 1, ..., floor((X-1)/g).\n    // The total count of such integers is floor((X-1)/g) + 1.\n    // This calculation is valid for X >= 1.\n    long long num_multiples = (X - 1) / g + 1;\n    \n    // The target set S* = {0*g, 1*g, ..., (n-1)*g} has n elements.\n    // The number of elements from S* that are < X is limited by n.\n    // It's the minimum of n and the total count of non-negative multiples of g less than X.\n    return std::min((long long)n, num_multiples);\n}\n\n/**\n * @brief Check function for binary search. Determines if the number of non-negative integers\n * missing from the target set {0, g, ..., (n-1)g} and less than X is at least k.\n * \n * @param X The upper bound (exclusive).\n * @param n The number of elements in the array.\n * @param k The target rank k for mex_k.\n * @param g The GCD of the initial array elements.\n * @return true If the count of missing numbers less than X is >= k.\n * @return false Otherwise.\n */\nbool check(long long X, int n, long long k, long long g) {\n    // Check for X < 0 mainly for safety during binary search logic. X should be non-negative.\n    if (X < 0) return false; \n    \n    // Calculate the count of elements present in the target set that are less than X.\n    long long present_count = P(X, n, g);\n    \n    // Number of missing integers < X is Total non-negative integers < X minus Present integers < X\n    // Total non-negative integers < X is X.\n    long long missing_count = X - present_count;\n\n    // Check if the count of missing integers meets the requirement k\n    return missing_count >= k;\n}\n\nint main() {\n    // Faster I/O operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Number of elements in the array\n        long long k; // The k-th missing element index (1-based)\n        std::cin >> n >> k;\n        std::vector<long long> a(n);\n        long long current_gcd = 0; // Initialize GCD\n        \n        bool first_element = true; // Flag to handle the initialization of GCD\n        // Read array elements and compute their GCD\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n            // Problem guarantees a_i >= 1. No need to check for non-positive values.\n            if (first_element) {\n                current_gcd = a[i];\n                first_element = false;\n            } else {\n                // Iteratively compute GCD of all elements\n                current_gcd = calculate_gcd(current_gcd, a[i]); \n            }\n        }\n         // Since all a_i >= 1 and n >= 1, current_gcd >= 1 is guaranteed.\n\n        // Handle the base case n = 1 where no operations can be performed\n        if (n == 1) {\n             // The array remains {a[0]}. mex_k is the k-th non-negative integer not equal to a[0].\n             // The missing non-negative integers are 0, 1, ..., a[0]-1, a[0]+1, ...\n             // The k-th missing integer is k-1 if k-1 < a[0].\n             // Otherwise (if k-1 >= a[0]), the k-th missing integer is k.\n             // Constraint k >= 1 is given.\n             if (k - 1 < a[0]) { \n                 std::cout << k - 1 << \"\\n\";\n             } else {\n                 // This covers cases where k-1 >= a[0].\n                 std::cout << k << \"\\n\";\n             }\n        } else { // Case n >= 2: operations are possible\n             long long g = current_gcd; // The GCD determines the set of achievable values {0, g, 2g, ...}\n             \n             // Binary search for the smallest non-negative integer X such that check(X) is true.\n             // `check(X)` is true if the number of missing values less than X is at least k.\n             // The search range needs to cover potential answers. mex_k can be up to k + n.\n             // Use a safe upper bound: maximum k + maximum n + a small buffer.\n             long long low = 0, high = 1000000000LL + 200005LL + 5; // k_max + n_max + buffer\n             // A slightly larger bound is safer: 2*10^9 + 2*10^5 + 5LL is fine too.\n             // It ensures coverage even if mex_k slightly exceeds k+n.\n             high = 2000000000LL + 200005LL; \n\n             long long ans_X = 0; // Will store the minimum X found satisfying check(X)\n\n             while (low <= high) {\n                 // Calculate midpoint carefully to avoid overflow using `low + (high - low) / 2`\n                 long long mid = low + (high - low) / 2; \n                 \n                 if (check(mid, n, k, g)) {\n                     // If mid satisfies the condition, it's a potential candidate for the smallest X.\n                     // Record it and try searching for an even smaller X in the lower half.\n                     ans_X = mid; \n                     high = mid - 1; \n                 } else {\n                     // If mid does not satisfy the condition, it means mid is too small.\n                     // The smallest X must be larger than mid. Search in the upper half.\n                     low = mid + 1; \n                 }\n             }\n             // After the binary search, ans_X holds the smallest non-negative integer X such that\n             // there are at least k missing numbers less than X.\n             // The k-th missing number (mex_k) is exactly ans_X - 1.\n             std::cout << ans_X - 1 << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2008e",
      "PROBLEM_ID": "2008E",
      "PROBLEM_STATEMENT": "Sakurako really loves alternating strings. She calls a string $s$ of lowercase Latin letters an alternating string if characters in the even positions are the same, if characters in the odd positions are the same, and the length of the string is even.\n\nFor example, the strings 'abab' and 'gg' are alternating, while the strings 'aba' and 'ggwp' are not.\n\nAs a good friend, you decided to gift such a string, but you couldn't find one. Luckily, you can perform two types of operations on the string:\n\n1. Choose an index $i$ and delete the $i$-th character from the string, which will reduce the length of the string by $1$. This type of operation can be performed no more than $1$ time;\n2. Choose an index $i$ and replace $s_i$ with any other letter.\n\nSince you are in a hurry, you need to determine the minimum number of operations required to make the string an alternating one.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single number $n$ ($1 \\le n\\le 2\\cdot 10^5$) \u00a0\u2014 the length of the string.\n\nThe second line of each test case contains a string $s$, consisting of lowercase Latin letters.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations required to turn the string $s$ into an alternating one.\n\n### Example\n\n#### Input #1\n\n```\n\n10\n\n1\n\na\n\n2\n\nca\n\n3\n\naab\n\n5\n\nababa\n\n6\n\nacdada\n\n9\n\nejibmyyju\n\n6\n\nbbccbc\n\n6\n\nabacba\n\n5\n\nbcbca\n\n5\n\ndcbdb\n\n```\n\n#### Output #1\n\n```\n1\n0\n1\n1\n2\n6\n2\n3\n1\n1\n```\n\n### Note\n\nFor the string ababa, you can delete the first character to get baba, which is an alternating string.\n\nFor the string acdada, you can change the first two characters to get dadada, which is an alternating string.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        if(n %2 ==0){\n            // Even length, no deletion\n            // Count frequency in odd and even positions\n            int num_odd = (n +1)/2;\n            int num_even = n/2;\n            vector<int> freq_odd(26,0);\n            vector<int> freq_even(26,0);\n            for(int i=0;i<n;i++){\n                if((i+1) %2 ==1){\n                    freq_odd[s[i]-'a']++;\n                }\n                else{\n                    freq_even[s[i]-'a']++;\n                }\n            }\n            int max_freq_odd = 0;\n            for(auto cnt: freq_odd){\n                if(cnt > max_freq_odd) max_freq_odd = cnt;\n            }\n            int max_freq_even =0;\n            for(auto cnt: freq_even){\n                if(cnt > max_freq_even) max_freq_even = cnt;\n            }\n            int min_changes = (num_odd - max_freq_odd) + (num_even - max_freq_even);\n            cout << min_changes << \"\\n\";\n        }\n        else{\n            // Odd length, need to delete one character\n            // Build prefix counts\n            // Initialize prefix counts\n            vector<vector<int>> prefix_odd(26, vector<int>(n+1, 0));\n            vector<vector<int>> prefix_even(26, vector<int>(n+1, 0));\n            for(int c=0;c<26;c++){\n                prefix_odd[c][0] =0;\n                prefix_even[c][0] =0;\n            }\n            for(int i=1;i<=n;i++){\n                for(int c=0;c<26;c++){\n                    prefix_odd[c][i] = prefix_odd[c][i-1];\n                    prefix_even[c][i] = prefix_even[c][i-1];\n                }\n                int c = s[i-1]-'a';\n                if(i %2 ==1){\n                    prefix_odd[c][i]++;\n                }\n                else{\n                    prefix_even[c][i]++;\n                }\n            }\n            // Build suffix counts\n            vector<vector<int>> suffix_odd(26, vector<int>(n+2, 0));\n            vector<vector<int>> suffix_even(26, vector<int>(n+2, 0));\n            for(int c=0;c<26;c++){\n                suffix_odd[c][n+1] =0;\n                suffix_even[c][n+1] =0;\n            }\n            for(int i=n;i>=1;i--){\n                for(int c=0;c<26;c++){\n                    suffix_odd[c][i] = suffix_odd[c][i+1];\n                    suffix_even[c][i] = suffix_even[c][i+1];\n                }\n                int c = s[i-1]-'a';\n                if(i%2 ==1){\n                    suffix_odd[c][i]++;\n                }\n                else{\n                    suffix_even[c][i]++;\n                }\n            }\n            // Iterate over all possible deletions\n            // Initialize minimum changes to a large number\n            long long min_changes = (long long)n; // Max possible\n            // Number of odd and even positions after deletion\n            int new_num_odd = (n-1)/2;\n            int new_num_even = (n-1)/2;\n            for(int i=1;i<=n;i++){\n                // After deletion at position i\n                // New odd frequencies: prefix_odd[c][i-1] + suffix_even[c][i+1]\n                // New even frequencies: prefix_even[c][i-1] + suffix_odd[c][i+1]\n                int max_freq_odd =0;\n                int max_freq_even=0;\n                for(int c=0;c<26;c++){\n                    int current_odd = prefix_odd[c][i-1] + suffix_even[c][i+1];\n                    if(current_odd > max_freq_odd){\n                        max_freq_odd = current_odd;\n                    }\n                    int current_even = prefix_even[c][i-1] + suffix_odd[c][i+1];\n                    if(current_even > max_freq_even){\n                        max_freq_even = current_even;\n                    }\n                }\n                // Total changes: (new_num_odd - max_freq_odd) + (new_num_even - max_freq_even) +1 (delete)\n                long long changes = (long long)(new_num_odd - max_freq_odd) + (long long)(new_num_even - max_freq_even) +1;\n                if(changes < min_changes){\n                    min_changes = changes;\n                }\n            }\n            cout << min_changes << \"\\n\";\n        }\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2008d",
      "PROBLEM_ID": "2008D",
      "PROBLEM_STATEMENT": "For a certain permutation $p$$^{\\\\text{\u2217}}$ Sakurako calls an integer $j$ reachable from an integer $i$ if it is possible to make $i$ equal to $j$ by assigning $i=p\\_i$ a certain number of times.\n\nIf $p=[3,5,6,1,2,4]$, then, for example, $4$ is reachable from $1$, because: $i=1$ $\\rightarrow$ $i=p_1=3$ $\\rightarrow$ $i=p_3=6$ $\\rightarrow$ $i=p_6=4$. Now $i=4$, so $4$ is reachable from $1$.\n\nEach number in the permutation is colored either black or white.\n\nSakurako defines the function $F(i)$ as the number of black integers that are reachable from $i$.\n\nSakurako is interested in $F(i)$ for each $1\\le i\\le n$, but calculating all values becomes very difficult, so she asks you, as her good friend, to compute this.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation (the number $2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$, but the array contains $4$).\n\n### Input\n\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$) \u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 2\\cdot 10^5$) \u00a0\u2014 the number of elements in the array.\n\nThe second line of each test case contains $n$ integers $p_1, p_2, \\dots, p_n$ ($1\\le p_i\\le n$) \u00a0\u2014 the elements of the permutation.\n\nThe third line of each test case contains a string $s$ of length $n$, consisting of '0' and '1'. If $s_i=0$, then the number $p_i$ is colored black; if $s_i=1$, then the number $p_i$ is colored white.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output $n$ integers $F(1), F(2), \\dots, F(n)$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n1\n\n0\n\n5\n\n1 2 4 5 3\n\n10101\n\n5\n\n5 4 1 3 2\n\n10011\n\n6\n\n3 5 6 1 2 4\n\n010000\n\n6\n\n1 2 3 4 5 6\n\n100110\n\n```\n\n#### Output #1\n\n```\n1\n0 1 1 1 1\n2 2 2 2 2\n4 1 4 4 1 4\n0 1 1 0 0 1\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\nvector<int> solve() {\n    int n;\n    cin >> n;\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n    }\n    string s;\n    cin >> s;\n    vector<bool> is_black(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '0') {\n            is_black[p[i]] = true;\n        }\n    }\n\n    vector<int> f_values(n + 1, 0);\n    vector<bool> in_cycle(n + 1, false);\n\n    for (int start_node = 1; start_node <= n; ++start_node) {\n        if (!in_cycle[start_node]) {\n            int black_count = 0;\n            vector<int> current_cycle_nodes;\n            int current_node = start_node;\n            while (!in_cycle[current_node]) {\n                in_cycle[current_node] = true;\n                current_cycle_nodes.push_back(current_node);\n                if (is_black[current_node]) {\n                    black_count++;\n                }\n                current_node = p[current_node - 1];\n            }\n            for (int node : current_cycle_nodes) {\n                f_values[node] = black_count;\n            }\n        }\n    }\n\n    vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        result.push_back(f_values[i]);\n    }\n    return result;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        vector<int> result = solve();\n        for (int i = 0; i < result.size(); ++i) {\n            cout << result[i] << (i == result.size() - 1 ? \"\" : \" \");\n        }\n        cout << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2008c",
      "PROBLEM_ID": "2008C",
      "PROBLEM_STATEMENT": "Today, Sakurako was studying arrays. An array $a$ of length $n$ is considered good if and only if:\n\n- the array $a$ is increasing, meaning $a_{i - 1} < a_i$ for all $2 \\le i \\le n$;\n- the differences between adjacent elements are increasing, meaning $a_i - a_{i-1} < a_{i+1} - a_i$ for all $2 \\le i < n$.\n\nSakurako has come up with boundaries $l$ and $r$ and wants to construct a good array of maximum length, where $l \\le a_i \\le r$ for all $a_i$.\n\nHelp Sakurako find the maximum length of a good array for the given $l$ and $r$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$) \u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains two integers $l$ and $r$ ($1\\le l\\le r\\le 10^9$).\n\n### Output\n\nFor each test case, output a single integer \u00a0\u2014 the length of the longest good array Sakurako can form given $l$ and $r$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1 2\n\n1 5\n\n2 2\n\n10 20\n\n1 1000000000\n\n```\n\n#### Output #1\n\n```\n2\n3\n1\n5\n44721\n```\n\n### Note\n\nFor $l=1$ and $r=5$, one possible array could be $(1,2,5)$. It can be proven that an array of length $4$ does not exist for the given $l$ and $r$.\n\nFor $l=2$ and $r=2$, the only possible array is $(2)$.\n\nFor $l=10$ and $r=20$, the only possible array is $(10,11,13,16,20)$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        long long l, r;\n        cin >> l >> r;\n        long long diff = r - l;\n        long long max_len = 0;\n        long long low = 1, high = 200000; // Upper bound for length. Should be sufficient. \n        while (low <= high) {\n            long long mid = low + (high - low) / 2;\n            long long val = mid * (mid - 1) / 2;\n            if (val <= diff) {\n                max_len = max(max_len, mid);\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        cout << max_len << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2008a",
      "PROBLEM_ID": "2008A",
      "PROBLEM_STATEMENT": "Today, Sakurako has a math exam. The teacher gave the array, consisting of $a$ ones and $b$ twos.\n\nIn an array, Sakurako must place either a '+' or a '-' in front of each element so that the sum of all elements in the array equals $0$.\n\nSakurako is not sure if it is possible to solve this problem, so determine whether there is a way to assign signs such that the sum of all elements in the array equals $0$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1\\le t\\le 100$) \u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains two integers $a$ and $b$ ($0\\le a,b<10$) \u00a0\u2014 the number of '1's and the number of '2's in the array.\n\n### Output\n\nFor each test case, output \"Yes\" if you can make the sum of the entire array equal to $0$, and \"No\" otherwise.\n\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n0 1\n\n0 3\n\n2 0\n\n2 3\n\n3 1\n\n```\n\n#### Output #1\n\n```\nNO\nNO\nYES\nYES\nNO\n```\n\n### Note\n\n1. $a=0$, $b=1$: This means the array is $[2]$ \u2014 it is impossible to add the signs '+' or '-' to get $0$ as a result;\n2. $a=0$, $b=3$: This means the array is $[2, 2, 2]$ \u2014 it is impossible to add the signs '+' or '-' to get $0$ as a result;\n3. $a=2$, $b=0$: This means the array is $[1, 1]$ \u2014 it is possible to add the signs '+' or '-' to get $0$ as a result ($+1-1=0$);\n4. $a=2$, $b=3$: This means the array is $[1, 1, 2, 2, 2]$ \u2014 it is possible to add the signs '+' or '-' to get $0$ as a result ($+1+1-2-2+2=0$);",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    for (int test = 0; test < t; test++) {\n        int a, b;\n        cin >> a >> b;\n        int sum = a + 2 * b;\n        if (sum % 2 != 0) {\n            cout << \"NO\" << endl;\n            continue;\n        }\n        int K = sum / 2;\n        bool possible = false;\n        for (int y = 0; y <= b; y++) {\n            int x = K - 2 * y;\n            if (x >= 0 && x <= a) {\n                possible = true;\n                break;\n            }\n        }\n        cout << (possible ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2007b",
      "PROBLEM_ID": "2007B",
      "PROBLEM_STATEMENT": "After receiving yet another integer array $a_1, a_2, \\ldots, a_n$ at her birthday party, Index decides to perform some operations on it.\n\nFormally, there are $m$ operations that she is going to perform in order. Each of them belongs to one of the two types:\n\n- $\\texttt{+ l r}$. Given two integers $l$ and $r$, for all $1 \\leq i \\leq n$ such that $l \\leq a_i \\leq r$, set $a_i := a_i + 1$.\n- $\\texttt{- l r}$. Given two integers $l$ and $r$, for all $1 \\leq i \\leq n$ such that $l \\leq a_i \\leq r$, set $a_i := a_i - 1$.\n\nFor example, if the initial array $a = [7, 1, 3, 4, 3]$, after performing the operation $\\texttt{+} \\space 2 \\space 4$, the array $a = [7, 1, 4, 5, 4]$. Then, after performing the operation $\\texttt{-} \\space 1 \\space 10$, the array $a = [6, 0, 3, 4, 3]$.\n\nIndex is curious about the maximum value in the array $a$. Please help her find it after each of the $m$ operations.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 2 \\cdot 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 10^5$)\u00a0\u2014 the length of the array and the number of operations.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$)\u00a0\u2014 the initial array $a$.\n\nThen $m$ lines follow, each line corresponds to the operation, in the following format: $\\texttt{c l r}$ ($c \\in \\{\\texttt +, \\texttt -\\}$, $l$ and $r$ are integers, $1 \\leq l \\leq r \\leq 10^9$)\u00a0\u2014 the description of the operation.\n\nNote that the elements $a_i$ may not satisfy $1\\le a_i\\le 10^9$ after some operations, as it is shown in the example.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $m$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output one single line containing $m$ integers, with the $i$-th of them describing the maximum value of the array after the $i$-th operation.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n5 5\n\n1 2 3 2 1\n\n\\+ 1 3\n\n\\- 2 3\n\n\\+ 1 2\n\n\\+ 2 4\n\n\\- 6 8\n\n5 5\n\n1 3 3 4 5\n\n\\+ 1 4\n\n\\+ 2 3\n\n\\- 4 5\n\n\\- 3 3\n\n\\- 2 6\n\n5 5\n\n1 1 1 1 1\n\n\\+ 2 3\n\n\\- 4 5\n\n\\+ 1 6\n\n\\- 2 5\n\n\\+ 1 8\n\n1 1\n\n1\n\n\\- 1 1\n\n1 1\n\n1000000000\n\n\\+ 1000000000 1000000000\n\n```\n\n#### Output #1\n\n```\n4 4 4 5 5\n5 5 4 4 3\n1 1 2 1 2\n0\n1000000001\n```\n\n### Note\n\nIn the first test case, the process of the operations is listed below:\n\n- After the first operation, the array becomes equal $[2,3,4,3,2]$. The maximum value is $4$.\n- After the second operation, the array becomes equal $[1,2,4,2,1]$. The maximum value is $4$.\n- After the third operation, the array becomes equal $[2,3,4,3,2]$. The maximum value is $4$.\n- After the fourth operation, the array becomes equal $[3,4,5,4,3]$. The maximum value is $5$.\n- After the fifth operation, the array becomes equal $[3,4,5,4,3]$. The maximum value is $5$.\n\nIn the second test case, the process of the operations is listed below:\n\n- After the first operation, the array becomes equal $[2,4,4,5,5]$. The maximum value is $5$.\n- After the second operation, the array becomes equal $[3,4,4,5,5]$. The maximum value is $5$.\n- After the third operation, the array becomes equal $[3,3,3,4,4]$. The maximum value is $4$.\n- After the fourth operation, the array becomes equal $[2,2,2,4,4]$. The maximum value is $4$.\n- After the fifth operation, the array becomes equal $[1,1,1,3,3]$. The maximum value is $3$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nint main() {\n\n  std::ios_base::sync_with_stdio(false);\n  long t;\n  std::cin >> t;\n  while (t--) {\n    long n, m;\n    std::cin >> n >> m;\n    long x(0);\n    for (long p = 0; p < n; p++) {\n      long a;\n      std::cin >> a;\n      x = (a > x ? a : x);\n    }\n    while (m--) {\n      char c;\n      long l, r;\n      std::cin >> c >> l >> r;\n      if (l <= x && x <= r) {\n        x += (c == '+') - (c == '-');\n      }\n      std::cout << x << \" \";\n    }\n\n    std::cout << std::endl;\n  }\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2007a",
      "PROBLEM_ID": "2007A",
      "PROBLEM_STATEMENT": "Dora has a set $s$ containing integers. In the beginning, she will put all integers in $[l, r]$ into the set $s$. That is, an integer $x$ is initially contained in the set if and only if $l \\leq x \\leq r$. Then she allows you to perform the following operations:\n\n- Select three distinct integers $a$, $b$, and $c$ from the set $s$, such that $\\gcd(a, b) = \\gcd(b, c) = \\gcd(a, c) = 1^\\dagger$.\n- Then, remove these three integers from the set $s$.\n\nWhat is the maximum number of operations you can perform?\n\n$^\\dagger$Recall that $\\gcd(x, y)$ means the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers $x$ and $y$.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 500$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains two integers $l$ and $r$ ($1 \\leq l \\leq r \\leq 1000$)\u00a0\u2014 the range of integers in the initial set.\n\n### Output\n\nFor each test case, output a single integer \u2014 the maximum number of operations you can perform.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n1 3\n\n3 7\n\n10 21\n\n2 8\n\n51 60\n\n2 15\n\n10 26\n\n1 1000\n\n```\n\n#### Output #1\n\n```\n1\n1\n3\n1\n2\n3\n4\n250\n```\n\n### Note\n\nIn the first test case, you can choose $a = 1$, $b = 2$, $c = 3$ in the only operation, since $\\gcd(1, 2) = \\gcd(2, 3) = \\gcd(1, 3) = 1$, and then there are no more integers in the set, so no more operations can be performed.\n\nIn the second test case, you can choose $a = 3$, $b = 5$, $c = 7$ in the only operation.\n\nIn the third test case, you can choose $a = 11$, $b = 19$, $c = 20$ in the first operation, $a = 13$, $b = 14$, $c = 15$ in the second operation, and $a = 10$, $b = 17$, $c = 21$ in the third operation. After the three operations, the set $s$ contains the following integers: $12$, $16$, $18$. It can be proven that it's impossible to perform more than $3$ operations.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\nint gcd(int a, int b) {\n    return std::gcd(a, b);\n}\n\nint solve() {\n    int l, r;\n    cin >> l >> r;\n    int even_count = 0;\n    int odd_count = 0;\n    for (int i = l; i <= r; ++i) {\n        if (i % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    return min(even_count, odd_count / 2);\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        cout << solve() << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2006f",
      "PROBLEM_ID": "2006F",
      "PROBLEM_STATEMENT": "Sadly, Dora poured the paint when painting the class mural. Dora considers the mural as the matrix $b$ of size $n \\times n$. Initially, $b_{i,j} = 0$ for all $1 \\le i, j \\le n$.\n\nDora has only two brushes which have two different colors. In one operation, she can paint the matrix with one of two brushes:\n\n- The first brush has color $1$ on it and can paint one column of the matrix. That is, Dora chooses $1 \\leq j \\leq n$ and makes $b_{i,j} := 1$ for all $1 \\leq i \\leq n$;\n- The second brush has color $2$ on it and can paint one row of the matrix. That is, Dora chooses $1 \\leq i \\leq n$ and makes $b_{i,j} := 2$ for all $1 \\leq j \\leq n$.\n\nDora paints the matrix so that the resulting matrix $b$ contains only $1$ and $2$.\n\nFor a matrix $b$, let $f(b)$ denote the minimum number of operations needed to turn the initial matrix (containing only $0$) into $b$. The beauty of a matrix $b$ is the number of ways to paint the initial matrix in exactly $f(b)$ operations to turn it into $b$. If there's no way to turn the initial matrix into $b$, the beauty of $b$ is $0$.\n\nHowever, Dora made a uniformly random mistake; there's exactly one element different in the matrix $a$ given to you from the real matrix $b$. That is, there is exactly one pair $(i, j)$ such that $a_{i, j} = 3 - b_{i, j}$.\n\nPlease help Dora compute the expected beauty of the real matrix $b$ modulo $998\\,244\\,353$ (all possible $n^2$ mistakes have equal probability).\n\nSince the size of the matrix is too large, Dora will only tell you the positions of $m$ elements of color $1$, and the remaining $n^2-m$ elements have color $2$.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($2 \\leq n \\leq 2 \\cdot 10^5$, $0 \\leq m \\leq \\min(10^6, n^2)$)\u00a0\u2014 the size of the matrix and the number of elements of color $1$.\n\nThen $m$ lines follow, each containing two positive integers $x_i$ and $y_i$ ($1 \\leq x_i, y_i \\leq n$)\u00a0\u2014 denoting that $a_{x_i, y_i} = 1$.\n\nIt is guaranteed that if $i \\neq j$, then $(x_i, y_i) \\neq (x_j, y_j)$.\n\nIt is also guaranteed that the sum of $n$ over all test cases does not exceed $4\\cdot10^5$, and the sum of $m$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the expected beauty of the real matrix $b$, modulo $998\\,244\\,353$.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n2 2\n\n1 1\n\n1 2\n\n2 1\n\n1 1\n\n3 2\n\n1 1\n\n3 3\n\n6 0\n\n5 10\n\n1 1\n\n1 2\n\n1 3\n\n2 1\n\n2 3\n\n5 1\n\n5 2\n\n5 3\n\n5 4\n\n5 5\n\n3 5\n\n1 1\n\n1 3\n\n2 2\n\n3 1\n\n3 3\n\n4 3\n\n1 1\n\n2 3\n\n2 4\n\n```\n\n#### Output #1\n\n```\n1\n499122178\n665496236\n120\n79859554\n776412275\n1\n```\n\n### Note\n\nIn the first test case, the matrix $a = \\left[\\begin{matrix}1&1\\\\2&2\\end{matrix}\\right]$. Let's consider changing the element $(1,1)$ to calculate the answer.\n\nIt can be proved that the minimum steps to paint the initial matrix into $\\left[\\begin{matrix}2&1\\\\2&2\\end{matrix}\\right]$ is $3$. We can first paint the first row into color $2$, then paint the second column into color $1$, and finally paint the second row into color $2$. The process is listed below:\n\n\n\n$$\\left[\\begin{matrix}0&0\\\\0&0\\end{matrix}\\right]\\Rightarrow\\left[\\begin{matrix}2&2\\\\0&0\\end{matrix}\\right]\\Rightarrow\\left[\\begin{matrix}2&1\\\\0&1\\end{matrix}\\right]\\Rightarrow\\left[\\begin{matrix}2&1\\\\2&2\\end{matrix}\\right]$$\n\nIt can be proved that this is the only way to paint the matrix in $3$ steps. So the beauty of the matrix $\\left[\\begin{matrix}2&1\\\\2&2\\end{matrix}\\right]$ is $1$. Similarly, if any other element of the matrix is changed, the beauty is always $1$, so the expected beauty of the real matrix $b$ is $1$.\n\nIn the second test case, the matrix $a = \\left[\\begin{matrix}1&2\\\\2&2\\end{matrix}\\right]$. Let's consider changing the element $(2, 2)$ to calculate the answer.\n\nIt can be proven that it's impossible to paint the initial matrix into $\\left[\\begin{matrix}1&2\\\\2&1\\end{matrix}\\right]$, so its beauty is $0$. If any other element of the matrix is changed, the beauty is always $2$, so the expected beauty is $\\frac{0 + 2 + 2 + 2}{4} = \\frac{6}{4} \\equiv 499\\,122\\,178 \\pmod {998\\,244\\,353}$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10,M=1e6+10;\nint n,m,c1[N],c2[N],inv[N];\nunordered_map<int,int>dd[N];\nconst int mod=998244353;\nvoid ad(int &x,int y){\n    x+=y;if(x>=mod)x-=mod;\n}\nint X[M],Y[M];\nint i1[N],i2[N],fz[N],jc[N];\nbool ca(int x,int y){\n    return dd[x].find(y)!=dd[x].end();\n}\nvector<int>tr(vector<int>e){\n    int sz=e.size(),k=-1;\n    vector<int>p;\n    for(int i=0;i+1<sz;i++)if(e[i]!=e[i+1])p.push_back(i-k),k=i;\n    p.push_back(sz-1-k);\n    return p;\n}\nint G(vector<int>e){\n    e=tr(e);int an=1;\n    for(int x:e)an=1ll*an*jc[x]%mod;\n    return an;\n}\nint H(vector<int>e){\n    e=tr(e);int s=n*2,an=1;for(int x:e)s-=x,an=1ll*an*jc[x]%mod;\n    e.push_back(s);\n    int su=0,sz=e.size();\n    for(int i=0;i+1<sz;i++){\n        int z=an;\n        if(i==sz-2)z=1ll*z*e[i+1]%mod;\n        if(e[i]==1&&i)z=1ll*z*(e[i-1]+1)%mod;\n        if(e[i+1]==1&&i+3<sz)z=1ll*z*(e[i+2]+1)%mod;\n        ad(su,z);\n    }\n    return su;\n}\nint b1[N],b2[N];\nint F(int x,int y){\n    for(int i=1;i<=n;i++)b1[i]=c1[i],b2[i]=c2[i];\n    if(ca(x,y))b1[x]--,b2[y]--;else b1[x]++,b2[y]++;\n    sort(b1+1,b1+n+1),sort(b2+1,b2+n+1);\n    int a=0,b=0;\n    vector<int>A;\n    while(a<n&&b<n){\n        if(b1[a+1]==b)a++,A.push_back(1);\n        else if(b2[n-b]==n-a)b++,A.push_back(2);\n        else return 0;\n    }\n    return G(A);\n}\nvoid sol(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)c1[i]=c2[i]=0,i1[i]=i2[i]=i,dd[i].clear();\n    for(int i=1;i<=m;i++)scanf(\"%d%d\",&X[i],&Y[i]),c1[X[i]]++,c2[Y[i]]++;\n    sort(i1+1,i1+n+1,[&](int x,int y){return c1[x]<c1[y];}),sort(c1+1,c1+n+1);\n    for(int i=1;i<=n;i++)fz[i1[i]]=i;for(int i=1;i<=n;i++)i1[i]=fz[i];\n    sort(i2+1,i2+n+1,[&](int x,int y){return c2[x]<c2[y];}),sort(c2+1,c2+n+1);\n    for(int i=1;i<=n;i++)fz[i2[i]]=i;for(int i=1;i<=n;i++)i2[i]=fz[i];\n    for(int i=1;i<=m;i++)X[i]=i1[X[i]],Y[i]=i2[Y[i]],dd[X[i]][Y[i]]=1;\n    int a=0,b=0;\n    vector<int>A;\n    int ans=0;\n    while(a<n&&b<n){\n        if(c1[a+1]==b)a++,A.push_back(1);\n        else if(c2[n-b]==n-a)b++,A.push_back(2);\n        else{\n            if(ca(a+1,n-b)){\n                int y=a+2;while(y<=n&&ca(y,n-b))y++;assert(y<=n);\n                int z=n-b-1;while(z&&(!ca(y,z)||ca(a+1,z)))z--;assert(z);\n                ad(ans,F(a+1,n-b)),ad(ans,F(y,n-b));\n                ad(ans,F(a+1,z)),ad(ans,F(y,z));\n            }\n            else{\n                int z=n-b-1;while(z&&!ca(a+1,z))z--;assert(z);\n                int y=a+2;while(y<=n&&(ca(y,z)||!ca(y,n-b)))y++;assert(y<=n);\n                ad(ans,F(a+1,n-b)),ad(ans,F(y,n-b));\n                ad(ans,F(a+1,z)),ad(ans,F(y,z));\n            }\n            break;\n        }\n    }\n    if(a==n||b==n)ans=H(A);\n    ans=1ll*ans*inv[n]%mod*inv[n]%mod;\n    printf(\"%d\\n\",ans);\n}\nint main(){\n    inv[1]=jc[0]=jc[1]=1;\n    for(int i=2;i<N;i++)jc[i]=1ll*i*jc[i-1]%mod,\n    inv[i]=mod-1ll*inv[mod%i]*(mod/i)%mod;\n    int T;scanf(\"%d\",&T);while(T--)sol();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2006a",
      "PROBLEM_ID": "2006A",
      "PROBLEM_STATEMENT": "Iris has a tree rooted at vertex $1$. Each vertex has a value of $\\mathtt 0$ or $\\mathtt 1$.\n\nLet's consider a leaf of the tree (the vertex $1$ is never considered a leaf) and define its weight. Construct a string formed by the values of the vertices on the path starting at the root and ending in this leaf. Then the weight of the leaf is the difference between the number of occurrences of $\\mathtt{10}$ and $\\mathtt{01}$ substrings in it.\n\nTake the following tree as an example. Green vertices have a value of $\\mathtt 1$ while white vertices have a value of $\\mathtt 0$.\n\n![](https://espresso.codeforces.com/d9350fda5ff8865950ffe82ce845754501957e88.png)\n\n- Let's calculate the weight of the leaf $5$: the formed string is $\\mathtt{10110}$. The number of occurrences of substring $\\mathtt{10}$ is $2$, the number of occurrences of substring $\\mathtt{01}$ is $1$, so the difference is $2 - 1 = 1$.\n- Let's calculate the weight of the leaf $6$: the formed string is $\\mathtt{101}$. The number of occurrences of substring $\\mathtt{10}$ is $1$, the number of occurrences of substring $\\mathtt{01}$ is $1$, so the difference is $1 - 1 = 0$.\n\nThe score of a tree is defined as the number of leaves with non-zero weight in the tree.\n\nBut the values of some vertices haven't been decided and will be given to you as $\\texttt{?}$. Filling the blanks would be so boring, so Iris is going to invite Dora to play a game. On each turn, one of the girls chooses any of the remaining vertices with value $\\texttt{?}$ and changes its value to $\\mathtt{0}$ or $\\mathtt{1}$, with Iris going first. The game continues until there are no vertices with value $\\mathtt{?}$ left in the tree. Iris aims to maximize the score of the tree, while Dora aims to minimize that.\n\nAssuming that both girls play optimally, please determine the final score of the tree.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 5\\cdot 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 10^5$)\u00a0\u2014 the number of vertices in the tree.\n\nThe following $n - 1$ lines each contain two integers $u$ and $v$ ($1 \\leq u, v \\leq n$)\u00a0\u2014 denoting an edge between vertices $u$ and $v$.\n\nIt's guaranteed that the given edges form a tree.\n\nThe last line contains a string $s$ of length $n$. The $i$-th character of $s$ represents the value of vertex $i$. It's guaranteed that $s$ only contains characters $\\mathtt{0}$, $\\mathtt{1}$ and $\\mathtt{?}$.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the final score of the tree.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n4\n\n1 2\n\n1 3\n\n4 1\n\n0101\n\n4\n\n1 2\n\n3 2\n\n2 4\n\n???0\n\n5\n\n1 2\n\n1 3\n\n2 4\n\n2 5\n\n?1?01\n\n6\n\n1 2\n\n2 3\n\n3 4\n\n5 3\n\n3 6\n\n?0????\n\n5\n\n1 2\n\n1 3\n\n1 4\n\n1 5\n\n11?1?\n\n2\n\n2 1\n\n??\n\n```\n\n#### Output #1\n\n```\n2\n1\n1\n2\n1\n0\n```\n\n### Note\n\nIn the first test case, all the values of the vertices have been determined. There are three different paths from the root to a leaf:\n\n- From vertex $1$ to vertex $2$. The string formed by the path is $\\mathtt{01}$, so the weight of the leaf is $0-1=-1$.\n- From vertex $1$ to vertex $3$. The string formed by the path is $\\mathtt{00}$, so the weight of the leaf is $0-0=0$.\n- From vertex $1$ to vertex $4$. The string formed by the path is $\\mathtt{01}$, so the weight of the leaf is $0-1=-1$.\n\nThus, there are two leaves with non-zero weight, so the score of the tree is $2$.\n\nIn the second test case, one of the sequences of optimal choices for the two players can be:\n\n- Iris chooses to change the value of the vertex $3$ to $\\mathtt 1$.\n- Dora chooses to change the value of the vertex $1$ to $\\mathtt 0$.\n- Iris chooses to change the value of the vertex $2$ to $\\mathtt 0$.\n\nThe final tree is as follows:\n\n![](https://espresso.codeforces.com/e0dfb0666ab640a4b73dd23d5176bbf71153cf68.png)\n\nThe only leaf with non-zero weight is $3$, so the score of the tree is $1$. Note that this may not be the only sequence of optimal choices for Iris and Dora.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n// #include <iostream>\nusing namespace std;\n\nvoid dfs(int i,int par,vector<vector<int>> &adj,vector<int>&leaf){\n  \n  for(auto &e:adj[i]){\n    if(e==par) continue;\n\n    if(adj[e].size()==1) leaf.push_back(e);\n    dfs(e,i,adj,leaf);\n  }\n}\nvoid solve(){\n  int n;\n  cin>>n;\n  vector<vector<int>> adj(n+1);\n\n  for(int i=0;i<n-1;i++){\n    int a,b;\n    cin>>a>>b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\nstring s;\ncin>>s;\n\nvector<int> leaf;\n\ndfs(1,-1,adj,leaf);\n\nint one=0,zero=0,t=0;\n\nfor(int i=0;i<leaf.size();i++){\n  // cout<<leaf[i]<<endl;\n  int j=leaf[i]-1;\nif(s[j]=='0')zero++;\nelse  if(s[j]=='1')one++;\nelse t++;\n}\n\nint total=0;\nfor(int i=1;i<n;i++){\n  if(s[i]=='?') total++;\n}\n\n// cout<<\"->\"<<one<<\" \"<<zero<<\" \"<<t<<endl;\nif(s[0]=='0'){\n  cout<<one+(t+1)/2<<endl;\n  return;\n}\n\nif(s[0]=='1'){\n  cout<<zero+(t+1)/2<<endl;\n  return;\n}\n\nif(zero>one){\n  cout<<zero+ (t)/2<<endl;\n  return;\n}\nif(zero<one){\n  cout<<one + (t)/2<<endl;\n  return;\n}\n\nif((total-t)%2==1)\n  cout<<one+ (t+1)/2<<endl;\nelse \ncout<<one+ (t)/2<<endl;\n\n  }\n  \n  int main(){\nios::sync_with_stdio(false);\ncin.tie(nullptr);\n\n  int t;\n  cin>>t;\n  while(t--){\n    solve();\n  }\n  \n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2005e2",
      "PROBLEM_ID": "2005E2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The differences between the two versions are the constraints on all the variables. You can make hacks only if both versions of the problem are solved.\n\nTsovak and Narek are playing a game. They have an array $a$ and a matrix $b$ of integers with $n$ rows and $m$ columns, numbered from $1$. The cell in the $i$-th row and the $j$-th column is $(i, j)$.\n\nThey are looking for the elements of $a$ in turns; Tsovak starts first. Each time a player looks for a cell in the matrix containing the current element of $a$ (Tsovak looks for the first, then Narek looks for the second, etc.). Let's say a player has chosen the cell $(r, c)$. The next player has to choose his cell in the submatrix starting at $(r + 1, c + 1)$ and ending in $(n, m)$ (the submatrix can be empty if $r=n$ or $c=m$). If a player cannot find such a cell (or the remaining submatrix is empty) or the array ends (the previous player has chosen the last element), then he loses.\n\nYour task is to determine the winner if the players play optimally.\n\nNote: since the input is large, you may need to optimize input/output for this problem.\n\nFor example, in C++, it is enough to use the following lines at the start of the main() function:\n\n```\n`int main() {<br/>    ios_base::sync_with_stdio(false);<br/>    cin.tie(NULL); cout.tie(NULL);<br/>}<br/>````\n\n### Input\n\nThe first line of the input contains $t$ ($1 \\le t \\le 1500$)\u00a0\u2013 the number of test cases.\n\nThe first line of each test case contains three integers $l$, $n$, and $m$ ($1 \\le l, n, m \\le 1500$)\u00a0\u2013 the size of the array and the sizes of the matrix.\n\nThe second line contains $l$ integers $a_1, a_2, a_3, \\ldots a_l$ ($1 \\le a_i \\le n \\cdot m$)\u00a0\u2013 the elements of the array $a$.\n\nThe $i$-th of the last $n$ lines contains $m$ integers $b_{i,1}, b_{i,2}, b_{i,3}, \\ldots b_{i,m}$ ($1 \\le b_{i,j} \\le n \\cdot m$)\u00a0\u2013 representing the $i$-th row of the matrix.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $3 \\cdot 10^6$.\n\nIt is guaranteed that the sum of $l$ over all test cases does not exceed $1500$.\n\n### Output\n\nYou should output $t$ lines, the $i$-th of them containing a character representing the answer of the $i$-th test case: \"T\" if Tsovak wins or \"N\", otherwise (without quotes).\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2 3\n\n1 2\n\n1 3 6\n\n4 6 2\n\n2 2 4\n\n1 2\n\n1 1 3 2\n\n4 2 5 1\n\n2 4 2\n\n1 2\n\n3 4\n\n5 6\n\n7 8\n\n8 8\n\n```\n\n#### Output #1\n\n```\nN\nT\nN\n```\n\n### Note\n\nIn the first example, Tsovak starts by looking for $1$. There is only one occurrence of $1$ at $(1,1)$, so he chooses it. Then Narek needs to look for $2$ in the submatrix of $(2, 2)$, which consists of just the last two elements: $6$ and $2$. He chooses $2$, and then Tsovak loses since the array has ended.\n\nIn the second example, Tsovak needs to choose $1$. There is a $1$ at the cell $(n,m)$, so he chooses that cell. Then, since the submatrix of $(n + 1, m + 1)$ is empty, Narek cannot find $2$, so he loses.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <cstdio>\n#include <cstring>\n\nvoid cmx(int &x,int y){if(x<y) x=y;}\n\nvoid re(int &x){\n\tx=0;int c=getchar();\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n}\n\nconst int N=1531;\n\nint a[N],p[N*N],g[N],mx[N][N];\n\nint main()\n{\n\tint T;re(T);while(T--){\n\t\tint l,n,m,x;re(l);re(n);re(m);int ul=l;\n\t\tfor(int i=1;i<=l;++i){\n\t\t\tre(a[i]);if(p[a[i]]) ul=i-1;\n\t\t\tif(i<=ul) p[a[i]]=i;\n\t\t}\n\t\tfor(int i=1;i<=n;++i) for(int j=1;j<=m;++j) re(x),cmx(mx[p[x]][i],j);\n\t\tfor(int k=ul;k;--k){\n\t\t\tfor(int i=1;i<=n;++i) g[i]=mx[k][i]+1>g[i+1]?mx[k][i]:0;\n\t\t\tfor(int i=n-1;i;--i) cmx(g[i],g[i+1]);\n\t\t}\n\t\tputs(g[1]?\"T\":\"N\");\n\t\tfor(int k=1;k<=ul;++k){\n\t\t\tp[a[k]]=0;for(int i=1;i<=n;++i) mx[k][i]=0;\n\t\t}\n\t\tmemset(g,0,sizeof(g));\n\t}\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2005e1",
      "PROBLEM_ID": "2005E1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The differences between the two versions are the constraints on all the variables. You can make hacks only if both versions of the problem are solved.\n\nTsovak and Narek are playing a game. They have an array $a$ and a matrix $b$ of integers with $n$ rows and $m$ columns, numbered from $1$. The cell in the $i$-th row and the $j$-th column is $(i, j)$.\n\nThey are looking for the elements of $a$ in turns; Tsovak starts first. Each time a player looks for a cell in the matrix containing the current element of $a$ (Tsovak looks for the first, then Narek looks for the second, etc.). Let's say a player has chosen the cell $(r, c)$. The next player has to choose his cell in the submatrix starting at $(r + 1, c + 1)$ and ending in $(n, m)$ (the submatrix can be empty if $r=n$ or $c=m$). If a player cannot find such a cell (or the remaining submatrix is empty) or the array ends (the previous player has chosen the last element), then he loses.\n\nYour task is to determine the winner if the players play optimally.\n\n### Input\n\nThe first line of the input contains $t$ ($1 \\le t \\le 300$)\u00a0\u2013 the number of test cases.\n\nThe first line of each test case contains three integers $l$, $n$, and $m$ ($1 \\le l, n, m \\le 300$)\u00a0\u2013 the size of the array and the sizes of the matrix.\n\nThe second line contains $l$ integers $a_1, a_2, a_3, \\ldots a_l$ ($1 \\le a_i \\le \\min(7, n \\cdot m)$)\u00a0\u2013 the elements of the array $a$.\n\nThe $i$-th of the last $n$ lines contains $m$ integers $b_{i,1}, b_{i,2}, b_{i,3}, \\ldots b_{i,m}$ ($1 \\le b_{i,j} \\le \\min(7, n \\cdot m)$)\u00a0\u2013 representing the $i$-th row of the matrix.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $10^5$.\n\nIt is guaranteed that the sum of $l$ over all test cases does not exceed $300$.\n\n### Output\n\nYou should output $t$ lines, the $i$-th of them containing a character representing the answer of the $i$-th test case: \"T\" if Tsovak wins or \"N\", otherwise (without quotes).\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2 3\n\n1 2\n\n1 3 5\n\n4 5 2\n\n2 2 4\n\n1 2\n\n1 1 3 2\n\n4 2 5 1\n\n2 4 2\n\n1 2\n\n3 4\n\n5 5\n\n5 5\n\n5 5\n\n```\n\n#### Output #1\n\n```\nN\nT\nN```\n\n### Note\n\nIn the first example, Tsovak starts by looking for $1$. There is only one occurrence of $1$ at $(1,1)$, so he chooses it. Then Narek needs to look for $2$ in the submatrix of $(2, 2)$, which consists of just the last two elements: $5$ and $2$. He chooses $2$, and then Tsovak loses since the array has ended.\n\nIn the second example, Tsovak needs to choose $1$. There is a $1$ at the cell $(n,m)$, so he chooses that cell. Then, since the submatrix of $(n + 1, m + 1)$ is empty, Narek cannot find $2$, so he loses.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <vector>\n\nusing namespace std;\n\nbool isWinning(int k, int r_start, int c_start, int l, int n, int m, const vector<int>& a, const vector<vector<int>>& b, vector<vector<vector<int>>>& memo) {\n    if (k > l) {\n        return false;\n    }\n    if (r_start > n || c_start > m) {\n        return false;\n    }\n    if (memo[k][r_start][c_start] != -1) {\n        return memo[k][r_start][c_start] == 1;\n    }\n\n    bool found_winning_move = false;\n    for (int r = r_start; r <= n; ++r) {\n        for (int c = c_start; c <= m; ++c) {\n            if (b[r - 1][c - 1] == a[k - 1]) {\n                if (!isWinning(k + 1, r + 1, c + 1, l, n, m, a, b, memo)) {\n                    found_winning_move = true;\n                    break;\n                }\n            }\n        }\n        if (found_winning_move) {\n            break;\n        }\n    }\n\n    memo[k][r_start][c_start] = found_winning_move ? 1 : 0;\n    return found_winning_move;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int l, n, m;\n        cin >> l >> n >> m;\n        vector<int> a(l);\n        for (int i = 0; i < l; ++i) {\n            cin >> a[i];\n        }\n        vector<vector<int>> b(n, vector<int>(m));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cin >> b[i][j];\n            }\n        }\n\n        vector<vector<vector<int>>> memo(l + 2, vector<vector<int>>(n + 2, vector<int>(m + 2, -1)));\n        if (isWinning(1, 1, 1, l, n, m, a, b, memo)) {\n            cout << \"T\" << endl;\n        } else {\n            cout << \"N\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2005c",
      "PROBLEM_ID": "2005C",
      "PROBLEM_STATEMENT": "Narek is too lazy to create the third problem of this contest. His friend Artur suggests that he should use ChatGPT. ChatGPT creates $n$ problems, each consisting of $m$ letters, so Narek has $n$ strings. To make the problem harder, he combines the problems by selecting some of the $n$ strings possibly none and concatenating them without altering their order. His chance of solving the problem is defined as $score_n - score_c$, where $score_n$ is Narek's score and $score_c$ is ChatGPT's score.\n\nNarek calculates $score_n$ by examining the selected string (he moves from left to right). He initially searches for the letter $\\texttt{\"n\"}$, followed by $\\texttt{\"a\"}$, $\\texttt{\"r\"}$, $\\texttt{\"e\"}$, and $\\texttt{\"k\"}$. Upon finding all occurrences of these letters, he increments $score_n$ by $5$ and resumes searching for $\\texttt{\"n\"}$ again (he doesn't go back, and he just continues from where he left off).\n\nAfter Narek finishes, ChatGPT scans through the array and increments $score_c$ by $1$ for each letter $\\texttt{\"n\"}$, $\\texttt{\"a\"}$, $\\texttt{\"r\"}$, $\\texttt{\"e\"}$, or $\\texttt{\"k\"}$ that Narek fails to utilize (note that if Narek fails to complete the last occurrence by finding all of the $5$ letters, then all of the letters he used are counted in ChatGPT's score $score_c$, and Narek doesn't get any points if he doesn't finish finding all the 5 letters).\n\nNarek aims to maximize the value of $score_n - score_c$ by selecting the most optimal subset of the initial strings.\n\n### Input\n\nIn the first line of the input, you're given a single integer $t$ ($1 \\le t \\le 10^5$), the number of test cases. Then the description of each test case follows.\n\nIn the first line of each test case, you're given two integers $n, m$ ($1 \\le n, m \\le 10^3$), the number of strings and the length of each string.\n\nIn the next $n$ lines, you're given $n$ strings, each having a length of $m$. The strings only contain lowercase letters of the English alphabet.\n\nThe sum of values of $n \\cdot m$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, output a single integer: the maximal possible value of $score_n - score_c$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n5 2\n\nnn\n\naa\n\nrr\n\nee\n\nkk\n\n1 5\n\nnarek\n\n1 4\n\nnare\n\n5 7\n\nnrrarek\n\nnrnekan\n\nuuuuuuu\n\nppppppp\n\nnkarekz\n\n```\n\n#### Output #1\n\n```\n0\n5\n0\n7\n```\n\n### Note\n\nIn the first test case, one of the optimal answers is when Narek doesn't choose any of the strings, so the answer is $0$. He can alternatively choose all the strings. In this case, the full string becomes \"nnaarreekk\". Narek can choose the first appearances of all letters and add $5$ to the score. His opponent will add $1$ for all second appearances, which will be $5$ in total. So the answer will be $5 - 5 = 0$.\n\nIn the third test case, the only optimal answer is when Narek doesn't choose the string. Note that if he were to choose the string, he wouldn't be able to find the last letter \"k\", so his score would stay at $0$ instead of becoming $5$. Then ChatGPT would add $4$ for all of the $4$ letters, and the answer would become $0 - 4 = -4$.\n\nIn the last test case, Narek needs to choose the first and the last strings. After putting these two next to each other, he gets \"${\\color{red}{n}}rr{\\color{red}{a}}{\\color{red}{r}}{\\color{red}{e}}{\\color{red}{k}}{\\color{red}{n}}k{\\color{red}{a}}{\\color{red}{r}}{\\color{red}{e}}{\\color{red}{k}}{\\color{blue}{z}}$\". Narek can choose the letters marked with red and add $10$ to his score. Since the black colored letters Narek left behind are eligible for the opponent to claim (they are used in the word \"narek\"), the opponent adds all other letters to the score and gets a score of $3$. Therefore, the answer is $10 - 3 = 7$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Use long long for scores as they can potentially exceed the range of a 32-bit integer.\ntypedef long long ll;\n\n// Define a constant representing negative infinity. \n// It should be smaller than any possible score. The minimum possible score is -N*M, which is at most -10^6.\n// -1e18 is a safe choice for negative infinity.\nconst ll INF = -1e18; \n// The target sequence Narek searches for.\nconst string TARGET = \"narek\";\n\n/**\n * @brief Processes a string to find occurrences of the TARGET sequence subsequence.\n * \n * Starts searching from a given state (index in TARGET) and finds occurrences greedily.\n * Updates the state and counts completed sequences.\n * \n * @param s The string to process.\n * @param start_state The initial state, representing the index of the character in TARGET Narek is currently looking for (0 for 'n', 1 for 'a', ..., 4 for 'k').\n * @return A pair: {final_state, delta_k}, where final_state is the state after processing the entire string,\n *         and delta_k is the number of complete \"narek\" sequences found within this string starting from the given state.\n */\npair<int, int> process(const string& s, int start_state) {\n    int current_state = start_state; // The index of the character in TARGET Narek is currently looking for.\n    int delta_k = 0; // Counter for complete sequences found in this string segment.\n    \n    // Iterate through each character of the string.\n    for (char c : s) {\n        // Check if the character matches the one Narek is currently searching for.\n        // The check `current_state < 5` ensures we only match if we are not already past 'k'.\n        // Since TARGET has length 5, indices are 0 to 4.\n        if (current_state < 5 && c == TARGET[current_state]) {\n            current_state++; // Match found, advance to look for the next character in TARGET.\n            if (current_state == 5) { // Found 'k', which completes the sequence \"narek\".\n                delta_k++; // Increment the count of completed sequences.\n                current_state = 0; // Reset the state to look for 'n' again for the next sequence.\n            }\n        }\n    }\n    // Return the final state and the number of sequences completed.\n    return {current_state, delta_k};\n}\n\n/**\n * @brief Counts the number of characters in a string that are part of the set {'n', 'a', 'r', 'e', 'k'}.\n * \n * These characters are relevant because they contribute to Narek's score if used in a full sequence,\n * or to ChatGPT's score if unused or used in an incomplete sequence.\n * \n * @param s The string to count characters in.\n * @return The total count of 'n', 'a', 'r', 'e', 'k' characters in the string.\n */\nint count_chars(const string& s) {\n    int count = 0;\n    for (char c : s) {\n        if (c == 'n' || c == 'a' || c == 'r' || c == 'e' || c == 'k') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    // Optimize standard I/O operations for speed.\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases.\n    cin >> t;\n    while (t--) {\n        int n; // Number of strings provided by ChatGPT.\n        int m; // Length of each string.\n        cin >> n >> m;\n        vector<string> s(n); // Vector to store the n strings.\n        \n        // Precompute the count of relevant characters ('n','a','r','e','k') for each string.\n        // This count (`delta_N_chars[i]`) is needed to calculate score contribution.\n        vector<int> delta_N_chars(n); \n        \n        // Precompute state transitions and number of completed sequences (`delta_k`) for each string `s[i]`\n        // and each possible starting state `j` (0 to 4).\n        // `info[i][j]` stores the pair `{end_state, delta_k}`.\n        vector<vector<pair<int, int>>> info(n, vector<pair<int, int>>(5));\n\n        // Read input strings and perform precomputations.\n        for (int i = 0; i < n; ++i) {\n            cin >> s[i];\n            delta_N_chars[i] = count_chars(s[i]);\n            for (int j = 0; j < 5; ++j) { // Iterate through all possible start states (0-4).\n                info[i][j] = process(s[i], j);\n            }\n        }\n\n        // Dynamic Programming state: `M[j]` stores the maximum score (`score_n - score_c`) achievable\n        // for any subsequence of strings considered so far, ending in state `j` (Narek looking for TARGET[j]).\n        vector<ll> M(5, INF); \n        M[0] = 0; // Base case: Before considering any strings, the state is 0 (looking for 'n'), and the score is 0.\n        \n        // Variable to keep track of the maximum score found overall across all possible subsequences and ending states.\n        // Initialize to 0, representing the score for selecting an empty subset of strings.\n        ll max_overall_score = 0;\n\n        // Iterate through each string `s[i]` from 0 to n-1.\n        for (int i = 0; i < n; ++i) {\n            // Temporary DP table `current_dp[j]` stores the maximum score achievable by a subsequence *ending specifically with* string `s[i]`,\n            // resulting in state `j`. Initialize with negative infinity.\n            vector<ll> current_dp(5, INF); \n            \n            // Iterate through all possible previous states `j_prev` (0 to 4).\n            for (int j_prev = 0; j_prev < 5; ++j_prev) {\n                // Check if state `j_prev` was reachable (i.e., `M[j_prev]` is not negative infinity).\n                // If `M[j_prev]` is INF, it means no valid subsequence ended in state `j_prev` before considering `s[i]`.\n                if (M[j_prev] > INF) { \n                    // Retrieve the precomputed transition result for string `s[i]` starting from state `j_prev`.\n                    pair<int, int> result = info[i][j_prev];\n                    int j_end = result.first; // The state Narek ends in after processing `s[i]`.\n                    int delta_k = result.second; // The number of full \"narek\" sequences completed within `s[i]`.\n                    \n                    // Calculate the score contribution of string `s[i]` for this transition.\n                    // The overall score is `10*k - N_chars`. The change in score by adding `s[i]` is `10*delta_k - delta_N_chars[i]`.\n                    ll score_contrib = 10LL * delta_k - delta_N_chars[i];\n                    \n                    // Update the temporary DP table `current_dp`. If the path through `s[i]` provides a better score\n                    // to reach state `j_end`, update `current_dp[j_end]`.\n                    current_dp[j_end] = max(current_dp[j_end], M[j_prev] + score_contrib);\n                }\n            }\n\n            // Update the main DP state `M`. `M[j]` represents the maximum score ending in state `j`\n            // considering all subsequences using strings from `s[0]` to `s[i]`.\n            // This step merges the best scores ending *before* `s[i]` (already stored in M)\n            // with the best scores ending *at* `s[i]` (computed in `current_dp`).\n            for (int j = 0; j < 5; ++j) {\n                 if (current_dp[j] > INF) { // Check if `current_dp[j]` holds a valid score (not negative infinity).\n                     M[j] = max(M[j], current_dp[j]);\n                 }\n            }\n             \n            // Update the overall maximum score encountered so far. The maximum score could be achieved\n            // after processing any string `s[i]` and ending in any state `j`.\n            for(int j = 0; j < 5; ++j) {\n                 if (M[j] > INF) { // Check if state `j` is reachable with a non-infinite score.\n                     max_overall_score = max(max_overall_score, M[j]);\n                 }\n             }\n             // Note: `max_overall_score` is initialized to 0. If all subsequences result in negative scores,\n             // the final answer will remain 0, correctly representing the choice of picking no strings.\n        }\n\n        // Output the maximum possible score Narek can achieve.\n        cout << max_overall_score << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2005b2",
      "PROBLEM_ID": "2005B2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The only differences between the two versions are the constraints on $m$ and $q$. In this version, $m, q \\le 10^5$. You can make hacks only if both versions of the problem are solved.\n\nNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David's homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now $m$ teachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\n\nThe classroom can be represented as a one-dimensional line with cells from $1$ to $n$, inclusive.\n\nAt the start, all $m$ teachers and David are in distinct cells. Then they make moves. During each move\n\n- David goes to an adjacent cell or stays at the current one.\n- Then, each of the $m$ teachers simultaneously goes to an adjacent cell or stays at the current one.\n\nThis continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others' moves, so they all act optimally.\n\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\n\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\n\nAlso, as Narek and Tsovak think this task is easy, they decided to give you $q$ queries on David's position.\n\n### Input\n\nIn the first line of the input, you are given a single integer $t$ ($1 \\le t \\le 10^5$)\u00a0\u2014 the number of test cases. The description of each test case follows.\n\nIn the first line of each test case, you are given three integers $n$, $m$, and $q$ ($3 \\le n \\le 10^9$, $1 \\le m, q \\le 10^5$)\u00a0\u2014 the number of cells on the line, the number of teachers, and the number of queries.\n\nIn the second line of each test case, you are given $m$ distinct integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le n$)\u00a0\u2014 the cell numbers of the teachers.\n\nIn the third line of each test case, you are given $q$ integers $a_1, a_2, \\ldots, a_q$ ($1 \\le a_i \\le n$)\u00a0\u2014 David's cell number for every query.\n\nIt is guaranteed that for any $i$, $j$ such that $1 \\le i \\le m$ and $1 \\le j \\le q$, $b_i \\neq a_j$.\n\nIt is guaranteed that the sum of values of $m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nIt is guaranteed that the sum of values of $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output $q$ lines, the $i$-th of them containing the answer of the $i$-th query.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n8 1 1\n\n6\n\n3\n\n10 3 3\n\n1 4 8\n\n2 3 10\n\n```\n\n#### Output #1\n\n```\n5\n1\n1\n2\n```\n\n### Note\n\nIn the only query of the first example, the student can run to cell $1$. It will take the teacher five moves to reach from cell $6$ to cell $1$, so the answer is $5$.\n\nIn the second query of the second example, the student can just stay at cell $3$. The teacher, initially located in cell $4$, can reach cell $3$ in one move. Therefore, the answer is $1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+10;\nint t,n,m,q,pos,a[N];\nvoid solve(){\n    cin>>n>>m>>q;\n    for(int i=1;i<=m;i++) cin>>a[i];\n    sort(a+1,a+m+1);\n    while(q--){\n        cin>>pos;\n        if(pos<a[1])cout<<a[1]-1<<endl;\n        else if(pos>a[m]) cout<<n-a[m]<<endl;\n        else{\n            int idx =lower_bound(a+1,a+m+1,pos)-a;\n            cout<<(a[idx]-a[idx-1])/2<<endl;\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>t;\n    while(t--) solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2005b1",
      "PROBLEM_ID": "2005B1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The only differences between the two versions are the constraints on $m$ and $q$. In this version, $m=2$ and $q=1$. You can make hacks only if both versions of the problem are solved.\n\nNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David's homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now $m$ teachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\n\nThe classroom can be represented as a one-dimensional line with cells from $1$ to $n$, inclusive.\n\nAt the start, all $m$ teachers and David are in distinct cells. Then they make moves. During each move\n\n- David goes to an adjacent cell or stays at the current one.\n- Then, each of the $m$ teachers simultaneously goes to an adjacent cell or stays at the current one.\n\nThis continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others' moves, so they all act optimally.\n\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\n\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\n\nAlso, as Narek and Tsovak think this task is easy, they decided to give you $q$ queries on David's position. Note: this is the easy version, and you are given only one query.\n\n### Input\n\nIn the first line of the input, you are given a single integer $t$ ($1 \\le t \\le 10^5$)\u00a0\u2014 the number of test cases. The description of each test case follows.\n\nIn the first line of each test case, you are given three integers $n$, $m$, and $q$ ($3 \\le n \\le 10^9$, $m=2$, $q=1$)\u00a0\u2014 the number of cells on the line, the number of teachers, and the number of queries.\n\nIn the second line of each test case, you are given $m$ distinct integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le n$)\u00a0\u2014 the cell numbers of the teachers.\n\nIn the third line of each test case, you are given $q$ integers $a_1, a_2, \\ldots, a_q$ ($1 \\le a_i \\le n$)\u00a0\u2014 David's cell number for every query.\n\nIt is guaranteed that for any $i$, $j$ such that $1 \\le i \\le m$ and $1 \\le j \\le q$, $b_i \\neq a_j$.\n\n### Output\n\nFor each test case, output $q$ lines, the $i$-th of them containing the answer of the $i$-th query.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n10 2 1\n\n1 4\n\n2\n\n8 2 1\n\n3 6\n\n1\n\n8 2 1\n\n3 6\n\n8\n\n```\n\n#### Output #1\n\n```\n1\n2\n2\n```\n\n### Note\n\nIn the first example, the student can just stay at cell $2$. The teacher, initially located in cell $1$, can reach cell $2$ in one move. Therefore, the answer is $1$.\n\nIn the second example, the student should just stay at cell $1$. The teacher, initially located in cell $3$, can reach cell $1$ in two moves. Therefore, the answer is $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Use long long for potentially large coordinates and time k\ntypedef long long ll;\n\n// The function `can_catch` checks if the teachers can guarantee catching David within k moves.\n// This is true if and only if every cell David can possibly reach after k moves is also reachable by at least one teacher within k moves.\n// Mathematically, let D_k be the set of cells David can reach in k moves, and T_{i,k} be the set for teacher i.\n// The condition is D_k subset of (T_{1,k} U T_{2,k}).\n// This is equivalent to checking if D_k has any intersection with the regions *not* covered by T_{1,k} U T_{2,k}.\n// If there is no intersection, D_k is fully covered, and teachers can guarantee a catch.\nbool can_catch(ll n, ll a, ll b1, ll b2, ll k) {\n    // David's reachable interval [LD, RD] after k moves.\n    // A cell x is reachable by David if |x - a| <= k and 1 <= x <= n.\n    // This forms the interval [max(1, a-k), min(n, a+k)].\n    ll LD = max(1LL, a - k);\n    ll RD = min(n, a + k);\n    // If LD > RD, it means the interval is empty. This can happen if a-k > n or a+k < 1.\n    // Given 1 <= a <= n and k >= 0, this interval is always valid unless k is extremely large,\n    // but even then max(1, negative) is 1, and min(n, large positive) is n.\n    // So LD <= RD should always hold for non-negative k.\n\n    // Teacher 1's reachable interval [L1, R1] after k moves.\n    ll L1 = max(1LL, b1 - k);\n    ll R1 = min(n, b1 + k);\n    // If L1 > R1, teacher 1's reachable set is empty. This might happen if b1-k > n or b1+k < 1.\n    // With 1 <= b1 <= n and k >= 0, this range should be valid.\n\n    // Teacher 2's reachable interval [L2, R2] after k moves.\n    ll L2 = max(1LL, b2 - k);\n    ll R2 = min(n, b2 + k);\n    // Similar validity considerations apply for T2's interval.\n\n    // The regions potentially not covered by the union T_{1,k} U T_{2,k} within [1, n] are:\n    // 1. Region to the left of T1_k: interval [1, L1-1]\n    // 2. Region potentially between T1_k and T2_k: interval [R1+1, L2-1]. This exists only if R1+1 <= L2-1.\n    // 3. Region to the right of T2_k: interval [R2+1, n]\n    // Note: Since b1 < b2, usually L1 <= L2 and R1 <= R2, but large k or boundary effects can change this.\n    // However, the structure of intervals ensures that the union covers cells from L1 to R1 and L2 to R2.\n    // The logic below checks for intersection of D_k with these potentially uncovered regions.\n\n    // Check if David's interval D_k = [LD, RD] intersects with the potentially uncovered region [1, L1-1].\n    ll uncovered_start1 = 1;\n    ll uncovered_end1 = L1 - 1;\n    // Check if the region [1, L1-1] is valid (non-empty)\n    if (uncovered_start1 <= uncovered_end1) { \n         // Check intersection of [LD, RD] and [uncovered_start1, uncovered_end1]\n         // Intersection is non-empty if max(LD, uncovered_start1) <= min(RD, uncovered_end1)\n         ll intersect_start1 = max(LD, uncovered_start1);\n         ll intersect_end1 = min(RD, uncovered_end1);\n         if (intersect_start1 <= intersect_end1) {\n             // If there's an intersection, David can reach a cell not covered by T1 or T2 from the left.\n             return false; \n         }\n    }\n\n    // Check if David's interval D_k intersects with the potentially uncovered gap region [R1+1, L2-1].\n    ll gap_start = R1 + 1;\n    ll gap_end = L2 - 1;\n    // Check if the gap region [R1+1, L2-1] is valid (non-empty)\n    if (gap_start <= gap_end) {\n        // Check intersection of [LD, RD] and [gap_start, gap_end].\n        ll intersect_start2 = max(LD, gap_start);\n        ll intersect_end2 = min(RD, gap_end);\n        if (intersect_start2 <= intersect_end2) {\n            // If there's an intersection, David can reach a cell in the gap between T1 and T2.\n            return false; \n        }\n    }\n    \n    // Check if David's interval D_k intersects with the potentially uncovered region [R2+1, n].\n    ll uncovered_start3 = R2 + 1;\n    ll uncovered_end3 = n;\n    // Check if the region [R2+1, n] is valid (non-empty)\n     if (uncovered_start3 <= uncovered_end3) { \n         // Check intersection of [LD, RD] and [uncovered_start3, uncovered_end3]\n         ll intersect_start3 = max(LD, uncovered_start3);\n         ll intersect_end3 = min(RD, uncovered_end3);\n         if (intersect_start3 <= intersect_end3) {\n              // If there's an intersection, David can reach a cell not covered by T1 or T2 from the right.\n              return false;\n         }\n    }\n\n    // If D_k does not intersect with any potentially uncovered region, it means D_k must be fully contained within T1_k U T2_k.\n    // This means for any cell David could reach, at least one teacher could also reach it.\n    // Thus, the teachers can coordinate to guarantee a catch by time k.\n    return true;\n}\n\nint main() {\n    // Faster I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        ll n; // Number of cells\n        int m; // Number of teachers (m=2 in easy version)\n        int q; // Number of queries (q=1 in easy version)\n        cin >> n >> m >> q;\n        vector<ll> b(m); // Teacher positions\n        for (int i = 0; i < m; ++i) {\n            cin >> b[i];\n        }\n        // Sort teacher positions to ensure b[0] is the leftmost teacher (b1) and b[1] is the rightmost (b2).\n        // This simplifies interval analysis.\n        sort(b.begin(), b.end()); \n        ll b1 = b[0];\n        ll b2 = b[1];\n\n        // Process each query (only 1 query in easy version)\n        for (int i = 0; i < q; ++i) {\n            ll a; // David's starting position\n            cin >> a;\n\n            // Binary search for the minimum time k required for teachers to guarantee catching David.\n            // The minimum time k can be from 0 to n.\n            ll low = 0, high = n, ans = n; \n            \n            while (low <= high) {\n                // Calculate midpoint carefully to avoid overflow\n                ll mid = low + (high - low) / 2; \n                if (can_catch(n, a, b1, b2, mid)) {\n                    // If teachers can catch David in 'mid' moves, this is a possible answer.\n                    // Try to find an even smaller time.\n                    ans = mid;\n                    high = mid - 1; \n                } else {\n                    // If teachers cannot catch David in 'mid' moves, they need more time.\n                    low = mid + 1; \n                }\n            }\n            // Output the minimum time found.\n            cout << ans << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2005a",
      "PROBLEM_ID": "2005A",
      "PROBLEM_STATEMENT": "Narek has to spend 2 hours with some 2-year-old kids at the kindergarten. He wants to teach them competitive programming, and their first lesson is about palindromes.\n\nNarek found out that the kids only know the vowels of the English alphabet (the letters $\\mathtt{a}$, $\\mathtt{e}$, $\\mathtt{i}$, $\\mathtt{o}$, and $\\mathtt{u}$), so Narek needs to make a string that consists of vowels only. After making the string, he'll ask the kids to count the number of subsequences that are palindromes. Narek wants to keep it simple, so he's looking for a string such that the amount of palindrome subsequences is minimal.\n\nHelp Narek find a string of length $n$, consisting of lowercase English vowels only (letters $\\mathtt{a}$, $\\mathtt{e}$, $\\mathtt{i}$, $\\mathtt{o}$, and $\\mathtt{u}$), which minimizes the amount of palindrome$^{\\dagger}$ subsequences$^{\\ddagger}$ in it.\n\n$^{\\dagger}$ A string is called a palindrome if it reads the same from left to right and from right to left.\n\n$^{\\ddagger}$ String $t$ is a subsequence of string $s$ if $t$ can be obtained from $s$ by removing several (possibly, zero or all) characters from $s$ and concatenating the remaining ones, without changing their order. For example, $\\mathtt{odocs}$ is a subsequence of $\\texttt{c}{\\color{red}{\\texttt{od}}}\\texttt{ef}{\\color{red}{\\texttt{o}}}\\texttt{r}{\\color{red}{\\texttt{c}}}\\texttt{e}{\\color{red}{\\texttt{s}}}$.\n\n### Input\n\nThe first line of the input contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases. Subsequently, the description of each test case follows.\n\nThe only line of each test case contains a single integer $n$ ($1 \\le n \\le 100$)\u00a0\u2014 the size of the string.\n\n### Output\n\nFor each test case, output any string of length $n$ that satisfies the above conditions.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2\n\n3\n\n6\n\n```\n\n#### Output #1\n\n```\nuo\niae\noeiiua\n```\n\n### Note\n\nIn the first example, $\\texttt{uo}$ has only three palindrome subsequences: $\\texttt{u}$, $\\texttt{o}$, and the empty string. It can be shown that there is no better answer.\n\nIn the third example, $\\texttt{oeiiua}$ has only eight palindrome subsequences: $\\texttt{o}$, $\\texttt{e}$, $\\texttt{i}$, $\\texttt{i}$, $\\texttt{u}$, $\\texttt{a}$, $\\texttt{ii}$, and the empty string. It can be shown that there is no better answer.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring minimizePalindromes(int n) {\n    const char vowels[5] = {'a', 'e', 'i', 'o', 'u'};\n    \n    if (n <= 5) {\n        // For n \u2264 5, use n distinct vowels\n        string result = \"\";\n        for (int i = 0; i < n; i++) {\n            result += vowels[i];\n        }\n        return result;\n    }\n    \n    // For n > 5, distribute vowels evenly with consecutive repetitions\n    int vowelCount[5] = {1, 1, 1, 1, 1};  // Start with 1 of each vowel\n    int remaining = n - 5;\n    \n    // Distribute remaining positions\n    for (int i = 0; i < remaining; i++) {\n        vowelCount[i % 5]++;\n    }\n    \n    // Build the string with consecutive repetitions\n    string result = \"\";\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < vowelCount[i]; j++) {\n            result += vowels[i];\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        cout << minimizePalindromes(n) << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2004d",
      "PROBLEM_ID": "2004D",
      "PROBLEM_STATEMENT": "There are $n$ cities located on a straight line. The cities are numbered from $1$ to $n$.\n\nPortals are used to move between cities. There are $4$ colors of portals: blue, green, red, and yellow. Each city has portals of two different colors. You can move from city $i$ to city $j$ if they have portals of the same color (for example, you can move between a \"blue-red\" city and a \"blue-green\" city). This movement costs $|i-j|$ coins.\n\nYour task is to answer $q$ independent queries: calculate the minimum cost to move from city $x$ to city $y$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of cities and the number of queries, respectively.\n\nThe second line contains $n$ strings of the following types: BG, BR, BY, GR, GY, or RY; the $i$-th of them describes the portals located in the $i$-th city; the symbol B indicates that there is a blue portal in the city, G\u00a0\u2014 green, R\u00a0\u2014 red, and Y\u00a0\u2014 yellow.\n\nThe $j$-th of the next $q$ lines contains two integers $x_j$ and $y_j$ ($1 \\le x_j, y_j \\le n$)\u00a0\u2014 the description of the $j$-th query.\n\nAdditional constraints on the input:\n\n- the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$;\n- the sum of $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each query, print a single integer\u00a0\u2014 the minimum cost to move from city $x$ to city $y$ (or $-1$ if it is impossible).\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n4 5\n\nBR BR GY GR\n\n1 2\n\n3 1\n\n4 4\n\n1 4\n\n4 2\n\n2 1\n\nBG RY\n\n1 2\n\n```\n\n#### Output #1\n\n```\n1\n4\n0\n3\n2\n-1\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n#define\tll long long\nusing namespace std;\nint a[200020];\nset<int> s[16];\nchar f[300];\nint main(){\n\tint t;cin>>t;\n    f['B']=1;//0001\n\tf['R']=2;//0010\n\tf['G']=4;//0100\n\tf['Y']=8;//1000    3 5 9 6 10 14\n    while(t--){\n        int n,k;cin>>n>>k;\n        memset(a,0,sizeof a);\n        for(int i=0;i<16;i++) s[i].clear();\n        for(int i=1;i<=n;i++){\n            string str;cin>>str;\n            a[i]=f[str[0]]|f[str[1]];\n            s[a[i]].insert(i);\n        }\n        for(int i=1;i<=k;i++){\n            int x,y;cin>>x>>y;\n            if(x>y) swap(x,y);\n            int ans=2e9;\n            if(x==y) {ans=0;}\n            for(int i=1;i<16;i++){\n                if(a[x]&(i) && a[y]&(i)){\n                  auto it=s[i].upper_bound(x);\n                  if(it!=s[i].end()) {\n                     ans=min(ans,abs(*it-x)+abs(*it-y));\n                  }\n                  if(it!=s[i].begin()) it--,ans=min(ans,y-*it+x-*it);\n                }\n            }\n            cout<< (ans==2e9 ? -1 :ans)<<endl;\n        }\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2004c",
      "PROBLEM_ID": "2004C",
      "PROBLEM_STATEMENT": "Alice and Bob have $n$ items they'd like to split between them, so they decided to play a game. All items have a cost, and the $i$-th item costs $a_i$. Players move in turns starting from Alice.\n\nIn each turn, the player chooses one of the remaining items and takes it. The game goes on until no items are left.\n\nLet's say that $A$ is the total cost of items taken by Alice and $B$ is the total cost of Bob's items. The resulting score of the game then will be equal to $A - B$.\n\nAlice wants to maximize the score, while Bob wants to minimize it. Both Alice and Bob will play optimally.\n\nBut the game will take place tomorrow, so today Bob can modify the costs a little. He can increase the costs $a_i$ of several (possibly none or all) items by an integer value (possibly, by the same value or by different values for each item). However, the total increase must be less than or equal to $k$. Otherwise, Alice may suspect something. Note that Bob can't decrease costs, only increase.\n\nWhat is the minimum possible score Bob can achieve?\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 5000$)\u00a0\u2014 the number of test cases. Then $t$ cases follow.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2 \\le n \\le 2 \\cdot 10^5$; $0 \\le k \\le 10^9$)\u00a0\u2014 the number of items and the maximum total increase Bob can make.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the initial costs of the items.\n\nIt's guaranteed that the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the minimum possible score $A - B$ after Bob increases the costs of several (possibly none or all) items.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2 5\n\n1 10\n\n3 0\n\n10 15 12\n\n4 6\n\n3 1 2 4\n\n2 4\n\n6 9\n\n```\n\n#### Output #1\n\n```\n4\n13\n0\n0\n```\n\n### Note\n\nIn the first test case, Bob can increase $a_1$ by $5$, making costs equal to $[6, 10]$. Tomorrow, Alice will take $10$ and Bob will take $6$. The total score will be equal to $10 - 6 = 4$, and it's the minimum possible.\n\nIn the second test case, Bob can't change costs. So the score will be equal to $(15 + 10) - 12 = 13$, since Alice will take $15$, Bob will take $12$, and Alice\u00a0\u2014 $10$.\n\nIn the third test case, Bob, for example, can increase $a_1$ by $1$, $a_2$ by $3$, and $a_3$ by $2$. The total change is equal to $1 + 3 + 2 \\le 6$ and costs will be equal to $[4, 4, 4, 4]$. Obviously, the score will be equal to $(4 + 4) - (4 + 4) = 0$.\n\nIn the fourth test case, Bob can increase $a_1$ by $3$, making costs equal to $[9, 9]$. The score will be equal to $9 - 9 = 0$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint solve() {\n    int n;\n    long long k;\n    cin >> n >> k;\n    vector<long long> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    sort(a.rbegin(), a.rend());\n    for (int i = 0; i < n / 2; ++i) {\n        long long diff = a[2 * i] - a[2 * i + 1];\n        if (diff > 0 && k > 0) {\n            long long increase = min(diff, k);\n            a[2 * i + 1] += increase;\n            k -= increase;\n            if (k == 0) {\n                break;\n            }\n        }\n    }\n    long long score = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            score += a[i];\n        } else {\n            score -= a[i];\n        }\n    }\n    return score;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        cout << solve() << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2004b",
      "PROBLEM_ID": "2004B",
      "PROBLEM_STATEMENT": "There are $100$ rooms arranged in a row and $99$ doors between them; the $i$-th door connects rooms $i$ and $i+1$. Each door can be either locked or unlocked. Initially, all doors are unlocked.\n\nWe say that room $x$ is reachable from room $y$ if all doors between them are unlocked.\n\nYou know that:\n\n- Alice is in some room from the segment $[l, r]$;\n- Bob is in some room from the segment $[L, R]$;\n- Alice and Bob are in different rooms.\n\nHowever, you don't know the exact rooms they are in.\n\nYou don't want Alice and Bob to be able to reach each other, so you are going to lock some doors to prevent that. What's the smallest number of doors you have to lock so that Alice and Bob cannot meet, regardless of their starting positions inside the given segments?\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $l$ and $r$ ($1 \\le l < r \\le 100$)\u00a0\u2014 the bounds of the segment of rooms where Alice is located.\n\nThe second line of each test case contains two integers $L$ and $R$ ($1 \\le L < R \\le 100$) \u2014 the bounds of the segment of rooms where Bob is located.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the smallest number of doors you have to lock so that Alice and Bob cannot meet, regardless of their starting positions inside the given segments.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1 2\n\n3 4\n\n2 5\n\n2 5\n\n3 7\n\n6 7\n\n4 5\n\n2 8\n\n```\n\n#### Output #1\n\n```\n1\n3\n2\n3\n```\n\n### Note\n\nIn the first test case, it is sufficient to lock the door between rooms $2$ and $3$.\n\nIn the second test case, the following doors have to be locked: $(2,3)$, $(3,4)$, $(4,5)$.\n\nIn the third test case, the following doors have to be locked: $(5, 6)$ and $(6,7)$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\nusing namespace std;\n\nint solve(int l, int r, int L, int R) {\n    int a = max(l, L);\n    int b = min(r, R);\n    \n    if (a > b) {\n        // Segments are disjoint\n        return 1; // Just lock one door between segments\n    } else {\n        // Segments overlap\n        int doors_to_lock = (b - a); // Doors within the overlap\n        \n        // Check if we need to lock a door to the left of the overlap\n        if (min(l, L) < a) {\n            doors_to_lock++;\n        }\n        \n        // Check if we need to lock a door to the right of the overlap\n        if (b < max(r, R)) {\n            doors_to_lock++;\n        }\n        \n        return doors_to_lock;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int l, r, L, R;\n        cin >> l >> r;\n        cin >> L >> R;\n        \n        cout << solve(l, r, L, R) << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2004a",
      "PROBLEM_ID": "2004A",
      "PROBLEM_STATEMENT": "Consider a set of points on a line. The distance between two points $i$ and $j$ is $|i - j|$.\n\nThe point $i$ from the set is the closest to the point $j$ from the set, if there is no other point $k$ in the set such that the distance from $j$ to $k$ is strictly less than the distance from $j$ to $i$. In other words, all other points from the set have distance to $j$ greater or equal to $|i - j|$.\n\nFor example, consider a set of points $\\{1, 3, 5, 8\\}$:\n\n- for the point $1$, the closest point is $3$ (other points have distance greater than $|1-3| = 2$);\n- for the point $3$, there are two closest points: $1$ and $5$;\n- for the point $5$, the closest point is $3$ (but not $8$, since its distance is greater than $|3-5|$);\n- for the point $8$, the closest point is $5$.\n\nYou are given a set of points. You have to add an integer point into this set in such a way that it is different from every existing point in the set, and it becomes the closest point to every point in the set. Is it possible?\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n- the first line contains one integer $n$ ($2 \\le n \\le 40$) \u2014 the number of points in the set;\n- the second line contains $n$ integers $x_1, x_2, \\dots, x_n$ ($1 \\le x_1 < x_2 < \\dots < x_n \\le 100$) \u2014 the points from the set.\n\n### Output\n\nFor each test case, print YES if it is possible to add a new point according to the conditions from the statement. Otherwise, print NO.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2\n\n3 8\n\n2\n\n5 6\n\n6\n\n1 2 3 4 5 10\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nNO\n```\n\n### Note\n\nIn the first example, the point $7$ will be the closest to both $3$ and $8$.\n\nIn the second example, it is impossible to add an integer point so that it becomes the closest to both $5$ and $6$, and is different from both of them.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\nbool solve() {\n    int n;\n    cin >> n;\n    vector<int> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i];\n    }\n    if (n < 2) return false;\n\n    vector<int> d(n);\n    d[0] = x[1] - x[0];\n    d[n - 1] = x[n - 1] - x[n - 2];\n    for (int i = 1; i < n - 1; ++i) {\n        d[i] = min(x[i] - x[i - 1], x[i + 1] - x[i]);\n    }\n\n    int max_l = -200;\n    int min_r = 201;\n\n    for (int i = 0; i < n; ++i) {\n        max_l = max(max_l, x[i] - d[i]);\n        min_r = min(min_r, x[i] + d[i]);\n    }\n\n    if (max_l > min_r) {\n        return false;\n    }\n\n    set<int> s_points;\n    for (int val : x) {\n        s_points.insert(val);\n    }\n\n    for (int p = max_l; p <= min_r; ++p) {\n        if (s_points.find(p) == s_points.end()) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        if (solve()) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2003f",
      "PROBLEM_ID": "2003F",
      "PROBLEM_STATEMENT": "Piggy gives Turtle three sequences $a_1, a_2, \\ldots, a_n$, $b_1, b_2, \\ldots, b_n$, and $c_1, c_2, \\ldots, c_n$.\n\nTurtle will choose a subsequence of $1, 2, \\ldots, n$ of length $m$, let it be $p_1, p_2, \\ldots, p_m$. The subsequence should satisfy the following conditions:\n\n- $a_{p_1} \\le a_{p_2} \\le \\cdots \\le a_{p_m}$;\n- All $b_{p_i}$ for all indices $i$ are pairwise distinct, i.e., there don't exist two different indices $i$, $j$ such that $b_{p_i} = b_{p_j}$.\n\nHelp him find the maximum value of $\\sum\\limits_{i = 1}^m c_{p_i}$, or tell him that it is impossible to choose a subsequence of length $m$ that satisfies the conditions above.\n\nRecall that a sequence $a$ is a subsequence of a sequence $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements.\n\n### Input\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 3000$, $1 \\le m \\le 5$) \u2014 the lengths of the three sequences and the required length of the subsequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the elements of the sequence $a$.\n\nThe third line contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le n$) \u2014 the elements of the sequence $b$.\n\nThe fourth line contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\le c_i \\le 10^4$) \u2014 the elements of the sequence $c$.\n\n### Output\n\nOutput a single integer \u2014 the maximum value of $\\sum\\limits_{i = 1}^m c_{p_i}$. If it is impossible to choose a subsequence of length $m$ that satisfies the conditions above, output $-1$.\n\n### Examples\n\n#### Input #1\n\n```\n\n4 2\n\n2 3 4 2\n\n1 3 3 2\n\n1 4 2 3\n\n```\n\n#### Output #1\n\n```\n5\n```\n\n#### Input #2\n\n```\n\n7 3\n\n1 4 5 2 3 6 7\n\n1 2 2 1 1 3 2\n\n1 5 6 7 3 2 4\n\n```\n\n#### Output #2\n\n```\n13\n```\n\n#### Input #3\n\n```\n\n5 3\n\n1 2 3 4 5\n\n1 1 2 1 2\n\n5 4 3 2 1\n\n```\n\n#### Output #3\n\n```\n-1\n```\n\n### Note\n\nIn the first example, we can choose $p = [1, 2]$, then $c_{p_1} + c_{p_2} = 1 + 4 = 5$. We can't choose $p = [2, 4]$ since $a_2 > a_4$, violating the first condition. We can't choose $p = [2, 3]$ either since $b_2 = b_3$, violating the second condition. We can choose $p = [1, 4]$, but $c_1 + c_4 = 4$, which isn't maximum.\n\nIn the second example, we can choose $p = [4, 6, 7]$.\n\nIn the third example, it is impossible to choose a subsequence of length $3$ that satisfies both of the conditions.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\n\nint T=140,n,m,a[3005],b[3005],c[3005],ky[3005],tr[3005][32],infn=30000005,ans=-30000005;\nmt19937 mt(0x4247AABC),mtt(random_device{}());\n\nvoid addbit(int x,int v,int lc){\n\tfor(;x<=n;x+=(x&-x))if(tr[x][lc]<v)tr[x][lc]=v;\n}\n\nint querybit(int x,int lc){\n\tint ca=-infn;for(;x;x&=(x-1))if(ca<tr[x][lc])ca=tr[x][lc];\n\treturn ca;\n}\n\nint main(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(int i=1;i<=n;i++)cin>>b[i];\n\tfor(int i=1;i<=n;i++)cin>>c[i];\n\twhile(T--){\n\t\tfor(int i=1;i<=n;i++)ky[i]=(mt()^mtt())%m;\n\t\tfor(int i=1;i<=n;i++)for(int z=0;z<(1<<m);z++)tr[i][z]=-infn;\n\t\taddbit(1,0,0);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint oo=ky[b[i]];for(int z=0;z<(1<<m);z++)if(z&(1<<oo))addbit(a[i],querybit(a[i],z^(1<<oo))+c[i],z);\n\t\t}\n\t\tans=max(ans,querybit(n,(1<<m)-1));\n\t}\n\tcout<<(ans<0?-1:ans);\n\treturn 0;\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2003d2",
      "PROBLEM_ID": "2003D2",
      "PROBLEM_STATEMENT": "The two versions are different problems. In this version of the problem, you can't choose the same integer twice or more. You can make hacks only if both versions are solved.\n\nOne day, Turtle was playing with $n$ sequences. Let the length of the $i$-th sequence be $l_i$. Then the $i$-th sequence was $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, l_i}$.\n\nPiggy gave Turtle a problem to solve when Turtle was playing. The statement of the problem was:\n\n- There was a non-negative integer $x$ at first. Turtle would perform an arbitrary number (possibly zero) of operations on the integer.\n- In each operation, Turtle could choose an integer $i$ such that $1 \\le i \\le n$ and $i$ wasn't chosen before, and set $x$ to $\\text{mex}^{\\dagger}(x, a_{i, 1}, a_{i, 2}, \\ldots, a_{i, l_i})$.\n- Turtle was asked to find the answer, which was the maximum value of $x$ after performing an arbitrary number of operations.\n\nTurtle solved the above problem without difficulty. He defined $f(k)$ as the answer to the above problem when the initial value of $x$ was $k$.\n\nThen Piggy gave Turtle a non-negative integer $m$ and asked Turtle to find the value of $\\sum\\limits_{i = 0}^m f(i)$ (i.e., the value of $f(0) + f(1) + \\ldots + f(m)$). Unfortunately, he couldn't solve this problem. Please help him!\n\n$^{\\dagger}\\text{mex}(c_1, c_2, \\ldots, c_k)$ is defined as the smallest non-negative integer $x$ which does not occur in the sequence $c$. For example, $\\text{mex}(2, 2, 0, 3)$ is $1$, $\\text{mex}(1, 2)$ is $0$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n, m$ ($1 \\le n \\le 2 \\cdot 10^5, 0 \\le m \\le 10^9$).\n\nEach of the following $n$ lines contains several integers. The first integer $l_i$ ($1 \\le l_i \\le 2 \\cdot 10^5$) represents the length of the $i$-th sequence, and the following $l_i$ integers $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, l_i}$ ($0 \\le a_{i, j} \\le 10^9$) represent the elements of the $i$-th sequence.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$ and the sum of $\\sum l_i$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the value of $\\sum\\limits_{i = 0}^m f(i)$.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n3 4\n\n2 0 2\n\n3 2 3 3\n\n4 7 0 1 5\n\n3 4\n\n5 0 2 0 4 11\n\n1 1\n\n5 1 3 0 3 3\n\n2 50\n\n2 1 2\n\n2 1 2\n\n1 1\n\n7 1 2 4 1 4 9 5\n\n4 114514\n\n2 2 2\n\n5 7 3 6 0 3\n\n3 0 1 1\n\n5 0 9 2 1 5\n\n5 1919810\n\n1 2\n\n2 324003 0\n\n3 1416324 2 1460728\n\n4 1312631 2 0 1415195\n\n5 1223554 192248 2 1492515 725556\n\n```\n\n#### Output #1\n\n```\n16\n18\n1281\n4\n6556785365\n1842836177961\n```\n\n### Note\n\nIn the first test case, when $x$ is initially $2$, Turtle can choose $i = 3$ and set $x$ to $\\text{mex}(x, a_{3, 1}, a_{3, 2}, a_{3, 3}, a_{3, 4}) = \\text{mex}(2, 7, 0, 1, 5) = 3$. It can be proved that Turtle can't make the value of $x$ greater than $3$, so $f(2) = 3$.\n\nIt can be seen that $f(0) = 3$, $f(1) = 3$, $f(2) = 3$, $f(3) = 3$, and $f(4) = 4$. So $f(0) + f(1) + f(2) + f(3) + f(4) = 3 + 3 + 3 + 3 + 4 = 16$.\n\nIn the second test case, when $x$ is initially $1$, Turtle can choose $i = 1$ and set $x$ to $\\text{mex}(x, a_{1, 1}, a_{1, 2}, a_{1, 3}, a_{1, 4}, a_{1, 5}) = \\text{mex}(1, 0, 2, 0, 4, 11) = 3$. It can be proved that Turtle can't make the value of $x$ greater than $3$, so $f(1) = 3$.\n\nIt can be seen that $f(0) = 4$, $f(1) = 3$, $f(2) = 4$, $f(3) = 3$, and $f(4) = 4$. So $f(0) + f(1) + f(2) + f(3) + f(4) = 4 + 3 + 4 + 3 + 4 = 18$.\n\nIn the fourth test case, it can be seen that $f(0) = 3$ and $f(1) = 1$. So $f(0) + f(1) = 3 + 1 = 4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define N 200009\n#define M 998244353\n#define ls p<<1\n#define rs p<<1|1\n#define lowbit(x) ((x)&-(x))\nusing ll=long long ;\nusing namespace std;\nint n,m,tot[N],a,num,in[N];\nint me[N],ma[N];\nint cnt,imp[N],vis[N];\nmap<int,int> mp;\nvector<int> e[N];\nmap<int,int> ans;\nvoid bfs(int p)\n{\n    int con=p;\n    p=mp[p];\n    if(vis[p]) return ;\n    ans[imp[p]]=con;\n    queue<int> q;\n    q.push(p);\n    vis[p]=1;\n    while(q.size())\n    {\n        int p=q.front();q.pop();\n        for(auto v:e[p])\n        {\n            if(vis[v]) continue;\n            vis[v]=1;q.push(v);\n            ans[imp[v]]=con;\n        }\n    }\n}\nvoid solve()\n{\n    cnt=0;mp.clear();ans.clear();\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>num;\n        for(int i=1;i<=num;i++)\n        {\n            cin>>a;\n            if(a<=num) tot[a]++;\n        }\n        int p=0;\n        while(tot[p]) p++;\n        me[i]=p;\n        int to=mp[p];\n        if(!to) mp[p]=++cnt,to=cnt,imp[cnt]=p,e[cnt].clear(),vis[cnt]=in[cnt]=0;\n        p++;\n        while(tot[p]) p++;\n        ma[i]=p; \n        int fr=mp[p];\n        if(!fr) mp[p]=++cnt,fr=cnt,imp[cnt]=p,e[cnt].clear(),vis[cnt]=in[cnt]=0;\n        e[fr].push_back(to);in[to]++;\n        for(int i=0;i<=num;i++) tot[i]=0;\n    }\n   // for(int i=1;i<=n;i++) cerr<<me[i]<<' '<<ma[i]<<endl;\n    sort(ma+1,ma+n+1,greater<int>());\n    for(int i=1;i<=n;i++) bfs(ma[i]);\n    int anss=0;\n    for(int i=1;i<=n;i++) \n    {\n        anss=max(anss,me[i]);\n        if(in[mp[me[i]]]>1) anss=max(anss,ans[me[i]]);\n    }\n    int maxa=0;\n    for(int i=1;i<=n;i++) maxa=max(maxa,ma[i]);\n    ll answer=0;\n    for(int i=0;i<=m&&i<=maxa;i++)\n    {\n        int con=max(i,anss);\n        con=max(con,ans[i]);\n        answer+=con;\n        //cerr<<con<<endl;\n    }\n    if(m>maxa) answer+=1ll*(m+1+maxa)*(m-maxa)/2;\n    cout<<answer<<endl;\n}\nint main()\n{\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int tt=1;\n    cin>>tt;\n    while(tt--) solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2003c",
      "PROBLEM_ID": "2003C",
      "PROBLEM_STATEMENT": "Turtle gives you a string $s$, consisting of lowercase Latin letters.\n\nTurtle considers a pair of integers $(i, j)$ ($1 \\le i < j \\le n$) to be a pleasant pair if and only if there exists an integer $k$ such that $i \\le k < j$ and both of the following two conditions hold:\n\n- $s_k \\ne s_{k + 1}$;\n- $s_k \\ne s_i$ or $s_{k + 1} \\ne s_j$.\n\nBesides, Turtle considers a pair of integers $(i, j)$ ($1 \\le i < j \\le n$) to be a good pair if and only if $s_i = s_j$ or $(i, j)$ is a pleasant pair.\n\nTurtle wants to reorder the string $s$ so that the number of good pairs is maximized. Please help him!\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the string.\n\nThe second line of each test case contains a string $s$ of length $n$, consisting of lowercase Latin letters.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the string $s$ after reordering so that the number of good pairs is maximized. If there are multiple answers, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3\n\nabc\n\n5\n\nedddf\n\n6\n\nturtle\n\n8\n\npppppppp\n\n10\n\ncodeforces\n\n```\n\n#### Output #1\n\n```\nacb\nddedf\nurtlet\npppppppp\ncodeforces\n```\n\n### Note\n\nIn the first test case, $(1, 3)$ is a good pair in the reordered string. It can be seen that we can't reorder the string so that the number of good pairs is greater than $1$. bac and cab can also be the answer.\n\nIn the second test case, $(1, 2)$, $(1, 4)$, $(1, 5)$, $(2, 4)$, $(2, 5)$, $(3, 5)$ are good pairs in the reordered string. efddd can also be the answer.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nint t,n,cnt[26];\n\nvoid solve(){\n    memset(cnt,0,sizeof cnt);\n    cin>>n;\n    string s;\n    cin>>s;\n    for(int i=0;i<n;i++){\n        cnt[s[i]-'a']++;\n    }\n    int num=0;\n    while(num<n){\n        for(int i=0;i<26;i++){\n            if(cnt[i]){\n                cout<<char(i+'a');\n                num++;\n                cnt[i]--;\n            }\n            if(num>=n) break;\n        }\n    }\n}\n\nint main(){\n    cin>>t;\n    while(t--) solve(),cout<<endl;\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2003a",
      "PROBLEM_ID": "2003A",
      "PROBLEM_STATEMENT": "Turtle thinks a string $s$ is a good string if there exists a sequence of strings $t_1, t_2, \\ldots, t_k$ ($k$ is an arbitrary integer) such that:\n\n- $k \\ge 2$.\n- $s = t_1 + t_2 + \\ldots + t_k$, where $+$ represents the concatenation operation. For example, $\\texttt{abc} = \\texttt{a} + \\texttt{bc}$.\n- For all $1 \\le i < j \\le k$, the first character of $t_i$ isn't equal to the last character of $t_j$.\n\nTurtle is given a string $s$ consisting of lowercase Latin letters. Please tell him whether the string $s$ is a good string!\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 100$) \u2014 the length of the string.\n\nThe second line of each test case contains a string $s$ of length $n$, consisting of lowercase Latin letters.\n\n### Output\n\nFor each test case, output \"YES\" if the string $s$ is a good string, and \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\naa\n\n3\n\naba\n\n4\n\nabcb\n\n12\n\nabcabcabcabc\n\n```\n\n#### Output #1\n\n```\nNo\nnO\nYes\nYES\n```\n\n### Note\n\nIn the first test case, the sequence of strings $\\texttt{a}, \\texttt{a}$ satisfies the condition $s = t_1 + t_2 + \\ldots + t_k$, but the first character of $t_1$ is equal to the last character of $t_2$. It can be seen that there doesn't exist any sequence of strings which satisfies all of the conditions, so the answer is \"NO\".\n\nIn the third test case, the sequence of strings $\\texttt{ab}, \\texttt{cb}$ satisfies all of the conditions.\n\nIn the fourth test case, the sequence of strings $\\texttt{abca}, \\texttt{bcab}, \\texttt{cabc}$ satisfies all of the conditions.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool is_good_string(string s) {\n    if (s.length() < 2) {\n        return false;\n    }\n    if (s[0] != s.back()) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        if (is_good_string(s)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2002f1",
      "PROBLEM_ID": "2002F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. In this version, $n=m$ and the time limit is lower. You can make hacks only if both versions of the problem are solved.\n\nIn the court of the Blue King, Lelle and Flamm are having a performance match. The match consists of several rounds. In each round, either Lelle or Flamm wins.\n\nLet $W_L$ and $W_F$ denote the number of wins of Lelle and Flamm, respectively. The Blue King considers a match to be successful if and only if:\n\n- after every round, $\\gcd(W_L,W_F)\\le 1$;\n- at the end of the match, $W_L\\le n, W_F\\le m$.\n\nNote that $\\gcd(0,x)=\\gcd(x,0)=x$ for every non-negative integer $x$.\n\nLelle and Flamm can decide to stop the match whenever they want, and the final score of the performance is $l \\cdot W_L + f \\cdot W_F$.\n\nPlease help Lelle and Flamm coordinate their wins and losses such that the performance is successful, and the total score of the performance is maximized.\n\n### Input\n\nThe first line contains an integer $t$ ($1\\leq t \\leq 10^3$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains four integers $n$, $m$, $l$, $f$ ($2\\leq n\\leq m \\leq 2\\cdot 10^7$, $1\\leq l,f \\leq 10^9$, $\\bf{n=m}$): $n$, $m$ gives the upper bound on the number of Lelle and Flamm's wins, $l$ and $f$ determine the final score of the performance.\n\nUnusual additional constraint: it is guaranteed that, for each test, there are no pairs of test cases with the same pair of $n$, $m$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximum total score of a successful performance.\n\n### Examples\n\n#### Input #1\n\n```\n\n8\n\n3 3 2 5\n\n4 4 1 4\n\n6 6 2 2\n\n7 7 2 3\n\n9 9 9 1\n\n2 2 1 4\n\n5 5 1 4\n\n8 8 6 7\n\n```\n\n#### Output #1\n\n```\n19\n17\n18\n33\n86\n9\n24\n86\n```\n\n#### Input #2\n\n```\n\n1\n\n20000000 20000000 1341 331\n\n```\n\n#### Output #2\n\n```\n33439999007\n```\n\n#### Input #3\n\n```\n\n2\n\n1984 1984 19 84\n\n9982 9982 44 35\n\n```\n\n#### Output #3\n\n```\n204143\n788403\n```\n\n### Note\n\nIn the first test case, a possible performance is as follows:\n\n- Flamm wins, $\\gcd(0,1)=1$.\n- Lelle wins, $\\gcd(1,1)=1$.\n- Flamm wins, $\\gcd(1,2)=1$.\n- Flamm wins, $\\gcd(1,3)=1$.\n- Lelle wins, $\\gcd(2,3)=1$.\n- Lelle and Flamm agree to stop the match.\n\nThe final score is $2\\cdot2+3\\cdot5=19$.\n\nIn the third test case, a possible performance is as follows:\n\n- Flamm wins, $\\gcd(0,1)=1$.\n- Lelle wins, $\\gcd(1,1)=1$.\n- Lelle wins, $\\gcd(2,1)=1$.\n- Lelle wins, $\\gcd(3,1)=1$.\n- Lelle wins, $\\gcd(4,1)=1$.\n- Lelle wins, $\\gcd(5,1)=1$.\n- Flamm wins, $\\gcd(5,2)=1$.\n- Flamm wins, $\\gcd(5,3)=1$.\n- Flamm wins, $\\gcd(5,4)=1$.\n- Lelle and Flamm agree to stop the match.\n\nThe final score is $5\\cdot2+4\\cdot2=18$. Note that Lelle and Flamm can stop the match even if neither of them has $n$ wins.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,m,l,f,T,i,j;\nvector<int> prime;\nbool np[20080506];\nbool vis[2085][2085];\nsigned main()\n{\n  \tfor(i=2;i<=20000000;i++)\n\t{\n    \tif(!np[i]) prime.push_back(i);\n    \tfor(int pj:prime)\n\t\t{\n      \t\tif(i*pj>20000000) break;\n      \t\tnp[i*pj]=true;\n      \t\tif(i%pj==0) break;\n    \t}\n  \t}\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\tcin>>n>>m>>l>>f;\n\t\tif(l<f) swap(l,f);\n\t\tif(!np[n])\n\t\t{\n\t\t\tcout<<n*l+(n-1)*f<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint fp=*(--lower_bound(prime.begin(),prime.end(),n)),sp=*(--lower_bound(prime.begin(),prime.end(),fp));\n\t\tif(n<=16) fp=sp=1;\n\t\tint x=n-fp+1,y=n-sp+1;\n\t\tcerr<<x<<\" \"<<y<<\" \"<<endl;\n\t\tfor(i=0;i<=x+1;i++)\n\t\t{\n\t\t\tfor(j=0;j<=y+1;j++)\n\t\t\t{\n\t\t\t\tif(i==0||i==x+1||j==0||j==y+1||__gcd(fp-1+i,sp-1+j)!=1) vis[i][j]=0;\n\t\t\t\telse vis[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int,int> > q;\n\t\tq.push({1,1});\n\t\tint ans=0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\ti=q.front().first,j=q.front().second;q.pop();\n\t\t\tans=max(ans,(fp-1+i)*l+(sp-1+j)*f);\n\t\t\tif(vis[i+1][j]) vis[i+1][j]=0,q.push({i+1,j});\n\t\t\tif(vis[i][j+1]) vis[i][j+1]=0,q.push({i,j+1});\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2002e",
      "PROBLEM_ID": "2002E",
      "PROBLEM_STATEMENT": "Given an array of integers $s_1, s_2, \\ldots, s_l$, every second, cosmic rays will cause all $s_i$ such that $i=1$ or $s_i\\neq s_{i-1}$ to be deleted simultaneously, and the remaining parts will be concatenated together in order to form the new array $s_1, s_2, \\ldots, s_{l'}$.\n\nDefine the strength of an array as the number of seconds it takes to become empty.\n\nYou are given an array of integers compressed in the form of $n$ pairs that describe the array left to right. Each pair $(a_i,b_i)$ represents $a_i$ copies of $b_i$, i.e. $\\underbrace{b_i,b_i,\\cdots,b_i}_{a_i\\textrm{ times}}$.\n\nFor each $i=1,2,\\dots,n$, please find the strength of the sequence described by the first $i$ pairs.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le3\\cdot10^5$)\u00a0\u2014 the length of sequence $a$.\n\nThe next $n$ lines contain two integers each $a_i$, $b_i$ ($1\\le a_i\\le10^9,0\\le b_i\\le n$)\u00a0\u2014 the pairs which describe the sequence.\n\nIt is guaranteed that the sum of all $n$ does not exceed $3\\cdot10^5$.\n\nIt is guaranteed that for all $1\\le i<n$, $b_i\\neq b_{i+1}$ holds.\n\n### Output\n\nFor each test case, print one line containing $n$ integers\u00a0\u2014 the answer for each prefix of pairs.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4\n\n2 0\n\n1 1\n\n3 0\n\n5 1\n\n6\n\n4 6\n\n1 3\n\n4 6\n\n4 0\n\n7 6\n\n6 3\n\n7\n\n9 0\n\n7 1\n\n5 0\n\n7 1\n\n9 0\n\n1 1\n\n2 0\n\n10\n\n10 7\n\n4 9\n\n2 2\n\n7 9\n\n2 8\n\n8 5\n\n11 7\n\n15 5\n\n12 7\n\n4 0\n\n```\n\n#### Output #1\n\n```\n2 2 4 5\n4 4 7 7 10 10\n9 9 9 9 9 9 10\n10 10 10 10 10 10 12 15 15 15\n```\n\n### Note\n\nIn the first test case, for the prefix of length $4$, the changes will be $[0,0,1,0,0,0,1,1,1,1,1]\\rightarrow[0,0,0,1,1,1,1]\\rightarrow[0,0,1,1,1]\\rightarrow[0,1,1]\\rightarrow[1]\\rightarrow[]$, so the array becomes empty after $5$ seconds.\n\nIn the second test case, for the prefix of length $4$, the changes will be $[6,6,6,6,3,6,6,6,6,0,0,0,0]\\rightarrow[6,6,6,6,6,6,0,0,0]\\rightarrow[6,6,6,6,6,0,0]\\rightarrow[6,6,6,6,0]\\rightarrow[6,6,6]\\rightarrow[6,6]\\rightarrow[6]\\rightarrow[]$, so the array becomes empty after $7$ seconds.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define N 300009\nusing namespace std;\nusing ll =long long ;\nconst ll INF =1e18;\nconst int mod=998244353;\nint n,top;\npair<ll,int> st[N];\nvoid solve()\n{\n    ll ans=0;\n    cin>>n;\n    top=0;\n    for(int i=1;i<=n;i++)\n    {\n        ll a,b;cin>>a>>b;\n        ll ma=0;\n        while(top)\n        {\n            if(st[top].second==b) a+=st[top].first-ma,top--,ma=0;\n            else if(st[top].first<=a) ma=st[top].first,top--;\n            else break;\n        }\n        st[++top]={a,b};\n        ans=max(ans,a);\n        cout<<ans<<' ';\n    }\n    cout<<'\n';\n}\nint main()\n{\n    ios::sync_with_stdio(false);cin.tie(0);\n    int tt=1;\n    cin>>tt;\n    while(tt--) solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2002d1",
      "PROBLEM_ID": "2002D1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. In this version, the given tree is a perfect binary tree and the constraints on $n$ and $q$ are lower. You can make hacks only if both versions of the problem are solved.\n\nYou are given a perfect binary tree$^\\dagger$ consisting of $n$ vertices. The vertices are numbered from $1$ to $n$, and the root is the vertex $1$. You are also given a permutation $p_1, p_2, \\ldots, p_n$ of $[1,2,\\ldots,n]$.\n\nYou need to answer $q$ queries. For each query, you are given two integers $x$, $y$; you need to swap $p_x$ and $p_y$ and determine if $p_1, p_2, \\ldots, p_n$ is a valid DFS order$^\\ddagger$ of the given tree.\n\nPlease note that the swaps are persistent through queries.\n\n$^\\dagger$ A perfect binary tree is a tree with vertex $1$ as its root, with size $n=2^k-1$ for a positive integer $k$, and where the parent of each vertex $i$ ($1<i\\le n$) is $\\left\\lfloor\\frac{i}{2}\\right\\rfloor$. Thus, all leaves of this tree are at a distance $k - 1$ from the root.\n\n$^\\ddagger$ A DFS order is found by calling the following $\\texttt{dfs}$ function on the given tree.\n\n```\n`dfs_order = []<br/><br/>function dfs(v):<br/>    append v to the back of dfs_order<br/>    pick an arbitrary permutation s of children of v<br/>    for child in s:<br/>        dfs(child)<br/>dfs(1)<br/>````\n\nNote that the DFS order is not unique.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $q$ ($3\\le n\\le 65\\,535$, $2\\le q\\le 5 \\cdot 10^4$)\u00a0\u2014 the number of vertices in the tree and the number of queries. It is guaranteed that $n=2^k-1$ for a positive integer $k$.\n\nThe next line contains $n-1$ integers $a_2,a_3,\\ldots,a_n$ ($1\\le a_i<i$)\u00a0\u2014 the parent of each vertex in the given tree. It is guaranteed that $a_i=\\left\\lfloor\\frac{i}{2}\\right\\rfloor$.\n\nThe next line contains $n$ integers $p_1,p_2,\\ldots,p_n$ ($1\\le p_i\\le n$, all $p_i$ are distinct)\u00a0\u2014 the initial permutation $p$.\n\nThe next $q$ lines each contain two integers $x$, $y$ ($1\\le x,y\\le n,x\\neq y$)\u00a0\u2014 the positions of the elements to swap in the permutation.\n\nIt is guaranteed that the sum of all $n$ does not exceed $65\\,535$, and the sum of all $q$ does not exceed $5 \\cdot 10^4$.\n\n### Output\n\nFor each test case, print $q$ lines corresponding to the $q$ queries. For each query, output $\\texttt{YES}$ if there is a DFS order that exactly equals the current permutation, and output $\\texttt{NO}$ otherwise.\n\nYou can output $\\texttt{Yes}$ and $\\texttt{No}$ in any case (for example, strings $\\texttt{yEs}$, $\\texttt{yes}$, $\\texttt{Yes}$ and $\\texttt{YES}$ will be recognized as a positive response).\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n3 3\n\n1 1\n\n1 2 3\n\n2 3\n\n3 2\n\n1 3\n\n7 4\n\n1 1 2 2 3 3\n\n1 2 3 4 5 6 7\n\n3 5\n\n2 5\n\n3 7\n\n4 6\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\nYES\nNO\nNO\nYES\n```\n\n### Note\n\nIn the first test case, the permutation $p_1, p_2, \\ldots, p_n$ after each modification is $[1,3,2],[1,2,3],[3,2,1]$, respectively. The first two permutations are valid DFS orders; the third is not a DFS order.\n\nIn the second test case, the permutation $p_1, p_2, \\ldots, p_n$ after each modification is $[1,2,5,4,3,6,7],[1,3,5,4,2,6,7],[1,3,7,4,2,6,5],[1,3,7,6,2,4,5]$, respectively.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <algorithm> // for std::swap\n\n// Global variables definition\nint N; // Number of vertices (up to 65535, fits in int)\nstd::vector<int> p; // permutation array p[1..N], stores vertex at index i\nstd::vector<int> pos; // position map pos[v] = index i such that p[i] = v\nstd::vector<int> S; // Subtree sizes S[v] = size of subtree rooted at v\nint total_violations = 0; // Global counter for violations of DFS order conditions\n\n/**\n * @brief Computes the size of the subtree rooted at vertex v recursively.\n * Assumes a perfect binary tree structure where children of v are 2v and 2v+1.\n * Stores the result in the global array S.\n * \n * @param v The root of the subtree for which size is computed.\n */\nvoid compute_subtree_sizes(int v) {\n    // Base case: If v is a leaf node (2*v > N)\n    if (2 * v > N) { \n        S[v] = 1; // A leaf node's subtree has size 1\n        return; // Return after processing leaf\n    } \n    \n    // Recursive step: Compute sizes for children and then for v\n    // In a perfect binary tree with N=2^k-1 (N>=3), if 2*v <= N, then 2*v+1 <= N also holds.\n    // So a non-leaf node always has both children.\n    compute_subtree_sizes(2 * v); // Compute size for left child\n    compute_subtree_sizes(2 * v + 1); // Compute size for right child\n    S[v] = 1 + S[2 * v] + S[2 * v + 1]; // Size of v is 1 + sizes of its children's subtrees\n}\n\n/**\n * @brief Checks if the DFS structure condition is violated for a non-leaf node v.\n * The condition requires that the children's subtrees appear contiguously immediately after v\n * in the permutation array p, in either order (left-then-right or right-then-left).\n * \n * @param v The vertex to check. Must be a non-leaf node.\n * @return int Returns 1 if the condition is violated, 0 otherwise.\n */\nint check_condition(int v) {\n    // This condition applies only to non-leaf nodes.\n    // A node v is non-leaf if 2*v <= N.\n    // If v is a leaf (2*v > N), it cannot violate this condition.\n    // The calling code should ensure v is non-leaf, but this check adds safety.\n    if (2 * v > N) {\n        return 0; \n    }\n    \n    // For a perfect binary tree N=2^k-1 (N>=3), if 2*v <= N, then 2*v+1 must exist (2*v+1 <= N).\n    // We check just in case, although it shouldn't be needed under problem constraints.\n    if (2 * v + 1 > N) {\n         // This should not happen. If it does, consider it a violation.\n         return 1; \n    }\n\n    // Retrieve positions and subtree sizes needed for check\n    // Use long long for intermediate position calculations to avoid potential overflow,\n    // although N <= 65535 means N+N+1 fits in standard 32-bit int. Safety doesn't hurt.\n    long long current_pos_v = pos[v]; // position of node v in p\n    long long pos_left_child = pos[2 * v]; // position of left child 2*v\n    long long pos_right_child = pos[2 * v + 1]; // position of right child 2*v+1\n    long long size_left_subtree = S[2 * v]; // size of subtree rooted at 2*v\n    long long size_right_subtree = S[2 * v + 1]; // size of subtree rooted at 2*v+1\n\n    // Check the two valid orderings for children subtrees in DFS traversal\n    // Case 1: Left child's subtree appears immediately after v, followed by right child's subtree.\n    bool case1 = (pos_left_child == current_pos_v + 1 && pos_right_child == current_pos_v + 1 + size_left_subtree);\n    // Case 2: Right child's subtree appears immediately after v, followed by left child's subtree.\n    bool case2 = (pos_right_child == current_pos_v + 1 && pos_left_child == current_pos_v + 1 + size_right_subtree);\n    \n    // If neither valid ordering matches the current positions, the condition is violated\n    if (case1 || case2) {\n        return 0; // Condition satisfied\n    } else {\n        return 1; // Condition violated\n    }\n}\n\n/**\n * @brief Solves a single test case.\n * Reads input, initializes state, processes queries, and outputs results.\n */\nvoid solve() {\n    int Q; // Number of queries\n    std::cin >> N >> Q;\n    \n    // Read and discard parent array input. The problem guarantees a specific perfect binary tree structure (parent of i is floor(i/2)),\n    // so we don't need this information but must consume it from input.\n    for (int i = 2; i <= N; ++i) {\n        int parent_unused;\n        std::cin >> parent_unused; \n    }\n\n    // Initialize/resize vectors based on N\n    p.assign(N + 1, 0); // 1-based indexing\n    pos.assign(N + 1, 0); // 1-based indexing\n    S.assign(N + 1, 0); // 1-based indexing\n    \n    // Read initial permutation p and populate the position map 'pos'\n    for (int i = 1; i <= N; ++i) {\n        std::cin >> p[i];\n        pos[p[i]] = i; // Store index i for vertex p[i]\n    }\n\n    // Precompute subtree sizes for all nodes\n    compute_subtree_sizes(1); // Start recursion from root 1\n    \n    // Calculate initial total violations count\n    total_violations = 0;\n    // Condition 1: Root of tree (vertex 1) must be at the first position (index 1).\n    if (N > 0 && pos[1] != 1) { // Check N>0 to avoid index out of bounds if N=0 (although N>=3 guaranteed)\n        total_violations++;\n    }\n    // Condition 2: Check structural condition for all non-leaf nodes.\n    // Non-leaf nodes are vertices v such that 2*v <= N. These are nodes from 1 up to N/2.\n    for (int v = 1; v <= N / 2; ++v) { \n        total_violations += check_condition(v);\n    }\n\n    // Process Q queries\n    for (int k = 0; k < Q; ++k) {\n        int x, y; // Indices in p to swap\n        std::cin >> x >> y;\n\n        // Get the vertices currently at positions x and y\n        int u = p[x];\n        int w = p[y];\n\n        // Identify the set of nodes whose conditions might change due to the swap.\n        // This includes u and w themselves (if they are non-leaf), and their parents (if they exist).\n        // Using std::set automatically handles duplicate nodes (e.g., if w is parent of u).\n        std::set<int> affected_nodes;\n        // Add nodes u, w if they are non-leaf (have children)\n        if (u * 2 <= N) affected_nodes.insert(u); \n        if (w * 2 <= N) affected_nodes.insert(w);\n        // Add parents of u, w if they exist (i.e., not the root node 1)\n        if (u > 1) affected_nodes.insert(u / 2); // Parent is floor(u/2)\n        if (w > 1) affected_nodes.insert(w / 2); // Parent is floor(w/2)\n\n        // --- Update total_violations: Before Swap ---\n        // Calculate the number of violations among affected nodes and the root BEFORE the swap.\n        int current_local_violations = 0;\n        if (N > 0 && pos[1] != 1) current_local_violations++; // Root condition violation\n        for (int v : affected_nodes) {\n             // We only need to check conditions for non-leaf nodes. The set might contain leaves (parents of swapped nodes).\n             // check_condition handles leaves correctly (returns 0), but explicitly checking 2*v <= N is clearer.\n             if (v * 2 <= N) { \n                 current_local_violations += check_condition(v); // Structural conditions\n             }\n        }\n        // Subtract these current violations from the total count, as they will be recalculated after swap.\n        total_violations -= current_local_violations;\n\n        // --- Perform the Swap ---\n        std::swap(p[x], p[y]); // Update permutation array p\n        pos[u] = y; // Update position of vertex u\n        pos[w] = x; // Update position of vertex w\n\n        // --- Update total_violations: After Swap ---\n        // Recalculate the number of violations among affected nodes and the root AFTER the swap.\n        int new_local_violations = 0;\n        if (N > 0 && pos[1] != 1) new_local_violations++; // Root condition violation\n        for (int v : affected_nodes) {\n             if (v * 2 <= N) {\n                new_local_violations += check_condition(v); // Structural conditions\n             }\n        }\n        // Add these new violations (based on the state after swap) to the total count.\n        total_violations += new_local_violations;\n        \n        // --- Output Result ---\n        // If total violations is 0, the current permutation p is a valid DFS order.\n        if (total_violations == 0) {\n            std::cout << \"YES\\n\";\n        } else {\n            std::cout << \"NO\\n\";\n        }\n    }\n}\n\nint main() {\n    // Optimize C++ standard I/O operations for speed\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int T; // Number of test cases\n    std::cin >> T;\n    while (T--) {\n        solve(); // Solve each test case independently\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2002c",
      "PROBLEM_ID": "2002C",
      "PROBLEM_STATEMENT": "There are $n$ circles on a two-dimensional plane. The $i$-th circle is centered at $(x_i,y_i)$. Initially, all circles have a radius of $0$.\n\nThe circles' radii increase at a rate of $1$ unit per second.\n\nYou are currently at $(x_s,y_s)$; your goal is to reach $(x_t,y_t)$ without touching the circumference of any circle (including the moment you reach $(x_t,y_t)$). You can move in any direction you want. However, your speed is limited to $1$ unit per second.\n\nPlease determine whether this is possible.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le10^5$)\u00a0\u2014 the number of circles.\n\nThe next $n$ lines each contain two integers $x_i$, $y_i$ ($1\\le x_i,y_i\\le10^9$)\u00a0\u2014 the center of each circle.\n\nThe final line contains four integers $x_s$, $y_s$, $x_t$, $y_t$ ($1\\le x_s,y_s,x_t,y_t\\le10^9$)\u00a0\u2014 the coordinates of the starting point and the goal, respectively.\n\nIt is guaranteed that these $n+2$ points are distinct.\n\nIt is guaranteed that the sum of $n$ over all testcases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output $\\texttt{YES}$ if it is possible to reach the goal without touching the circle boundaries, and output $\\texttt{NO}$ otherwise.\n\nYou can output $\\texttt{Yes}$ and $\\texttt{No}$ in any case (for example, strings $\\texttt{yEs}$, $\\texttt{yes}$, $\\texttt{Yes}$, and $\\texttt{YES}$ will be recognized as a positive response).\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n3\n\n2 5\n\n2 14\n\n10 13\n\n4 9 9 7\n\n3\n\n10 11\n\n6 9\n\n12 12\n\n14 13 4 8\n\n1\n\n5 7\n\n12 6 11 13\n\n2\n\n1000000000 2\n\n2 1000000000\n\n1 1 2 2\n\n1\n\n999999998 1000000000\n\n999999999 999999999 1 1\n\n1\n\n1000000000 1\n\n1 1000000000 1 1\n\n10\n\n989237121 2397081\n\n206669655 527238537\n\n522705783 380636165\n\n532545346 320061691\n\n207818728 199485303\n\n884520552 315781807\n\n992311437 802563521\n\n205138355 324818663\n\n223575704 395073023\n\n281560523 236279118\n\n216941610 572010615 323956540 794523071\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nYES\nYES\nNO\nYES\n```\n\n### Note\n\nIn the first test case, a feasible way of movement is as follows.\n\n![](https://espresso.codeforces.com/44e6932b7c975d247fecdc471ff7f6c1fa344b13.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool solve() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> centers(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> centers[i].first >> centers[i].second;\n    }\n    int xs, ys, xt, yt;\n    cin >> xs >> ys >> xt >> yt;\n\n    long long dist_sq_start_target = (long long)(xt - xs) * (xt - xs) + (long long)(yt - ys) * (yt - ys);\n    bool possible = true;\n    for (int i = 0; i < n; ++i) {\n        long long dist_sq_target_center = (long long)(xt - centers[i].first) * (xt - centers[i].first) + (long long)(yt - centers[i].second) * (yt - centers[i].second);\n        if (dist_sq_target_center <= dist_sq_start_target) {\n            possible = false;\n            break;\n        }\n    }\n\n    return possible;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        if (solve()) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2002a",
      "PROBLEM_ID": "2002A",
      "PROBLEM_STATEMENT": "You received an $n\\times m$ grid from a mysterious source. The source also gave you a magic positive integer constant $k$.\n\nThe source told you to color the grid with some colors, satisfying the following condition:\n\n- If $(x_1,y_1)$, $(x_2,y_2)$ are two distinct cells with the same color, then $\\max(|x_1-x_2|,|y_1-y_2|)\\ge k$.\n\nYou don't like using too many colors. Please find the minimum number of colors needed to color the grid.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le1000$). The description of the test cases follows.\n\nThe only line of each test case consists of three positive integers $n$, $m$, $k$ ($1\\le n,m,k\\le10^4$)\u00a0\u2014 the dimensions of the grid and the magic constant.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the minimum number of colors needed to color the grid.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n3 3 2\n\n5 1 10000\n\n7 3 4\n\n3 2 7\n\n8 9 6\n\n2 5 4\n\n```\n\n#### Output #1\n\n```\n4\n5\n12\n6\n36\n8\n```\n\n### Note\n\nIn the first test case, one of the optimal constructions is:\n\n![](https://espresso.codeforces.com/c168a84807ca605cdc35f5a02f92961ad180041e.png)\n\nIn the second test case, the color of all cells must be pairwise different, so the answer is $5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        if (k > max(n, m)) {\n            cout << n * m << endl;\n        } else {\n            cout << min(n, k) * min(m, k) << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2001e2",
      "PROBLEM_ID": "2001E2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The difference between the two versions is the definition of deterministic max-heap, time limit, and constraints on $n$ and $t$. You can make hacks only if both versions of the problem are solved.\n\nConsider a perfect binary tree with size $2^n - 1$, with nodes numbered from $1$ to $2^n-1$ and rooted at $1$. For each vertex $v$ ($1 \\le v \\le 2^{n - 1} - 1$), vertex $2v$ is its left child and vertex $2v + 1$ is its right child. Each node $v$ also has a value $a_v$ assigned to it.\n\nDefine the operation $\\mathrm{pop}$ as follows:\n\n1. initialize variable $v$ as $1$;\n2. repeat the following process until vertex $v$ is a leaf (i.e. until $2^{n - 1} \\le v \\le 2^n - 1$);\n1. among the children of $v$, choose the one with the larger value on it and denote such vertex as $x$; if the values on them are equal (i.e. $a_{2v} = a_{2v + 1}$), you can choose any of them;\n2. assign $a_x$ to $a_v$ (i.e. $a_v := a_x$);\n3. assign $x$ to $v$ (i.e. $v := x$);\n3. assign $-1$ to $a_v$ (i.e. $a_v := -1$).\n\nThen we say the $\\mathrm{pop}$ operation is deterministic if there is a unique way to do such operation. In other words, $a_{2v} \\neq a_{2v + 1}$ would hold whenever choosing between them.\n\nA binary tree is called a max-heap if for every vertex $v$ ($1 \\le v \\le 2^{n - 1} - 1$), both $a_v \\ge a_{2v}$ and $a_v \\ge a_{2v + 1}$ hold.\n\nA max-heap is deterministic if the $\\mathrm{pop}$ operation is deterministic to the heap when we do it for the first and the second time.\n\nInitially, $a_v := 0$ for every vertex $v$ ($1 \\le v \\le 2^n - 1$), and your goal is to count the number of different deterministic max-heaps produced by applying the following operation $\\mathrm{add}$ exactly $k$ times:\n\n- Choose an integer $v$ ($1 \\le v \\le 2^n - 1$) and, for every vertex $x$ on the path between $1$ and $v$, add $1$ to $a_x$.\n\nTwo heaps are considered different if there is a node which has different values in the heaps.\n\nSince the answer might be large, print it modulo $p$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 50$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n, k, p$ ($2 \\le n \\le 100$, $1 \\le k \\le 500$, $10^8 \\le p \\le 10^9$, $p$ is a prime).\n\nIt is guaranteed that the sum of $n$ does not exceed $100$ and the sum of $k$ over all test cases does not exceed $500$.\n\n### Output\n\nFor each test case, output a single line containing an integer: the number of different deterministic max-heaps produced by applying the aforementioned operation $\\mathrm{add}$ exactly $k$ times, modulo $p$.\n\n### Examples\n\n#### Input #1\n\n```\n\n6\n\n2 1 998244353\n\n3 2 998244853\n\n3 3 998244353\n\n3 4 100000037\n\n4 2 100000039\n\n4 3 100000037\n\n```\n\n#### Output #1\n\n```\n2\n12\n40\n100\n32\n224\n```\n\n#### Input #2\n\n```\n\n1\n\n100 500 100000037\n\n```\n\n#### Output #2\n\n```\n66681128\n```\n\n#### Input #3\n\n```\n\n2\n\n87 63 100000037\n\n13 437 100000039\n\n```\n\n#### Output #3\n\n```\n83566569\n54517140\n```\n\n### Note\n\nFor the first testcase, if we choose $v = 1$ and do the operation, we would have $a = [1, 0, 0]$, and since $a_2 = a_3$, we can choose either of them when doing the first $\\mathrm{pop}$ operation, so such heap is not a deterministic max-heap.\n\nAnd if we choose $v = 2$, we would have $a = [1, 1, 0]$, during the first $\\mathrm{pop}$, the following would happen:\n\n- initialize $v$ as $1$\n- since $a_{2v} > a_{2v + 1}$, choose $2v$ as $x$, then $x = 2$\n- assign $a_x$ to $a_v$, then $a = [1, 1, 0]$\n- assign $x$ to $v$, then $v = 2$\n- since $v$ is a leaf, assign $-1$ to $a_v$, then $a = [1, -1, 0]$\n\nAnd during the second $\\mathrm{pop}$, the following would happen:\n\n- initialize $v$ as $1$\n- since $a_{2v} < a_{2v + 1}$, choose $2v + 1$ as $x$, then $x = 3$\n- assign $a_x$ to $a_v$, then $a = [0, -1, 0]$\n- assign $x$ to $v$, then $v = 3$\n- since $v$ is a leaf, assign $-1$ to $a_v$, then $a = [0, -1, -1]$\n\nSince both the first and the second $\\mathrm{pop}$ operation are deterministic, this is a deterministic max-heap. Also, if we choose $v = 3$, $a$ would be a deterministic max-heap, so the answer is $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> pr;\ninline LL rd(){\n\tLL x=0,y=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')y=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*y;\n}\nconst LL N=505;\nLL T,n,m,p,o,g[N][N],f[N][N],h[N][N],H[N][N],u[N][N],v[N][N];\nint main(){\n\tfor(T=rd();T--;){\n\t\tn=rd();m=rd();p=rd();o=0;\n\t\tfor(LL i=0;i<=n;++i)for(LL j=0;j<=m;++j)g[i][j]=f[i][j]=0;\n\t\tfor(LL i=0;i<=m;++i)f[1][i]=1,g[1][i]=1;\n\t\tfor(LL i=2;i<=n;++i)for(LL j=0;j<=m;++j){\n\t\t\tfor(LL k=0;k<=j;++k)g[i][j]=(g[i][j]+g[i-1][k]*g[i-1][j-k])%p;\n\t\t\tg[i][j]=(g[i][j]+(j?g[i][j-1]:0))%p;\n\t\t}\n\t\tfor(LL i=2;i<=n;++i)for(LL j=0;j<=m;++j){\n\t\t\tfor(LL k=0;k<(j+1>>1);++k)f[i][j]=(f[i][j]+f[i-1][j-k]*g[i-1][k]%p*2)%p;\n\t\t\tf[i][j]=(f[i][j]+(j?f[i][j-1]:0))%p;\n\t\t}\n\t\tfor(LL j=0;j<=m;++j)for(LL k=0;k<=j;++k)h[j][k]=H[j][k]=(j?h[j-1][k]:0)+(k>j-k?2:0);\n\t\tfor(LL i=3;i<=n;++i){\n\t\t\tfor(LL j=0;j<=m;++j)for(LL k=0;k<=j;++k)u[j][k]=((k?u[j][k-1]:0)+H[j][k])%p;\n\t\t\tfor(LL j=0;j<=m;++j)for(LL k=j;k>=0;--k)v[j][k]=((k<j?v[j][k+1]:0)+h[j][k])%p,h[j][k]=0;\n\t\t\tfor(LL j=0;j<=m;++j)for(LL k=0;k<=j;++k){\n\t\t\t\th[j][k]=((j?h[j-1][k]:0)+2*(k>j-k)*((j-k?u[k][j-k-1]:0)*f[i-1][j-k]+(k?v[k][j-k+1]:0)*g[i-1][j-k]))%p;\n\t\t\t\tH[j][k]=((j?H[j-1][k]:0)+2*(k>j-k)*f[i-1][k]*g[i-1][j-k])%p;\n\t\t\t}\n\t\t}\n\t\tfor(LL i=0;i<=m;++i)o=(o+h[m][i])%p;\n\t\tprintf(\"%lld\\n\",o);\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2001e1",
      "PROBLEM_ID": "2001E1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The difference between the two versions is the definition of deterministic max-heap, time limit, and constraints on $n$ and $t$. You can make hacks only if both versions of the problem are solved.\n\nConsider a perfect binary tree with size $2^n - 1$, with nodes numbered from $1$ to $2^n-1$ and rooted at $1$. For each vertex $v$ ($1 \\le v \\le 2^{n - 1} - 1$), vertex $2v$ is its left child and vertex $2v + 1$ is its right child. Each node $v$ also has a value $a_v$ assigned to it.\n\nDefine the operation $\\mathrm{pop}$ as follows:\n\n1. initialize variable $v$ as $1$;\n2. repeat the following process until vertex $v$ is a leaf (i.e. until $2^{n - 1} \\le v \\le 2^n - 1$);\n1. among the children of $v$, choose the one with the larger value on it and denote such vertex as $x$; if the values on them are equal (i.e. $a_{2v} = a_{2v + 1}$), you can choose any of them;\n2. assign $a_x$ to $a_v$ (i.e. $a_v := a_x$);\n3. assign $x$ to $v$ (i.e. $v := x$);\n3. assign $-1$ to $a_v$ (i.e. $a_v := -1$).\n\nThen we say the $\\mathrm{pop}$ operation is deterministic if there is a unique way to do such operation. In other words, $a_{2v} \\neq a_{2v + 1}$ would hold whenever choosing between them.\n\nA binary tree is called a max-heap if for every vertex $v$ ($1 \\le v \\le 2^{n - 1} - 1$), both $a_v \\ge a_{2v}$ and $a_v \\ge a_{2v + 1}$ hold.\n\nA max-heap is deterministic if the $\\mathrm{pop}$ operation is deterministic to the heap when we do it for the first time.\n\nInitially, $a_v := 0$ for every vertex $v$ ($1 \\le v \\le 2^n - 1$), and your goal is to count the number of different deterministic max-heaps produced by applying the following operation $\\mathrm{add}$ exactly $k$ times:\n\n- Choose an integer $v$ ($1 \\le v \\le 2^n - 1$) and, for every vertex $x$ on the path between $1$ and $v$, add $1$ to $a_x$.\n\nTwo heaps are considered different if there is a node which has different values in the heaps.\n\nSince the answer might be large, print it modulo $p$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n, k, p$ ($1 \\le n, k \\le 500$, $10^8 \\le p \\le 10^9$, $p$ is a prime).\n\nIt is guaranteed that the sum of $n$ and the sum of $k$ over all test cases does not exceed $500$.\n\n### Output\n\nFor each test case, output a single line containing an integer: the number of different deterministic max-heaps produced by applying the aforementioned operation $\\mathrm{add}$ exactly $k$ times, modulo $p$.\n\n### Examples\n\n#### Input #1\n\n```\n\n7\n\n1 13 998244353\n\n2 1 998244353\n\n3 2 998244853\n\n3 3 998244353\n\n3 4 100000037\n\n4 2 100000039\n\n4 3 100000037\n\n```\n\n#### Output #1\n\n```\n1\n2\n12\n52\n124\n32\n304\n```\n\n#### Input #2\n\n```\n\n1\n\n500 500 100000007\n\n```\n\n#### Output #2\n\n```\n76297230\n```\n\n#### Input #3\n\n```\n\n6\n\n87 63 100000037\n\n77 77 100000039\n\n100 200 998244353\n\n200 100 998244353\n\n32 59 998244853\n\n1 1 998244353\n\n```\n\n#### Output #3\n\n```\n26831232\n94573603\n37147649\n847564946\n727060898\n1\n```\n\n### Note\n\nFor the first testcase, there is only one way to generate $a$, and such sequence is a deterministic max-heap, so the answer is $1$.\n\nFor the second testcase, if we choose $v = 1$ and do the operation, we would have $a = [1, 0, 0]$, and since $a_2 = a_3$, we can choose either of them when doing the first $\\mathrm{pop}$ operation, so such heap is not a deterministic max-heap.\n\nAnd if we choose $v = 2$, we would have $a = [1, 1, 0]$, during the first $\\mathrm{pop}$, the following would happen:\n\n- initialize $v$ as $1$\n- since $a_{2v} > a_{2v + 1}$, choose $2v$ as $x$, then $x = 2$\n- assign $a_x$ to $a_v$, then $a = [1, 1, 0]$\n- assign $x$ to $v$, then $v = 2$\n- since $v$ is a leaf, assign $-1$ to $a_v$, then $a = [1, -1, 0]$\n\nSince the first $\\mathrm{pop}$ operation is deterministic, this is a deterministic max-heap. Also, if we choose $v = 3$, $a$ would be a deterministic max-heap, so the answer is $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // For std::fill if needed, though vector::assign is used primarily\n\nusing namespace std;\n\n// Using vectors for DP tables for dynamic sizing and easy clearing between test cases.\nvector<vector<long long>> dpF; // dpF[n][k]: number of deterministic max-heaps of height n using k operations\nvector<vector<long long>> dpG; // dpG[n][k]: total number of distinct max-heaps of height n using k operations\nvector<long long> term1; // Helper array for computation within F calculation\nvector<long long> term2; // Helper array for computation within F calculation\nvector<long long> T_val; // Stores T(S) = Term1(S) + Term2(S) used in F calculation\nlong long p; // Modulus\n\n// Helper function for modular addition\n// Ensures the result is within [0, p-1]\nlong long add(long long a, long long b) {\n    long long res = a + b;\n    if (res >= p) res -= p; \n    return res;\n}\n\n// Helper function for modular multiplication\n// Computes (a * b) % p\nlong long mul(long long a, long long b) {\n    return (a * b) % p;\n}\n\n// Global temporary vector for convolution results (H) needed for G calculation.\n// Declared globally to potentially avoid frequent reallocations, though assign handles this.\nvector<long long> H_glob; \n\n// Function to solve a single test case\nvoid solve() {\n    int n_in, k_in; // Input height N and number of operations K for the current test case\n    cin >> n_in >> k_in >> p; // Read inputs\n\n    // Resize DP tables and helper vectors based on current test case inputs N, K.\n    // Using assign clears previous content and resizes. Initializes with 0.\n    // Size N+1 x K+1 to use 1-based indexing for height n and 0-based for operations k.\n    dpF.assign(n_in + 1, vector<long long>(k_in + 1, 0));\n    dpG.assign(n_in + 1, vector<long long>(k_in + 1, 0));\n    \n    // Resize helper arrays used within the loops. Size K+1 for indices 0..K.\n    term1.assign(k_in + 1, 0);\n    term2.assign(k_in + 1, 0);\n    T_val.assign(k_in + 1, 0);\n    H_glob.assign(k_in + 1, 0);\n\n    // Base case: Tree of height n=1 (a single node)\n    // Any number of operations k results in a_1 = k. A single node tree is trivially a deterministic max-heap.\n    // There is only one distinct configuration for any fixed k.\n    for (int k = 0; k <= k_in; ++k) {\n        dpF[1][k] = 1; // F(1, k) = 1\n        dpG[1][k] = 1; // G(1, k) = 1\n    }\n\n    // Compute DP states level by level (height n) from 2 up to n_in\n    for (int N = 2; N <= n_in; ++N) {\n        // Compute dpG[N][k] for k = 0..k_in using values from dpG[N-1]\n        // G(N, k) = sum_{S=0..k} H(S), where H(S) is the convolution:\n        // H(S) = sum_{kL=0..S} G(N-1, kL) * G(N-1, S-kL)\n        \n        // Clear H_glob for current level N computation before filling\n        fill(H_glob.begin(), H_glob.end(), 0); \n        \n        // Compute H(S) for S = 0..k_in. This is the convolution step.\n        // Implemented naively with O(K^2) complexity overall.\n        // Optimization: iterate kL only up to S/2 utilizing symmetry\n        for (int S = 0; S <= k_in; ++S) {\n            for (int kL = 0; kL <= S / 2; ++kL) {\n                 int kR = S - kL; // Calculate the corresponding kR for the right subtree\n                 if (kL == kR) { // Case when S is even and kL = kR = S/2\n                     // Add the term G(N-1, kL) * G(N-1, kR) once\n                     H_glob[S] = add(H_glob[S], mul(dpG[N-1][kL], dpG[N-1][kR]));\n                 } else { // Case when kL != kR\n                     // Add contribution for pair (kL, kR) and (kR, kL).\n                     // Compute G(N-1, kL) * G(N-1, kR) and add it twice.\n                     long long term = mul(dpG[N-1][kL], dpG[N-1][kR]);\n                     H_glob[S] = add(H_glob[S], add(term, term)); // Effectively term * 2 % p\n                 }\n            }\n        }\n\n        // Compute G(N, k) = sum_{S=0..k} H(S) using prefix sums\n        // G(N, 0) = H(0) = G(N-1, 0) * G(N-1, 0)\n        dpG[N][0] = H_glob[0]; \n        for (int k = 1; k <= k_in; ++k) {\n            // G(N, k) = G(N, k-1) + H(k)\n            dpG[N][k] = add(dpG[N][k-1], H_glob[k]);\n        }\n\n        // Compute dpF[N][k] for k = 0..k_in using values from dpF[N-1] and dpG[N-1]\n        // F(N, k) = sum_{S=0..k} T(S), where T(S) collects terms where kL != kR\n        // T(S) = Term1(S) + Term2(S)\n        // Term1(S) = sum_{kL = floor(S/2)+1 .. S} F(N-1, kL) * G(N-1, S-kL)  (corresponds to kL > kR)\n        // Term2(S) = sum_{kL = 0 .. floor((S-1)/2)} G(N-1, kL) * F(N-1, S-kL) (corresponds to kR > kL)\n\n        // Clear helper arrays for current level N computation\n        fill(term1.begin(), term1.end(), 0);\n        fill(term2.begin(), term2.end(), 0);\n        fill(T_val.begin(), T_val.end(), 0);\n\n        // Compute T(S) = Term1(S) + Term2(S) for S = 1..k_in\n        // T(0) = 0 because F(N, 0) = 0 for N > 1 (heap with all zeros is non-deterministic)\n        for (int S = 1; S <= k_in; ++S) {\n             // Compute Term1(S): Sum over kL from floor(S/2)+1 to S.\n             // This loop iterates roughly S/2 times. Total O(K^2) across all S.\n             for (int kL = S / 2 + 1; kL <= S; ++kL) {\n                 int kR = S - kL; // Calculate kR for the right subtree\n                 term1[S] = add(term1[S], mul(dpF[N-1][kL], dpG[N-1][kR]));\n             }\n\n             // Compute Term2(S): Sum over kL from 0 to floor((S-1)/2).\n             // This loop iterates roughly S/2 times. Total O(K^2) across all S.\n             for (int kL = 0; kL <= (S - 1) / 2; ++kL) {\n                  int kR = S - kL; // Calculate kR for the right subtree\n                  term2[S] = add(term2[S], mul(dpG[N-1][kL], dpF[N-1][kR]));\n             }\n             // T(S) combines contributions where kL > kR and kR > kL\n             T_val[S] = add(term1[S], term2[S]);\n        }\n\n        // Compute F(N, k) = sum_{S=0..k} T(S) using prefix sums\n        // F(N, 0) = 0 for N > 1, as the all-zero heap has a_2=a_3=0, hence non-deterministic.\n        dpF[N][0] = 0; \n        for (int k = 1; k <= k_in; ++k) {\n            // F(N, k) = F(N, k-1) + T(k)\n            dpF[N][k] = add(dpF[N][k-1], T_val[k]);\n        }\n    }\n\n    // The final answer is the number of deterministic max-heaps for height n_in with k_in operations.\n    cout << dpF[n_in][k_in] << endl;\n}\n\nint main() {\n    // Use fast I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        solve(); // Solve each test case\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2001b",
      "PROBLEM_ID": "2001B",
      "PROBLEM_STATEMENT": "There is an integer sequence $a$ of length $n$, where each element is initially $-1$.\n\nMisuki has two typewriters where the first one writes letters from left to right, with a pointer initially pointing to $1$, and another writes letters from right to left with a pointer initially pointing to $n$.\n\nMisuki would choose one of the typewriters and use it to perform the following operations until $a$ becomes a permutation of $[1, 2, \\ldots, n]$\n\n- write number: write the minimum positive integer that isn't present in the array $a$ to the element $a_i$, $i$ is the position where the pointer points at. Such operation can be performed only when $a_i = -1$.\n- carriage return: return the pointer to its initial position (i.e. $1$ for the first typewriter, $n$ for the second)\n- move pointer: move the pointer to the next position, let $i$ be the position the pointer points at before this operation, if Misuki is using the first typewriter, $i := i + 1$ would happen, and $i := i - 1$ otherwise. Such operation can be performed only if after the operation, $1 \\le i \\le n$ holds.\n\nYour task is to construct any permutation $p$ of length $n$, such that the minimum number of carriage return operations needed to make $a = p$ is the same no matter which typewriter Misuki is using.\n\n### Input\n\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 500$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the permutation.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a line of $n$ integers, representing the permutation $p$ of length $n$ such that the minimum number of carriage return operations needed to make $a = p$ is the same no matter which typewriter Misuki is using, or $-1$ if it is impossible to do so.\n\nIf there are multiple valid permutations, you can output any of them.\n\n### Example\n\n#### Input #1\n\n```\n3\n1\n2\n3\n```\n\n#### Output #1\n\n```\n1\n-1\n3 1 2```\n\n### Note\n\nIn the first testcase, it's possible to make $a = p = [1]$ using $0$ carriage return operations.\n\nIn the second testcase, it is possible to make $a = p = [1, 2]$ with the minimal number of carriage returns as follows:\n\nIf Misuki is using the first typewriter:\n\n- Write number: write $1$ to $a_1$, $a$ becomes $[1, -1]$\n- Move pointer: move the pointer to the next position. (i.e. $2$)\n- Write number: write $2$ to $a_2$, $a$ becomes $[1, 2]$\n\nIf Misuki is using the second typewriter:\n\n- Move pointer: move the pointer to the next position. (i.e. $1$)\n- Write number: write $1$ to $a_1$, $a$ becomes $[1, -1]$\n- Carriage return: return the pointer to $2$.\n- Write number: write $2$ to $a_2$, $a$ becomes $[1, 2]$\n\nIt can be proven that the minimum number of carriage returns needed to transform $a$ into $p$ when using the first typewriter is $0$ and it is $1$ when using the second one, so this permutation is not valid.\n\nSimilarly, $p = [2, 1]$ is also not valid, so there is no solution for $n = 2$.\n\nIn the third testcase, it is possibile to make $a = p = [3, 1, 2]$ with $1$ carriage return with both the first and the second typewriter. It can be proven that, for both typewriters, it is impossible to write $p$ with $0$ carriage returns.\n\nWith the first typewriter it is possible to:\n\n- Move pointer: move the pointer to the next position. (i.e. $2$)\n- Write number: write $1$ to $a_2$, $a$ becomes $[-1, 1, -1]$\n- Move pointer: move the pointer to the next position. (i.e. $3$)\n- Write number: write $2$ to $a_3$, $a$ becomes $[-1, 1, 2]$\n- Carriage return: return the pointer to $1$.\n- Write number: write $3$ to $a_1$, $a$ becomes $[3,1,2]$\n\nWith the second typewriter it is possible to:\n\n- Move pointer: move the pointer to the next position. (i.e. $2$)\n- Write number: write $1$ to $a_2$, $a$ becomes $[-1, 1, -1]$\n- Carriage return: return the pointer to $3$.\n- Write number: write $2$ to $a_3$, $a$ becomes $[-1, 1, 2]$\n- Move pointer: move the pointer to the next position. (i.e. $2$)\n- Move pointer: move the pointer to the next position. (i.e. $1$)\n- Write number: write $3$ to $a_1$, $a$ becomes $[3, 1, 2]$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid solve() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        \n        if (n % 2 == 0) {\n            // If `n` is even, output -1\n            cout << -1 << endl;\n        } else {\n            // Generate the valid permutation for odd `n`\n            vector<int> p;\n            int left = 1, right = n;\n            bool toggle = false;\n            while (left <= right) {\n                if (!toggle) {\n                    p.push_back(right--);\n                } else {\n                    p.push_back(left++);\n                }\n                toggle = !toggle;\n            }\n            for (int i = 0; i < n; i++) {\n                if (i > 0) cout << \" \";\n                cout << p[i];\n            }\n            cout << endl;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    solve();\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2001a",
      "PROBLEM_ID": "2001A",
      "PROBLEM_STATEMENT": "You are given a cyclic array $a_1, a_2, \\ldots, a_n$.\n\nYou can perform the following operation on $a$ at most $n - 1$ times:\n\n- Let $m$ be the current size of $a$, you can choose any two adjacent elements where the previous one is no greater than the latter one (In particular, $a_m$ and $a_1$ are adjacent and $a_m$ is the previous one), and delete exactly one of them. In other words, choose an integer $i$ ($1 \\leq i \\leq m$) where $a_i \\leq a_{(i \\bmod m) + 1}$ holds, and delete exactly one of $a_i$ or $a_{(i \\bmod m) + 1}$ from $a$.\n\nYour goal is to find the minimum number of operations needed to make all elements in $a$ equal.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the elements of array $a$.\n\n### Output\n\nFor each test case, output a single line containing an integer: the minimum number of operations needed to make all elements in $a$ equal.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n1\n\n1\n\n3\n\n1 2 3\n\n3\n\n1 2 2\n\n5\n\n5 4 3 2 1\n\n6\n\n1 1 2 2 3 3\n\n8\n\n8 7 6 3 8 7 6 3\n\n6\n\n1 1 4 5 1 4\n\n```\n\n#### Output #1\n\n```\n0\n2\n1\n4\n4\n6\n3\n```\n\n### Note\n\nIn the first test case, there is only one element in $a$, so we can't do any operation.\n\nIn the second test case, we can perform the following operations to make all elements in $a$ equal:\n\n- choose $i = 2$, delete $a_3$, then $a$ would become $[1, 2]$.\n- choose $i = 1$, delete $a_1$, then $a$ would become $[2]$.\n\nIt can be proven that we can't make all elements in $a$ equal using fewer than $2$ operations, so the answer is $2$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(vector<int>& a) {\n    int n = a.size();\n    if (n == 1) return 0;\n    \n    // Try keeping each possible value and calculate minimum operations needed\n    int min_ops = n;  // Initialize with maximum possible operations\n    \n    for (int keep_val : a) {\n        // For each value, try to keep it and remove others\n        vector<int> curr = a;\n        int ops = 0;\n        int curr_size = n;\n        \n        while (curr_size > 1) {\n            bool found = false;\n            // Try to find a pair where we can remove one element\n            for (int i = 0; i < curr_size && !found; i++) {\n                int next_i = (i + 1) % curr_size;\n                if (curr[i] <= curr[next_i]) {\n                    // If current element is not the value we want to keep, remove it\n                    if (curr[i] != keep_val) {\n                        curr.erase(curr.begin() + i);\n                        found = true;\n                    }\n                    // If next element is not the value we want to keep, remove it\n                    else if (curr[next_i] != keep_val) {\n                        curr.erase(curr.begin() + next_i);\n                        found = true;\n                    }\n                }\n            }\n            \n            if (!found) break;  // If we can't make any more removals\n            ops++;\n            curr_size--;\n        }\n        \n        // Check if all remaining elements are equal\n        bool all_equal = true;\n        for (int i = 0; i < curr_size; i++) {\n            if (curr[i] != keep_val) {\n                all_equal = false;\n                break;\n            }\n        }\n        \n        if (all_equal) {\n            min_ops = min(min_ops, ops);\n        }\n    }\n    \n    return min_ops == n ? -1 : min_ops;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        cout << solve(a) << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2000g",
      "PROBLEM_ID": "2000G",
      "PROBLEM_STATEMENT": "You live in a city consisting of $n$ intersections and $m$ streets connecting some pairs of intersections. You can travel in either direction on each street. No two streets connect the same pair of intersections, and no street connects an intersection to itself. You can reach any intersection from any other, possibly passing through some other intersections.\n\nEvery minute, you can board a bus at intersection $u_i$ and travel for $l_{i1}$ minutes to intersection $v_i$. Conversely, you can travel from intersection $v_i$ to intersection $u_i$ in $l_{i1}$ minutes. You can only board and exit the bus at intersections. You can only board the bus at an intersection if you are currently there.\n\nYou can also walk along each street, which takes $l_{i2} > l_{i1}$ minutes.\n\nYou can make stops at intersections.\n\nYou live at intersection number $1$. Today you woke up at time $0$, and you have an important event scheduled at intersection number $n$, which you must reach no later than time $t_0$. You also have a phone call planned that will last from $t_1$ to $t_2$ minutes ($t_1 < t_2 < t_0$).\n\nDuring the phone call, you cannot ride the bus, but you can walk along any streets, make stops, or stay at home. You can exit the bus at minute $t_1$ and board the bus again at minute $t_2$.\n\nSince you want to get enough sleep, you became curious \u2014 how late can you leave home to have time to talk on the phone and still not be late for the event?\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The following are the descriptions of the test cases.\n\nThe first line of each test case contains two integers $n$, $m$ ($2 \\le n \\le 10^5, 1 \\le m \\le 10^5$) \u2014 the number of intersections and streets in the city.\n\nThe second line of each test case contains three integers $t_0$, $t_1$, $t_2$ ($1 \\le t_1 < t_2 < t_0 \\le 10^9$) \u2014 the start time of the event, the start time of the phone call, and its end time, respectively.\n\nThe next $m$ lines of each test case contain descriptions of the streets.\n\nThe $i$-th line contains four integers $u_i$, $v_i$, $l_{i1}$, $l_{i2}$ ($1 \\le u_i, v_i \\le n$, $u_i \\neq v_i$, $1 \\le l_{i1} < l_{i2} \\le 10^9$) \u2014 the numbers of the intersections connected by the $i$-th street, as well as the travel time along the street by bus and on foot. It is guaranteed that no two streets connect the same pair of intersections and that it is possible to reach any intersection from any other.\n\nIt is guaranteed that the sum of the values of $n$ across all test cases does not exceed $10^5$. It is also guaranteed that the sum of the values of $m$ across all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the latest time you can leave home to have time to talk on the phone and not be late for the event. If you cannot reach the event on time, output -1.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n5 5\n\n100 20 80\n\n1 5 30 100\n\n1 2 20 50\n\n2 3 20 50\n\n3 4 20 50\n\n4 5 20 50\n\n2 1\n\n100 50 60\n\n1 2 55 110\n\n4 4\n\n100 40 60\n\n1 2 30 100\n\n2 4 30 100\n\n1 3 20 50\n\n3 4 20 50\n\n3 3\n\n100 80 90\n\n1 2 1 10\n\n2 3 10 50\n\n1 3 20 21\n\n3 2\n\n58 55 57\n\n2 1 1 3\n\n2 3 3 4\n\n2 1\n\n12 9 10\n\n2 1 6 10\n\n5 5\n\n8 5 6\n\n2 1 1 8\n\n2 3 4 8\n\n4 2 2 4\n\n5 3 3 4\n\n4 5 2 6\n\n```\n\n#### Output #1\n\n```\n0\n-1\n60\n80\n53\n3\n2\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <limits> // Required for numeric_limits\n\nusing namespace std;\n\n// Define long long type alias for convenience\ntypedef long long ll;\n\n// Define a large constant for infinity. \n// Using approximately half of LL max to prevent overflow issues when adding edge weights.\n// The maximum possible arrival time could be around N * max_edge_weight ~ 10^5 * 10^9 = 10^14, \n// which fits within long long (~9e18).\nconst ll INF = numeric_limits<ll>::max() / 2; \n\n// Structure to represent state in Dijkstra's algorithm (current time, current vertex)\nstruct State {\n    ll time; // Current time at vertex u\n    int u;    // Current vertex u\n\n    // Custom comparator for the priority queue to make it a min-heap.\n    // Orders states primarily by time (ascending).\n    // Using > operator for min-heap behavior with std::priority_queue.\n    bool operator>(const State& other) const {\n       return time > other.time;\n    }\n};\n\n// Function check(D): Determines if it's possible to reach destination 'n' by time 't0',\n// starting from node 1 at departure time 'D', while respecting the phone call constraint.\n// The phone call is from time t1 to t2 (interpreted as interval [t1, t2)). \n// During this interval, travel by bus is forbidden.\n// Uses a modified Dijkstra algorithm.\nbool check(int n, const vector<vector<tuple<int, ll, ll>>>& adj, ll t0, ll t1, ll t2, ll D) {\n    // dist[i] stores the minimum arrival time at intersection i found so far. Initialize to infinity.\n    vector<ll> dist(n + 1, INF);\n    \n    // Priority queue for Dijkstra. Stores {time, vertex} states. Uses the State comparator for min-heap behavior.\n    priority_queue<State, vector<State>, greater<State>> pq;\n\n    // Initialize the starting state: at node 1 at departure time D.\n    dist[1] = D;\n    pq.push({D, 1});\n\n    // Main Dijkstra loop continues as long as there are states to process.\n    while (!pq.empty()) {\n        // Extract the state with the minimum time from the priority queue.\n        State current = pq.top();\n        pq.pop();\n\n        ll currentTime = current.time; // Time of arrival at node u for this path\n        int u = current.u;             // Current intersection\n\n        // If we've already found a path to 'u' that arrives at or before 'currentTime',\n        // then this extracted state is redundant (or not better). Skip it.\n        // Note: Using '>' is standard. If `currentTime == dist[u]`, it means we found this path before, \n        // or another path arrived at the same time. Processing it again won't yield a shorter path from `u`.\n        if (currentTime > dist[u]) {\n            continue;\n        }\n        \n        // Optimization: If the current time already exceeds the deadline t0,\n        // any path extending from this state will also arrive after t0 (since travel times are non-negative).\n        // So, we can prune this branch of exploration.\n        // We need '<=' check for t0 because arriving exactly at t0 is allowed.\n         if (currentTime > t0) {\n              continue;\n         }\n\n        // Explore neighbors 'v' connected to 'u' by streets.\n        for (const auto& edge : adj[u]) {\n            int v;    // Neighbor intersection\n            ll l1;    // Bus travel time for street (u, v)\n            ll l2;    // Walk travel time for street (u, v)\n            tie(v, l1, l2) = edge;\n\n            // --- Option 1: Travel by Bus ---\n            ll arrivalTimeBus = currentTime + l1; // Calculate arrival time if taking the bus now.\n            \n            // Check the phone call constraint. Bus travel is forbidden if the time interval\n            // spent on the bus, (currentTime, arrivalTimeBus), overlaps with the phone call interval [t1, t2).\n            // Non-overlap condition: arrivalTimeBus <= t1 OR currentTime >= t2.\n            bool can_take_bus_now = (arrivalTimeBus <= t1) || (currentTime >= t2);\n\n            if (can_take_bus_now) {\n                 // If the bus is allowed now, check if this path improves the shortest distance to 'v'.\n                 // We also check if the arrival time is within the deadline t0. Although the check at the start\n                 // of the loop helps, checking here ensures we don't push states that are already too late.\n                if (arrivalTimeBus < dist[v] && arrivalTimeBus <= t0) {\n                    dist[v] = arrivalTimeBus; // Update the minimum arrival time at 'v'.\n                    pq.push({arrivalTimeBus, v}); // Add the new state {arrivalTimeBus, v} to the priority queue.\n                }\n            } else {\n                // Option 1b: Bus is forbidden now because of the phone call overlap.\n                // This implies: currentTime < t2 AND arrivalTimeBus > t1.\n                // Consider waiting at node 'u' until the phone call ends at time t2, then take the bus.\n                // This is only relevant if we are currently before t2.\n                if (currentTime < t2) { \n                    ll wait_until = t2; // Earliest time we can depart by bus after the call.\n                    ll arrivalTimeBusAfterWait = wait_until + l1; // Arrival time at 'v' after waiting and taking the bus.\n                     \n                     // Check if this alternative path (wait + bus) improves the shortest distance to 'v'\n                     // and arrives within the deadline t0.\n                     if (arrivalTimeBusAfterWait < dist[v] && arrivalTimeBusAfterWait <= t0) {\n                         dist[v] = arrivalTimeBusAfterWait; // Update the minimum arrival time at 'v'.\n                         pq.push({arrivalTimeBusAfterWait, v}); // Add the new state to the priority queue.\n                    }\n                 }\n            }\n\n            // --- Option 2: Travel by Walking ---\n            ll arrivalTimeWalk = currentTime + l2; // Calculate arrival time if walking.\n            // Walking is always permitted, regardless of the phone call.\n            // Check if this path improves the shortest distance to 'v' and arrives within the deadline t0.\n            if (arrivalTimeWalk < dist[v] && arrivalTimeWalk <= t0) {\n                dist[v] = arrivalTimeWalk; // Update the minimum arrival time at 'v'.\n                pq.push({arrivalTimeWalk, v}); // Add the new state to the priority queue.\n            }\n        }\n    }\n\n    // After the Dijkstra algorithm finishes, dist[n] holds the minimum arrival time at the destination 'n'.\n    // If dist[n] is still INF, 'n' is unreachable.\n    // The function returns true if 'n' is reachable and the arrival time is not later than t0.\n    return dist[n] <= t0;\n}\n\nint main() {\n    // Optimize standard input/output operations for speed.\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        int n; // Number of intersections\n        int m; // Number of streets\n        cin >> n >> m; \n        \n        ll t0, t1, t2; // Event deadline, phone call start time, phone call end time\n        cin >> t0 >> t1 >> t2;\n\n        // Represent the city map using an adjacency list.\n        // adj[i] stores a vector of tuples for streets connected to intersection i.\n        // Each tuple: {neighbor_node, bus_time, walk_time}\n        vector<vector<tuple<int, ll, ll>>> adj(n + 1);\n        for (int i = 0; i < m; ++i) {\n            int u, v;\n            ll l1, l2; // Bus time, Walk time\n            cin >> u >> v >> l1 >> l2;\n            // Since streets are bidirectional, add the edge in both directions.\n            adj[u].emplace_back(v, l1, l2);\n            adj[v].emplace_back(u, l1, l2);\n        }\n\n        // Binary search for the latest possible departure time D.\n        // The search range for D is [0, t0].\n        ll low = 0, high = t0, ans = -1; // Initialize answer to -1 (representing impossible).\n\n        while (low <= high) {\n            // Calculate the midpoint safely to avoid potential overflow for large low/high values.\n            ll mid = low + (high - low) / 2; \n            // Call the check function to see if departing at time 'mid' works.\n            if (check(n, adj, t0, t1, t2, mid)) {\n                // If departing at 'mid' is feasible, it becomes a potential answer.\n                // We try to find an even later departure time, so we search in the upper half [mid+1, high].\n                ans = mid;          \n                low = mid + 1;      \n            } else {\n                // If departing at 'mid' is not feasible, it's too late.\n                // We must leave earlier, so we search in the lower half [low, mid-1].\n                high = mid - 1;     \n            }\n        }\n        // Output the final answer (the latest feasible departure time found).\n        cout << ans << \"\\n\"; \n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2000f",
      "PROBLEM_ID": "2000F",
      "PROBLEM_STATEMENT": "You have $n$ rectangles, the $i$-th of which has a width of $a_i$ and a height of $b_i$.\n\nYou can perform the following operation an unlimited number of times: choose a rectangle and a cell in it, and then color it.\n\nEach time you completely color any row or column, you earn $1$ point. Your task is to score at least $k$ points with as few operations as possible.\n\nSuppose you have a rectangle with a width of $6$ and a height of $3$. You can score $4$ points by coloring all the cells in any $4$ columns, thus performing $12$ operations.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases. The following are the descriptions of the test cases.\n\nThe first line of each test case description contains two integers $n$ and $k$ ($1 \\le n \\le 1000, 1 \\le k \\le 100$) \u2014 the number of rectangles in the case and the required number of points.\n\nThe next $n$ lines contain the descriptions of the rectangles. The $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 100$) \u2014 the width and height of the $i$-th rectangle.\n\nIt is guaranteed that the sum of the values of $n$ across all test cases does not exceed $1000$.\n\n### Output\n\nFor each test case, output a single integer \u2014 the minimum number of operations required to score at least $k$ points. If it is impossible to score at least $k$ points, output -1.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n1 4\n\n6 3\n\n1 5\n\n4 4\n\n5 10\n\n1 1\n\n1 1\n\n1 1\n\n1 1\n\n1 1\n\n2 100\n\n1 2\n\n5 6\n\n3 11\n\n2 2\n\n3 3\n\n4 4\n\n3 25\n\n9 2\n\n4 3\n\n8 10\n\n4 18\n\n5 4\n\n8 5\n\n8 3\n\n6 2\n\n```\n\n#### Output #1\n\n```\n12\n14\n5\n-1\n17\n80\n35\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<pair<int, int>> rectangles(n);\n    int max_total_points = 0;\n    for (int i = 0; i < n; ++i) {\n        cin >> rectangles[i].first >> rectangles[i].second;\n        max_total_points += rectangles[i].first + rectangles[i].second;\n    }\n\n    if (max_total_points < k) {\n        return -1;\n    }\n\n    vector<vector<int>> costs(n, vector<int>(201, -1));\n\n    for (int i = 0; i < n; ++i) {\n        int a = rectangles[i].first;\n        int b = rectangles[i].second;\n        for (int p = 0; p <= a + b; ++p) {\n            int min_ops = -1;\n            for (int r = max(0, p - a); r <= min(p, b); ++r) {\n                int c = p - r;\n                int ops = r * a + c * b - r * c;\n                if (min_ops == -1 || ops < min_ops) {\n                    min_ops = ops;\n                }\n            }\n            costs[i][p] = min_ops;\n        }\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 1e9 + 7));\n    dp[0][0] = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        int a_i = rectangles[i - 1].first;\n        int b_i = rectangles[i - 1].second;\n        for (int j = 0; j <= k; ++j) {\n            for (int p = 0; p <= a_i + b_i; ++p) {\n                int prev_points_needed = max(0, j - p);\n                if (prev_points_needed <= k && costs[i - 1][p] != -1) {\n                    dp[i][j] = min(dp[i][j], dp[i - 1][prev_points_needed] + costs[i - 1][p]);\n                }\n            }\n        }\n    }\n\n    if (dp[n][k] >= 1e9 + 7) {\n        return -1;\n    } else {\n        return dp[n][k];\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        cout << solve() << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2000e",
      "PROBLEM_ID": "2000E",
      "PROBLEM_STATEMENT": "You really love gorillas, so you decided to organize a photoshoot for them. Gorillas live in the jungle. The jungle is represented as a grid of $n$ rows and $m$ columns. $w$ gorillas agreed to participate in the photoshoot, and the gorilla with index $i$ ($1 \\le i \\le w$) has a height of $a_i$. You want to place all the gorillas in the cells of the grid such that there is no more than one gorilla in each cell.\n\nThe spectacle of the arrangement is equal to the sum of the spectacles of all sub-squares of the grid with a side length of $k$.\n\nThe spectacle of a sub-square is equal to the sum of the heights of the gorillas in it.\n\nFrom all suitable arrangements, choose the arrangement with the maximumspectacle.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^3$)\u00a0\u2014 the number of test cases.\n\nThe descriptions of the test cases follow.\n\nThe first line contains integers $n$, $m$, $k$ ($1 \\le n, m \\le 2 \\cdot 10^5$, $1 \\le n \\cdot m \\le 2 \\cdot 10^5$, $1 \\le k \\le \\min(n, m)$)\u00a0\u2014 the dimensions of the grid and the side length of the square.\n\nThe second line contains an integer $w$ ($1 \\le w \\le n \\cdot m$)\u00a0\u2014 the number of gorillas.\n\nThe third line contains $w$ integers $a_1, a_2, \\ldots, a_w$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the heights of the gorillas.\n\nIt is guaranteed that the sum of $n \\cdot m$ across all test cases does not exceed $2 \\cdot 10^5$. The same guarantee applies to $w$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximumspectacle of a suitable arrangement.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3 4 2\n\n9\n\n1 1 1 1 1 1 1 1 1\n\n2 1 1\n\n2\n\n5 7\n\n20 15 7\n\n9\n\n4 1 4 5 6 1 1000000000 898 777\n\n1984 1 1\n\n4\n\n5 4 1499 2004\n\n9 5 5\n\n6\n\n6 7 14 16 16 6\n\n```\n\n#### Output #1\n\n```\n21\n12\n49000083104\n3512\n319\n```\n\n### Note\n\nIn the first test case of the first input set, the spectacle of the following sub-squares is summed:\n\n![](https://espresso.codeforces.com/fcecb8349be690c7d5ebb99bd46d5ef17ce8ac3e.png)Yellow color corresponds to the sub-squares, green\u00a0\u2014 to the rest of the grid squares.\n\nThe picture shows the optimal arrangement of the gorillas. The spectacle of the arrangement is $4 + 4 + 3 + 3 + 4 + 3 = 21$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvoid solve() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    int w;\n    cin >> w;\n    vector<ll> a(w);\n    for(int i = 0; i < w; i++) {\n        cin >> a[i];\n    }\n    \n    // Sort gorillas in descending order to place highest ones first\n    sort(a.rbegin(), a.rend());\n    \n    // Calculate how many times each cell contributes to k\u00d7k squares\n    vector<vector<int>> contribution(n, vector<int>(m, 0));\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            // For each cell, count in how many k\u00d7k squares it appears\n            int top = max(0, i - k + 1);\n            int left = max(0, j - k + 1);\n            int bottom = min(n - k, i);\n            int right = min(m - k, j);\n            contribution[i][j] = (bottom - top + 1) * (right - left + 1);\n        }\n    }\n    \n    // Create priority queue of cells based on their contribution\n    priority_queue<pair<int, pair<int, int>>> pq;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            pq.push({contribution[i][j], {i, j}});\n        }\n    }\n    \n    // Place gorillas in cells with highest contribution\n    ll result = 0;\n    int idx = 0;\n    vector<vector<ll>> grid(n, vector<ll>(m, 0));\n    \n    while(!pq.empty() && idx < w) {\n        auto [cont, pos] = pq.top();\n        pq.pop();\n        auto [i, j] = pos;\n        grid[i][j] = a[idx++];\n    }\n    \n    // Calculate total spectacle\n    for(int i = 0; i <= n-k; i++) {\n        for(int j = 0; j <= m-k; j++) {\n            ll square_sum = 0;\n            for(int x = i; x < i+k; x++) {\n                for(int y = j; y < j+k; y++) {\n                    square_sum += grid[x][y];\n                }\n            }\n            result += square_sum;\n        }\n    }\n    \n    cout << result << \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2000d",
      "PROBLEM_ID": "2000D",
      "PROBLEM_STATEMENT": "Vlad found a strip of $n$ cells, numbered from left to right from $1$ to $n$. In the $i$-th cell, there is a positive integer $a_i$ and a letter $s_i$, where all $s_i$ are either 'L' or 'R'.\n\nVlad invites you to try to score the maximum possible points by performing any (possibly zero) number of operations.\n\nIn one operation, you can choose two indices $l$ and $r$ ($1 \\le l < r \\le n$) such that $s_l$ = 'L' and $s_r$ = 'R' and do the following:\n\n- add $a_l + a_{l + 1} + \\dots + a_{r - 1} + a_r$ points to the current score;\n- replace $s_i$ with '.' for all $l \\le i \\le r$, meaning you can no longer choose these indices.\n\nFor example, consider the following strip:\n\n$3\n\n$$5$$\n\n1\n\n$$4$$\n\n3$$2$LRLLLR\n\nYou can first choose $l = 1$, $r = 2$ and add $3 + 5 = 8$ to your score.\n\n$3\n\n$$5$$\n\n1\n\n$$4$$\n\n3$$2$..LLLR\n\nThen choose $l = 3$, $r = 6$ and add $1 + 4 + 3 + 2 = 10$ to your score.\n\n$3\n\n$$5$$\n\n1\n\n$$4$$\n\n3$$2$......\n\nAs a result, it is impossible to perform another operation, and the final score is $18$.\n\nWhat is the maximum score that can be achieved?\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of the strip.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^5$)\u00a0\u2014 the numbers written on the strip.\n\nThe third line of each test case contains a string $s$ of $n$ characters 'L' and 'R'.\n\nIt is guaranteed that the sum of the values of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output one integer\u00a0\u2014 the maximum possible number of points that can be scored.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n6\n\n3 5 1 4 3 2\n\nLRLLLR\n\n2\n\n2 8\n\nLR\n\n2\n\n3 9\n\nRL\n\n5\n\n1 2 3 4 5\n\nLRLRR\n\n```\n\n#### Output #1\n\n```\n18\n10\n0\n22\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 1e6 + 5;\nconst int INF = 1e9 + 7;\n\nvoid solve(){\n  int n; cin >> n;\n  vector<ll> v(n);\n  for(int i=0;i<n;i++) cin >> v[i];\n  string s; cin >> s;\n  for(int i=1;i<n;i++) v[i]+=v[i-1];\n  int l=0,r=n-1;\n  ll ans=0;\n  while(l<r){\n    while (l < n && s[l] != 'L') l++;\n    while (r >= 0 && s[r] != 'R') r--;\n\n    if(l>=r || l>n-1 || r<0) break;\n    ans += v[r]-(l-1>=0 ? v[l-1]:0);\n    l++,r--;\n  }\n  cout << ans << endl;\n}\nint main() {\n    int t;\n    cin >> t;\n    while (t--) solve();\n    return 0;\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-2000b",
      "PROBLEM_ID": "2000B",
      "PROBLEM_STATEMENT": "In Berland, a bus consists of a row of $n$ seats numbered from $1$ to $n$. Passengers are advised to always board the bus following these rules:\n\n- If there are no occupied seats in the bus, a passenger can sit in any free seat;\n- Otherwise, a passenger should sit in any free seat that has at least one occupied neighboring seat. In other words, a passenger can sit in a seat with index $i$ ($1 \\le i \\le n$) only if at least one of the seats with indices $i-1$ or $i+1$ is occupied.\n\nToday, $n$ passengers boarded the bus. The array $a$ chronologically records the seat numbers they occupied. That is, $a_1$ contains the seat number where the first passenger sat, $a_2$ \u2014 the seat number where the second passenger sat, and so on.\n\nYou know the contents of the array $a$. Determine whether all passengers followed the recommendations.\n\nFor example, if $n = 5$, and $a$ = \\[$5, 4, 2, 1, 3$\\], then the recommendations were not followed, as the $3$-rd passenger sat in seat number $2$, while the neighboring seats with numbers $1$ and $3$ were free.\n\n### Input\n\nThe first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe following describes the input test cases.\n\nThe first line of each test case contains exactly one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of seats in the bus and the number of passengers who boarded the bus.\n\nThe second line of each test case contains $n$ distinct integers $a_i$ ($1 \\le a_i \\le n$) \u2014 the seats that the passengers occupied in chronological order.\n\nIt is guaranteed that the sum of $n$ values across all test cases does not exceed $2 \\cdot 10^5$, and that no passenger sits in an already occupied seat.\n\n### Output\n\nFor each test case, output on a separate line:\n\n- \"YES\", if all passengers followed the recommendations;\n- \"NO\" otherwise.\n\nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n5\n\n5 4 2 1 3\n\n3\n\n2 3 1\n\n4\n\n2 3 1 4\n\n5\n\n1 2 3 5 4\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nYES\nNO```\n\n### Note\n\nThe first test case is explained in the problem statement.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nbool solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<bool> is_occupied(n, false);\n    for (int i = 0; i < n; ++i) {\n        int seat_number = a[i];\n        if (i == 0) {\n            is_occupied[seat_number - 1] = true;\n        } else {\n            bool has_occupied_neighbor = false;\n            if (seat_number == 1) {\n                if (n > 1 && is_occupied[1]) {\n                    has_occupied_neighbor = true;\n                }\n            } else if (seat_number == n) {\n                if (n > 1 && is_occupied[n - 2]) {\n                    has_occupied_neighbor = true;\n                }\n            } else {\n                if (is_occupied[seat_number - 2] || is_occupied[seat_number]) {\n                    has_occupied_neighbor = true;\n                }\n            }\n            if (!has_occupied_neighbor) {\n                return false;\n            }\n            is_occupied[seat_number - 1] = true;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        if (solve()) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1999f",
      "PROBLEM_ID": "1999F",
      "PROBLEM_STATEMENT": "Arul has a binary array$^{\\text{\u2217}}$ $a$ of length $n$.\n\nHe will take all subsequences$^{\\text{\u2020}}$ of length $k$ ($k$ is odd) of this array and find their median.$^{\\text{\u2021}}$\n\nWhat is the sum of all these values?\n\nAs this sum can be very large, output it modulo $10^9 + 7$. In other words, print the remainder of this sum when divided by $10^9 + 7$.\n\n$^{\\text{\u2217}}$A binary array is an array consisting only of zeros and ones.\n\n$^{\\text{\u2020}}$An array $b$ is a subsequence of an array $a$ if $b$ can be obtained from $a$ by the deletion of several (possibly, zero or all) elements. Subsequences don't have to be contiguous.\n\n$^{\\text{\u2021}}$The median of an array of odd length $k$ is the $\\frac{k+1}{2}$-th element when sorted.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\leq k \\leq n \\leq 2 \\cdot 10^5$, $k$ is odd)\u00a0\u2014 the length of the array and the length of the subsequence, respectively.\n\nThe second line of each test case contains $n$ integers $a_i$ ($0 \\leq a_i \\leq 1$)\u00a0\u2014 the elements of the array.\n\nIt is guaranteed that sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print the sum modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n4 3\n\n1 0 0 1\n\n5 1\n\n1 1 1 1 1\n\n5 5\n\n0 1 0 1 0\n\n6 3\n\n1 0 1 0 1 1\n\n4 3\n\n1 0 1 1\n\n5 3\n\n1 0 1 1 0\n\n2 1\n\n0 0\n\n34 17\n\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n```\n\n#### Output #1\n\n```\n2\n5\n0\n16\n4\n7\n0\n333606206\n```\n\n### Note\n\nIn the first test case, there are four subsequences of $[1,0,0,1]$ with length $k=3$:\n\n- $[1,0,0]$: median $= 0$.\n- $[1,0,1]$: median $= 1$.\n- $[1,0,1]$: median $= 1$.\n- $[0,0,1]$: median $= 0$.\n\nThe sum of the results is $0+1+1+0=2$.\n\nIn the second test case, all subsequences of length $1$ have median $1$, so the answer is $5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nlong long power(long long base, long long exp) {\n    long long res = 1;\n    base %= 1000000007;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % 1000000007;\n        base = (base * base) % 1000000007;\n        exp /= 2;\n    }\n    return res;\n}\n\nlong long modInverse(long long n) {\n    return power(n, 1000000007 - 2);\n}\n\nlong long nCrModPFermat(int n, int r, const vector<long long>& fact, const vector<long long>& invFact) {\n    if (r < 0 || r > n) return 0;\n    return (((fact[n] * invFact[r]) % 1000000007) * invFact[n - r]) % 1000000007;\n}\n\nint main() {\n    vector<long long> fact(200001);\n    vector<long long> invFact(200001);\n    fact[0] = 1;\n    invFact[0] = 1;\n    for (int i = 1; i <= 200000; i++) {\n        fact[i] = (fact[i - 1] * i) % 1000000007;\n        invFact[i] = modInverse(fact[i]);\n    }\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        int count_zeros = 0;\n        int count_ones = 0;\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            if (a[i] == 0) {\n                count_zeros++;\n            } else {\n                count_ones++;\n            }\n        }\n\n        int m = (k + 1) / 2;\n        int l = max(m, k - count_zeros);\n        int r = min(count_ones, k);\n\n        long long total_sum = 0;\n        if (l <= r) {\n            for (int i = l; i <= r; i++) {\n                long long combinations_ones = nCrModPFermat(count_ones, i, fact, invFact);\n                long long combinations_zeros = nCrModPFermat(count_zeros, k - i, fact, invFact);\n                total_sum = (total_sum + (combinations_ones * combinations_zeros) % 1000000007) % 1000000007;\n            }\n        }\n\n        cout << total_sum << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1999e",
      "PROBLEM_ID": "1999E",
      "PROBLEM_STATEMENT": "On the board Ivy wrote down all integers from $l$ to $r$, inclusive.\n\nIn an operation, she does the following:\n\n- pick two numbers $x$ and $y$ on the board, erase them, and in their place write the numbers $3x$ and $\\lfloor \\frac{y}{3} \\rfloor$. (Here $\\lfloor \\bullet \\rfloor$ denotes rounding down to the nearest integer).\n\nWhat is the minimum number of operations Ivy needs to make all numbers on the board equal $0$? We have a proof that this is always possible.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains two integers $l$ and $r$ ($1 \\leq l < r \\leq 2 \\cdot 10^5$).\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations needed to make all numbers on the board equal $0$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1 3\n\n2 4\n\n199999 200000\n\n19 84\n\n```\n\n#### Output #1\n\n```\n5\n6\n36\n263\n```\n\n### Note\n\nIn the first test case, we can perform $5$ operations as follows: \n\n$$ 1,2,3 \\xrightarrow[x=1,\\,y=2]{} 3,0,3 \\xrightarrow[x=0,\\,y=3]{} 1,0,3 \\xrightarrow[x=0,\\,y=3]{} 1,0,1 \\xrightarrow[x=0,\\,y=1]{} 0,0,1 \\xrightarrow[x=0,\\,y=1]{} 0,0,0 .$$\n\n",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <cmath> // Included for completeness, though log3 is computed via powers\n\n// Use long long for sums and results to avoid overflow, as values can exceed 2^31-1\nusing ll = long long;\n\n// Global vector to store precomputed powers of 3\nstd::vector<ll> pow3;\n\n// Precompute powers of 3 up to 3^12.\n// 3^12 = 531441, which is greater than the maximum possible value of r (200000).\n// We need powers up to index 12 because floor(log3(200000)) = 11, and we need 3^(11+1).\nvoid precompute_powers() {\n    pow3.reserve(13); // Reserve space for 13 elements (indices 0 to 12)\n    ll current_p = 1; // Start with 3^0\n    for (int i = 0; i <= 12; ++i) {\n        pow3.push_back(current_p);\n        // Calculate the next power of 3, ensure we don't attempt multiplication if it would overflow.\n        // Note: For 3^12, long long provides ample space. Check is mostly for robustness.\n        if (i < 12) {\n             // A basic check to prevent overflow, although unlikely with these limits.\n             // if (current_p > __LONG_LONG_MAX__ / 3) { break; } \n             current_p *= 3;\n        }\n    }\n    // After this loop, pow3 contains [1, 3, 9, 27, ..., 531441]\n}\n\n// Compute f(k) = floor(log3 k) + 1 for k >= 1\n// This function calculates the number of operations needed to reduce k to 0 using\n// repeated division by 3 (floor division), assuming a 0 is available.\n// It's equivalent to the number of digits in the base-3 representation of k.\nint compute_f(int k) {\n    // Handle base case k=0, although problem constraints state l >= 1.\n    if (k <= 0) return 0; \n\n    // Find the largest integer p such that pow3[p] <= k. This p is floor(log3 k).\n    int p = 0;\n    // We can use a linear scan over the precomputed powers because the number of powers is small (13).\n    // A binary search (like std::upper_bound) could also be used but is not necessary for performance here.\n    // Check p + 1 against pow3.size() to prevent out-of-bounds access.\n    while (p + 1 < pow3.size() && pow3[p + 1] <= k) {\n        p++;\n    }\n    // After the loop, p is the largest index such that pow3[p] <= k.\n    // Therefore, p = floor(log3 k).\n    // The function returns p + 1, which is floor(log3 k) + 1.\n    return p + 1;\n}\n\n// Compute S(x) = sum_{k=1}^x f(k) using a prefix sum approach.\n// This function efficiently calculates the sum of f(k) for all k from 1 to x.\nll compute_S(int x) {\n    // Base case for S(0), used when computing S(l-1) where l=1.\n    if (x <= 0) return 0; \n    \n    ll total_sum = 0;\n    \n    // Find p_max = floor(log3 x). This is the highest power p such that 3^p <= x.\n    int p_max = 0;\n    while (p_max + 1 < pow3.size() && pow3[p_max + 1] <= x) {\n        p_max++;\n    }\n\n    // Calculate sum contributions from full intervals [3^p, 3^{p+1}-1] where p < p_max.\n    // In each such interval, f(k) is constant and equal to p + 1.\n    for (int p = 0; p < p_max; ++p) {\n        // The count of numbers k in the interval [pow3[p], pow3[p+1]-1] is pow3[p+1] - pow3[p].\n        ll count = pow3[p + 1] - pow3[p];\n        // Add the contribution of this interval to the total sum.\n        // Cast (p + 1) to ll to ensure intermediate multiplication doesn't overflow standard int.\n        total_sum += count * (ll)(p + 1); \n    }\n\n    // Calculate sum contribution from the last, potentially partial interval [pow3[p_max], x].\n    // In this interval, f(k) is constant and equal to p_max + 1.\n    // The count of numbers k in this interval is x - pow3[p_max] + 1.\n    ll count_last = (ll)x - pow3[p_max] + 1;\n    // Add the contribution of this final interval. Cast (p_max + 1) to ll.\n    total_sum += count_last * (ll)(p_max + 1); \n    \n    return total_sum;\n}\n\nint main() {\n    // Use faster I/O operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    precompute_powers(); // Precompute powers of 3 once at the start\n    \n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int l, r; // Input range bounds [l, r]\n        std::cin >> l >> r;\n        \n        // The minimum number of operations is derived to be M = f(l) + Sum_{k=l}^r f(k).\n        // The sum part is calculated efficiently using prefix sums: Sum_{k=l}^r f(k) = S(r) - S(l-1).\n        \n        // Compute S(r), the prefix sum up to r.\n        ll S_r = compute_S(r); \n        // Compute S(l-1), the prefix sum up to l-1.\n        ll S_l_minus_1 = compute_S(l - 1); \n        \n        // Calculate the sum over the specific range [l, r].\n        ll sum_f_k_range = S_r - S_l_minus_1;\n        \n        // Compute f(l).\n        int f_l = compute_f(l); \n        \n        // Calculate the final answer: f(l) + sum over [l, r]. Cast f_l to ll before adding.\n        ll total_ops = (ll)f_l + sum_f_k_range;\n        \n        // Output the result for the current test case.\n        std::cout << total_ops << \"\\n\"; \n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1999d",
      "PROBLEM_ID": "1999D",
      "PROBLEM_STATEMENT": "Slavic has a very tough exam and needs your help in order to pass it. Here is the question he is struggling with:\n\nThere exists a string $s$, which consists of lowercase English letters and possibly zero or more \"?\".\n\nSlavic is asked to change each \"?\" to a lowercase English letter such that string $t$ becomes a subsequence (not necessarily continuous) of the string $s$.\n\nOutput any such string, or say that it is impossible in case no string that respects the conditions exists.\n\n### Input\n\nThe first line contains a single integer $T$ ($1 \\leq T \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single string $s$ ($1 \\leq |s| \\leq 2 \\cdot 10^5$, and $s$ consists only of lowercase English letters and \"?\"-s) \u00a0\u2013 the original string you have.\n\nThe second line of each test case contains a single string $t$ ($1 \\leq |t| \\leq |s|$, and $t$ consists only of lowercase English letters) \u00a0\u2013 the string that should be a subsequence of string $s$.\n\nThe sum of $|s|$ over all test cases doesn't exceed $2 \\cdot 10^5$, where $|x|$ denotes the length of the string $x$.\n\n### Output\n\nFor each test case, if no such string exists as described in the statement, output \"NO\" (without quotes).\n\nOtherwise, output \"YES\" (without quotes). Then, output one line\u00a0\u2014 the string that respects all conditions.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\n\nIf multiple answers are possible, you can output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n?????\n\nxbx\n\nab??e\n\nabcde\n\nayy?x\n\na\n\nab??e\n\ndac\n\npaiu\n\nmom\n\n```\n\n#### Output #1\n\n```\nYES\nxabax\nYES\nabcde\nYES\nayyyx\nNO\nNO\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int t_cases;\n    cin >> t_cases;\n    while (t_cases--) {\n        string s, t;\n        cin >> s >> t;\n        int n = s.length();\n        int m = t.length();\n        vector<char> s_arr(n);\n        for (int i = 0; i < n; ++i) {\n            s_arr[i] = s[i];\n        }\n        int last_matched_index = -1;\n        bool possible = true;\n        for (int i = 0; i < m; ++i) {\n            char target_char = t[i];\n            bool found_match = false;\n            for (int j = last_matched_index + 1; j < n; ++j) {\n                if (s_arr[j] == target_char || s_arr[j] == '?') {\n                    last_matched_index = j;\n                    if (s_arr[j] == '?') {\n                        s_arr[j] = target_char;\n                    }\n                    found_match = true;\n                    break;\n                }\n            }\n            if (!found_match) {\n                possible = false;\n                break;\n            }\n        }\n        if (possible) {\n            cout << \"YES\" << endl;\n            for (int i = 0; i < n; ++i) {\n                if (s_arr[i] == '?') {\n                    s_arr[i] = 'a';\n                }\n            }\n            for (int i = 0; i < n; ++i) {\n                cout << s_arr[i];\n            }\n            cout << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1999c",
      "PROBLEM_ID": "1999C",
      "PROBLEM_STATEMENT": "As a computer science student, Alex faces a hard challenge\u00a0\u2014 showering. He tries to shower daily, but despite his best efforts there are always challenges. He takes $s$ minutes to shower and a day only has $m$ minutes!\n\nHe already has $n$ tasks planned for the day. Task $i$ is represented as an interval $(l_i$, $r_i)$, which means that Alex is busy and can not take a shower in that time interval (at any point in time strictly between $l_i$ and $r_i$). No two tasks overlap.\n\nGiven all $n$ time intervals, will Alex be able to shower that day? In other words, will Alex have a free time interval of length at least $s$?\n\n![](https://espresso.codeforces.com/555dc2bc8c4fc246d7de951a4c88791c8f382b59.png)\n\nIn the first test case, Alex can shower for the first $3$ minutes of the day and not miss any of the tasks.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains three integers $n$, $s$, and $m$ ($1 \\leq n \\leq 2 \\cdot 10^5$; $1 \\leq s, m \\leq 10^9$)\u00a0\u2014 the number of time intervals Alex already has planned, the amount of time Alex takes to take a shower, and the amount of minutes a day has.\n\nThen $n$ lines follow, the $i$-th of which contains two integers $l_i$ and $r_i$ ($0 \\leq l_i < r_i \\leq m$)\u00a0\u2014 the time interval of the $i$-th task. No two tasks overlap.\n\nAdditional constraint on the input: $l_i > r_{i-1}$ for every $i > 1$.\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case output \"YES\" (without quotes) if Alex can take a shower for that given test case, and \"NO\" (also without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n3 3 10\n\n3 5\n\n6 8\n\n9 10\n\n3 3 10\n\n1 2\n\n3 5\n\n6 7\n\n3 3 10\n\n1 2\n\n3 5\n\n6 8\n\n3 4 10\n\n1 2\n\n6 7\n\n8 9\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\nYES\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid solve() {\n    int n;\n    long long s, m;\n    cin >> n >> s >> m;\n    \n    vector<pair<long long, long long>> tasks(n);\n    for(int i = 0; i < n; i++) {\n        cin >> tasks[i].first >> tasks[i].second;\n    }\n    \n    // Check gap before first task\n    if(tasks[0].first >= s) {\n        cout << \"YES\\n\";\n        return;\n    }\n    \n    // Check gaps between tasks\n    for(int i = 1; i < n; i++) {\n        if(tasks[i].first - tasks[i-1].second >= s) {\n            cout << \"YES\\n\";\n            return;\n        }\n    }\n    \n    // Check gap after last task\n    if(m - tasks[n-1].second >= s) {\n        cout << \"YES\\n\";\n        return;\n    }\n    \n    cout << \"NO\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1999b",
      "PROBLEM_ID": "1999B",
      "PROBLEM_STATEMENT": "Suneet and Slavic play a card game. The rules of the game are as follows:\n\n- Each card has an integer value between $1$ and $10$.\n- Each player receives $2$ cards which are face-down (so a player doesn't know their cards).\n- The game is turn-based and consists exactly of two turns. In a round, both players pick a random unflipped card and flip it. The player who flipped a card with a strictly greater number wins the round. In case of equality, no one wins the round.\n- A player wins a game if he wins the most number of rounds (i.e. strictly greater than the other player). In case of equality, no one wins the game.\n\nSince Suneet and Slavic aren't best friends, you need to calculate the number of ways the game could happen that Suneet would end up as the winner.\n\nFor a better understanding, please check the notes section.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first and only line of each test case contains $4$ integers $a_1$, $a_2$, $b_1$, $b_2$ ($1 \\leq a_1, a_2, b_1, b_2 \\leq 10$) where $a_1$ and $a_2$ represent the cards Suneet has, and $b_1$ and $b_2$ represent the cards Slavic has, respectively.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the number of games Suneet would win considering all possible games.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n3 8 2 6\n\n1 1 1 1\n\n10 10 2 2\n\n1 1 10 10\n\n3 8 7 2\n\n```\n\n#### Output #1\n\n```\n2\n0\n4\n0\n2\n```\n\n### Note\n\nConsider the first test case when Slavic starts with the cards that have the values $2$ and $6$, and Suneet starts with cards that have the values $3$ and $8$. The game could happen in $4$ different ways:\n\n- Suneet flips $3$ and Slavic flips $2$. Suneet wins the first round. Then, Suneet flips $8$ and Slavic flips $6$. Suneet wins the second round as well. Since Suneet won $2$ rounds, he wins the game.\n\n- Suneet flips $3$ and Slavic flips $6$. Slavic wins the first round. Then, Suneet flips $8$ and Slavic flips $2$. Suneet wins the second round. Nobody wins since both players won an equal amount of rounds.\n\n- Suneet flips $8$ and Slavic flips $6$. Suneet wins the first round. Then, Suneet flips $3$ and Slavic flips $2$. Suneet wins the second round as well. Since Suneet won $2$ rounds, he wins the game.\n\n- Suneet flips $8$ and Slavic flips $2$. Suneet wins the first round. Then, Suneet flips $3$ and Slavic flips $6$. Slavic wins the round. Nobody wins since both players won an equal amount of rounds.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nusing namespace std;\n\nint round_winner(int card1, int card2) {\n    if (card1 > card2) {\n        return 1;\n    } else if (card2 > card1) {\n        return -1;\n    } else {\n        return 0;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int a1, a2, b1, b2;\n        cin >> a1 >> a2 >> b1 >> b2;\n        int suneet_wins_count = 0;\n\n        // Scenario 1: ((a1, b1), (a2, b2))\n        int w11 = round_winner(a1, b1);\n        int w12 = round_winner(a2, b2);\n        if (w11 + w12 > 0) {\n            suneet_wins_count++;\n        }\n\n        // Scenario 2: ((a1, b2), (a2, b1))\n        int w21 = round_winner(a1, b2);\n        int w22 = round_winner(a2, b1);\n        if (w21 + w22 > 0) {\n            suneet_wins_count++;\n        }\n\n        // Scenario 3: ((a2, b1), (a1, b2))\n        int w31 = round_winner(a2, b1);\n        int w32 = round_winner(a1, b2);\n        if (w31 + w32 > 0) {\n            suneet_wins_count++;\n        }\n\n        // Scenario 4: ((a2, b2), (a1, b1))\n        int w41 = round_winner(a2, b2);\n        int w42 = round_winner(a1, b1);\n        if (w41 + w42 > 0) {\n            suneet_wins_count++;\n        }\n\n        cout << suneet_wins_count << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1999a",
      "PROBLEM_ID": "1999A",
      "PROBLEM_STATEMENT": "Given a two-digit positive integer $n$, find the sum of its digits.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 90$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains a single two-digit positive integer $n$ ($10 \\leq n \\leq 99$).\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the sum of the digits of $n$.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n77\n\n21\n\n40\n\n34\n\n19\n\n84\n\n10\n\n99\n\n```\n\n#### Output #1\n\n```\n14\n3\n4\n7\n10\n12\n1\n18\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nint main() {\n    int t;\n    std::cin >> t;  // number of test cases\n    \n    while (t--) {\n        int n;\n        std::cin >> n;\n        \n        // For a two-digit number:\n        // First digit = n/10\n        // Second digit = n%10\n        int sum = (n/10) + (n%10);\n        \n        std::cout << sum << std::endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1998b",
      "PROBLEM_ID": "1998B",
      "PROBLEM_STATEMENT": "It is known that [Farmer John likes Permutations](https://usaco.org/index.php?page=viewproblem2&cpid=1421), but I like them too!\n\n\u2014 Sun Tzu, The Art of Constructing Permutations\n\nYou are given a permutation$^{\\text{\u2217}}$ $p$ of length $n$.\n\nFind a permutation $q$ of length $n$ that minimizes the number of pairs ($i, j$) ($1 \\leq i \\leq j \\leq n$) such that $p_i + p_{i+1} + \\ldots + p_j = q_i + q_{i+1} + \\ldots + q_j$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n### Input\n\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$).\n\nThe following line contains $n$ space-separated integers $p_1, p_2, \\ldots, p_n$ ($1 \\leq p_i \\leq n$)\u00a0\u2014 denoting the permutation $p$ of length $n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output one line containing any permutation of length $n$ (the permutation $q$) such that $q$ minimizes the number of pairs.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2\n\n1 2\n\n5\n\n1 2 3 4 5\n\n7\n\n4 7 5 1 2 6 3\n\n```\n\n#### Output #1\n\n```\n2 1\n3 5 4 2 1\n6 2 1 4 7 3 5```\n\n### Note\n\nFor the first test, there exists only one pair ($i, j$) ($1 \\leq i \\leq j \\leq n$) such that $p_i + p_{i+1} + \\ldots + p_j = q_i + q_{i+1} + \\ldots + q_j$, which is ($1, 2$). It can be proven that no such $q$ exists for which there are no pairs.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n\n// Main function contains the solution logic\nint main() {\n    // Use fast I/O operations for competitive programming\n    std::ios_base::sync_with_stdio(false); // Disable synchronization with C standard streams\n    std::cin.tie(NULL); // Untie cin from cout\n\n    int t; // Variable to store the number of test cases\n    std::cin >> t; // Read the number of test cases from input\n    \n    // Loop through each test case\n    while (t--) {\n        int n; // Variable to store the size of the permutation\n        std::cin >> n; // Read the size of the permutation for the current test case\n        \n        // Declare a vector p of size n to store the input permutation\n        std::vector<int> p(n);\n        // Read the elements of permutation p from input\n        for (int i = 0; i < n; ++i) {\n            std::cin >> p[i];\n        }\n        \n        // Declare a vector q of size n to store the resulting permutation\n        // The goal is to find a permutation q such that the number of pairs (i, j)\n        // with 1 <= i <= j <= n satisfying sum(p[k] for k=i..j) = sum(q[k] for k=i..j) is minimized.\n        // Let P_k and Q_k be the prefix sums of p and q respectively. The condition is P_j - P_{i-1} = Q_j - Q_{i-1}.\n        // Let D_k = P_k - Q_k. The condition becomes D_j = D_{i-1}.\n        // Let k' = i-1. The condition is D_j = D_{k'} for 0 <= k' < j <= n.\n        // The minimum number of such pairs is 1, because D_0 = 0 and D_n = 0 always holds (corresponding to pair (i, j) = (1, n)).\n        // To achieve this minimum, we need D_1, ..., D_{n-1} to be distinct and non-zero.\n        \n        // A construction that achieves this is based on applying a cyclic permutation pi to p.\n        // Let pi be the permutation (1 2 ... n), which maps k to k+1 for k < n, and maps n to 1.\n        // We construct q such that q[i] = pi(p[i]).\n        // The function pi(k) can be computed as (k % n) + 1.\n        // So we set q[i] = (p[i] % n) + 1.\n        std::vector<int> q(n);\n        for (int i = 0; i < n; ++i) {\n             // Compute the value for q[i] using the derived rule.\n             // The rule q[i] = (p[i] % n) + 1 implements the permutation pi = (1 2 ... n).\n             // Example check:\n             // If p[i] = k where 1 <= k < n, then p[i] % n = k. The result is k + 1. Correctly maps k to k+1 which is pi(k).\n             // If p[i] = n, then p[i] % n = 0. The result is 0 + 1 = 1. Correctly maps n to 1 which is pi(n).\n             q[i] = (p[i] % n) + 1;\n        }\n\n        // Print the elements of the constructed permutation q\n        for (int i = 0; i < n; ++i) {\n            // Print element q[i] followed by a space, except for the last element\n            std::cout << q[i] << (i == n - 1 ? \"\" : \" \");\n        }\n        // Print a newline character after the output for the current test case\n        std::cout << \"\\n\"; \n    }\n    \n    // Return 0 to indicate successful execution\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1997f",
      "PROBLEM_ID": "1997F",
      "PROBLEM_STATEMENT": "You have $n$ chips, and you are going to place all of them in one of $x$ points, numbered from $1$ to $x$. There can be multiple chips in each point.\n\nAfter placing the chips, you can perform the following four operations (in any order, any number of times):\n\n- choose a chip in point $i \\ge 3$, remove it and place two chips: one in $i-1$, one in $i-2$;\n- choose two chips in adjacent points $i$ and $i+1$, remove them and place a new chip in $i+2$;\n- choose a chip in point $1$ and move it to $2$;\n- choose a chip in point $2$ and move it to $1$.\n\nNote that the coordinates of the chips you place during the operations cannot be less than $1$, but can be greater than $x$.\n\nDenote the cost of chip placement as the minimum number of chips which can be present on the line after you perform these operations, starting from the placement you've chosen.\n\nFor example, the cost of placing two chips in points $3$ and one chip in point $5$ is $2$, because you can reduce the number of chips to $2$ as follows:\n\n- choose a chip in point $3$, remove it, place a chip in $1$ and another chip in $2$;\n- choose the chips in points $2$ and $3$, remove them and place a chip in $4$;\n- choose the chips in points $4$ and $5$, remove them and place a chip in $6$.\n\nYou are given three integers $n$, $x$ and $m$. Calculate the number of placements of exactly $n$ chips in points from $1$ to $x$ having cost equal to $m$, and print it modulo $998244353$. Two placements are considered different if the number of chips in some point differs between these placements.\n\n### Input\n\nThe only line contains three integers $n$, $x$ and $m$ ($1 \\le m \\le n \\le 1000$; $2 \\le x \\le 10$).\n\n### Output\n\nPrint one integer \u2014 the number of placements with cost equal to $m$, taken modulo $998244353$.\n\n### Examples\n\n#### Input #1\n\n```\n\n2 3 1\n\n```\n\n#### Output #1\n\n```\n5\n```\n\n#### Input #2\n\n```\n\n42 10 5\n\n```\n\n#### Output #2\n\n```\n902673363\n```\n\n#### Input #3\n\n```\n\n1000 10 8\n\n```\n\n#### Output #3\n\n```\n187821763\n```\n\n### Note\n\nIn the first example, there are five ways to place $2$ chips in points from $1$ to $3$ so that the cost is $1$:\n\n- $(1, 1)$;\n- $(1, 2)$;\n- $(1, 3)$;\n- $(2, 2)$;\n- $(2, 3)$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm> // Required for std::min\n\n// Use long long for inputs as good practice, although constraints N <= 1000 suggest int is fine.\nlong long N_in, X_in, M_in; \nint N, X, M; // Use int for loop bounds and array indices based on constraints.\n\nconst int MOD = 998244353; // The specified modulus.\n\n// Array to store Fibonacci numbers. F[i] stores the i-th Fibonacci number (F_1 = 1, F_2 = 1, ...).\n// Size 100 is sufficient since F_k grows exponentially and we only need up to F_X or related to S_MAX.\nlong long F[100]; \n\n// S_MAX is the maximum possible Fibonacci sum value we need to consider.\nint S_MAX;\n\n// The DP table. dp[i][j] stores the number of ways to place i chips such that their total Fibonacci value is j.\n// It will be resized dynamically based on N and S_MAX.\nstd::vector<std::vector<int>> dp; \n\n// Stores the maximum index k such that F[k] is relevant for Zeckendorf calculations up to S_MAX.\nint max_fib_idx = 0;\n\n/**\n * @brief Calculates the number of terms in the standard Zeckendorf representation of S.\n * The standard Zeckendorf representation uses Fibonacci numbers F_k with k >= 2,\n * such that no two consecutive Fibonacci numbers are used. F_1 = 1, F_2 = 1, F_3 = 2, ...\n * \n * @param S The integer value whose Zeckendorf representation length is needed.\n * @return The number of terms (cost).\n */\nint calculate_Z_standard(int S) {\n    if (S == 0) return 0; // Zeckendorf representation of 0 has 0 terms.\n    int count = 0; // Initialize term count.\n    \n    // Start searching for the largest Fibonacci number F[k] <= S from the precomputed max relevant index.\n    // We only consider indices k >= 2 for standard Zeckendorf.\n    int k = max_fib_idx; \n    \n    // Adjust k downwards if F[k] is initially larger than S.\n    while (k >= 2 && F[k] > S) {\n        k--;\n    }\n\n    // Greedily subtract largest possible Fibonacci numbers F_k ensuring non-consecutiveness.\n    while (S > 0 && k >= 2) {\n        // Use F[k] in the representation.\n        count++;\n        S -= F[k];\n        \n        // The next Fibonacci number index must be at most k-2.\n        k -= 2; \n        if (k < 2) break; // Minimum index allowed is 2.\n        \n        // Adjust k downwards if F[k] is too large for the remaining value of S.\n        while (k >= 2 && F[k] > S) {\n            k--;\n        }\n        // If k drops below 2, the loop will terminate naturally.\n    }\n    // According to Zeckendorf's theorem, any positive integer S has a unique representation,\n    // so S should be 0 at the end.\n    return count;\n}\n\nint main() {\n    // Optimize C++ standard streams for faster I/O.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // Read inputs N (number of chips), X (max point index), M (target cost).\n    std::cin >> N_in >> X_in >> M_in;\n    N = N_in; X = X_in; M = M_in;\n\n    // Precompute Fibonacci numbers. F[0] is unused (or 0), F[1]=1, F[2]=1, ...\n    F[0] = 0; \n    F[1] = 1;\n    F[2] = 1;\n    // Compute Fibonacci sequence up to index 89, or until overflow / exceeding a large threshold.\n    for (int i = 3; i < 90; ++i) {\n        // Check for potential overflow before adding. Use long long for intermediate sum.\n        if (F[i - 1] == -1 || F[i - 2] == -1 || (F[i-1] > 0 && F[i-2] > 0 && F[i-1] > (2000000000LL - F[i-2])) ) { // Rough overflow check\n             F[i] = -1; // Mark as invalid/overflowed\n             continue; // Stop computing further if overflow detected or parent is invalid\n        }\n        F[i] = F[i - 1] + F[i - 2];\n        if (F[i] < F[i-1] && F[i-1] > 0) { // Check for wrap-around overflow\n             F[i] = -1;\n        }\n    }\n    \n    // Determine S_MAX = N * F[X]. Check validity of F[X].\n    // Constraints N <= 1000, X <= 10 mean F[X] <= F[10] = 55.\n    // S_MAX <= 1000 * 55 = 55000. This is well within reasonable limits.\n    if (X >= 90 || X < 1 || F[X] == -1) {\n         // Error: X is out of bounds or F[X] calculation failed.\n         // This case is highly unlikely given problem constraints X <= 10.\n         // If it happened, we might need a fallback or error handling.\n         // Assuming constraints hold, F[X] is valid.\n         S_MAX = 0; // Set S_MAX to 0 or handle error appropriately. In this context, 0 works.\n    } else {\n       // Calculate N * F[X] using long long to prevent potential intermediate overflow if N or F[X] were large.\n       long long s_max_ll = (long long)N * F[X];\n       // S_MAX should not exceed a practical limit (e.g., memory capacity). \n       // Cap S_MAX if necessary. Based on N=1000, X=10, S_MAX=55000 is acceptable.\n       // Let's set a generous cap like 60000 just in case.\n       S_MAX = (int)std::min(s_max_ll, 60000LL); \n    }\n\n    // Find max_fib_idx: the largest index k such that F[k] <= S_MAX. Needed for Zeckendorf calculation.\n    max_fib_idx = 1;\n    // Ensure indices are within bounds and F value is valid.\n    while(max_fib_idx + 1 < 90 && F[max_fib_idx + 1] != -1 && F[max_fib_idx + 1] <= S_MAX) {\n         max_fib_idx++;\n    }\n\n    // Allocate the DP table. Size (N+1) x (S_MAX+1). Initialize all counts to 0.\n    dp.resize(N + 1, std::vector<int>(S_MAX + 1, 0));\n    dp[0][0] = 1; // Base case: There's 1 way to place 0 chips with total value 0.\n\n    // Main DP calculation. Iterate through each point k from 1 to X.\n    for (int k = 1; k <= X; ++k) { \n        // Skip if Fibonacci number F[k] is invalid (e.g., overflowed) or 0.\n        if (k >= 90 || F[k] == -1 || F[k] == 0) continue; \n        long long Fk_val_ll = F[k]; // Use long long temporarily for safety, though F[10] is small.\n        int Fk_val = (int)Fk_val_ll;\n        \n        // If F[k] > S_MAX, placing any chip at point k would exceed the maximum relevant sum. Skip.\n        if (Fk_val > S_MAX) continue; \n\n        // Update DP table using the optimized recurrence relation.\n        // This relation reflects adding any number of chips (0, 1, 2, ...) at point k.\n        // It is equivalent to D[k][n][S] = sum_{i>=0} D[k-1][n-i][S - i*Fk].\n        // The optimized form is D[k][n][S] = D[k-1][n][S] + D[k][n-1][S - Fk].\n        // Implemented iteratively using one table layer:\n        // The outer loop iterates through number of chips `cur_n`.\n        // The inner loop iterates through total sum `cur_S`.\n        // Order: `cur_n` from 1 to N, `cur_S` from Fk_val to S_MAX.\n        for (int cur_n = 1; cur_n <= N; ++cur_n) {\n            for (int cur_S = Fk_val; cur_S <= S_MAX; ++cur_S) {\n                // Add the ways to reach state (cur_n-1, cur_S - Fk_val) using points 1..k.\n                // This represents adding one chip at point k to a previously valid state.\n                 dp[cur_n][cur_S] = (dp[cur_n][cur_S] + dp[cur_n - 1][cur_S - Fk_val]) % MOD;\n            }\n        }\n    }\n\n    // After processing all points 1 to X, dp[N][S] contains the number of ways\n    // to place exactly N chips resulting in total Fibonacci value S.\n    // Sum up the counts for states where the cost (Zeckendorf length of S) is M.\n    long long total_ways = 0;\n    for (int S = 0; S <= S_MAX; ++S) {\n        // Check if state (N chips, sum S) is reachable.\n        if (dp[N][S] > 0) { \n            // Calculate the cost (Zeckendorf length) for this sum S.\n            if (calculate_Z_standard(S) == M) {\n                // If cost matches M, add the number of ways to the total count.\n                total_ways = (total_ways + dp[N][S]) % MOD;\n            }\n        }\n    }\n\n    // Print the final answer modulo 998244353.\n    std::cout << total_ways << std::endl;\n\n    return 0; // Indicate successful execution.\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1997e",
      "PROBLEM_ID": "1997E",
      "PROBLEM_STATEMENT": "Monocarp is playing a computer game. He starts the game being level $1$. He is about to fight $n$ monsters, in order from $1$ to $n$. The level of the $i$-th monster is $a_i$.\n\nFor each monster in the given order, Monocarp's encounter goes as follows:\n\n- if Monocarp's level is strictly higher than the monster's level, the monster flees (runs away);\n- otherwise, Monocarp fights the monster.\n\nAfter every $k$-th fight with a monster (fleeing monsters do not count), Monocarp's level increases by $1$. So, his level becomes $2$ after $k$ monsters he fights, $3$ after $2k$ monsters, $4$ after $3k$ monsters, and so on.\n\nYou need to process $q$ queries of the following form:\n\n- $i~x$: will Monocarp fight the $i$-th monster (or will this monster flee) if the parameter $k$ is equal to $x$?\n\n### Input\n\nThe first line contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of monsters and the number of queries.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$)\u00a0\u2014 the levels of the monsters.\n\nIn the $j$-th of the following $q$ lines, two integers $i$ and $x$ ($1 \\le i, x \\le n$)\u00a0\u2014 the index of the monster and the number of fights required for a level up in the $j$-th query.\n\n### Output\n\nFor each query, output \"YES\", if Monocarp will fight the $i$-th monster in this query, and \"NO\", if the $i$-th monster flees.\n\n### Examples\n\n#### Input #1\n\n```\n\n4 16\n\n2 1 2 1\n\n1 1\n\n2 1\n\n3 1\n\n4 1\n\n1 2\n\n2 2\n\n3 2\n\n4 2\n\n1 3\n\n2 3\n\n3 3\n\n4 3\n\n1 4\n\n2 4\n\n3 4\n\n4 4\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\n```\n\n#### Input #2\n\n```\n\n7 15\n\n1 1 2 1 1 1 1\n\n5 3\n\n2 2\n\n2 2\n\n1 6\n\n5 1\n\n5 5\n\n7 7\n\n3 5\n\n7 4\n\n4 3\n\n2 5\n\n1 2\n\n5 6\n\n4 1\n\n6 1\n\n```\n\n#### Output #2\n\n```\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nNO\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <tuple>\nusing namespace std;\nconst int N = 4e5 + 10;\nint a[N], n, q, tr[N], idx = 1, l, r, mid, req[N], cur;\ntemplate <typename _Tp>\ninline void read(_Tp &x)\n{\n    char ch;\n    while (ch = getchar(), !isdigit(ch))\n        ;\n    x = ch - '0';\n    while (ch = getchar(), isdigit(ch))\n        x = (x << 3) + (x << 1) + (ch ^ '0');\n}\ntemplate <typename _Tp, typename... _Args>\ninline void read(_Tp &x, _Args &...args)\n{\n    read(x);\n    read(args...);\n}\ninline void update(int x, int v)\n{\n    while (x < N)\n    {\n        tr[x] += v;\n        x += (x & -x);\n    }\n}\nint main()\n{\n    read(n, q);\n    for (int i = 1; i <= n; i++)\n    {\n        read(a[i]);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        l = cur = 0;\n        for (int j = 17; ~j; j--)\n        {\n            if (1ll * a[i] * (l | (1 << j)) <= cur + tr[l | (1 << j)])\n                l |= (1 << j), cur += tr[l];\n        }\n        l++;\n        update(l, 1);\n        req[i] = l;\n    }\n    for (int i = 1, x, k; i <= q; i++)\n    {\n        read(x, k);\n        puts(k < req[x] ? \"NO\" : \"YES\");\n    }\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1997c",
      "PROBLEM_ID": "1997C",
      "PROBLEM_STATEMENT": "Monocarp had a regular bracket sequence $s$ of length $n$ ($n$ is even). He even came up with his own way to calculate its cost.\n\nHe knows that in a regular bracket sequence (RBS), each opening bracket is paired up with the corresponding closing bracket. So he decided to calculate the cost of RBS as the sum of distances between pairs of corresponding bracket pairs.\n\nFor example, let's look at RBS (())(). It has three pairs of brackets:\n\n- (\\_\\_)\\_\\_: the distance between brackets at position $1$ and at $4$ is $4 - 1 = 3$;\n- \\_()\\_\\_\\_: the distance is $3 - 2 = 1$;\n- \\_\\_\\_\\_(): the distance is $6 - 5 = 1$.\n\nSo the cost of (())() is $3 + 1 + 1 = 5$.\n\nUnfortunately, due to data corruption, Monocarp lost all characters on odd positions $s_1, s_3, \\dots, s_{n-1}$. Only characters on even positions ($s_2, s_4, \\dots, s_{n}$) remain. For example, (())() turned to \\_(\\_)\\_).\n\nMonocarp wants to restore his RBS by placing brackets on the odd positions. But since the restored RBS may not be unique, he wants to choose one with minimum cost. It's too hard to do for Monocarp alone, so can you help him?\n\nReminder: A regular bracket sequence is a string consisting of only brackets, such that this sequence, when inserted 1-s and +-s, gives a valid mathematical expression. For example, (), (()) or (()())() are RBS, while ), ()( or ())(() are not.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 5000$)\u00a0\u2014 the number of test cases. Next $t$ cases follow.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$; $n$ is even)\u00a0\u2014 the length of string $s$.\n\nThe second line of each test case contains a string $s$ of length $n$, where all characters on the odd positions are '\\_' and all characters on the even positions are either '(' or ')'.\n\nAdditional constraints:\n\n- $s$ can be restored to at least one regular bracket sequence;\n- the total sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print one integer\u00a0\u2014 the minimum cost of the regular bracket sequence that can be obtained from $s$ by replacing '\\_'-s with brackets.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n6\n\n\\_(\\_)\\_)\n\n2\n\n\\_)\n\n8\n\n\\_)\\_)\\_)\\_)\n\n8\n\n\\_(\\_)\\_(\\_)\n\n```\n\n#### Output #1\n\n```\n5\n1\n4\n8\n```\n\n### Note\n\nIn the first test case, it's optimal to make $s$ equal to (())(). The cost of $s$ will be equal to $3 + 1 + 1 = 5$.\n\nIn the second test case, the only option is to make $s$ equal to () with cost $1$.\n\nIn the third test case, the only possible RBS is ()()()() with cost $1 + 1 + 1 + 1 = 4$.\n\nIn the fourth test case, it's optimal to make $s$ equal to (())(()) with cost $3 + 1 + 3 + 1 = 8$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n\n        // Stack to manage unmatched '(' positions\n        vector<int> openStack;\n        long long cost = 0;\n\n        // Reconstructed sequence\n        string reconstructed = s;\n\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) { // Odd position (1-based)\n                // Decide what to place here: '(' or ')'\n                if (!openStack.empty() && reconstructed[i] == '_') {\n                    // If there is an unmatched '(', place ')' to minimize cost\n                    reconstructed[i] = ')';\n                    int matchedIndex = openStack.back();\n                    openStack.pop_back();\n                    cost += (i - matchedIndex);\n                } else {\n                    // Otherwise, place '('\n                    reconstructed[i] = '(';\n                    openStack.push_back(i);\n                }\n            } else { // Even position (1-based)\n                if (s[i] == '(') {\n                    openStack.push_back(i);\n                } else if (s[i] == ')') {\n                    if (!openStack.empty()) {\n                        int matchedIndex = openStack.back();\n                        openStack.pop_back();\n                        cost += (i - matchedIndex);\n                    }\n                    // If there is no open bracket to match with, it's invalid RBS\n                }\n            }\n        }\n\n        cout << cost << \"\\n\";\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1997b",
      "PROBLEM_ID": "1997B",
      "PROBLEM_STATEMENT": "There is a grid, consisting of $2$ rows and $n$ columns. Each cell of the grid is either free or blocked.\n\nA free cell $y$ is reachable from a free cell $x$ if at least one of these conditions holds:\n\n- $x$ and $y$ share a side;\n- there exists a free cell $z$ such that $z$ is reachable from $x$ and $y$ is reachable from $z$.\n\nA connected region is a set of free cells of the grid such that all cells in it are reachable from one another, but adding any other free cell to the set violates this rule.\n\nFor example, consider the following layout, where white cells are free, and dark grey cells are blocked:\n\n![](https://espresso.codeforces.com/aedd15634fe9e1556defb3420dad68714321bc34.png)\n\nThere are $3$ regions in it, denoted with red, green and blue color respectively:\n\n![](https://espresso.codeforces.com/681c37e72094b7fd357b26d25fde1c8e8dee01cb.png)\n\nThe given grid contains at most $1$ connected region. Your task is to calculate the number of free cells meeting the following constraint:\n\n- if this cell is blocked, the number of connected regions becomes exactly $3$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of columns.\n\nThe $i$-th of the next two lines contains a description of the $i$-th row of the grid\u00a0\u2014 the string $s_i$, consisting of $n$ characters. Each character is either . (denoting a free cell) or x (denoting a blocked cell).\n\nAdditional constraint on the input:\n\n- the given grid contains at most $1$ connected region;\n- the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the number of cells such that the number of connected regions becomes $3$ if this cell is blocked.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n8\n\n.......x\n\n.x.xx...\n\n2\n\n..\n\n..\n\n3\n\nxxx\n\nxxx\n\n9\n\n..x.x.x.x\n\nx.......x\n\n```\n\n#### Output #1\n\n```\n1\n0\n0\n2\n```\n\n### Note\n\nIn the first test case, if the cell $(1, 3)$ is blocked, the number of connected regions becomes $3$ (as shown in the picture from the statement).",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream> // Required for input/output operations\n#include <vector>   // Required for using std::vector\n#include <string>   // Required for using std::string\n\n// Use the standard namespace to avoid writing std:: prefix repeatedly\nusing namespace std;\n\nint main() {\n    // Faster I/O operations by decoupling C++ standard streams from C stdio\n    ios_base::sync_with_stdio(false);\n    // Untie cin from cout to speed up input operations\n    cin.tie(NULL);\n\n    int t; // Declare variable to store the number of test cases\n    cin >> t; // Read the number of test cases from input\n\n    // Process each test case\n    while (t--) {\n        int n; // Declare variable to store the number of columns in the grid\n        cin >> n; // Read the number of columns from input\n\n        // Declare a vector of strings to store the grid. \n        // It will have 2 elements, s[0] for the first row and s[1] for the second row.\n        vector<string> s(2); \n        cin >> s[0] >> s[1]; // Read the two rows of the grid from input\n\n        int count = 0; // Initialize a counter for the number of cells meeting the criteria\n\n        // Iterate through the interior columns of the grid.\n        // The grid columns are 0-indexed in C++, so we iterate from column index j = 1 to j = n-2.\n        // This corresponds to 1-based column indices c = 2 to c = n-1.\n        // Cells in the first column (j=0) and the last column (j=n-1) cannot have \n        // neighbors both to the left and right simultaneously. \n        // A cell needs 3 free neighbors (left, right, and vertical) to potentially split the region into 3 upon removal.\n        // Cells in boundary columns can have at most 2 neighbors. Thus, they cannot meet the criteria.\n        // We only need to check cells in the interior columns (1 to n-2).\n        // The loop condition `j < n - 1` automatically handles cases where n < 3 (loop doesn't run).\n        for (int j = 1; j < n - 1; ++j) {\n            \n            // Check the cell at (row 0, column j)\n            // A free cell (i, j) qualifies if blocking it results in exactly 3 connected regions.\n            // Our analysis showed this happens if and only if:\n            // 1. The cell (i, j) itself is free (represented by '.').\n            // 2. Its three neighbors: (i, j-1) [left], (i, j+1) [right], and (1-i, j) [in the other row] are all free ('.').\n            // 3. The two cells (1-i, j-1) and (1-i, j+1) are blocked ('x'). These cells are adjacent to the neighbor in the other row.\n            \n            // Evaluate conditions for cell (0, j)\n            if (s[0][j] == '.' &&           // Condition 1: Cell (0, j) must be free\n                s[0][j-1] == '.' &&         // Condition 2a: Left neighbor (0, j-1) must be free\n                s[0][j+1] == '.' &&         // Condition 2b: Right neighbor (0, j+1) must be free\n                s[1][j] == '.' &&           // Condition 2c: Neighbor below (1, j) must be free\n                s[1][j-1] == 'x' &&         // Condition 3a: Cell (1, j-1) (in row 1, col j-1) must be blocked\n                s[1][j+1] == 'x') {         // Condition 3b: Cell (1, j+1) (in row 1, col j+1) must be blocked\n                count++; // If all conditions are met, this cell qualifies. Increment the counter.\n            }\n\n            // Evaluate conditions for cell (1, j)\n            if (s[1][j] == '.' &&           // Condition 1: Cell (1, j) must be free\n                s[1][j-1] == '.' &&         // Condition 2a: Left neighbor (1, j-1) must be free\n                s[1][j+1] == '.' &&         // Condition 2b: Right neighbor (1, j+1) must be free\n                s[0][j] == '.' &&           // Condition 2c: Neighbor above (0, j) must be free\n                s[0][j-1] == 'x' &&         // Condition 3a: Cell (0, j-1) (in row 0, col j-1) must be blocked\n                s[0][j+1] == 'x') {         // Condition 3b: Cell (0, j+1) (in row 0, col j+1) must be blocked\n                count++; // If all conditions are met, this cell qualifies. Increment the counter.\n            }\n        }\n        \n        // Output the final count for the current test case, followed by a newline character.\n        cout << count << \"\\n\";\n    }\n    \n    return 0; // Indicate successful execution of the program\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1997a",
      "PROBLEM_ID": "1997A",
      "PROBLEM_STATEMENT": "Monocarp's current password on Codeforces is a string $s$, consisting of lowercase Latin letters. Monocarp thinks that his current password is too weak, so he wants to insert exactly one lowercase Latin letter into the password to make it stronger. Monocarp can choose any letter and insert it anywhere, even before the first character or after the last character.\n\nMonocarp thinks that the password's strength is proportional to the time it takes him to type the password. The time it takes to type the password is calculated as follows:\n\n- the time to type the first character is $2$ seconds;\n- for each character other than the first, the time it takes to type it is $1$ second if it is the same as the previous character, or $2$ seconds otherwise.\n\nFor example, the time it takes to type the password abacaba is $14$; the time it takes to type the password a is $2$; the time it takes to type the password aaabacc is $11$.\n\nYou have to help Monocarp \u2014 insert a lowercase Latin letter into his password so that the resulting password takes the maximum possible amount of time to type.\n\n### Input\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nEach test case consists of one line containing the string $s$ ($1 \\le |s| \\le 10$), consisting of lowercase Latin letters.\n\n### Output\n\nFor each test case, print one line containing the new password \u2014 a string which can be obtained from $s$ by inserting one lowercase Latin letter. The string you print should have the maximum possible required time to type it. If there are multiple answers, print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\na\n\naaa\n\nabb\n\npassword\n\n```\n\n#### Output #1\n\n```\nwa\naada\nabcb\npastsword\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Calculate the time it takes to type a password\nint calculateTypingTime(const string& s) {\n    if (s.empty()) return 0;\n    \n    int time = 2; // First character always takes 2 seconds\n    for (int i = 1; i < s.size(); ++i) {\n        if (s[i] == s[i-1]) {\n            time += 1; // Same character takes 1 second\n        } else {\n            time += 2; // Different character takes 2 seconds\n        }\n    }\n    return time;\n}\n\n// Insert one character to maximize typing time\nstring findMaxTypingTime(const string& s) {\n    string bestPassword = \"\";\n    int maxTime = 0;\n    \n    // Try inserting each letter at each position\n    for (int pos = 0; pos <= s.size(); ++pos) {\n        for (char c = 'a'; c <= 'z'; ++c) {\n            // Create new password with inserted character\n            string newPassword = s.substr(0, pos) + c + s.substr(pos);\n            int time = calculateTypingTime(newPassword);\n            \n            // Update if we found a better solution\n            if (time > maxTime) {\n                maxTime = time;\n                bestPassword = newPassword;\n            }\n        }\n    }\n    \n    return bestPassword;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        string s;\n        cin >> s;\n        cout << findMaxTypingTime(s) << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1996g",
      "PROBLEM_ID": "1996G",
      "PROBLEM_STATEMENT": "On Penacony, The Land of the Dreams, there exists $n$ houses and $n$ roads. There exists a road between house $i$ and $i+1$ for all $1 \\leq i \\leq n-1$ and a road between house $n$ and house $1$. All roads are bidirectional. However, due to the crisis on Penacony, the overseeing family has gone into debt and may not be able to maintain all roads.\n\nThere are $m$ pairs of friendships between the residents of Penacony. If the resident living in house $a$ is friends with the resident living in house $b$, there must be a path between houses $a$ and $b$ through maintained roads.\n\nWhat is the minimum number of roads that must be maintained?\n\n### Input\n\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$) \u2013 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($3 \\leq n \\leq 2 \\cdot 10^5, 1 \\leq m \\leq 2 \\cdot 10^5$) \u2013 the number of houses and the number of friendships.\n\nThe next $m$ lines contain two integers $a$ and $b$ ($1 \\leq a < b \\leq n$) \u2013 the resident in house $a$ is friends with the resident in house $b$. It is guaranteed all ($a, b$) are distinct.\n\nIt is guaranteed the sum of $n$ and $m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output an integer, the minimum number of roads that must be maintained.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n8 3\n\n1 8\n\n2 7\n\n4 5\n\n13 4\n\n1 13\n\n2 12\n\n3 11\n\n4 10\n\n10 2\n\n2 3\n\n3 4\n\n10 4\n\n3 8\n\n5 10\n\n2 10\n\n4 10\n\n4 1\n\n1 3\n\n5 2\n\n3 5\n\n1 4\n\n5 2\n\n2 5\n\n1 3\n\n```\n\n#### Output #1\n\n```\n4\n7\n2\n7\n2\n3\n3\n```\n\n### Note\n\nFor the first test case, the following roads must be maintained:\n\n- $8 \\leftarrow \\rightarrow 1$\n- $7 \\leftarrow \\rightarrow 8$\n- $1 \\leftarrow \\rightarrow 2$\n- $4 \\leftarrow \\rightarrow 5$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n,t,q;\nvector<int> v[200005];\nint b[200005<<2],cnt[200005<<2],add[200005<<2];\n\nvoid pushup(int rt){\n\tb[rt]=min(b[rt<<1],b[rt<<1|1]);\n\tcnt[rt]=0;\n\tif(b[rt]==b[rt<<1])cnt[rt]+=cnt[rt<<1];\n\tif(b[rt]==b[rt<<1|1])cnt[rt]+=cnt[rt<<1|1];\n}\n\nvoid build(int l,int r,int rt){\n\tadd[rt]=0;\n\tb[rt]=0;\n\tif(l==r){\n\t\tcnt[rt]=1;\n\t\treturn ;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(l,m,rt<<1);\n\tbuild(m+1,r,rt<<1|1);\n\tpushup(rt);\n}\n\nvoid pushdown(int rt){\n\tb[rt<<1]+=add[rt];\n\tb[rt<<1|1]+=add[rt];\n\tadd[rt<<1]+=add[rt];\n\tadd[rt<<1|1]+=add[rt];\n\tadd[rt]=0;\n}\n\nvoid update(int L,int R,int c,int l,int r,int rt){\n\tif(L<=l&&r<=R){\n\t\tb[rt]+=c;\n\t\tadd[rt]+=c;\n\t\treturn ;\n\t}\n\tint m=(l+r)>>1;\n\tpushdown(rt);\n\tif(L<=m)update(L,R,c,l,m,rt<<1);\n\tif(R>m)update(L,R,c,m+1,r,rt<<1|1);\n\tpushup(rt);\n}\n\nint query(int L,int R,int l,int r,int rt){\n\tif(L<=l&&r<=R){\n\t\treturn cnt[rt];\n\t}\n\tint m=(l+r)>>1;\n\tint ans=0;\n\tpushdown(rt);\n\tif(L<=m&&b[rt<<1]==b[rt])ans+=query(L,R,l,m,rt<<1);\n\tif(R>m&&b[rt<<1|1]==b[rt])ans+=query(L,R,m+1,r,rt<<1|1);\n\treturn ans;\n}\n\nint qry(){\n\tint x=query(1,n,1,n,1);\n\tif(b[1]==0)return n-x;\n\treturn x;\n}\n\nint main(){\n\tcin >> t;\n\twhile(t--){\n\t\tcin >> n >> q;\n\t\tfor(int i=1;i<=n;i++)v[i].clear();\n\t\tbuild(1,n,1);\n\t\twhile(q--){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv[x].push_back(y);\n\t\t\tv[y].push_back(x);\n\t\t\tupdate(x,y-1,1,1,n,1);\n\t\t}\n\t\tint ans=INT_MAX;\n\t\tans=min(ans,qry());\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(auto y:v[i]){\n\t\t\t\tif(y>i){\n\t\t\t\t\tupdate(1,n,1,1,n,1);\n\t\t\t\t\tupdate(i,y-1,-2,1,n,1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tupdate(1,n,-1,1,n,1);\n\t\t\t\t\tupdate(y,i-1,2,1,n,1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=min(ans,qry());\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1996e",
      "PROBLEM_ID": "1996E",
      "PROBLEM_STATEMENT": "In a desperate attempt to obtain your waifu favorite character, you have hacked into the source code of the game. After days of struggling, you finally find the binary string that encodes the gacha system of the game. In order to decode it, you must first solve the following problem.\n\nYou are given a binary string $s$ of length $n$. For each pair of integers $(l, r)$ $(1 \\leq l \\leq r \\leq n)$, count the number of pairs $(x, y)$ $(l \\leq x \\leq y \\leq r)$ such that the amount of $\\mathtt{0}$ equals the amount of $\\mathtt{1}$ in the substring $s_xs_{x+1}...s_y$.\n\nOutput the sum of counts over all possible $(l, r)$ modulo $10^9+7$.\n\n### Input\n\nThe first line contains $t$ ($1 \\leq t \\leq 1000$)\u00a0\u2014 the number of test cases.\n\nEach test case contains a binary string $s$ ($1 \\leq |s| \\leq 2 \\cdot 10^5$). It is guaranteed $s$ only contains characters $\\mathtt{0}$ and $\\mathtt{1}$.\n\nIt is guaranteed the sum of $|s|$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output an integer, the answer modulo $10^9+7$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n0000\n\n01010101\n\n1100111001\n\n11000000111\n\n```\n\n#### Output #1\n\n```\n0\n130\n147\n70\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Define MOD constant for modulo arithmetic\nconst int MOD = 1e9 + 7;\n\nint main() {\n    // Optimize standard input/output operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        string s; // Input binary string\n        cin >> s;\n        int n = s.length(); // Length of the string\n\n        // The core idea is to transform the problem into finding pairs of indices (i, j)\n        // such that the prefix sums of balances are equal.\n        // Let v_k = 1 if s_k = '1' and v_k = -1 if s_k = '0'.\n        // Define prefix sum P_k = sum_{m=1}^k v_m, with P_0 = 0.\n        // A substring s[x..y] has equal numbers of 0s and 1s if and only if P_y = P_{x-1}.\n        // The problem asks for the sum over all 1 <= l <= r <= n, of the count of pairs (x, y)\n        // such that l <= x <= y <= r and s[x..y] has equal 0s and 1s.\n        // This sum can be rewritten by changing the order of summation:\n        // Sum = sum_{1 <= x <= y <= n, P_y = P_{x-1}} x * (n - y + 1).\n        // Let i = x - 1 and j = y. The conditions become 0 <= i < j <= n and P_i = P_j.\n        // The term becomes (i + 1) * (n - j + 1).\n        // The final sum is Sum = sum_{0 <= i < j <= n, P_i = P_j} (i + 1) * (n - j + 1) mod MOD.\n\n        // We can compute this efficiently by iterating j from 1 to n.\n        // For each j, we find all i < j such that P_i = P_j.\n        // The contribution for a fixed j is (n - j + 1) * sum_{0 <= i < j, P_i = P_j} (i + 1).\n        // We maintain the required sums sum_{0 <= i < k, P_i = V} (i + 1) for different values V.\n\n        // Use a vector to store sums of (index + 1) for each prefix sum value.\n        // The prefix sum P can range from -n to n.\n        // We use an offset of n to map these values to non-negative indices [0, 2n].\n        // The size of the vector needs to be 2*n + 1.\n        vector<long long> sum_indices(2 * n + 1, 0);\n        \n        long long total_sum = 0; // Initialize total sum modulo MOD\n        long long current_P = 0; // Current prefix sum value (balance: #1s - #0s)\n        int offset = n; // Offset to map P to vector index P + offset\n        \n        // Initialize for the empty prefix P_0 = 0 which corresponds to index i=0 in the formula.\n        // The value stored for P_0 is (0+1) = 1.\n        int P0_shifted = current_P + offset;\n        sum_indices[P0_shifted] = 1; \n\n        // Iterate through the string indices j from 1 to n.\n        // P_j corresponds to the prefix sum up to the j-th character s[j-1].\n        for (int j = 1; j <= n; ++j) {\n            // Update the current prefix sum based on the character s[j-1].\n            // Character s[j-1] corresponds to the j-th character (1-based index).\n            if (s[j - 1] == '1') {\n                current_P += 1;\n            } else { // s[j-1] == '0'\n                current_P -= 1;\n            }\n            \n            // Calculate the shifted index for the current prefix sum P_j.\n            // This index will be used to access the sum_indices vector.\n            int Pj_shifted = current_P + offset;\n            // The index Pj_shifted is guaranteed to be within [0, 2n] because -n <= current_P <= n.\n\n            // Retrieve the sum S = sum_{0 <= i < j, P_i = P_j} (i+1)\n            // This value is stored in sum_indices[Pj_shifted], modulo MOD.\n            long long S = sum_indices[Pj_shifted];\n            \n            // Calculate the contribution of pairs (i, j) with P_i = P_j ending at index j to the total sum.\n            // The contribution is (n - j + 1) * S. Perform calculation using long long to avoid overflow.\n            // Take modulo MOD at the end.\n            long long term = (1LL * (n - j + 1) * S) % MOD;\n            \n            // Add the term to the total sum, taking modulo MOD.\n            total_sum = (total_sum + term) % MOD;\n\n            // Update the sum_indices vector for the current prefix sum P_j.\n            // Add (j+1) to the stored sum corresponding to P_j. This prepares the sum for future steps k > j where P_k = P_j.\n            // (j+1) is the value associated with index j in the formula.\n            // Take modulo MOD.\n            sum_indices[Pj_shifted] = (sum_indices[Pj_shifted] + (j + 1)) % MOD;\n        }\n        \n        // Ensure the final result is non-negative and within [0, MOD-1].\n        // In C++, the result of % operator can be negative if the dividend is negative.\n        // Although total_sum is built by adding non-negative terms here, this is safer practice.\n        cout << (total_sum % MOD + MOD) % MOD << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1996d",
      "PROBLEM_ID": "1996D",
      "PROBLEM_STATEMENT": "Counting is Fun!\n\n\u2014 satyam343\n\nGiven two integers $n$ and $x$, find the number of triplets ($a,b,c$) of positive integers such that $ab + ac + bc \\le n$ and $a + b + c \\le x$.\n\nNote that order matters (e.g. ($1, 1, 2$) and ($1, 2, 1$) are treated as different) and $a$, $b$, $c$ must be strictly greater than $0$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u00a0\u2014 the number of test cases.\n\nEach test case contains two integers $n$ and $x$ ($1 \\leq n,x \\leq 10^6$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$ and that the sum of $x$ over all test cases does not exceed $10^6$.\n\n### Output\n\nOutput a single integer \u2014 the number of triplets ($a,b,c$) of positive integers such that $ab + ac + bc \\le n$ and $a + b + c \\le x$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n7 4\n\n10 5\n\n7 1000\n\n900000 400000\n\n```\n\n#### Output #1\n\n```\n4\n10\n7\n1768016938\n```\n\n### Note\n\nIn the first test case, the triplets are ($1, 1, 1$), ($1, 1, 2$), ($1, 2, 1$), and ($2, 1, 1$).\n\nIn the second test case, the triplets are ($1, 1, 1$), ($1, 1, 2$), ($1, 1, 3$), ($1, 2, 1$), ($1, 2, 2$), ($1, 3, 1$), ($2, 1, 1$), ($2, 1, 2$), ($2, 2, 1$), and ($3, 1, 1$).",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nll countTriplets(ll n, ll x) {\n    ll count = 0;\n    \n    for (ll a = 1; a <= min(x-2, (n-1)/2); a++) {\n        for (ll b = 1; b <= min(x-a-1, (n-a)/(a+1)); b++) {\n            ll c_max1 = x - a - b;  // From second condition\n            ll c_max2 = (n - a*b) / (a+b);  // From first condition\n            ll c_max = min(c_max1, c_max2);\n            \n            if (c_max > 0) {\n                count += c_max;\n            }\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        ll n, x;\n        cin >> n >> x;\n        cout << countTriplets(n, x) << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1996c",
      "PROBLEM_ID": "1996C",
      "PROBLEM_STATEMENT": "You are given two strings $a$ and $b$ of length $n$. Then, you are (forced against your will) to answer $q$ queries.\n\nFor each query, you are given a range bounded by $l$ and $r$. In one operation, you can choose an integer $i$ ($l \\leq i \\leq r$) and set $a_i = x$ where $x$ is any character you desire. Output the minimum number of operations you must perform such that $\\texttt{sorted(a[l..r])} = \\texttt{sorted(b[l..r])}$. The operations you perform on one query does not affect other queries.\n\nFor an arbitrary string $c$, $\\texttt{sorted(c[l..r])}$ denotes the substring consisting of characters $c_l, c_{l+1}, ... , c_r$ sorted in lexicographical order.\n\n### Input\n\nThe first line contains $t$ ($1 \\leq t \\leq 1000$) \u2013 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\leq n, q \\leq 2 \\cdot 10^5$) \u2013 the length of both strings and the number of queries.\n\nThe following line contains $a$ of length $n$. It is guaranteed $a$ only contains lowercase latin letters.\n\nThe following line contains $b$ of length $n$. It is guaranteed $b$ only contains lowercase latin letters.\n\nThe following $q$ lines contain two integers $l$ and $r$ ($1 \\leq l \\leq r \\leq n$) \u2013 the range of the query.\n\nIt is guaranteed the sum of $n$ and $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each query, output an integer, the minimum number of operations you need to perform in a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5 3\n\nabcde\n\nedcba\n\n1 5\n\n1 4\n\n3 3\n\n4 2\n\nzzde\n\nazbe\n\n1 3\n\n1 4\n\n6 3\n\nuwuwuw\n\nwuwuwu\n\n2 4\n\n1 3\n\n1 6\n\n```\n\n#### Output #1\n\n```\n0\n1\n0\n2\n2\n1\n1\n0\n```\n\n### Note\n\nFor the first query, $\\texttt{sorted(a[1..5])} =$ abcde and $\\texttt{sorted(b[1..5])} =$ abcde, so no operations are necessary.\n\nFor the second query, you need to set $a_1 = $ e. Then, $\\texttt{sorted(a[1..4])} = \\texttt{sorted(b[1..4])} = $ bcde.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n\tint n, k;\n\tstring a, b;\n\tcin >> n >> k;\n\tcin >> a >> b;\n\tvector<vector<int>> a1(n + 1, vector<int>(26, 0));\n\tvector<vector<int>> b1(n + 1, vector<int>(26, 0));\n\tfor (int i = 0; i < n; ++i) {\n\t\ta1[i + 1] = a1[i], a1[i + 1][a[i] - 'a']++;\n\t\tb1[i + 1] = b1[i], b1[i + 1][b[i] - 'a']++;\n\t}\n\twhile (k--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tsum += min(a1[y][i] - a1[x - 1][i], b1[y][i] - b1[x - 1][i]);\n\t\t}\n\t\tcout << y - x + 1 - sum << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tsolve();\n\t}\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1996b",
      "PROBLEM_ID": "1996B",
      "PROBLEM_STATEMENT": "Tina has a square grid with $n$ rows and $n$ columns. Each cell in the grid is either $0$ or $1$.\n\nTina wants to reduce the grid by a factor of $k$ ($k$ is a divisor of $n$). To do this, Tina splits the grid into $k \\times k$ nonoverlapping blocks of cells such that every cell belongs to exactly one block.\n\nTina then replaces each block of cells with a single cell equal to the value of the cells in the block. It is guaranteed that every cell in the same block has the same value.\n\nFor example, the following demonstration shows a grid being reduced by factor of $3$.\n\nOriginal grid$0\n\n$$0$$\n\n0\n\n$$1$$\n\n1\n\n$$1$$\n\n0\n\n$$0$$\n\n0\n\n$$1$$\n\n1\n\n$$1$$\n\n0\n\n$$0$$\n\n0\n\n$$1$$\n\n1\n\n$$1$$\n\n1\n\n$$1$$\n\n1\n\n$$0$$\n\n0\n\n$$0$$\n\n1\n\n$$1$$\n\n1\n\n$$0$$\n\n0\n\n$$0$$\n\n1\n\n$$1$$\n\n1\n\n$$0$$\n\n0\n\n$$0$Reduced grid$0$$\n\n1\n\n$$1$$\n\n0$\n\nHelp Tina reduce the grid by a factor of $k$.\n\n### Input\n\nThe first line contains $t$ ($1 \\leq t \\leq 100$) \u2013 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\leq n \\leq 1000$, $1 \\le k \\le n$, $k$ is a divisor of $n$) \u2014 the number of rows and columns of the grid, and the factor that Tina wants to reduce the grid by.\n\nEach of the following $n$ lines contain $n$ characters describing the cells of the grid. Each character is either $0$ or $1$. It is guaranteed every $k$ by $k$ block has the same value.\n\nIt is guaranteed the sum of $n$ over all test cases does not exceed $1000$.\n\n### Output\n\nFor each test case, output the grid reduced by a factor of $k$ on a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4 4\n\n0000\n\n0000\n\n0000\n\n0000\n\n6 3\n\n000111\n\n000111\n\n000111\n\n111000\n\n111000\n\n111000\n\n6 2\n\n001100\n\n001100\n\n111111\n\n111111\n\n110000\n\n110000\n\n8 1\n\n11111111\n\n11111111\n\n11111111\n\n11111111\n\n11111111\n\n11111111\n\n11111111\n\n11111111\n\n```\n\n#### Output #1\n\n```\n0\n01\n10\n010\n111\n100\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        \n        vector<string> grid(n);\n        for (int i = 0; i < n; i++) {\n            cin >> grid[i];\n        }\n        \n        int reducedSize = n / k;\n        \n        for (int i = 0; i < reducedSize; i++) {\n            for (int j = 0; j < reducedSize; j++) {\n                // Since all cells in a block have the same value,\n                // we can just take the top-left cell of each block\n                cout << grid[i * k][j * k];\n            }\n            cout << endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1996a",
      "PROBLEM_ID": "1996A",
      "PROBLEM_STATEMENT": "It's another beautiful day on Farmer John's farm.\n\nAfter Farmer John arrived at his farm, he counted $n$ legs. It is known only chickens and cows live on the farm, and a chicken has $2$ legs while a cow has $4$.\n\nWhat is the minimum number of animals Farmer John can have on his farm assuming he counted the legs of all animals?\n\n### Input\n\nThe first line contains single integer $t$ ($1 \\leq t \\leq 10^3$)\u00a0\u2014 the number of test cases.\n\nEach test case contains an integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^3$, $n$ is even).\n\n### Output\n\nFor each test case, output an integer, the minimum number of animals Farmer John can have on his farm.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2\n\n6\n\n8\n\n```\n\n#### Output #1\n\n```\n1\n2\n2\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nint main() {\n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        int n;\n        std::cin >> n;\n        \n        // For n = 4k, we can have k cows (minimum is k animals)\n        // For n = 4k+2, we need k cows and 1 chicken (minimum is k+1 animals)\n        // This can be computed as (n+2)/4\n        int result = (n + 2) / 4;\n        \n        std::cout << result << std::endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1995d",
      "PROBLEM_ID": "1995D",
      "PROBLEM_STATEMENT": "You're a linguist studying a mysterious ancient language. You know that\n\n1. Its words consist only of the first $c$ letters of the Latin alphabet.\n2. Each word has a case which can be unambiguously determined by its last letter (different letters correspond to different cases). For example, words \"ABACABA\" and \"ABA\" (if they exist) have the same case in this language because they both have the same ending 'A', whereas \"ALICE\" and \"BOB\" have different cases. If the language does not have a case corresponding to some letter, it means that the word cannot end with this letter.\n3. The length of each word is $k$ or less.\n\nYou have a single text written in this language. Unfortunately, as the language is really ancient, spaces between words are missing and all letters are uppercase. You wonder what is the minimum number of cases the language can have. Can you find this out?\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10\\,000$)\u00a0\u2014 the number of test cases. It is followed by descriptions of the test cases.\n\nThe first line of each test case contains three integers $n$, $c$, $k$ ($1 \\le k \\le n \\le 2^{18}$, $1 \\le c \\le 18$)\u00a0\u2014 the length of the text, the number of letters in the language, and the maximum length of the word.\n\nThe second line contains a string of $n$ characters\u00a0\u2014 the text itself. Each character is one of the first $c$ uppercase letters of the Latin alphabet.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2^{18}$ and the sum of $2^c$ over all test cases does not exceed $2^{18}$.\n\n### Output\n\nFor each test case, output a single line consisting of a single integer\u00a0\u2014 the minimum number of cases in the language.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n5 5 1\n\nABCDE\n\n3 1 2\n\nAAA\n\n3 2 2\n\nAAB\n\n10 2 2\n\nABABABABAB\n\n4 4 4\n\nDCBA\n\n1 17 1\n\nQ\n\n9 3 2\n\nABCABCABC\n\n```\n\n#### Output #1\n\n```\n5\n1\n2\n1\n1\n1\n2\n```\n\n### Note\n\nIn the first test case, there must be five cases in the language (for each of the letters 'A', 'B', 'C', 'D', and 'E' there must be a case that has a corresponding ending).\n\nIn the fourth test case, one case with ending 'B' is sufficient.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\n#define ll long long\n#define N 1000005\nusing namespace std;\nll T,n,c,k,i,j,now,p[N],cnt[20],ans;\nchar s[N];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>T;\n\twhile(T--){\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tcin>>n>>c>>k>>(s+1),ans=c,now=0;\n\t\tfor(i=1;i<=k;i++) now|=(1ll<<(s[i]-'A')),cnt[s[i]-'A']++;\n\t\tp[((1<<c)-1)-now]=1;\n\t\tfor(i=k+1;i<=n;i++){\n\t\t\tnow|=(1ll<<(s[i]-'A')),cnt[s[i]-'A']++;\n\t\t\tif(--cnt[s[i-k]-'A']==0) now-=(1ll<<(s[i-k]-'A'));\n\t\t\tp[((1<<c)-1)-now]=1;\n\t\t}\n\t\tp[((1<<c)-1)-(1<<s[n]-'A')]=1;\n\t\tfor(i=0;i<c;i++){\n\t\t\tfor(j=0;j<(1<<c);j++) if((j>>i)&1) p[j-(1<<i)]|=p[j];\n\t\t}\n\t\tfor(i=0;i<(1<<c);i++) if(!p[i]) ans=min(ans,(ll)__builtin_popcount(i));\n\t\tcout<<ans<<endl;\n\t\tfor(i=0;i<(1<<c);i++) p[i]=0;\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1995c",
      "PROBLEM_ID": "1995C",
      "PROBLEM_STATEMENT": "ikrpprpp found an array $a$ consisting of integers. He likes justice, so he wants to make $a$ fair\u00a0\u2014 that is, make it non-decreasing. To do that, he can perform an act of justice on an index $1 \\le i \\le n$ of the array, which will replace $a_i$ with $a_i ^ 2$ (the element at position $i$ with its square). For example, if $a = [2,4,3,3,5,3]$ and ikrpprpp chooses to perform an act of justice on $i = 4$, $a$ becomes $[2,4,3,9,5,3]$.\n\nWhat is the minimum number of acts of justice needed to make the array non-decreasing?\n\n### Input\n\nFirst line contains an integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. It is followed by the description of test cases.\n\nFor each test case, the first line contains an integer $n$\u00a0\u2014 size of the array $a$. The second line contains $n$ ($1 \\le n \\le 2 \\cdot 10 ^5$) integers $a_1, a_2,\\ldots, a_n$ ($1 \\le a_i \\le 10 ^ 6$).\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot {10}^5$.\n\n### Output\n\nFor each testcase, print an integer\u00a0\u2014 minimum number of acts of justice required to make the array $a$ non-decreasing. If it is impossible to do that, print $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n3\n\n1 2 3\n\n2\n\n3 2\n\n3\n\n3 1 5\n\n4\n\n1 1 2 3\n\n3\n\n4 3 2\n\n9\n\n16 2 4 2 256 2 4 2 8\n\n11\n\n10010 10009 10008 10007 10006 10005 10004 10003 10002 10001 10000\n\n```\n\n#### Output #1\n\n```\n0\n1\n-1\n0\n3\n15\n55\n```\n\n### Note\n\nIn the first test case, there's no need to perform acts of justice. The array is fair on its own!\n\nIn the third test case, it can be proven that the array cannot become non-decreasing.\n\nIn the fifth test case, ikrpprppp can perform an act of justice on index 3, then an act of justice on index 2, and finally yet another act of justice on index 3. After that, $a$ will become $[4, 9, 16]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\tll n, flag = 1;\n\t\tcin >> n;\n\t\tvector<ll> a (n, 0);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> a[i];\n\t\t\tif(i != 0 && a[i-1] != 1 && a[i] == 1) flag = 0;\n\t\t}\n\t\tif(flag == 0) {\n\t\t\tcout << \"-1\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tvector<ll> b (n, 0);\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint num = 0;\n\t\t\tnum = b[i-1];\n\t\t\tll t = a[i-1];\n\t\t\twhile(t != 1 && t * t <= a[i]){\n\t\t\t\tt = t * t;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t\tll t1 = a[i];\n\t\t\twhile(t1 < t){\n\t\t\t\tt1 = t1 * t1;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tb[i] = max( 0 , num );\n\t\t}\n\t\tll ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tans += b[i];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1995b1",
      "PROBLEM_ID": "1995B1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The only difference is that in this version, the flowers are specified by enumeration.\n\nA girl is preparing for her birthday and wants to buy the most beautiful bouquet. There are a total of $n$ flowers in the store, each of which is characterized by the number of petals, and a flower with $k$ petals costs $k$ coins. The girl has decided that the difference in the number of petals between any two flowers she will use in her bouquet should not exceed one. At the same time, the girl wants to assemble a bouquet with the maximum possible number of petals. Unfortunately, she only has $m$ coins, and she cannot spend more. What is the maximum total number of petals she can assemble in the bouquet?\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10\\,000$)\u00a0\u2014 the number of test cases. This is followed by descriptions of the test cases.\n\nThe first line of each test case contains two integers $n$, $m$ ($1 \\le n \\le 2 \\cdot 10^5, 1 \\le m \\le 10^{18}$)\u00a0\u2014 the number of flowers in the store and the number of coins the girl possesses, respectively. The second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the number of petals of the $i$-th flower in the store.\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot {10}^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximum possible number of petals in the bouquet that the girl can assemble while meeting all the conditions listed above.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n5 10\n\n1 1 2 2 3\n\n8 20\n\n4 2 7 5 6 1 1 1\n\n8 100000\n\n239 30 610 122 24 40 8 2\n\n11 13\n\n2 4 11 1 1 2 3 5 4 3 2\n\n8 1033\n\n206 206 206 207 207 207 207 1000\n\n```\n\n#### Output #1\n\n```\n7\n13\n610\n13\n1033\n```\n\n### Note\n\nIn the first test case, you can assemble a bouquet with $(1, 1, 2, 2), (2, 2, 3), (1, 1), (2, 2)$. The maximum over all valid bouquets not greater than $10$ is $7$ for $(2, 2, 3)$. In the third test case, you can assemble a bouquet with only one flower of any type, so the answer is $610$. In the fourth test case, you can assemble a bouquet with $(4, 4, 5)$, which gives you $13$ petals, and it is the maximum amount of petals that the girl can buy.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        ll m;\n        cin >> n >> m;\n        vector<ll> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        sort(a.rbegin(), a.rend());\n        \n        ll max_petals = 0;\n        ll current_sum = 0;\n        int left = 0;\n        \n        for (int right = 0; right < n; ++right) {\n            current_sum += a[right];\n            while (left <= right && (a[left] - a[right] > 1 || current_sum > m)) {\n                current_sum -= a[left];\n                left++;\n            }\n            if (current_sum <= m) {\n                max_petals = max(max_petals, current_sum);\n            }\n        }\n        \n        cout << max_petals << '\\n';\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1995a",
      "PROBLEM_ID": "1995A",
      "PROBLEM_STATEMENT": "Vitaly503 is given a checkered board with a side of $n$ and $k$ chips. He realized that all these $k$ chips need to be placed on the cells of the board (no more than one chip can be placed on a single cell).\n\nLet's denote the cell in the $i$-th row and $j$-th column as $(i ,j)$. A diagonal is the set of cells for which the value $i + j$ is the same. For example, cells $(3, 1)$, $(2, 2)$, and $(1, 3)$ lie on the same diagonal, but $(1, 2)$ and $(2, 3)$ do not. A diagonal is called occupied if it contains at least one chip.\n\nDetermine what is the minimum possible number of occupied diagonals among all placements of $k$ chips.\n\n### Input\n\nEach test consists of several sets of input data. The first line contains a single integer $t$ ($1 \\le t \\le 500$)\u00a0\u2014 the number of sets of input data. Then follow the descriptions of the sets of input data.\n\nThe only line of each set of input data contains two integers $n$, $k$ ($1 \\le n \\le 100, 0 \\le k \\le n^2$)\u00a0\u2014 the side of the checkered board and the number of available chips, respectively.\n\n### Output\n\nFor each set of input data, output a single integer\u00a0\u2014 the minimum number of occupied diagonals with at least one chip that he can get after placing all $k$ chips.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n1 0\n\n2 2\n\n2 3\n\n2 4\n\n10 50\n\n100 239\n\n3 9\n\n```\n\n#### Output #1\n\n```\n0\n1\n2\n3\n6\n3\n5\n```\n\n### Note\n\nIn the first test case, there are no chips, so 0 diagonals will be occupied. In the second test case, both chips can be placed on diagonal $(2, 1), (1, 2)$, so the answer is 1. In the third test case, 3 chips can't be placed on one diagonal, but placing them on $(1, 2), (2, 1), (1, 1)$ makes 2 diagonals occupied. In the 7th test case, chips will occupy all 5 diagonals in any valid placing.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        \n        if (k == 0) {\n            cout << \"0\\n\";\n            continue;\n        }\n        \n        // Calculate the size of each diagonal\n        vector<int> diagonal_sizes;\n        for (int s = 2; s <= 2 * n; s++) {\n            int size;\n            if (s <= n + 1) {\n                size = s - 1;  // Diagonals starting from top-left\n            } else {\n                size = 2 * n + 1 - s;  // Diagonals starting from bottom-left\n            }\n            diagonal_sizes.push_back(size);\n        }\n        \n        // Sort diagonals by size in descending order\n        sort(diagonal_sizes.rbegin(), diagonal_sizes.rend());\n        \n        int diagonals_used = 0;\n        int chips_placed = 0;\n        \n        // Greedily place chips on largest diagonals first\n        for (int size : diagonal_sizes) {\n            if (chips_placed >= k) break;\n            \n            diagonals_used++;\n            int chips_to_place = min(size, k - chips_placed);\n            chips_placed += chips_to_place;\n        }\n        \n        cout << diagonals_used << \"\\n\";\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1994g",
      "PROBLEM_ID": "1994G",
      "PROBLEM_STATEMENT": "After winning another Bed Wars game, Masha and Olya wanted to relax and decided to play a new game. Masha gives Olya an array $a$ of length $n$ and a number $s$. Now Olya's task is to find a non-negative number $x$ such that $\\displaystyle\\sum_{i=1}^{n} a_i \\oplus x = s$. But she is very tired after a tight round, so please help her with this.\n\nBut this task seemed too simple to them, so they decided to make the numbers larger (up to $2^k$) and provide you with their binary representation.\n\n### Input\n\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n, k, n \\cdot k \\le 2 \\cdot 10^6$)\u00a0\u2014 the length of the array $a$ and the length of the binary representation of all numbers.\n\nThe second line contains a string of length $k$, consisting of zeros and ones\u00a0\u2014 the binary representation of the number $s$, starting from the most significant bits.\n\nThe next $n$ lines also contain strings of length $k$, consisting of zeros and ones, the $i$-th of these strings contains the binary representation of the number $a_i$, starting from the most significant bits.\n\nIt is guaranteed that the sum of the values $n \\cdot k$ for all test cases does not exceed $2 \\cdot 10^6$.\n\n### Output\n\nFor each test case, output a string of length $k$ on a separate line, consisting of zeros or ones\u00a0\u2014 the binary representation of any suitable number $x$ ($x \\ge 0$), starting from the most significant bits, or $-1$ if such $x$ does not exist.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n4 5\n\n01011\n\n01110\n\n00110\n\n01100\n\n01111\n\n2 8\n\n00101001\n\n10111111\n\n10011110\n\n5 4\n\n0101\n\n0010\n\n0000\n\n0000\n\n0010\n\n0011\n\n6 5\n\n00011\n\n10110\n\n11001\n\n01010\n\n11100\n\n10011\n\n10000\n\n```\n\n#### Output #1\n\n```\n01110\n10011010\n0010\n-1\n```\n\n### Note\n\nIn the first test case, $s = 11, a = [14, 6, 12, 15]$, if $x = 14$, then $\\displaystyle\\sum_{i=1}^{n} a_i \\oplus x = (14 \\oplus 14) + (6 \\oplus 14) + (12 \\oplus 14) + (15 \\oplus 14) = 0 + 8 + 2 + 1 = 11 = s$.\n\nIn the second test case, $s = 41, a = [191, 158]$, if $x = 154$, then $\\displaystyle\\sum_{i=1}^{n} a_i \\oplus x = (191 \\oplus 154) + (158 \\oplus 154) = 37 + 4 = 41 = s$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\n/*\n    Solution approach: Dynamic Programming on bits.\n\n    Problem: Find a non-negative integer x such that sum(a_i XOR x) = s.\n    The numbers a_i and s are given in binary representation of length k.\n    We need to find the binary representation of x, also length k.\n\n    We process the bits of x from Least Significant Bit (LSB, index 0) to Most Significant Bit (MSB, index k-1).\n    The state of the DP is (j, C), representing that we have processed bits 0 to j-1 of x, and the carry propagated into bit position j from position j-1 during the sum calculation is C.\n    Our goal is to determine if we can reach state (k, 0), which means after processing all k bits, the final carry is 0 (ensuring the sum is exactly s and does not exceed 2^k - 1).\n\n    Details of the transition:\n    At step j (processing bit j):\n    We need to decide the j-th bit of x, denoted x_j (0 or 1).\n    Let N1 be the count of numbers a_i such that the j-th bit of a_i is 1.\n    Let N0 be the count of numbers a_i such that the j-th bit of a_i is 0. Note N0 = n - N1.\n    Let s_j be the j-th bit of the target sum s.\n    Let C be the carry into bit position j from bit position j-1.\n\n    If we choose x_j = 0:\n    The j-th bit of (a_i XOR x) is the same as the j-th bit of a_i.\n    The sum of the j-th bits across all i is N1.\n    The total value contributed by bit position j (including carry-in) is T0 = N1 + C.\n    The j-th bit of the final sum S is T0 mod 2. This must match s_j.\n    The carry propagated to the next position (j+1) is C_{j+1} = floor(T0 / 2).\n    This transition is valid if (T0 mod 2 == s_j) and C_{j+1} <= n (since max carry cannot exceed n).\n\n    If we choose x_j = 1:\n    The j-th bit of (a_i XOR x) is the flipped j-th bit of a_i.\n    The sum of the j-th bits across all i is N0.\n    The total value contributed by bit position j (including carry-in) is T1 = N0 + C.\n    The j-th bit of the final sum S is T1 mod 2. This must match s_j.\n    The carry propagated to the next position (j+1) is C_{j+1} = floor(T1 / 2).\n    This transition is valid if (T1 mod 2 == s_j) and C_{j+1} <= n.\n\n    We use DP tables to store reachability and path information:\n    dp[step][carry]: Stores the bit choice (0 or 1) for x_{step-1} that led to reaching state (step, carry). Initialized to -1 (unreachable).\n    parent_carry[step][carry]: Stores the carry value C_{step-1} from the previous state (step-1, C_{step-1}) which led to state (step, carry).\n\n    Base case: dp[0][0] = 0. This signifies that at step 0 (before processing any bits), the carry is 0. The choice value is arbitrary but needed to mark state reachable.\n\n    The DP iterates from j = 0 to k-1. After the loop, we check if dp[k][0] != -1. If yes, a solution exists.\n    We reconstruct the binary string for x by backtracking from state (k, 0) using the parent_carry table to find the sequence of carries, and the dp table to find the corresponding choices for x_j bits.\n\n    Complexity:\n    Time: O(N*K) for precomputing N1 counts + O(N*K) for DP computation + O(K) for reconstruction. Overall O(N*K).\n    Memory: O(N*K) for the DP tables dp and parent_carry.\n    The problem constraint N*K <= 2*10^6 makes this approach feasible.\n*/\nint main() {\n    // Faster I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        int n; // Length of array a\n        int k; // Length of binary representations\n        cin >> n >> k;\n\n        string s_str; // Binary representation of s\n        cin >> s_str;\n        vector<string> a_str(n); // Binary representations of a_i\n        for (int i = 0; i < n; ++i) {\n            cin >> a_str[i];\n        }\n\n        // Precompute the count of '1's (N1) for each bit position j\n        // Bit j is indexed from 0 (LSB) to k-1 (MSB)\n        vector<int> N1_counts(k);\n        for (int j = 0; j < k; ++j) {\n            int count1 = 0;\n            // The j-th bit (LSB=0) corresponds to character index k-1-j in the input string (MSB=0)\n            int string_idx = k - 1 - j;\n            for (int i = 0; i < n; ++i) {\n                // Ensure string index is valid before accessing. It ranges from k-1 down to 0.\n                if (string_idx >= 0 && string_idx < k) {\n                    if (a_str[i][string_idx] == '1') {\n                        count1++;\n                    }\n                }\n            }\n            N1_counts[j] = count1;\n        }\n\n        // Extract the target bits s_j for each position j (0=LSB to k-1=MSB)\n        vector<int> s_bits(k);\n        for (int j = 0; j < k; ++j) {\n             // The j-th bit (LSB=0) corresponds to character index k-1-j in the input string\n            int string_idx = k - 1 - j;\n            if (string_idx >= 0 && string_idx < k) {\n               s_bits[j] = s_str[string_idx] - '0';\n            }\n        }\n\n        // DP state table: dp[step][carry] stores the bit choice (0 or 1) for x_{step-1}\n        // that led to being at step 'step' with 'carry'. -1 indicates unreachable.\n        // Dimensions: (k+1) steps x (n+1) possible carries (0 to n).\n        vector<vector<int>> dp(k + 1, vector<int>(n + 1, -1));\n        \n        // parent_carry[step][carry] stores the carry value C_{step-1} from the previous step ('step-1')\n        // that led to the current state ('step', 'carry').\n        vector<vector<int>> parent_carry(k + 1, vector<int>(n + 1, -1));\n\n        // Base case: At step 0 (before processing any bits), the carry is 0.\n        // Set dp[0][0] to 0 to mark it reachable. The choice value is arbitrary.\n        dp[0][0] = 0; \n\n        // Fill the DP table step by step (bit by bit from LSB to MSB)\n        for (int j = 0; j < k; ++j) { // Current bit position is j\n            int N1 = N1_counts[j]; // Count of a_i having j-th bit as 1\n            int N0 = n - N1;       // Count of a_i having j-th bit as 0\n            int target_bit = s_bits[j]; // Target j-th bit for the sum s\n\n            // Iterate through all possible carries C from the previous step (j)\n            for (int C = 0; C <= n; ++C) {\n                // If state (j, C) is reachable (i.e., dp[j][C] != -1)\n                if (dp[j][C] != -1) { \n\n                    // Option 1: Choose x_j = 0\n                    // Sum of j-th bits is N1. Total value at this bit = N1 + Carry C\n                    long long T0 = (long long)N1 + C; // Use long long for safety against potential overflow\n                    // Check if the parity matches the target bit s_j\n                    if ((T0 % 2) == target_bit) {\n                        long long C_next_ll = T0 / 2; // Calculate carry to the next step (j+1)\n                         // Ensure the next carry doesn't exceed n (max possible carry is n)\n                        if (C_next_ll <= n) { \n                            int C_next = (int)C_next_ll;\n                            // If the state (j+1, C_next) hasn't been reached yet\n                            if (dp[j + 1][C_next] == -1) { \n                                dp[j + 1][C_next] = 0; // Record that this state is reached via x_j=0\n                                parent_carry[j + 1][C_next] = C; // Store the carry C from previous step\n                            }\n                        }\n                    }\n\n                    // Option 2: Choose x_j = 1\n                    // Sum of j-th bits is N0. Total value at this bit = N0 + Carry C\n                    long long T1 = (long long)N0 + C;\n                    // Check if the parity matches the target bit s_j\n                    if ((T1 % 2) == target_bit) {\n                       long long C_next_ll = T1 / 2; // Calculate carry to the next step (j+1)\n                        // Ensure the next carry doesn't exceed n\n                        if (C_next_ll <= n) {\n                            int C_next = (int)C_next_ll;\n                            // If the state (j+1, C_next) hasn't been reached yet\n                            if (dp[j + 1][C_next] == -1) { \n                                dp[j + 1][C_next] = 1; // Record that this state is reached via x_j=1\n                                parent_carry[j + 1][C_next] = C; // Store the carry C from previous step\n                            }\n                            // If dp[j + 1][C_next] is already set (meaning reachable via x_j=0),\n                            // we don't overwrite. This policy finds *a* solution, potentially prioritizing x_j=0 path if both lead to the same state.\n                        }\n                    }\n                }\n            }\n        }\n\n        // After filling DP table, check if the final state (k, 0) is reachable.\n        // State (k, 0) means all k bits processed, and the final carry is 0.\n        if (dp[k][0] != -1) {\n            string x_str(k, '0'); // Initialize result string for x with default '0's\n            int current_carry = 0; // Start reconstruction from the target final carry = 0\n            // Reconstruct bits of x from MSB (j=k-1) down to LSB (j=0)\n            for (int j = k - 1; j >= 0; --j) {\n                // Get the choice x_j made at step j that led to state (j+1, current_carry)\n                // dp[j+1][current_carry] holds the value of x_j\n                int choice = dp[j + 1][current_carry];\n                // The j-th bit (LSB=0) corresponds to index k-1-j in the MSB-first string representation\n                x_str[k - 1 - j] = (choice == 0 ? '0' : '1');\n                // Update current_carry to the carry from the previous step (j) by backtracking\n                current_carry = parent_carry[j + 1][current_carry];\n                // Basic sanity check for reconstruction logic\n                 if (current_carry == -1 && j > 0) { \n                    // This state indicates an error if parent carry is -1 before reaching the initial state.\n                    // Could indicate a bug. But under correct logic this shouldn't happen.\n                 }\n            }\n            cout << x_str << \"\\n\"; // Output the found binary string for x\n        } else {\n            cout << -1 << \"\\n\"; // No solution found\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1994d",
      "PROBLEM_ID": "1994D",
      "PROBLEM_STATEMENT": "Vanya has a graph with $n$ vertices (numbered from $1$ to $n$) and an array $a$ of $n$ integers; initially, there are no edges in the graph. Vanya got bored, and to have fun, he decided to perform $n - 1$ operations.\n\nOperation number $x$ (operations are numbered in order starting from $1$) is as follows:\n\n- Choose $2$ different numbers $1 \\leq u,v \\leq n$, such that $|a_u - a_v|$ is divisible by $x$.\n- Add an undirected edge between vertices $u$ and $v$ to the graph.\n\nHelp Vanya get a connected$^{\\text{\u2217}}$ graph using the $n - 1$ operations, or determine that it is impossible.\n\n$^{\\text{\u2217}}$A graph is called connected if it is possible to reach any vertex from any other by moving along the edges.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{3}$)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains the number $n$ ($1 \\leq n \\leq 2000$)\u00a0\u2014 the number of vertices in the graph.\n\nThe second line of each test case contains $n$ numbers $a_1, a_2, \\cdots a_n$ ($1 \\leq a_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.\n\n### Output\n\nFor each test case, if there is no solution, then output \"No\" (without quotes).\n\nOtherwise, output \"Yes\" (without quotes), and then output $n - 1$ lines, where in the $i$-th line, output the numbers $u$ and $v$ that need to be chosen for operation $i$.\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n2\n\n1 4\n\n4\n\n99 7 1 13\n\n5\n\n10 2 31 44 73\n\n5\n\n87 6 81 44 32\n\n5\n\n62 35 33 79 16\n\n5\n\n6 51 31 69 42\n\n5\n\n52 63 25 21 5\n\n12\n\n33 40 3 11 31 43 37 8 50 5 12 22\n\n```\n\n#### Output #1\n\n```\nYES\n2 1\nYES\n4 1\n2 1\n3 2\nYES\n5 1\n4 1\n3 1\n2 1\nYES\n4 1\n3 1\n2 1\n5 4\nYES\n3 1\n5 1\n2 1\n4 2\nYES\n4 1\n5 1\n2 1\n3 2\nYES\n2 1\n5 2\n3 1\n4 3\nYES\n9 1\n12 9\n11 1\n10 1\n6 1\n7 6\n2 1\n8 2\n5 2\n3 1\n4 1\n```\n\n### Note\n\nLet's consider the second test case.\n\n- First operation $(x = 1)$: we can connect vertices $4$ and $1$, since $|a_4 - a_1| = |13 - 99| = |-86| = 86$, and $86$ is divisible by $1$.\n\n![](https://espresso.codeforces.com/24b0967a906dec08457b4ca26b1b9f94e4ae11d0.png)\n\n- Second operation $(x = 2)$: we can connect vertices $2$ and $1$, since $|a_2 - a_1| = |7 - 99| = |-92| = 92$, and $92$ is divisible by $2$.\n\n![](https://espresso.codeforces.com/fdb54e80cd5428b2a0b745bfed10e1b4409a4a07.png)\n\n- Third operation $(x = 3)$: we can connect vertices $3$ and $2$, since $|a_3 - a_2| = |1 - 7| = |-6| = 6$, and $6$ is divisible by $3$.\n\n![](https://espresso.codeforces.com/449331c248284a198b0c59042745856fef47c643.png) From the picture, it can be seen that a connected graph is obtained.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define pb  push_back\nint bin[2005];\nint find(int x){\n\treturn bin[x]==x?x:bin[x]=find(bin[x]);\n}\nvoid solve(){\n\tint n;\n\tcin>>n;\n\tvector<int>a(n+1,0);\n\tvector<pair<int,int>>ans;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tbin[i]=i;\n\t}\n\tfor(int i=n-1;i>=1;i--){\n\t\tmap<int,vector<int>>c;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tc[a[j]%i].pb(j);\n\t\t}\n\t\tfor(auto x:c){\n\t\t\tvector<int>q=x.second;\n\t\t\tif(q.size()==1)continue;\n\t\t\tint X=find(q[0]),f=1;\n\t\t\tfor(int j=1;j<q.size();j++){\n\t\t\t\tint Y=find(q[j]);\n\t\t\t\tif(Y!=X){\n\t\t\t\tans.pb({q[0],q[j]});\n\t\t\t\tbin[Y]=X;\n\t\t\t\tf=0;break;}\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t}\n\tcout<<\"YES\"<<'\n';\n\tfor(int i=ans.size()-1;i>=0;i--)cout<<ans[i].first<<\" \"<<ans[i].second<<'\n';\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0),cout.tie(0);\n\tint t=1;\n\tcin>>t;\n\twhile(t--)solve();\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1994c",
      "PROBLEM_ID": "1994C",
      "PROBLEM_STATEMENT": "Yaroslav is playing a computer game, and at one of the levels, he encountered $n$ mushrooms arranged in a row. Each mushroom has its own level of toxicity; the $i$-th mushroom from the beginning has a toxicity level of $a_i$. Yaroslav can choose two integers $1 \\le l \\le r \\le n$, and then his character will take turns from left to right to eat mushrooms from this subsegment one by one, i.e., the mushrooms with numbers $l, l+1, l+2, \\ldots, r$.\n\nThe character has a toxicity level $g$, initially equal to $0$. The computer game is defined by the number $x$\u00a0\u2014 the maximum toxicity level at any given time. When eating a mushroom with toxicity level $k$, the following happens:\n\n1. The toxicity level of the character is increased by $k$.\n2. If $g \\leq x$, the process continues; otherwise, $g$ becomes zero and the process continues.\n\nYaroslav became interested in how many ways there are to choose the values of $l$ and $r$ such that the final value of $g$ is not zero. Help Yaroslav find this number!\n\n### Input\n\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{4}$)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains two integers $n$, $x$ ($1 \\leq n \\leq 2 \\cdot 10^5, 1 \\le x \\le 10^9$)\u00a0\u2014 the number of mushrooms and the maximum toxicity level.\n\nThe second line of each test case contains $n$ numbers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single number\u00a0\u2014 the number of subsegments such that the final value of $g$ will not be zero.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4 2\n\n1 1 1 1\n\n3 2\n\n1 2 3\n\n1 6\n\n10\n\n6 3\n\n1 2 1 4 3 8\n\n5 999999999\n\n999999999 999999998 1000000000 1000000000 500000000\n\n```\n\n#### Output #1\n\n```\n8\n2\n0\n10\n7\n```\n\n### Note\n\nIn the first test case, the subsegments $(1, 1)$, $(1, 2)$, $(1, 4)$, $(2, 2)$, $(2, 3)$, $(3, 3)$, $(3, 4)$ and $(4, 4)$ are suitable.\n\nIn the second test case, non-zero $g$ will remain only on the subsegments $(1, 1)$ and $(2, 2)$.\n\nIn the third test case, on the only possible subsegment, $g$ will be zero.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint t,n,g,a[200005],ans;\nsigned main(){\n\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tfor(cin>>t;t;t--){\n\t\tcin>>n>>g;\n\t\tvector<int>dp(n+5,0);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tint r=n+1,sum=0,ans=0;\n\t\tfor(int l=n;l;l--){\n\t\t\tsum+=a[l];\n\t\t\twhile(sum>g){\n\t\t\t\tsum-=a[--r];\n\t\t\t}\n\t\t\tdp[l]=dp[r+1]+r-l,ans+=dp[l];\n\t\t}\n\t\tcout<<ans<<'\n';\n\t}\n\treturn 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1994b",
      "PROBLEM_ID": "1994B",
      "PROBLEM_STATEMENT": "Vova really loves the [XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) operation (denoted as $\\oplus$). Recently, when he was going to sleep, he came up with a fun game.\n\nAt the beginning of the game, Vova chooses two binary sequences $s$ and $t$ of length $n$ and gives them to Vanya. A binary sequence is a sequence consisting only of the numbers $0$ and $1$. Vanya can choose integers $l, r$ such that $1 \\leq l \\leq r \\leq n$, and for all $l \\leq i \\leq r$ simultaneously replace $s_i$ with $s_i \\oplus s_{i - l + 1}$, where $s_i$ is the $i$-th element of the sequence $s$.\n\nIn order for the game to be interesting, there must be a possibility to win. Vanya wins if, with an unlimited number of actions, he can obtain the sequence $t$ from the sequence $s$. Determine if the game will be interesting for the sequences $s$ and $t$.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains an integer $q$ ($1 \\le q \\le 10^{4}$)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the length of the sequences $s$ and $t$.\n\nThe second line of each test case contains a binary sequence $s$ of length $n$.\n\nThe third line of each test case contains a binary sequence $t$ of length $n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output \"Yes\" if the game will be interesting, otherwise output \"No\".\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1\n\n0\n\n1\n\n7\n\n0110100\n\n0110100\n\n9\n\n100101010\n\n101111110\n\n4\n\n0011\n\n1011\n\n4\n\n0100\n\n0001\n\n8\n\n10110111\n\n01100000\n\n```\n\n#### Output #1\n\n```\nNO\nYES\nYES\nNO\nYES\nYES\n```\n\n### Note\n\nIn the first test case, Vanya will not be able to change the sequence $s$ with the only possible action of choosing $l = r = 1$.\n\nIn the second test case, the sequences $s$ and $t$ are already equal.\n\nIn the third test case, Vanya can act as follows:\n\n1. Choose $l = 3$ and $r = 5$, then $s$ will become $\\mathtt{101101010}$.\n2. Choose $l = 5$ and $r = 6$, then $s$ will become $\\mathtt{101111010}$.\n3. Choose $l = 7$ and $r = 7$, then $s$ will become $\\mathtt{101111110}$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nint main() {\n\n  long q;\n  std::cin >> q;\n  while (q--) {\n    long n;\n    std::cin >> n;\n    std::string s, t;\n    std::cin >> s >> t;\n    bool possible(true);\n    for (long p = 0; possible && p < s.size(); p++) {\n      if (s[p] == '1') {\n        break;\n      } else if (t[p] == '1') {\n        possible = false;\n      }\n    }\n\n    std::cout << (possible ? \"YES\" : \"NO\") << std::endl;\n  }\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1994a",
      "PROBLEM_ID": "1994A",
      "PROBLEM_STATEMENT": "Petr, watching Sergey's stream, came up with a matrix $a$, consisting of $n$ rows and $m$ columns (the number in the $i$-th row and $j$-th column is denoted as $a_{i, j}$), which contains all integers from $1$ to $n \\cdot m$. But he didn't like the arrangement of the numbers, and now he wants to come up with a new matrix $b$, consisting of $n$ rows and $m$ columns, which will also contain all integers from $1$ to $n \\cdot m$, such that for any $1 \\leq i \\leq n, 1 \\leq j \\leq m$ it holds that $a_{i, j} \\ne b_{i, j}$.\n\nYou are given the matrix $a$, construct any matrix $b$ that meets Petr's requirements, or determine that it is impossible.\n\nHurry up! Otherwise, he will donate all his money to the stream in search of an answer to his question.\n\n### Input\n\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\leq t \\leq 10^3$)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 10$)\u00a0\u2014 the number of rows and columns of matrix $a$.\n\nThe next $n$ lines contain $m$ integers each, describing matrix $a$. The $i$-th of these lines contains the elements of matrix $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, m}$.\n\nIt is guaranteed that all numbers in matrix $a$ are distinct and $1 \\leq a_{i, j} \\leq n \\cdot m$.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $5 \\cdot 10^4$.\n\n### Output\n\nFor each test case, output $n \\cdot m$ integers\u00a0\u2014 any suitable matrix $b$, or $-1$ if such a matrix does not exist.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1 1\n\n1\n\n2 1\n\n2\n\n1\n\n1 5\n\n2 4 5 3 1\n\n2 4\n\n1 2 3 4\n\n5 6 7 8\n\n3 3\n\n4 2 1\n\n9 8 3\n\n6 7 5\n\n```\n\n#### Output #1\n\n```\n-1\n1\n2\n4 5 3 1 2\n6 7 8 5\n2 3 4 1\n8 3 9\n7 5 6\n2 1 4\n```\n\n### Note\n\nIn the first test case, there is only one element in the matrix, so matrix $b$ is the only matrix and it does not fit.\n\nIn the second test case $a_{1, 1} = 2 \\neq 1 = b_{1, 1}$, $a_{2, 1} = 1 \\neq 2 = b_{2, 1}$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    for (int test = 0; test < t; test++) {\n        int n, m;\n        cin >> n >> m;\n        vector<int> a;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int x;\n                cin >> x;\n                a.push_back(x);\n            }\n        }\n        if (a.size() == 1) {\n            cout << -1 << endl;\n            continue;\n        }\n        vector<int> b;\n        b.push_back(a.back());\n        for (int i = 0; i < a.size() - 1; i++) {\n            b.push_back(a[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cout << b[i * m + j] << \" \";\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1993f2",
      "PROBLEM_ID": "1993F2",
      "PROBLEM_STATEMENT": "This is the hard version of the problem. The only difference is that in this version $k \\le 10^{12}$. You can make hacks only if both versions of the problem are solved.\n\nGiven a $w \\times h$ rectangle on the $Oxy$ plane, with points $(0, 0)$ at the bottom-left and $(w, h)$ at the top-right of the rectangle.\n\nYou also have a robot initially at point $(0, 0)$ and a script $s$ of $n$ characters. Each character is either L, R, U, or D, which tells the robot to move left, right, up, or down respectively.\n\nThe robot can only move inside the rectangle; otherwise, it will change the script $s$ as follows:\n\n- If it tries to move outside a vertical border, it changes all L characters to R's (and vice versa, all R's to L's).\n- If it tries to move outside a horizontal border, it changes all U characters to D's (and vice versa, all D's to U's).\n\nThen, it will execute the changed script starting from the character which it couldn't execute.\n\n![](https://espresso.codeforces.com/44058d13574b8a336b6b4ffc319b349c0a98032e.png)An example of the robot's movement process, $s = \\texttt{\"ULULURD\"}$\n\nThe script $s$ will be executed for $k$ times continuously. All changes to the string $s$ will be retained even when it is repeated. During this process, how many times will the robot move to the point $(0, 0)$ in total? Note that the initial position does NOT count.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains four integers $n$, $k$, $w$, and $h$ ($1 \\le n, w, h \\le 10^6$; $1 \\le k \\le 10^{12}$).\n\nThe second line contains a single string $s$ of size $n$ ($s_i \\in \\{\\texttt{L}, \\texttt{R}, \\texttt{U}, \\texttt{D}\\}$)\u00a0\u2014 the script to be executed.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the number of times the robot reaches $(0, 0)$ when executing script $s$ for $k$ times continuously.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n2 4 2 2\n\nUR\n\n4 2 1 1\n\nLLDD\n\n6 3 3 1\n\nRLRRRL\n\n5 6 3 3\n\nRUURD\n\n7 5 3 4\n\nRRDLUUU\n\n7 123456789999 3 2\n\nULULURD\n\n```\n\n#### Output #1\n\n```\n1\n4\n3\n1\n1\n41152263332\n```\n\n### Note\n\nIn the first test case, the robot only moves up and right for the first two executions. After that, it occupies the position $(2, 2)$. For the next two executions, it moves down and left and finishes at $(0, 0)$. So the answer is $1$.\n\nIn the second test case, each time executing the script the robot visits the origin twice. And since $k=2$, it visits the origin $2 \\cdot 2 = 4$ times overall.\n\n![](https://espresso.codeforces.com/4fc54bd5ef19b611fe31366a3ac8c0ccfa7bf1f1.png)\n\nIn the third test case, the visualization is shown as below:\n\n![](https://espresso.codeforces.com/fbf49c7b363f655844f0192b2cbc3766a46aaa29.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nnamespace CRT {    \n    // v * inv(v, M) = 1 (mod M)\n    ll inv(ll v, ll M) {\n        ll a = 1, b = 0;\n        for (ll x = v, y = M; x != 0; ) {\n            swap(a, b -= y/x * a);\n            swap(x, y -= y/x * x);\n        }\n        return b + (b<0) * M;\n    }\n\n    // Minimum x that ax = b (mod c)\n    ll solve_1(ll a, ll b, ll c) {\n        ll g = gcd(a, c);\n        if (b % g != 0) return -1;\n        return b/g * inv(a/g, c/g) % (c/g);\n    }\n\n    // Minimum x that x%b = a and x%d = c\n    ll solve_2(ll a, ll b, ll c, ll d) {\n        ll t = (c-a)%d;\n        if (t < 0) t += d;\n        ll k = solve_1(b, t, d);\n        return k==-1 ? -1 : a + k*b;\n    }\n}\n\nconst int N = 1e6 + 5;\n\nll n, k, w, h;\nll x[N], y[N];\n\nint main() {\n    cin.tie(nullptr) -> sync_with_stdio(false);\n\n    int tc; cin >> tc;\n    while (tc--) {\n        string s;\n        cin >> n >> k >> w >> h >> s;\n\n        for (int i = 1; i <= n; i++) {\n            x[i] = x[i-1] + (s[i-1] == 'R') - (s[i-1] == 'L');\n            y[i] = y[i-1] + (s[i-1] == 'U') - (s[i-1] == 'D');\n            x[i] += (x[i] < 0) * 2*w - (x[i] >= 2*w) * 2*w;\n            y[i] += (y[i] < 0) * 2*h - (y[i] >= 2*h) * 2*h;\n        }\n\n        ll ww = 2*w / gcd(x[n], 2*w);\n        ll hh = 2*h / gcd(y[n], 2*h);\n        ll ans = 0, l = lcm(ww, hh);\n\n        for (int i = 1; i <= n; i++) {\n            ll cx = CRT::solve_1(x[n], 2*w - x[i], 2*w);\n            ll cy = CRT::solve_1(y[n], 2*h - y[i], 2*h);\n            if (cx == -1 || cy == -1) continue;\n\n            ll result = CRT::solve_2(cx, ww, cy, hh);\n            if (result != -1 && result < k) {\n                ans += (k - result - 1) / l + 1;\n            }\n        }\n\n        cout << ans << '\\n';\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1993f1",
      "PROBLEM_ID": "1993F1",
      "PROBLEM_STATEMENT": "This is the easy version of the problem. The only difference is that in this version $k \\le n$. You can make hacks only if both versions of the problem are solved.\n\nGiven a $w \\times h$ rectangle on the $Oxy$ plane, with points $(0, 0)$ at the bottom-left and $(w, h)$ at the top-right of the rectangle.\n\nYou also have a robot initially at point $(0, 0)$ and a script $s$ of $n$ characters. Each character is either L, R, U, or D, which tells the robot to move left, right, up, or down respectively.\n\nThe robot can only move inside the rectangle; otherwise, it will change the script $s$ as follows:\n\n- If it tries to move outside a vertical border, it changes all L characters to R's (and vice versa, all R's to L's).\n- If it tries to move outside a horizontal border, it changes all U characters to D's (and vice versa, all D's to U's).\n\nThen, it will execute the changed script starting from the character which it couldn't execute.\n\n![](https://espresso.codeforces.com/44058d13574b8a336b6b4ffc319b349c0a98032e.png)An example of the robot's movement process, $s = \\texttt{\"ULULURD\"}$\n\nThe script $s$ will be executed for $k$ times continuously. All changes to the string $s$ will be retained even when it is repeated. During this process, how many times will the robot move to the point $(0, 0)$ in total? Note that the initial position does NOT count.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains four integers $n$, $k$, $w$, and $h$ ($1 \\le n, w, h \\le 10^6$; $1 \\le k \\le n$).\n\nThe second line contains a single string $s$ of size $n$ ($s_i \\in \\{\\texttt{L}, \\texttt{R}, \\texttt{U}, \\texttt{D}\\}$)\u00a0\u2014 the script to be executed.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the number of times the robot reaches $(0, 0)$ when executing script $s$ for $k$ times continuously.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2 2 2 2\n\nUR\n\n4 2 1 1\n\nLLDD\n\n6 3 3 1\n\nRLRRRL\n\n5 5 3 3\n\nRUURD\n\n7 5 3 4\n\nRRDLUUU\n\n```\n\n#### Output #1\n\n```\n0\n4\n3\n0\n1\n```\n\n### Note\n\nIn the first test case, the robot only moves up and right. In the end, it occupies the position $(2, 2)$ but never visits $(0, 0)$. So the answer is $0$.\n\nIn the second test case, each time executing the script the robot visits the origin twice. And since $k=2$, it visits the origin $2 \\cdot 2 = 4$ times overall.\n\n![](https://espresso.codeforces.com/4fc54bd5ef19b611fe31366a3ac8c0ccfa7bf1f1.png)\n\nIn the third test case, the visualization is shown as below:\n\n![](https://espresso.codeforces.com/fbf49c7b363f655844f0192b2cbc3766a46aaa29.png)",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nconst int N = 1e6 + 5;\n \nstring s;\nll n, k, w, h;\nll tx[2*N], ty[2*N];\nmap<pair<ll, ll>, ll> cnt;\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n    \n    int t;\n    cin >> t;\n \n    while (t--) {\n        cin >> n >> k >> w >> h >> s;\n \n        cnt.clear();\n        ll x = 0, y = 0;\n \n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'L') x--;\n            if (s[i] == 'R') x++;\n            if (s[i] == 'D') y--;\n            if (s[i] == 'U') y++;\n\n            x = (x + 2*w) % (2*w);\n            y = (y + 2*h) % (2*h);\n            cnt[{x, y}]++;\n        }\n \n        ll ans = 0;\n        for (int i = 0; i < k; i++) {\n            ll vx = (-i*x%(2*w) + 2*w)%(2*w);\n            ll vy = (-i*y%(2*h) + 2*h)%(2*h);\n            ans += cnt[{vx, vy}];\n        }\n\n        cout << ans << '\\n';\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1993e",
      "PROBLEM_ID": "1993E",
      "PROBLEM_STATEMENT": "Given a matrix $a$ of size $n \\times m$, each cell of which contains a non-negative integer. The integer lying at the intersection of the $i$-th row and the $j$-th column of the matrix is called $a_{i,j}$.\n\nLet's define $f(i)$ and $g(j)$ as the [XOR](https://en.wikipedia.org/wiki/Exclusive_or) of all integers in the $i$-th row and the $j$-th column, respectively. In one operation, you can either:\n\n- Select any row $i$, then assign $a_{i,j} := g(j)$ for each $1 \\le j \\le m$; or\n- Select any column $j$, then assign $a_{i,j} := f(i)$ for each $1 \\le i \\le n$.\n\n![](https://espresso.codeforces.com/3ad45bee646fd98f1fde1a1caab7627c01708237.png)An example of applying an operation on column $2$ of the matrix.\n\nIn this example, as we apply an operation on column $2$, all elements in this column are changed:\n\n- $a_{1,2} := f(1) = a_{1,1} \\oplus a_{1,2} \\oplus a_{1,3} \\oplus a_{1,4} = 1 \\oplus 1 \\oplus 1 \\oplus 1 = 0$\n- $a_{2,2} := f(2) = a_{2,1} \\oplus a_{2,2} \\oplus a_{2,3} \\oplus a_{2,4} = 2 \\oplus 3 \\oplus 5 \\oplus 7 = 3$\n- $a_{3,2} := f(3) = a_{3,1} \\oplus a_{3,2} \\oplus a_{3,3} \\oplus a_{3,4} = 2 \\oplus 0 \\oplus 3 \\oplus 0 = 1$\n- $a_{4,2} := f(4) = a_{4,1} \\oplus a_{4,2} \\oplus a_{4,3} \\oplus a_{4,4} = 10 \\oplus 11 \\oplus 12 \\oplus 16 = 29$\n\nYou can apply the operations any number of times. Then, we calculate the $\\textit{beauty}$ of the final matrix by summing the absolute differences between all pairs of its adjacent cells.\n\nMore formally, $\\textit{beauty}(a) = \\sum|a_{x,y} - a_{r,c}|$ for all cells $(x, y)$ and $(r, c)$ if they are adjacent. Two cells are considered adjacent if they share a side.\n\nFind the minimum $\\textit{beauty}$ among all obtainable matrices.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 250$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 15$)\u00a0\u2014 the number of rows and columns of $a$, respectively.\n\nThe next $n$ lines, each containing $m$ integers $a_{i,1}, a_{i,2}, \\ldots, a_{i,m}$ ($0 \\le a_{i,j} < 2^{20}$)\u00a0\u2014 description of the matrix $a$.\n\nIt is guaranteed that the sum of $(n^2 + m^2)$ over all test cases does not exceed $500$.\n\n### Output\n\nFor each test case, print a single integer $b$\u00a0\u2014 the smallest possible $\\textit{beauty}$ of the matrix.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1 2\n\n1 3\n\n2 3\n\n0 1 0\n\n5 4 4\n\n2 3\n\n0 2 4\n\n4 5 1\n\n3 3\n\n1 2 3\n\n4 5 6\n\n7 8 9\n\n```\n\n#### Output #1\n\n```\n1\n3\n13\n24\n```\n\n### Note\n\nLet's denote $r(i)$ as the first type operation applied on the $i$-th row, and $c(j)$ as the second type operation applied on the $j$-th column.\n\nIn the first test case, you can apply an operation $c(1)$, which assigns $a_{1,1} := 1 \\oplus 3 = 2$. Then, we'll receive this matrix:\n\n23\n\nIn the second test case, you can apply an operation $r(1)$, which assigns:\n\n- $a_{1,1} := g(1) = 0 \\oplus 5 = 5$\n- $a_{1,2} := g(2) = 1 \\oplus 4 = 5$\n- $a_{1,3} := g(3) = 0 \\oplus 4 = 4$\n\nThe resulting matrix after performing the operation is:\n\n554544\n\nIn the third test case, the best way to achieve minimum $\\textit{beauty}$ is applying three operations: $c(3)$, $r(2)$, and $c(2)$. The resulting matrix is:\n\n046456",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 16;\n \nint n, m;\nint a[N][N];\n \nint fr[N][N], fc[N][N];\nint w[N][N], dp[N][1<<N];\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n    \n    int t;\n    cin >> t;\n \n    while (t--) {\n        cin >> n >> m;\n \n        for (int i = 0; i <= n; i++) a[i][m] = 0;\n        for (int j = 0; j <= m; j++) a[n][j] = 0;\n \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> a[i][j];\n                a[i][m] ^= a[i][j];\n                a[n][j] ^= a[i][j];\n                a[n][m] ^= a[i][j];\n            }\n        }\n \n        int fullmask_n = (1 << (n+1)) - 1;\n        int fullmask_m = (1 << (m+1)) - 1;\n \n        for (int rmv = 0; rmv <= m; rmv++) {\n            for (int i = 0; i <= n; i++) {\n                for (int j = i + 1; j <= n; j++) {\n                    w[i][j] = 0;\n                    for (int l = 0; l <= m; l++) {\n                        if (rmv == l) continue;\n                        w[i][j] += abs(a[i][l] - a[j][l]);\n                    }\n                    w[j][i] = w[i][j];\n                }\n            }\n \n            for (int i = 0; i <= n; i++) {\n                fill(dp[i], dp[i] + fullmask_n, INT_MAX);\n                dp[i][1 << i] = 0;\n            }\n \n            for (int mask = 0; mask <= fullmask_n; mask++) {\n                for (int last = 0; last <= n; last++) {\n                    if (~mask >> last & 1) continue;\n                    if (__builtin_popcount(mask) == n) continue;\n \n                    for (int next = 0; next <= n; next++) {\n                        if (mask >> next & 1) continue;\n \n                        int new_mask = mask | 1 << next;\n                        dp[next][new_mask] = min(\n                            dp[next][new_mask],\n                            dp[last][mask] + w[last][next]\n                        );\n                    }\n                }\n            }\n \n            for (int i = 0; i <= n; i++) {\n                fr[i][rmv] = INT_MAX;\n                int mask = fullmask_n ^ 1 << i;\n \n                for (int last = 0; last <= n; last++) {\n                    fr[i][rmv] = min(fr[i][rmv], dp[last][mask]);\n                }\n            }\n        }\n \n        for (int rmv = 0; rmv <= n; rmv++) {\n            for (int i = 0; i <= m; i++) {\n                for (int j = i + 1; j <= m; j++) {\n                    w[i][j] = 0;\n                    for (int l = 0; l <= n; l++) {\n                        if (rmv == l) continue;\n                        w[i][j] += abs(a[l][i] - a[l][j]);\n                    }\n                    w[j][i] = w[i][j];\n                }\n            }\n \n            for (int i = 0; i <= m; i++) {\n                fill(dp[i], dp[i] + fullmask_m, INT_MAX);\n                dp[i][1 << i] = 0;\n            }\n \n            for (int mask = 0; mask <= fullmask_m; mask++) {\n                for (int last = 0; last <= m; last++) {\n                    if (~mask >> last & 1) continue;\n                    if (__builtin_popcount(mask) == m) continue;\n \n                    for (int next = 0; next <= m; next++) {\n                        if (mask >> next & 1) continue;\n \n                        int new_mask = mask | 1 << next;\n                        dp[next][new_mask] = min(\n                            dp[next][new_mask],\n                            dp[last][mask] + w[last][next]\n                        );\n                    }\n                }\n            }\n \n            for (int i = 0; i <= m; i++) {\n                fc[rmv][i] = INT_MAX;\n                int mask = fullmask_m ^ 1 << i;\n \n                for (int last = 0; last <= m; last++) {\n                    fc[rmv][i] = min(fc[rmv][i], dp[last][mask]);\n                }\n            }\n        }\n \n        int ans = INT_MAX;\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                ans = min(ans, fr[i][j] + fc[i][j]);\n            }\n        }\n \n        cout << ans << '\\n';\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1993d",
      "PROBLEM_ID": "1993D",
      "PROBLEM_STATEMENT": "Given two positive integers $n$ and $k$, and another array $a$ of $n$ integers.\n\nIn one operation, you can select any subarray of size $k$ of $a$, then remove it from the array without changing the order of other elements. More formally, let $(l, r)$ be an operation on subarray $a_l, a_{l+1}, \\ldots, a_r$ such that $r-l+1=k$, then performing this operation means replacing $a$ with $[a_1, \\ldots, a_{l-1}, a_{r+1}, \\ldots, a_n]$.\n\nFor example, if $a=[1,2,3,4,5]$ and we perform operation $(3,5)$ on this array, it will become $a=[1,2]$. Moreover, operation $(2, 4)$ results in $a=[1,5]$, and operation $(1,3)$ results in $a=[4,5]$.\n\nYou have to repeat the operation while the length of $a$ is greater than $k$ (which means $|a| \\gt k$). What is the largest possible median$^\\dagger$ of all remaining elements of the array $a$ after the process?\n\n$^\\dagger$The median of an array of length $n$ is the element whose index is $\\left \\lfloor (n+1)/2 \\right \\rfloor$ after we sort the elements in non-decreasing order. For example: $median([2,1,5,4,3]) = 3$, $median([5]) = 5$, and $median([6,8,2,4]) = 4$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n, k \\le 5 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the largest median possible after performing the operations.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n4 3\n\n3 9 9 2\n\n5 3\n\n3 2 5 6 4\n\n7 1\n\n5 9 2 6 5 4 6\n\n8 2\n\n7 1 2 6 8 3 4 5\n\n4 5\n\n3 4 5 6\n\n```\n\n#### Output #1\n\n```\n3\n4\n9\n6\n4\n```\n\n### Note\n\nIn the first test case, you can select a subarray $(l, r)$ which can be either $(1, 3)$ or $(2, 4)$. Thus, two obtainable final arrays are $[3]$ and $[2]$. The former one has the larger median ($3 > 2$) so the answer is $3$.\n\nIn the second test case, three obtainable final arrays are $[6, 4]$, $[3, 4]$, and $[3, 2]$. Their medians are $4$, $3$, and $2$ respectively. The answer is $4$.\n\nIn the third test case, only one element is left in the final array and it can be any element of the initial array. The largest one among them is $9$, so the answer is $9$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 500005;\n\nint n, k, a[N];\nint dp[N], b[N];\n\nbool check(int med) {\n    for (int i = 0; i < n; i++) {\n        if (a[i] >= med) {\n            b[i] = 1;\n        } else {\n            b[i] = -1;\n        }\n    }\n\n    dp[0] = b[0];\n    for (int i = 1; i < n; i++) {\n        if (i%k == 0) {\n            dp[i] = max(dp[i-k], b[i]);\n        } else {\n            dp[i] = dp[i-1] + b[i];\n            if (i > k) {\n                dp[i] = max(dp[i], dp[i-k]);\n            }\n        }\n    }\n\n    return dp[n-1] > 0;\n}\n\nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n\n    int t; cin >> t;\n    while (t--) {\n        cin >> n >> k;\n\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n\n        int lo = 1, hi = 1e9;\n        while (lo <= hi) {\n            int mid = lo + hi >> 1;\n            if (check(mid)) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n\n        cout << hi << '\\n';\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1993c",
      "PROBLEM_ID": "1993C",
      "PROBLEM_STATEMENT": "There is an apartment consisting of $n$ rooms, each with its light initially turned off.\n\nTo control the lights in these rooms, the owner of the apartment decided to install chips in the rooms so that each room has exactly one chip, and the chips are installed at different times. Specifically, these times are represented by the array $a_1, a_2, \\ldots, a_n$, where $a_i$ is the time (in minutes) at which a chip is installed in the $i$-th room.\n\nAs soon as a chip is installed, it changes the room's light status every $k$ minutes\u00a0\u2014 it turns on the light for $k$ minutes, then turns it off for the next $k$ minutes, then turns it back on for the next $k$ minutes, and so on. In other words, the light status is changed by the chip at minute $a_i$, $a_i + k$, $a_i + 2k$, $a_i + 3k$, $\\ldots$ for the $i$-th room.\n\nWhat is the earliest moment when all rooms in the apartment have their lights turned on?\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of rooms in the apartment and the period of the chips.\n\nThe second line contains $n$ distinct integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the moments when the chips are installed.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the answer to the question (in minutes). If there is no such moment that the lights are turned on in all the rooms, print $-1$ instead.\n\n### Example\n\n#### Input #1\n\n```\n\n9\n\n4 4\n\n2 3 4 5\n\n4 3\n\n2 3 4 5\n\n4 3\n\n3 4 8 9\n\n3 3\n\n6 2 1\n\n1 1\n\n1\n\n7 5\n\n14 34 6 25 46 7 17\n\n6 5\n\n40 80 99 60 90 50\n\n6 5\n\n64 40 50 68 70 10\n\n2 1\n\n1 1000000000\n\n```\n\n#### Output #1\n\n```\n5\n-1\n10\n8\n1\n47\n100\n-1\n-1\n```\n\n### Note\n\nIn the first test case, all lights will be on by the minute $5$ without any of them being turned off by the chips. The answer is $5$.\n\nIn the second test case, due to $k=3$, the $1$-st light will be on at minutes $2, 3, 4, 8, 9, 10, 14, \\ldots$; meanwhile, the $4$-th light will be on at minutes $5, 6, 7, 11, 12, 13, 17, \\ldots$. These two sequences don't have any number in common, so they will never be on at the same time.\n\nIn the third test case, it can be seen that the $1$-st and $2$-nd lights will be turned off at minutes $6$ and $7$, but the chips will turn them back on at minutes $9$ and $10$. The $3$-rd and $4$-th lights will also be on at minute $10$, so the answer is $10$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    \n    int max_a = *max_element(a.begin(), a.end());\n    \n    // The valid intervals for t mod 2k are [a_i mod 2k, (a_i mod 2k + k - 1) mod 2k]\n    // So for each room, the interval is [L, R], possibly wrapping around.\n    // We need to find a common x in [0, 2k-1] that is in all rooms' intervals.\n    \n    // The initial candidate is the entire [0, 2k-1].\n    vector<pair<int, int>> candidates = {{0, 2 * k - 1}};\n    \n    for (int ai : a) {\n        int L = ai % (2 * k);\n        int R = (L + k - 1) % (2 * k);\n        \n        vector<pair<int, int>> new_candidates;\n        for (auto [cl, cr] : candidates) {\n            if (L <= R) {\n                // The current interval is [L, R].\n                // Intersect with [cl, cr].\n                int new_cl = max(cl, L);\n                int new_cr = min(cr, R);\n                if (new_cl <= new_cr) {\n                    new_candidates.emplace_back(new_cl, new_cr);\n                }\n            } else {\n                // The interval is [L, 2k-1] and [0, R].\n                // Intersect with [cl, cr].\n                // First part: [L, 2k-1]\n                int new_cl = max(cl, L);\n                int new_cr = min(cr, 2 * k - 1);\n                if (new_cl <= new_cr) {\n                    new_candidates.emplace_back(new_cl, new_cr);\n                }\n                // Second part: [0, R]\n                new_cl = max(cl, 0);\n                new_cr = min(cr, R);\n                if (new_cl <= new_cr) {\n                    new_candidates.emplace_back(new_cl, new_cr);\n                }\n            }\n        }\n        \n        if (new_candidates.empty()) {\n            cout << -1 << '\\n';\n            return;\n        }\n        \n        candidates = move(new_candidates);\n    }\n    \n    // Now, find the smallest t >= max_a such that t mod 2k is in one of the candidate intervals.\n    int t = -1;\n    for (auto [cl, cr] : candidates) {\n        // Find the smallest t >= max_a with t mod 2k in [cl, cr].\n        int mod = max_a % (2 * k);\n        int current_t;\n        if (mod <= cr) {\n            current_t = max_a + max(0, cl - mod);\n        } else {\n            current_t = max_a + (2 * k - mod) + cl;\n        }\n        // Check if current_t mod 2k is in [cl, cr].\n        // Also, ensure that current_t >= max_a.\n        if (t == -1 || current_t < t) {\n            t = current_t;\n        }\n    }\n    \n    cout << t << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1993a",
      "PROBLEM_ID": "1993A",
      "PROBLEM_STATEMENT": "Tim is doing a test consisting of $4n$ questions; each question has $4$ options: 'A', 'B', 'C', and 'D'. For each option, there are exactly $n$ correct answers corresponding to that option \u2014 meaning there are $n$ questions with the answer 'A', $n$ questions with the answer 'B', $n$ questions with the answer 'C', and $n$ questions with the answer 'D'.\n\nFor each question, Tim wrote his answer on the answer sheet. If he could not figure out the answer, he would leave a question mark '?' for that question.\n\nYou are given his answer sheet of $4n$ characters. What is the maximum number of correct answers Tim can get?\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 100$).\n\nThe second line of each test case contains a string $s$ of $4n$ characters ($s_i \\in \\{\\texttt{A}, \\texttt{B}, \\texttt{C}, \\texttt{D}, \\texttt{?}\\}$)\u00a0\u2014 Tim's answers for the questions.\n\n### Output\n\nFor each test case, print a single integer\u00a0\u2014 the maximum score that Tim can achieve.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1\n\nABCD\n\n2\n\nAAAAAAAA\n\n2\n\nAAAABBBB\n\n2\n\n????????\n\n3\n\nABCABCABCABC\n\n5\n\nACADC??ACAC?DCAABC?C\n\n```\n\n#### Output #1\n\n```\n4\n2\n4\n0\n9\n13\n```\n\n### Note\n\nIn the first test case, there is exactly one question with each answer 'A', 'B', 'C', and 'D'; so it's possible that Tim gets all his answers correct.\n\nIn the second test case, there are only two correct answers 'A' which makes him get exactly $2$ points in any case.\n\nIn the third test case, Tim can get at most $2$ correct answers with option 'A' and $2$ correct answers with option 'B'. For example, he would get $4$ points if the answers were 'AACCBBDD'.\n\nIn the fourth test case, he refuses to answer any question at all, which makes him get $0$ points.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        string s;\n        cin >> s;\n        \n        int countA = 0, countB = 0, countC = 0, countD = 0;\n        \n        for (char c : s) {\n            if (c == 'A') countA++;\n            else if (c == 'B') countB++;\n            else if (c == 'C') countC++;\n            else if (c == 'D') countD++;\n        }\n        \n        int result = min(n, countA) + min(n, countB) + min(n, countC) + min(n, countD);\n        \n        cout << result << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1992g",
      "PROBLEM_ID": "1992G",
      "PROBLEM_STATEMENT": "K1o0n gave you an array $a$ of length $n$, consisting of numbers $1, 2, \\ldots, n$. Accept it? Of course! But what to do with it? Of course, calculate $\\text{MEOW}(a)$.\n\nLet $\\text{MEX}(S, k)$ be the $k$-th positive (strictly greater than zero) integer in ascending order that is not present in the set $S$. Denote $\\text{MEOW}(a)$ as the sum of $\\text{MEX}(b, |b| + 1)$, over all distinct subsets $b$ of the array $a$.\n\nExamples of $\\text{MEX}(S, k)$ values for sets:\n\n- $\\text{MEX}(\\{3,2\\}, 1) = 1$, because $1$ is the first positive integer not present in the set;\n- $\\text{MEX}(\\{4,2,1\\}, 2) = 5$, because the first two positive integers not present in the set are $3$ and $5$;\n- $\\text{MEX}(\\{\\}, 4) = 4$, because there are no numbers in the empty set, so the first $4$ positive integers not present in it are $1, 2, 3, 4$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nIn a single line of each test case, an integer $n$ ($1 \\le n \\le 5000$) is entered, the size of the array of gifted numbers.\n\nIt is guaranteed that the sum of $n^2$ over all test cases does not exceed $25 \\cdot 10^6$.\n\n### Output\n\nFor each test case, output a single number\u00a0\u2014 $\\text{MEOW}(a)$. Since it may be very large, output it modulo $10^9 + 7$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n3\n\n4999\n\n5\n\n1\n\n```\n\n#### Output #1\n\n```\n12\n31\n354226409\n184\n4\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm> // Needed for min/max\n\nusing namespace std;\n\n// Define the modulo value for calculations\nconst int MOD = 1e9 + 7;\n\n// Define the maximum possible value for N based on problem constraints\n// N can be up to 5000. Array sizes should accommodate this.\nconst int MAXN_N = 5005; \n\n// Declare a 2D vector to store precomputed combinations (nCr) modulo MOD\n// C[i][j] will store the value of \"i choose j\" modulo MOD\nvector<vector<int>> C(MAXN_N, vector<int>(MAXN_N));\n\n// Function to precompute combinations using Pascal's identity\n// C(n, k) = C(n-1, k-1) + C(n-1, k)\n// This function fills the combination table C up to MAXN_N\nvoid precompute_combinations() {\n    // Base cases for combinations\n    for (int i = 0; i < MAXN_N; ++i) {\n        C[i][0] = 1; // C(i, 0) = 1 for all i >= 0\n        for (int j = 1; j <= i; ++j) {\n            // Apply Pascal's identity modulo MOD\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n        }\n    }\n}\n\n// Declare a global vector P to store prefix sums of combinations temporarily during calculations\n// P[r] will store sum_{l=0}^r C(N_suffix, l) mod MOD for a fixed N_suffix\nvector<int> P(MAXN_N); \n\nint main() {\n    // Optimize standard input/output operations for speed\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    // Precompute all combinations needed up to MAXN_N. This is done once.\n    // The complexity is O(MAXN_N^2).\n    precompute_combinations(); \n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        int n; // Input: size of the array a = {1, 2, ..., n}\n        cin >> n;\n\n        long long total_meow = 0; // Initialize the total MEOW sum for this test case\n\n        // Precompute prefix sums P_n[k] = sum_{i=0}^k C(n, i) mod MOD\n        // This array is used for the optimization when x > n+1\n        // The size is n+1 because indices go from 0 to n\n        vector<int> P_n_prefix_sums(n + 1); \n        // Perform calculation only if n is non-negative (always true by constraints 1 <= n <= 5000)\n        if (n >= 0) { \n             P_n_prefix_sums[0] = C[n][0]; // Base case for prefix sum: P_n[0] = C(n, 0)\n             for(int k = 1; k <= n; ++k) {\n                 // Calculate prefix sum iteratively\n                 P_n_prefix_sums[k] = (P_n_prefix_sums[k - 1] + C[n][k]) % MOD;\n             }\n        }\n        // P_n_total_sum stores Sum_{k=0..n} C(n, k) which equals 2^n mod MOD.\n        // This value is correctly stored in P_n_prefix_sums[n].\n        // Handle n=0 case separately just to be safe, though constraints state n>=1.\n        long long P_n_total_sum = (n < 0) ? 0 : P_n_prefix_sums[n]; \n        \n        // The value MEOW(a) is calculated as Sum_{x=1}^{2n+1} N(x), where N(x) is the count of subsets b\n        // such that MEX(b, |b|+1) >= x.\n        // The maximum possible value for MEX(b, |b|+1) is 2n+1 (for b={1..n}).\n        for (int x = 1; x <= 2 * n + 1; ++x) {\n            long long current_Nx = 0; // Accumulator for N(x) for the current value of x\n\n            // Calculate N_prefix and N_suffix based on x and n.\n            // N_prefix = | {1, ..., n} intersect {1, ..., x-1} | = count of elements in {1..n} that are <= x-1\n            int N_prefix = min(n, x - 1);\n             if (N_prefix < 0) N_prefix = 0; // Ensure N_prefix is non-negative (mainly for x=1 case where x-1 = 0)\n            // N_suffix = | {1, ..., n} intersect {x, x+1, ...} | = count of elements in {1..n} that are >= x\n            int N_suffix = n - N_prefix; \n             if (N_suffix < 0) N_suffix = 0; // Ensure N_suffix is non-negative\n\n            // Optimization case: if x > n+1, then N_prefix = n and N_suffix = 0.\n            // The condition MEX(b, |b|+1) >= x simplifies significantly.\n            if (x > n + 1) { \n                // The condition becomes x-1 <= 2k, where k = |b intersect {1..x-1}| = |b intersect {1..n}| = |b|.\n                // This implies k >= ceil((x-1)/2).\n                // N(x) = Sum_{k=ceil((x-1)/2)}^n C(n, k)\n                \n                // Calculate ceil((x-1)/2) using integer division trick (A+B-1)/B for ceil(A/B)\n                 int k_min = (x - 1 + 2 - 1) / 2; // Correct ceiling calculation is (numerator + denominator - 1) / denominator\n                // Simpler way: (x-1 + 1) / 2 also works for non-negative x-1 due to integer division properties. Let's use this one.\n                // Check: if x-1=5, k_min=(5+1)/2 = 3. Correct. if x-1=6, k_min=(6+1)/2 = 3. Correct.\n                 k_min = (x - 1 + 1) / 2; \n\n                // If the minimum required k exceeds n, the sum is 0.\n                if (k_min > n) {\n                    current_Nx = 0;\n                } else {\n                    // Calculate the sum Sum_{k=k_min}^n C(n, k) using precomputed prefix sums P_n\n                    // Sum = TotalSum - SumUpTo(k_min - 1)\n                    // Need to handle k_min = 0 case carefully where k_min - 1 = -1\n                    long long sum_up_to_k_min_minus_1 = (k_min == 0) ? 0 : P_n_prefix_sums[k_min - 1];\n                    // Calculate the sum modulo MOD, ensuring result is non-negative\n                    current_Nx = (P_n_total_sum - sum_up_to_k_min_minus_1 + MOD) % MOD;\n                 }\n\n            } else { // General case: x <= n+1\n                // We need prefix sums P[r] = sum_{l=0}^r C(N_suffix, l) mod MOD for the current N_suffix\n                // Compute these prefix sums into the temporary global vector P\n                if (N_suffix >= 0) { // N_suffix is guaranteed non-negative here\n                     P[0] = C[N_suffix][0]; // Base case P[0] = C(N_suffix, 0)\n                     for (int r = 1; r <= N_suffix; ++r) {\n                         // Compute prefix sums iteratively\n                         P[r] = (P[r - 1] + C[N_suffix][r]) % MOD;\n                     }\n                }\n\n                // Iterate over possible counts 'k' of elements chosen from {1, ..., x-1} (size N_prefix)\n                for (int k = 0; k <= N_prefix; ++k) {\n                    // The condition for MEX(b, |b|+1) >= x is x-1 <= 2k+l.\n                    // This requires l >= x-1-2k. Find the minimum required value for l.\n                    int l_min = x - 1 - 2 * k;\n                    l_min = max(0, l_min); // l must be non-negative\n\n                    // If minimum required l exceeds the available count N_suffix, no subsets are possible for this k.\n                    if (l_min > N_suffix) {\n                        continue; // Skip to the next k\n                    }\n\n                    // Calculate the inner sum: Sum_{l=l_min}^{N_suffix} C(N_suffix, l) mod MOD\n                    // Use prefix sums P: Sum = P[N_suffix] - P[l_min - 1]\n                    long long inner_sum;\n                    // Get P[N_suffix], which is sum C(N_suffix, l) for l=0..N_suffix\n                    long long total_sum_suffix = P[N_suffix]; \n                    // Get P[l_min - 1], handling the case l_min = 0 where index would be -1\n                    long long sum_up_to_l_min_minus_1 = (l_min == 0) ? 0 : P[l_min - 1];\n                    \n                    // Compute the inner sum = P[N_suffix] - P[l_min-1], modulo MOD\n                    inner_sum = (total_sum_suffix - sum_up_to_l_min_minus_1 + MOD) % MOD;\n                    \n                    // The number of ways to choose k elements is C(N_prefix, k)\n                    // The number of ways to choose l elements (satisfying the condition l >= l_min) is inner_sum\n                    // Total contribution for this k is C(N_prefix, k) * inner_sum\n                    // Use long long for multiplication to prevent overflow before modulo operation\n                    long long term = (long long)C[N_prefix][k] * inner_sum % MOD;\n                    \n                    // Add the contribution for this k to current_Nx\n                    current_Nx = (current_Nx + term) % MOD;\n                }\n            }\n\n            // Add the count N(x) for this x to the total MEOW sum\n            total_meow = (total_meow + current_Nx) % MOD;\n        }\n\n        // Output the final result for the test case\n        cout << total_meow << \"\\n\";\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1992f",
      "PROBLEM_ID": "1992F",
      "PROBLEM_STATEMENT": "In his favorite cafe Kmes once again wanted to try the herring under a fur coat. Previously, it would not have been difficult for him to do this, but the cafe recently introduced a new purchasing policy.\n\nNow, in order to make a purchase, Kmes needs to solve the following problem: $n$ cards with prices for different positions are laid out in front of him, on the $i$-th card there is an integer $a_i$, among these prices there is no whole positive integer $x$.\n\nKmes is asked to divide these cards into the minimum number of bad segments (so that each card belongs to exactly one segment). A segment is considered bad if it is impossible to select a subset of cards with a product equal to $x$. All segments, in which Kmes will divide the cards, must be bad.\n\nFormally, the segment $(l, r)$ is bad if there are no indices $i_1 < i_2 < \\ldots < i_k$ such that $l \\le i_1, i_k \\le r$, and $a_{i_1} \\cdot a_{i_2} \\ldots \\cdot a_{i_k} = x$.\n\nHelp Kmes determine the minimum number of bad segments in order to enjoy his favorite dish.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^3$) \u2014 the number of test cases.\n\nThe first line of each set of input data gives you $2$ integers $n$ and $x$ ($1 \\le n \\le 10^5, 2 \\le x \\le 10^5$) \u2014 the number of cards and the integer, respectively.\n\nThe second line of each set of input data contains $n$ integers $a_i$ ($1 \\le a_i \\le 2 \\cdot 10^5, a_i \\neq x$) \u2014 the prices on the cards.\n\nIt is guaranteed that the sum of $n$ over all sets of test data does not exceed $10^5$.\n\n### Output\n\nFor each set of input data, output the minimum number of bad segments.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n6 4\n\n2 3 6 2 1 2\n\n9 100000\n\n50000 25000 12500 6250 3125 2 4 8 16\n\n5 2\n\n1 1 1 1 1\n\n8 6\n\n4 3 4 3 4 3 4 3\n\n7 12\n\n6 11 1 3 11 10 2\n\n10 5\n\n2 4 4 2 4 4 4 3 1 1\n\n7 8\n\n4 6 5 1 2 4 1\n\n8 27\n\n3 9 17 26 2 20 9 3\n\n```\n\n#### Output #1\n\n```\n3\n2\n1\n1\n2\n1\n3\n3\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <unordered_set> // Using unordered_set for better average time complexity\n\n// Use long long for potentially large products and the target value x\nusing ll = long long;\n\n/**\n * @brief Checks if divisor divides dividend safely.\n * \n * Handles edge cases like divisor being 0 or 1.\n * Includes an optimization for positive numbers: if divisor > dividend, it cannot divide.\n * Assumes dividend >= 2 based on problem constraints for x.\n * \n * @param divisor The number to check if it divides the dividend.\n * @param dividend The number being divided.\n * @return true if divisor divides dividend, false otherwise.\n */\nbool divides(ll divisor, ll dividend) {\n    // Base cases and safety checks\n    if (divisor == 0) return false; // Division by zero is undefined\n    if (divisor == 1) return true;  // 1 divides everything\n\n    // Optimization for positive numbers: If divisor > dividend, it cannot divide.\n    // This holds since x >= 2, so dividend is positive. Divisor is also positive (comes from a_i >= 1).\n    if (divisor > dividend) return false; \n    \n    // Perform the modulo check\n    return dividend % divisor == 0;\n}\n\nint main() {\n    // Faster I/O operations\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Number of cards\n        ll x;  // Target product\n        std::cin >> n >> x;\n        std::vector<ll> a(n); // Card prices\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n        }\n        \n        int count = 0; // Counter for the number of bad segments\n        int current_L = 0; // Start index of the current segment being considered (0-based)\n        \n        // Iterate through the array, partitioning it into bad segments\n        while (current_L < n) {\n            count++; // Increment segment count for the new segment starting at current_L\n            \n            // Store the set of achievable subset products that are divisors of x within the current segment\n            // Initialized with 1 (product of empty subset)\n            std::unordered_set<ll> divisors_product_set;\n            divisors_product_set.insert(1); \n            \n            // Tracks the end index of the largest bad segment found so far starting at current_L\n            int last_bad_R = current_L - 1; \n            bool segment_found_good = false; // Flag to indicate if a 'good' segment was identified\n\n            // Extend the current segment to the right (index R)\n            for (int R = current_L; R < n; ++R) {\n                ll current_a = a[R]; // Current card price\n                \n                // If current card price is 1, it doesn't affect the product value.\n                // The segment remains bad if it was bad, good if it was good.\n                // Simply extend the potential bad segment boundary.\n                if (current_a == 1) {\n                   last_bad_R = R; \n                   continue; // Skip product processing logic for 1\n                }\n\n                bool is_good = false; // Flag for the segment (current_L, R)\n                \n                // Check if current_a can potentially complete a product equal to x.\n                // It must divide x to be potentially useful.\n                if (divides(current_a, x)) {\n                     ll target = x / current_a;\n                     // Check if the required complementary factor 'target' exists in the set\n                     // of products formed by elements before index R within this segment.\n                     if (divisors_product_set.count(target)) {\n                         is_good = true; // Found a subset product equal to x ending at R\n                     }\n                }\n\n                if (is_good) {\n                    // Segment (current_L, R) is good. This means the maximal bad segment\n                    // starting at current_L must end at R-1.\n                    segment_found_good = true;\n                    break; // Found the minimal R that makes the segment good, stop extending\n                } else {\n                    // Segment (current_L, R) is still bad. Update the end index of the bad segment.\n                    last_bad_R = R;\n                    \n                    // Update the set of achievable subset products (that are divisors of x)\n                    // by incorporating current_a. Only consider current_a if it divides x.\n                    if (divides(current_a, x)) { \n                        // Temporary storage for new divisors found in this step to avoid modifying the set while iterating\n                        std::vector<ll> new_divisors_to_add; \n                        \n                        // Check if current_a itself is a new divisor product\n                         if (divisors_product_set.find(current_a) == divisors_product_set.end()){\n                              new_divisors_to_add.push_back(current_a);\n                         }\n\n                        // Iterate through existing products `p` in the set\n                        for (ll p : divisors_product_set) {\n                             // We can skip p=1 because p*current_a = current_a, which was handled above.\n                             if (p == 1) continue;\n\n                             // Calculate new product using long long to prevent overflow\n                             // Check for potential overflow: Max product value can be up to x * max(a_i), which is roughly 10^5 * 2*10^5 = 2*10^10. This fits within 64-bit long long.\n                             ll new_prod_ll = p * current_a;\n\n                            // If product exceeds x, it cannot divide x (since x >= 2)\n                            if (new_prod_ll > x) continue; \n\n                            // Check if the new product divides x and if it's a new divisor product\n                            if (divides(new_prod_ll, x)) {\n                                // Check if this new product is already in the main set\n                                if (divisors_product_set.find(new_prod_ll) == divisors_product_set.end()) {\n                                     // Check if it's already scheduled to add in this step\n                                     bool already_scheduled = false;\n                                     for(ll scheduled_val : new_divisors_to_add) {\n                                        if (scheduled_val == new_prod_ll) {\n                                            already_scheduled = true;\n                                            break;\n                                        }\n                                     }\n                                     if (!already_scheduled) {\n                                         new_divisors_to_add.push_back(new_prod_ll);\n                                     }\n                                }\n                            }\n                        }\n                        \n                        // Add all the newly found distinct divisor products to the main set\n                        for(ll nd : new_divisors_to_add) {\n                            divisors_product_set.insert(nd);\n                        }\n                    }\n                }\n            } // End loop for R\n\n            // Set the starting index for the next segment search.\n            // The next segment starts immediately after the end of the identified bad segment.\n            // last_bad_R holds the index of the last element of this bad segment.\n             current_L = last_bad_R + 1; \n\n        } // End while loop current_L < n\n        \n        // Output the minimum number of bad segments found\n        std::cout << count << \"\\n\";\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1992e",
      "PROBLEM_ID": "1992E",
      "PROBLEM_STATEMENT": "One of the first programming problems by K1o0n looked like this: \"Noobish\\_Monk has $n$ $(1 \\le n \\le 100)$ friends. Each of them gave him $a$ $(1 \\le a \\le 10000)$ apples for his birthday. Delighted with such a gift, Noobish\\_Monk returned $b$ $(1 \\le b \\le \\min(10000, a \\cdot n))$ apples to his friends. How many apples are left with Noobish\\_Monk?\"\n\nK1o0n wrote a solution, but accidentally considered the value of $n$ as a string, so the value of $n \\cdot a - b$ was calculated differently. Specifically:\n\n- when multiplying the string $n$ by the integer $a$, he will get the string $s=\\underbrace{n + n + \\dots + n + n}_{a\\ \\text{times}}$\n- when subtracting the integer $b$ from the string $s$, the last $b$ characters will be removed from it. If $b$ is greater than or equal to the length of the string $s$, it will become empty.\n\nLearning about this, ErnKor became interested in how many pairs $(a, b)$ exist for a given $n$, satisfying the constraints of the problem, on which K1o0n's solution gives the correct answer.\n\n\"The solution gives the correct answer\" means that it outputs a non-empty string, and this string, when converted to an integer, equals the correct answer, i.e., the value of $n \\cdot a - b$.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$) \u00a0\u2014 the number of test cases.\n\nFor each test case, a single line of input contains an integer $n$ ($1 \\le n \\le 100$).\n\nIt is guaranteed that in all test cases, $n$ is distinct.\n\n### Output\n\nFor each test case, output the answer in the following format:\n\nIn the first line, output the integer $x$\u00a0\u2014 the number of bad tests for the given $n$.\n\nIn the next $x$ lines, output two integers $a_i$ and $b_i$\u00a0\u2014 such integers that K1o0n's solution on the test \"$n$ $a_i$ $b_i$\" gives the correct answer.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2\n\n3\n\n10\n\n```\n\n#### Output #1\n\n```\n3\n20 18\n219 216\n2218 2214\n1\n165 162\n1\n1262 2519\n```\n\n### Note\n\nIn the first example, $a = 20$, $b = 18$ are suitable, as \"$\\text{2}$\" $\\cdot 20 - 18 =$ \"$\\text{22222222222222222222}$\"$- 18 = 22 = 2 \\cdot 20 - 18$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits> // Required for numeric_limits\n\nusing namespace std;\n\n// Use unsigned long long for potentially large values resulting from string concatenation interpretation\ntypedef unsigned long long ull;\n\n// Structure to store the pair (a, b) that satisfies the condition\nstruct Pair {\n    int a; // Constraint: 1 <= a <= 10000\n    int b; // Constraint: 1 <= b <= min(10000, a*n)\n};\n\nint main() {\n    // Use faster I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        int n; // Input integer n\n        cin >> n;\n\n        vector<Pair> results; // Store the valid (a, b) pairs\n\n        // Handle the special case n = 1 separately\n        if (n == 1) {\n            // For n=1, K1o0n's string calculation result needs to match the integer calculation result 1*a - b = a - b.\n            // Let N = \"1\". L=1. String s = N repeated 'a' times = \"11...1\" (a ones). Length is a.\n            // Remove last b chars. Resulting string s' has length k = a - b.\n            // s' is \"11...1\" (k ones).\n            // The integer value of s' is V_k = (10^k - 1) / 9.\n            // The condition is V_k = a - b. Since k = a - b, this becomes V_k = k.\n            // (10^k - 1) / 9 = k. This equation holds true only for k = 1.\n            // Thus, we must have k = 1.\n            // From k = a - b, we have b = a - k = a - 1.\n            // Now check constraints on 'a' and 'b':\n            // 1 <= a <= 10000\n            // 1 <= b <= min(10000, a*n) which is 1 <= b <= min(10000, a).\n            // Check b >= 1: a - 1 >= 1 => a >= 2.\n            // Check b <= 10000: a - 1 <= 10000 => a <= 10001. Combined with a <= 10000, we need a <= 10000.\n            // Check b <= a: a - 1 <= a. This is always true.\n            // Also check K1o0n's condition that the resulting string s' is non-empty. Length k = 1 > 0. OK.\n            // So, for n=1, valid pairs (a, b) are (a, a-1) for all 'a' such that 2 <= a <= 10000.\n            for (int a = 2; a <= 10000; ++a) {\n                results.push_back({a, a - 1});\n            }\n        } else {\n            // Case n > 1\n            string N = to_string(n); // String representation of n\n            int L = N.length(); // Length of string N\n            ull current_V = 0; // Stores the integer value of the prefix s'_k (K1o0n's interpreted value)\n            \n            // Maximum value representable by unsigned long long\n            ull max_ull = numeric_limits<ull>::max();\n\n            // Iterate through possible prefix lengths k. \n            // K1o0n's calculation results in a string s' of length k = L*a - b.\n            // We iterate through possible values of k.\n            // Based on analysis, k needs to be relatively small because 'a' grows exponentially with k and a <= 10000.\n            // Iterating up to 64 is safe, covering the full range representable by unsigned long long for V_k.\n            for (int k = 1; k <= 64; ++k) { \n                // Determine the k-th character in the concatenated string NNN...\n                // This corresponds to the character at index (k-1) % L in string N (using 0-based indexing).\n                int digit_idx = (k - 1) % L;\n                int digit = N[digit_idx] - '0'; // Convert character digit to integer value\n\n                // Update V_k = V_{k-1} * 10 + digit_k\n                // Check for potential overflow before performing arithmetic operations\n                // Check overflow for V * 10\n                 if (current_V > max_ull / 10) {\n                     break; // Stop if overflow is imminent\n                }\n                 ull V_times_10 = current_V * 10;\n                 \n                 // Check overflow for V * 10 + digit\n                 if (V_times_10 > max_ull - digit) {\n                     break; // Stop if overflow is imminent\n                 }\n                \n                current_V = V_times_10 + digit; // This is V_k, the value of the prefix of length k\n\n                // The core condition is that K1o0n's value integer(s') equals the correct value n*a - b.\n                // integer(s') is V_k. The length of s' is k = L*a - b. From this, b = L*a - k.\n                // Substituting b into the correct value: n*a - (L*a - k) = (n - L)*a + k.\n                // So the condition becomes: V_k = (n - L)*a + k\n                // Rearranging gives: V_k - k = (n - L)*a\n\n                // Check if V_k >= k. This should hold for k >= 1 since V_k grows much faster than k.\n                // Cast k to ull for safe comparison.\n                if (current_V < (ull)k) { \n                     continue; // Should not happen for k>=1, but good practice\n                }\n\n                ull V_minus_k = current_V - k;\n                long long n_minus_L = (long long)n - L; \n                \n                // Check if n_minus_L is zero. Based on analysis, this doesn't happen for n > 1.\n                // If n=2..9, L=1, n-L=n-1 > 0. If n>=10, L>=2, n-L=n-L > 0.\n                if (n_minus_L == 0) { \n                   continue; // Defensive check\n                }\n\n                // We need 'a' = (V_k - k) / (n - L) to be a positive integer.\n                // Check divisibility: V_k - k must be divisible by n - L.\n                // Since n > 1, n-L is always positive.\n                if (V_minus_k % n_minus_L == 0) {\n                    ull a_ull = V_minus_k / n_minus_L;\n\n                    // 'a' must satisfy 1 <= a <= 10000\n                    if (a_ull == 0) continue; // a must be at least 1\n                    if (a_ull > 10000) {\n                        // If 'a' exceeds 10000 for this k, it will likely exceed for larger k too\n                        // because V_k grows exponentially.\n                        break; // Stop iterating k\n                    }\n\n                    int a = (int)a_ull; // Safe cast since a_ull <= 10000\n                    \n                    // Now check the constraints related to b = L*a - k\n                    // Constraint: 1 <= b <= min(10000, a*n)\n                    \n                    long long L_times_a = (long long)L * a; // Use long long for intermediate calculation\n                    \n                    // Calculate b = L*a - k.\n                    // Check if b >= 1. This is equivalent to k <= L*a - 1.\n                    if ((ull)k <= L_times_a - 1) { \n                        \n                        long long b_ll = L_times_a - k;\n                         \n                        // Check constraint: b <= 10000\n                        // b >= 1 is already implied by k <= L*a - 1\n                        if (b_ll >= 1 && b_ll <= 10000) {\n                            int b = (int)b_ll; // Safe cast b_ll is in range [1, 10000]\n                           \n                            // Check constraint: b <= n*a\n                            long long n_times_a = (long long)n * a; // Use long long\n                            if (b <= n_times_a) {\n                                // All conditions are met for this pair (a, b) derived from k.\n                                results.push_back({a, b});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Output the results for the current test case\n        cout << results.size() << \"\\n\";\n        for (const auto& p : results) {\n            cout << p.a << \" \" << p.b << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1992d",
      "PROBLEM_ID": "1992D",
      "PROBLEM_STATEMENT": "ErnKor is ready to do anything for Julen, even to swim through crocodile-infested swamps. We decided to test this love. ErnKor will have to swim across a river with a width of $1$ meter and a length of $n$ meters.\n\nThe river is very cold. Therefore, in total (that is, throughout the entire swim from $0$ to $n+1$) ErnKor can swim in the water for no more than $k$ meters. For the sake of humanity, we have added not only crocodiles to the river, but also logs on which he can jump. Our test is as follows:\n\nInitially, ErnKor is on the left bank and needs to reach the right bank. They are located at the $0$ and $n+1$ meters respectively. The river can be represented as $n$ segments, each with a length of $1$ meter. Each segment contains either a log 'L', a crocodile 'C', or just water 'W'. ErnKor can move as follows:\n\n- If he is on the surface (i.e., on the bank or on a log), he can jump forward for no more than $m$ ($1 \\le m \\le 10$) meters (he can jump on the bank, on a log, or in the water).\n- If he is in the water, he can only swim to the next river segment (or to the bank if he is at the $n$-th meter).\n- ErnKor cannot land in a segment with a crocodile in any way.\n\nDetermine if ErnKor can reach the right bank.\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains three numbers $n, m, k$ ($0 \\le k \\le 2 \\cdot 10^5$, $1 \\le n \\le 2 \\cdot 10^5$, $1 \\le m \\le 10$)\u00a0\u2014 the length of the river, the distance ErnKor can jump, and the number of meters ErnKor can swim without freezing.\n\nThe second line of each test case contains a string $a$ of length $n$. $a_i$ denotes the object located at the $i$-th meter. ($a_i \\in \\{$'W','C','L'$\\}$)\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output \"YES\" if ErnKor can pass the test, and output \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n6 2 0\n\nLWLLLW\n\n6 1 1\n\nLWLLLL\n\n6 1 1\n\nLWLLWL\n\n6 2 15\n\nLWLLCC\n\n6 10 0\n\nCCCCCC\n\n6 6 1\n\nWCCCCW\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nNO\nNO\nYES\nYES\n```\n\n### Note\n\nLet's consider examples:\n\n- First example: We jump from the shore to the first log ($0 \\rightarrow 1$), from the first log to the second ($1 \\rightarrow 3$), from the second to the fourth ($3 \\rightarrow 5$), and from the last log to the shore ($5 \\rightarrow 7$). So, we have $0 \\rightarrow 1 \\rightarrow 3 \\rightarrow 5 \\rightarrow 7$. Since we did not encounter a crocodile and swam no more than k meters, the answer is \u00abYES\u00bb.\n- Second example: $0 \\rightarrow 1$, we jump into the water from the first log ($1 \\rightarrow 2$), swim a cell to the log ($2 \\leadsto 3$), $3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \\rightarrow 7$. Since we did not encounter a crocodile and swam no more than k meters, the answer is \u00abYES\u00bb.\n- In the third example, ErnKor needs to swim two cells 'W', but can only swim one. Therefore, the answer is \u00abNO\u00bb.\n- Sixth example: We jump from the shore into the water ($0 \\rightarrow 6$) and swim one cell in the water ($6 \\leadsto 7$). Since we did not encounter a crocodile and swam no more than k meters, the answer is \u00abYES\u00bb.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <limits>\n#include <algorithm> // For min\n\nusing namespace std;\n\n// Use long long for costs. The maximum possible swimming distance is N, which can be up to 2e5.\n// The total cost could accumulate up to N, which fits in a 32-bit integer.\n// However, using long long is safer practice in competitive programming to avoid potential overflow issues,\n// especially if N or K were larger, or if costs could sum up differently.\nconst long long INF = numeric_limits<long long>::max(); \n\n// Define a State struct for Dijkstra's algorithm.\n// It stores the total swimming cost accumulated so far and the current position.\nstruct State {\n    long long cost; // Total swimming cost to reach this state\n    int pos;      // Current position (0 for left bank, 1 to N for river segments, N+1 for right bank)\n\n    // Overload the greater-than operator to make the priority queue a min-heap based on cost.\n    // Lower cost states have higher priority.\n    bool operator>(const State& other) const {\n        // Primarily order by cost ascendingly.\n        if (cost != other.cost) {\n            return cost > other.cost;\n        }\n        // If costs are equal, use position as a tie-breaker (optional, but makes behavior deterministic).\n        // Smaller position index could be preferred, or larger; doesn't affect correctness.\n        return pos > other.pos; \n    }\n};\n\nint main() {\n    // Use faster I/O operations.\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        int n; // Length of the river (number of 1-meter segments)\n        int m; // Maximum jump distance from a surface\n        long long k; // Maximum total swimming distance allowed\n        cin >> n >> m >> k;\n        string a; // String describing the river segments (0-indexed, length n)\n        cin >> a; // a[i] corresponds to the state of river segment at position i+1.\n\n        // Precomputation Step 1: Calculate `next_non_water_pos[p]`\n        // This stores the index of the first position p' >= p that is not water ('W').\n        // This is needed to determine where a sequence of swimming steps ends.\n        vector<int> next_non_water_pos(n + 2);\n        next_non_water_pos[n + 1] = n + 1; // Base case: Position n+1 (right bank) is non-water.\n        for (int p = n; p >= 1; --p) {\n             // The state at position p corresponds to index p-1 in the 0-indexed string 'a'.\n            if (a[p - 1] != 'W') { // If position p contains a Log 'L' or a Crocodile 'C'\n                next_non_water_pos[p] = p; // The first non-water position starting from p is p itself.\n            } else { // If position p contains Water 'W'\n                // The first non-water position starting from p is the same as starting from p+1.\n                next_non_water_pos[p] = next_non_water_pos[p + 1]; \n            }\n        }\n        // Note: next_non_water_pos[0] is not computed as position 0 is the left bank (always non-water).\n\n        // Precomputation Step 2: Calculate `next_crocodile[p]`\n        // This stores the index of the first position p' >= p that contains a crocodile 'C'.\n        // This is needed to check if a swimming path or a landing spot is safe.\n        vector<int> next_crocodile(n + 2); \n        next_crocodile[n + 1] = n + 2; // Use n+2 as a sentinel value indicating no crocodile found from this point onwards.\n        for (int p = n; p >= 1; --p) {\n             // Check state at position p (index p-1 in string 'a').\n            if (a[p - 1] == 'C') { // If position p is a Crocodile\n                next_crocodile[p] = p; // The first crocodile starting from p is p itself.\n            } else { // If position p is not a Crocodile\n                // The first crocodile starting from p is the same as starting from p+1.\n                next_crocodile[p] = next_crocodile[p + 1]; \n            }\n        }\n        // Note: next_crocodile[0] is not computed as position 0 is the left bank.\n\n        // Initialize Dijkstra's algorithm data structures.\n        // dp[p] stores the minimum swimming cost found so far to reach position p (must be a surface position).\n        vector<long long> dp(n + 2, INF);\n        // Min-priority queue stores states to visit, ordered by minimum cost.\n        priority_queue<State, vector<State>, greater<State>> pq;\n\n        dp[0] = 0; // Starting at the left bank (position 0) requires 0 swimming cost.\n        pq.push({0, 0}); // Push the initial state into the priority queue.\n\n        // Main Dijkstra loop continues as long as there are states to process.\n        while (!pq.empty()) {\n            State current = pq.top(); // Extract the state with the minimum cost.\n            pq.pop();\n\n            long long cost = current.cost; // The minimum cost found so far to reach position u.\n            int u = current.pos;      // The current position.\n\n            // If the extracted state's cost is greater than the already known minimum cost to reach u,\n            // this state is outdated (due to finding a shorter path earlier). Skip it.\n            if (cost > dp[u]) { \n                continue;\n            }\n            \n            // If the current position is the target (right bank, n+1), we don't need to explore further from it.\n            // Note: The first time we extract n+1, we have found the minimum cost path.\n            if (u == n + 1) {\n                 continue;\n            }\n\n            // Explore possible moves (jumps) from the current position u.\n            // Jumps are only possible from surface positions (bank or log).\n            // All positions `u` processed here are guaranteed to be surface positions because we only push\n            // states corresponding to landing on surfaces into the PQ.\n            // The destination `v` can be any position from u+1 up to u+m, capped at n+1.\n            for (int v = u + 1; v <= min(u + m, n + 1); ++v) {\n                 \n                 if (v == n + 1) { // Case 1: Jump directly to the right bank (position n+1).\n                    // This jump has 0 swimming cost. Check if this path offers a lower total cost to reach n+1.\n                    if (cost < dp[n + 1]) { \n                        dp[n + 1] = cost; // Update the minimum cost.\n                        pq.push({cost, n + 1}); // Add the target state to the priority queue.\n                    }\n                 } else { // Case 2: Jump to a position v within the river (1 <= v <= n).\n                     // Check the state of the destination position v (index v-1 in string 'a').\n                     if (a[v - 1] == 'C') { // Cannot land on a crocodile 'C'.\n                         continue; // This jump is invalid, skip to the next possible destination v.\n                     }\n\n                     if (a[v - 1] == 'L') { // Jump onto a log 'L' at position v.\n                         // This jump has 0 swimming cost. Check if this path offers a lower total cost to reach v.\n                         if (cost < dp[v]) { \n                             dp[v] = cost; // Update the minimum cost to reach log v.\n                             pq.push({cost, v}); // Add this log state to the priority queue.\n                         }\n                     } else { // a[v - 1] == 'W', jump into water 'W' at position v.\n                         // ErnKor must swim starting from v until reaching the first non-water position.\n                         int v_prime = next_non_water_pos[v]; // Find the landing position v_prime >= v.\n                         \n                         // Check if there is any crocodile in the swimming path [v, v_prime - 1].\n                         // The first crocodile at or after v is at `next_crocodile[v]`.\n                         // If this crocodile's position is less than v_prime, it blocks the path.\n                         if (next_crocodile[v] < v_prime) {\n                             continue; // Crocodile encountered during swim, path invalid.\n                         }\n                         \n                         // Additionally, explicitly check if the landing spot v_prime itself is a crocodile.\n                         // This check is necessary because `next_crocodile[v] < v_prime` only covers the path strictly before v_prime.\n                         if (v_prime <= n && a[v_prime - 1] == 'C') {\n                             continue; // Cannot land on a crocodile at the end of swim.\n                         }\n\n                         // Calculate the distance swam in this sequence.\n                         long long swim_dist = (long long)v_prime - v; \n                         // Calculate the new total swimming cost to reach v_prime via this path.\n                         long long new_cost = cost + swim_dist; \n\n                         // Optimization: If the new cost already exceeds the maximum allowed swimming distance k,\n                         // this path (and any path extending it) is invalid. Prune it.\n                         if (new_cost > k) continue; \n\n                         // Check if this path to v_prime (either bank or log) provides a lower cost.\n                         if (v_prime == n + 1) { // Reached the right bank after swimming.\n                             if (new_cost < dp[n + 1]) {\n                                 dp[n + 1] = new_cost; // Update minimum cost to reach bank.\n                                 pq.push({new_cost, n + 1}); // Add target state to PQ.\n                             }\n                         } else { // Reached a log at v_prime after swimming (since it's non-water and not crocodile).\n                             if (new_cost < dp[v_prime]) {\n                                 dp[v_prime] = new_cost; // Update minimum cost to reach this log.\n                                 pq.push({new_cost, v_prime}); // Add log state to PQ.\n                             }\n                         }\n                     }\n                 }\n            }\n        }\n        \n        // After Dijkstra's algorithm finishes, check if the minimum cost found to reach the right bank (dp[n+1])\n        // is within the allowed swimming limit k.\n        if (dp[n + 1] <= k) {\n             cout << \"YES\\n\"; // If reachable within the limit.\n        } else {\n             cout << \"NO\\n\"; // If not reachable or minimum cost exceeds the limit.\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1992c",
      "PROBLEM_ID": "1992C",
      "PROBLEM_STATEMENT": "Gorilla and Noobish\\_Monk found three numbers $n$, $m$, and $k$ ($m < k$). They decided to construct a permutation$^{\\dagger}$ of length $n$.\n\nFor the permutation, Noobish\\_Monk came up with the following function: $g(i)$ is the sum of all the numbers in the permutation on a prefix of length $i$ that are not greater than $m$. Similarly, Gorilla came up with the function $f$, where $f(i)$ is the sum of all the numbers in the permutation on a prefix of length $i$ that are not less than $k$. A prefix of length $i$ is a subarray consisting of the first $i$ elements of the original array.\n\nFor example, if $n = 5$, $m = 2$, $k = 5$, and the permutation is $[5, 3, 4, 1, 2]$, then:\n\n- $f(1) = 5$, because $5 \\ge 5$; $g(1) = 0$, because $5 > 2$;\n- $f(2) = 5$, because $3 < 5$; $g(2) = 0$, because $3 > 2$;\n- $f(3) = 5$, because $4 < 5$; $g(3) = 0$, because $4 > 2$;\n- $f(4) = 5$, because $1 < 5$; $g(4) = 1$, because $1 \\le 2$;\n- $f(5) = 5$, because $2 < 5$; $g(5) = 1 + 2 = 3$, because $2 \\le 2$.\n\nHelp them find a permutation for which the value of $\\left(\\sum_{i=1}^n f(i) - \\sum_{i=1}^n g(i)\\right)$ is maximized.\n\n$^{\\dagger}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in any order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation (as $2$ appears twice in the array) and $[1,3,4]$ is also not a permutation (as $n=3$, but $4$ appears in the array).\n\n### Input\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u00a0\u2014 the number of test cases.\n\nThe only line of each case contains three integers $n$, $m$, $k$ ($2\\le n \\le 10^5$; $1 \\le m < k \\le n$)\u00a0\u2014 the size of the permutation to be constructed and two integers.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the permutation \u00a0\u2014 a set of numbers that satisfies the conditions of the problem. If there are multiple solutions, output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n5 2 5\n\n3 1 3\n\n10 3 8\n\n```\n\n#### Output #1\n\n```\n5 3 4 1 2\n3 2 1\n10 9 8 4 7 5 6 1 2 3```\n\n### Note\n\nIn the first example, $\\left(\\sum_{i=1}^n f(i) - \\sum_{i=1}^n g(i)\\right) = 5 \\cdot 5 - (0 \\cdot 3 + 1 + 3) = 25 - 4 = 21$",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int t;\n    cin >> t;\n    for (int tc = 0; tc < t; ++tc) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        vector<int> A, B, C;\n        for (int x = 1; x <= n; ++x) {\n            if (x >= k) {\n                A.push_back(x);\n            } else if (x > m) {\n                B.push_back(x);\n            } else {\n                C.push_back(x);\n            }\n        }\n        sort(A.begin(), A.end(), greater<int>());\n        sort(C.begin(), C.end());\n        vector<int> res;\n        res.insert(res.end(), A.begin(), A.end());\n        res.insert(res.end(), B.begin(), B.end());\n        res.insert(res.end(), C.begin(), C.end());\n        for (int num : res) {\n            cout << num << ' ';\n        }\n        cout << '\\n';\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1992a",
      "PROBLEM_ID": "1992A",
      "PROBLEM_STATEMENT": "Kmes has written three integers $a$, $b$ and $c$ in order to remember that he has to give Noobish\\_Monk $a \\times b \\times c$ bananas.\n\nNoobish\\_Monk has found these integers and decided to do the following at most $5$ times:\n\n- pick one of these integers;\n- increase it by $1$.\n\nFor example, if $a = 2$, $b = 3$ and $c = 4$, then one can increase $a$ three times by one and increase $b$ two times. After that $a = 5$, $b = 5$, $c = 4$. Then the total number of bananas will be $5 \\times 5 \\times 4 = 100$.\n\nWhat is the maximum value of $a \\times b \\times c$ Noobish\\_Monk can achieve with these operations?\n\n### Input\n\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first and only line of each test case contains three integers $a$, $b$ and $c$ ($1 \\le a, b, c \\le 10$)\u00a0\u2014 Kmes's integers.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximum amount of bananas Noobish\\_Monk can get.\n\n### Example\n\n#### Input #1\n\n```\n\n2\n\n2 3 4\n\n10 1 10\n\n```\n\n#### Output #1\n\n```\n100\n600\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nint main() {\n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        long long a, b, c;\n        std::cin >> a >> b >> c;\n        \n        // Perform 5 operations\n        for (int i = 0; i < 5; ++i) {\n            // Calculate the increase in product if we increase each integer\n            long long increase_a = b * c;\n            long long increase_b = a * c;\n            long long increase_c = a * b;\n            \n            // Choose the operation that gives the maximum increase\n            if (increase_a >= increase_b && increase_a >= increase_c) {\n                a++;  // Increasing a gives the maximum or tied maximum benefit\n            } else if (increase_b >= increase_c) {\n                b++;  // Increasing b gives the maximum or tied maximum benefit (a not eligible)\n            } else {\n                c++;  // Increasing c gives the maximum benefit\n            }\n        }\n        \n        // Output the final product\n        std::cout << a * b * c << std::endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1991h",
      "PROBLEM_ID": "1991H",
      "PROBLEM_STATEMENT": "Alice and Bob are playing a game with $n$ piles of stones, where the $i$-th pile has $a_i$ stones. Players take turns making moves, with Alice going first.\n\nOn each move, the player does the following three-step process:\n\n1. Choose an integer $k$ ($1 \\leq k \\leq \\frac n 2$). Note that the value of $k$ can be different for different moves.\n2. Remove $k$ piles of stones.\n3. Choose another $k$ piles of stones and split each pile into two piles. The number of stones in each new pile must be a prime number.\n\nThe player who is unable to make a move loses.\n\nDetermine who will win if both players play optimally.\n\n### Input\n\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of piles of stones.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of stones in the piles.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output \"Alice\" (without quotes) if Alice wins and \"Bob\" (without quotes) otherwise.\n\nYou can output each letter in any case (upper or lower). For example, the strings \"alIcE\", \"Alice\", and \"alice\" will all be considered identical.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n2 1\n\n3\n\n3 5 7\n\n4\n\n4 6 8 10\n\n5\n\n8 8 8 8 8\n\n```\n\n#### Output #1\n\n```\nBob\nAlice\nAlice\nBob\n```\n\n### Note\n\nIn the first test case, there are $2$ piles of stones with $2$ and $1$ stones respectively. Since neither $1$ nor $2$ can be split into two prime numbers, Alice cannot make a move, so Bob wins.\n\nIn the second test case, there are $3$ piles of stones with $3$, $5$, and $7$ stones respectively. Alice can choose $k = 1$, remove the pile of $7$ stones, and then split the pile of $5$ stones into two piles of prime numbers of stones, $2$ and $3$. Then, the piles consist of $3$ piles of stones with $3$, $2$, and $3$ stones respectively, leaving Bob with no valid moves, so Alice wins.\n\nIn the third test case, there are $4$ piles of stones with $4$, $6$, $8$, and $10$ stones respectively. Alice can choose $k = 2$, removing two piles of $8$ and $10$ stones. She splits the pile of $4$ stones into two piles of prime numbers of stones, $2$ and $2$, and the pile of $6$ stones into two piles of $3$ and $3$ stones. Then, Bob has no valid moves, so Alice wins.\n\nIn the fourth test case, there are $5$ piles of stones, each containing $8$ stones. It can be shown that if both players play optimally, Bob will win.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "hard",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 2e5 + 5;\nbitset<MAX_N + 1> isComposite, isWinning, isPrimeLosing, isPrimeWinning, isGoodPosition;\nvoid initialize() {\n    isComposite[1] = true;\n    for (int i = 2; i <= MAX_N; i++)\n        for (int j = 2 * i; j <= MAX_N; j += i)\n            isComposite[j] = true;\n    for (int i = 3; i <= MAX_N; i += 2) {\n        int count = 0, j = i;\n        while (!isComposite[j - 2]) {\n            count++;\n            j -= 2;\n        }\n        isWinning[i] = count % 2;\n        isPrimeLosing[i] = !isComposite[i] && !isWinning[i];\n    }\n    isWinning[4] = true;\n    for (int i = 3; i <= MAX_N; i += 2)\n        if (isPrimeLosing[i])\n            isWinning |= isPrimeLosing << i;\n    for (int i = 1; i <= MAX_N; ++i)\n        isPrimeWinning[i] = (i % 2) && isWinning[i] && !isComposite[i];\n    for (int i = 3; i <= MAX_N; i += 2)\n        if (isPrimeWinning[i])\n            isGoodPosition |= isPrimeWinning << i;\n}\nvoid solve() {\n    int n, x, totalWinning = 0, totalGood = 0;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> x;\n        totalWinning += isWinning[x];\n        totalGood += isGoodPosition[x];\n    }\n    if (totalWinning <= n - n % 2)\n        cout << (totalWinning ? \"Alice\" : \"Bob\") << endl;\n    else\n        cout << (totalGood && totalGood < n ? \"Alice\" : \"Bob\") << endl;\n}\nint main() {\n    initialize();\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1991g",
      "PROBLEM_ID": "1991G",
      "PROBLEM_STATEMENT": "You are given a grid consisting of $n$ rows and $m$ columns, where each cell is initially white. Additionally, you are given an integer $k$, where $1 \\le k \\le \\min(n, m)$.\n\nYou will process $q$ operations of two types:\n\n- $\\mathtt{H}$ (horizontal operation)\u00a0\u2014 You choose a $1 \\times k$ rectangle completely within the grid, where all cells in this rectangle are white. Then, all cells in this rectangle are changed to black.\n- $\\mathtt{V}$ (vertical operation)\u00a0\u2014 You choose a $k \\times 1$ rectangle completely within the grid, where all cells in this rectangle are white. Then, all cells in this rectangle are changed to black.\n\nAfter each operation, if any rows or columns become completely black, all cells in these rows and columns are simultaneously reset to white. Specifically, if all cells in the row and column a cell is contained in become black, all cells in both the row and column will be reset to white.\n\nChoose the rectangles in a way that you can perform all given operations, or determine that it is impossible.\n\n### Input\n\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains four integers $n$, $m$, $k$, and $q$ ($1 \\le n, m \\le 100$, $1 \\le k \\le \\min(n, m)$, $1 \\le q \\le 1000$)\u00a0\u2014 the number of rows and columns in the grid, the size of the operation rectangle, and the number of operations, respectively.\n\nThe second line of each test case contains a string $s$ of length $q$, consisting only of characters $\\mathtt{H}$ and $\\mathtt{V}$\u00a0\u2014 the sequence of operation types.\n\nIt is guaranteed that the sum of $q$ over all test cases does not exceed $1000$.\n\n### Output\n\nFor each test case, output a single integer $-1$ if it is impossible to perform all the operations.\n\nOtherwise, output $q$ lines. Each line contains two integers $i$, $j$ ($1 \\le i \\le n$, $1 \\le j \\le m$)\u00a0\u2014 the coordinates of the top-left cell of the operation rectangle.\n\nIf there are multiple solutions, output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n1\n\n4 5 3 6\n\nHVVHHV\n\n```\n\n#### Output #1\n\n```\n1 1\n2 1\n1 1\n2 3\n3 3\n2 2\n```\n\n### Note\n\n![](https://espresso.codeforces.com/5f11eda6b2e6af97c5175719de15ebefdba4d493.png)Illustration of example.\n\nThe first operation is horizontal. The operation rectangle starts at $(1,1)$ and is a $1 \\times 3$ rectangle. After the operation, cells $(1,1)$, $(1,2)$, and $(1,3)$ become black.\n\nThe second operation is vertical. The operation rectangle starts at $(2,1)$ and is a $3 \\times 1$ rectangle. After the operation, cells $(2,1)$, $(3,1)$, and $(4,1)$ become black. At this point, the first column becomes completely black, so all cells in the first column are reset to white.\n\nThe third operation is vertical. The operation rectangle starts at $(1,1)$ and is a $3 \\times 1$ rectangle. After the operation, cells $(1,1)$, $(2,1)$, and $(3,1)$ become black.\n\nThe fourth operation is horizontal. The operation rectangle starts at $(2,3)$ and is a $1 \\times 3$ rectangle. After the operation, cells $(2,3)$, $(2,4)$, and $(2,5)$ become black.\n\nThe fifth operation is horizontal. The operation rectangle starts at $(3,3)$ and is a $1 \\times 3$ rectangle. After the operation, cells $(3,3)$, $(3,4)$, and $(3,5)$ become black.\n\nThe sixth operation is vertical. The operation rectangle starts at $(2,2)$ and is a $3 \\times 1$ rectangle. After the operation, cells $(2,2)$, $(3,2)$, and $(4,2)$ become black. At this point, two rows and one column become completely black, so all cells in these rows and the column are reset to white.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_SIZE = 105;\nchar operationType;\nint n, m, k, q, grid[MAX_SIZE][MAX_SIZE];\nstring s;\nint calculateSum(int x1, int y1, int x2, int y2) {\n    int sum = 0;\n    for (int i = x1; i <= x2; i++)\n        for (int j = y1; j <= y2; j++)\n            sum += grid[i][j];\n    return sum;\n}\nvoid performOperation(int x, int y) {\n    cout << x << ' ' << y << '\\n';\n    for (int i = 1; i <= k; i++) {\n        grid[x][y] = 1;\n        if (operationType == 'H')\n            y++;\n        else\n            x++;\n    }\n    int rowSums[MAX_SIZE] = {}, colSums[MAX_SIZE] = {};\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++) {\n            rowSums[i] += grid[i][j];\n            colSums[j] += grid[i][j];\n        }\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            if (rowSums[i] == m || colSums[j] == n)\n                grid[i][j] = 0;\n}\nvoid solve() {\n    cin >> n >> m >> k >> q >> s;\n    s = ' ' + s;\n    memset(grid, 0, sizeof(grid));\n    for (int i = 1; i <= q; i++) {\n        operationType = s[i];\n        if (operationType == 'H') {\n            int row = -1;\n            for (int j = 1; j <= n; j++)\n                if (calculateSum(j, 1, j, k) == 0) {\n                    row = j;\n                    if (calculateSum(j, 1, j, m) == m - k) {\n                        break;\n                    }\n                }\n            performOperation(row, 1);\n        } else {\n            int col = -1;\n            for (int j = 1; j <= m; j++)\n                if (calculateSum(1, j, k, j) == 0) {\n                    col = j;\n                    if (calculateSum(1, j, n, j) == n - k) {\n                        break;\n                    }\n                }\n            performOperation(1, col);\n        }\n    }\n}\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1991d",
      "PROBLEM_ID": "1991D",
      "PROBLEM_STATEMENT": "You are given an undirected graph with $n$ vertices, numbered from $1$ to $n$. There is an edge between vertices $u$ and $v$ if and only if $u \\oplus v$ is a [prime number](https://en.wikipedia.org/wiki/Prime_number), where $\\oplus$ denotes the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nColor all vertices of the graph using the minimum number of colors, such that no two vertices directly connected by an edge have the same color.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of test cases follows.\n\nThe only line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of vertices in the graph.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output two lines.\n\nThe first line should contain a single integer $k$ ($1 \\le k \\le n$)\u00a0\u2014 the minimum number of colors required.\n\nThe second line should contain $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\le c_i \\le k$)\u00a0\u2014 the color of each vertex.\n\nIf there are multiple solutions, output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n```\n\n#### Output #1\n\n```\n1\n1\n2\n1 2\n2\n1 2 2\n3\n1 2 2 3\n3\n1 2 2 3 3\n4\n1 2 2 3 3 4```\n\n### Note\n\nIn the first test case, the minimum number of colors is $1$, because there is only one vertex.\n\nIn the second test case, the minimum number of colors is $2$, because there is an edge connecting $1$ and $2$ ($1 \\oplus 2 = 3$, which is a prime number).\n\nIn the third test case, the minimum number of colors is still $2$, because $2$ and $3$ can be colored the same since there is no edge between $2$ and $3$ ($2 \\oplus 3 = 1$, which is not a prime number).\n\nIn the fourth test case, it can be shown that the minimum number of colors is $3$.\n\nIn the fifth test case, it can be shown that the minimum number of colors is $3$.\n\nIn the sixth test case, it can be shown that the minimum number of colors is $4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nll T,n;\nint main(){\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;\n\t\tif (n<=5){\n\t\t\tcout<<n/2+1<<endl;\n\t\t\tfor (int i=1;i<=n;++i) cout<<i/2+1<<' ';cout<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<4<<endl;\n\t\t\tfor (int i=1;i<=n;++i) cout<<(i%4)+1<<' ';cout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1991c",
      "PROBLEM_ID": "1991C",
      "PROBLEM_STATEMENT": "You are given an array $a$ of $n$ integers.\n\nIn one operation, you will perform the following two-step move:\n\n1. Choose an integer $x$ ($0 \\le x \\le 10^{9}$).\n2. Replace each $a_i$ with $|a_i - x|$, where $|v|$ denotes the [absolute value](https://en.wikipedia.org/wiki/Absolute_value) of $v$.\n\nFor example, by choosing $x = 8$, the array $[5, 7, 10]$ will be changed into $[|5-8|, |7-8|, |10-8|] = [3,1,2]$.\n\nConstruct a sequence of operations to make all elements of $a$ equal to $0$ in at most $40$ operations or determine that it is impossible. You do not need to minimize the number of operations.\n\n### Input\n\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$)\u00a0\u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer $-1$ if it is impossible to make all array elements equal to $0$ in at most $40$ operations.\n\nOtherwise, output two lines. The first line of output should contain a single integer $k$ ($0 \\le k \\le 40$)\u00a0\u2014 the number of operations. The second line of output should contain $k$ integers $x_1, x_2, \\ldots, x_k$ ($0 \\le x_i \\le 10^{9}$)\u00a0\u2014 the sequence of operations, denoting that on the $i$-th operation, you chose $x=x_i$.\n\nIf there are multiple solutions, output any of them.\n\nYou do not need to minimize the number of operations.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n5\n\n2\n\n0 0\n\n3\n\n4 6 8\n\n4\n\n80 40 20 10\n\n5\n\n1 2 3 4 5\n\n```\n\n#### Output #1\n\n```\n1\n5\n0\n\n3\n6 1 1\n7\n60 40 20 10 30 25 5\n-1```\n\n### Note\n\nIn the first test case, we can perform only one operation by choosing $x = 5$, changing the array from $[5]$ to $[0]$.\n\nIn the second test case, no operations are needed because all elements of the array are already $0$.\n\nIn the third test case, we can choose $x = 6$ to change the array from $[4, 6, 8]$ to $[2, 0, 2]$, then choose $x = 1$ to change it to $[1, 1, 1]$, and finally choose $x = 1$ again to change the array into $[0, 0, 0]$.\n\nIn the fourth test case, we can make all elements $0$ by following the operation sequence $(60, 40, 20, 10, 30, 25, 5)$.\n\nIn the fifth test case, it can be shown that it is impossible to make all elements $0$ in at most $40$ operations. Therefore, the output is $-1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <vector>       // For std::vector\n#include <numeric>      // Standard library header, not strictly used here but potentially useful\n#include <cmath>        // For std::abs function\n#include <iostream>     // For standard input/output operations (cin, cout)\n#include <algorithm>    // Provides useful algorithms, though min/max finding is implemented manually here\n#include <vector>       // Ensure vector header is included\n\n/**\n * @brief Finds the minimum and maximum elements in a vector of integers.\n * \n * This function iterates through the vector once to find the minimum and maximum values.\n * It assumes the vector is non-empty, as guaranteed by the problem constraints (N >= 1).\n * \n * @param n The size of the vector.\n * @param a A constant reference to the vector of integers.\n * @return A std::pair containing the minimum value (first) and maximum value (second).\n * Time Complexity: O(N) where N is the number of elements in the vector.\n * Space Complexity: O(1) extra space.\n */\nstd::pair<int, int> find_min_max(int n, const std::vector<int>& a) {\n    // Initialize minimum and maximum values with the first element of the array.\n    // Since N >= 1, a[0] is always accessible.\n    int min_val = a[0];\n    int max_val = a[0];\n    \n    // Iterate through the rest of the elements starting from the second element (index 1).\n    for (int i = 1; i < n; ++i) {\n        // If the current element is smaller than the current minimum, update minimum.\n        if (a[i] < min_val) {\n            min_val = a[i];\n        }\n        // If the current element is larger than the current maximum, update maximum.\n        if (a[i] > max_val) {\n            max_val = a[i];\n        }\n    }\n    // Return the found minimum and maximum values as a pair.\n    return {min_val, max_val};\n}\n\nint main() {\n    // Optimize standard C++ input/output operations for faster execution.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t; // Variable to store the number of test cases.\n    std::cin >> t; // Read the number of test cases.\n    \n    // Loop through each test case.\n    while (t--) {\n        int n; // Variable to store the size of the array for the current test case.\n        std::cin >> n; // Read the size of the array.\n        std::vector<int> a(n); // Declare the integer vector 'a' of size 'n'.\n        \n        // Read the elements of the array 'a'.\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n        }\n\n        // Crucial Check: Determine if all elements have the same parity.\n        // The operation preserves the property of having uniform parity (all even or all odd)\n        // or flips all parities simultaneously. If the initial array has mixed parities,\n        // it's impossible to reach the all-zero state (where all elements are 0, hence even).\n        // Constraint N >= 1 guarantees a[0] is accessible.\n        int first_parity = a[0] % 2; // Calculate the parity of the first element (0 for even, 1 for odd).\n        bool mixed_parity = false; // Flag to indicate if elements with different parities are found.\n        \n        // Iterate through the array starting from the second element.\n        for (int i = 1; i < n; ++i) {\n            // Check if the parity of the current element differs from the first element's parity.\n            // Since a[i] >= 0, a[i] % 2 correctly returns 0 or 1.\n            if (a[i] % 2 != first_parity) {\n                mixed_parity = true; // Set the flag if mixed parity is detected.\n                break; // Exit the loop early as the condition is met.\n            }\n        }\n\n        // If mixed parities were found, output -1 and proceed to the next test case.\n        if (mixed_parity) {\n            std::cout << -1 << \"\\n\"; \n            continue; \n        }\n\n        // If all elements have the same parity, the problem is potentially solvable within 40 steps.\n        // Apply the strategy: repeatedly choose x = (min + max) / 2.\n        std::vector<int> ops; // Vector to store the sequence of chosen 'x' values for operations.\n        \n        // Perform the operations. Loop at most 40 times.\n        // Based on analysis (max value roughly halves each step), this should be sufficient.\n        for (int k = 0; k < 40; ++k) {\n             // Find the current minimum (m) and maximum (M) values in the array 'a'.\n             std::pair<int, int> min_max = find_min_max(n, a);\n             int m = min_max.first; \n             int M = min_max.second;\n\n             // If the maximum value M is 0, all elements are 0. The goal is achieved.\n             if (M == 0) {\n                 break; // Terminate the operations loop.\n             }\n             \n             // Calculate the operation value x = (m+M)/2.\n             // Use 'long long' for the intermediate sum m+M to prevent potential integer overflow\n             // when m and M are close to 10^9.\n             // Since m and M have the same parity, m+M is always even, and x is an integer.\n             long long sum_m_M = (long long)m + M;\n             int x = sum_m_M / 2;\n             ops.push_back(x); // Record the chosen value 'x' for this operation.\n\n             // Apply the operation: update each element a_i to |a_i - x|.\n             for (int i = 0; i < n; ++i) {\n                 // std::abs from <cmath> computes the absolute value.\n                 // The result is guaranteed non-negative and remains within the range [0, 10^9].\n                 a[i] = std::abs(a[i] - x); \n             }\n        }\n        \n        // After the loop completes (either by reaching M=0 or hitting the 40 iteration limit),\n        // output the results for this test case.\n        \n        // Output the total number of operations performed.\n        std::cout << ops.size() << \"\\n\";\n        \n        // Output the sequence of operation values x_1, x_2, ..., x_k, separated by spaces.\n        if (!ops.empty()) { // Check if any operations were actually performed.\n             for (size_t i = 0; i < ops.size(); ++i) {\n                 // Print the current operation value. Add a space after it unless it's the last one.\n                 std::cout << ops[i] << (i == ops.size() - 1 ? \"\" : \" \"); \n             }\n        }\n        // Print a newline character to properly format the output between test cases.\n        std::cout << \"\\n\"; \n    }\n    \n    return 0; // Indicate successful program execution.\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1991b",
      "PROBLEM_ID": "1991B",
      "PROBLEM_STATEMENT": "You are given an array $b$ of $n - 1$ integers.\n\nAn array $a$ of $n$ integers is called good if $b_i = a_i \\, \\& \\, a_{i + 1}$ for $1 \\le i \\le n-1$, where $\\&$ denotes the [bitwise AND operator](https://en.wikipedia.org/wiki/Bitwise_operation#AND).\n\nConstruct a good array, or report that no good arrays exist.\n\n### Input\n\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$)\u00a0\u2014 the length of the array $a$.\n\nThe second line of each test case contains $n - 1$ integers $b_1, b_2, \\ldots, b_{n - 1}$ ($0 \\le b_i < 2^{30}$)\u00a0\u2014 the elements of the array $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each test case, output a single integer $-1$ if no good arrays exist.\n\nOtherwise, output $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i < 2^{30}$)\u00a0\u2014 the elements of a good array $a$.\n\nIf there are multiple solutions, you may output any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n2\n\n1\n\n3\n\n2 0\n\n4\n\n1 2 3\n\n5\n\n3 5 4 2\n\n```\n\n#### Output #1\n\n```\n5 3\n3 2 1\n-1\n3 7 5 6 3\n```\n\n### Note\n\nIn the first test case, $b = [1]$. A possible good array is $a=[5, 3]$, because $a_1 \\, \\& \\, a_2 = 5 \\, \\& \\, 3 = 1 = b_1$.\n\nIn the second test case, $b = [2, 0]$. A possible good array is $a=[3, 2, 1]$, because $a_1 \\, \\& \\, a_2 = 3 \\, \\& \\, 2 = 2 = b_1$ and $a_2 \\, \\& \\, a_3 = 2 \\, \\& \\, 1 = 0 = b_2$.\n\nIn the third test case, $b = [1, 2, 3]$. It can be shown that no good arrays exist, so the output is $-1$.\n\nIn the fourth test case, $b = [3, 5, 4, 2]$. A possible good array is $a=[3, 7, 5, 6, 3]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define all(x) (x).begin(), (x).end()\n#define vi vector<ll>\n#define vpi vector<pair<ll,ll>>\n#define vout(a) for(auto x:a)cout<<x<<\" \";cout<<endl;\n#define vvout(a) for(auto x:a){for(auto y:x)cout<<y<<\" \";cout<<endl;}\n#define pb push_back\n#define pans(x) cout<<((x)? \"YES \" : \"NO \")<<endl;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    ll tt = 1;\n    cin>>tt;\n    while(tt--) {\n      int n;\n      cin>>n;\n      vi b(n-1);\n      for(int i=0;i<n-1;i++){\n        cin>>b[i];\n      }\n\n      vi a(n);\n      for(int i = 0;i<n;i++){\n        if(i == 0){\n          a[i] = b[0];\n        }else if(i == n - 1){\n          a[i] = b[n-2];\n        }else{\n          a[i] = (b[i] | b[i-1]);\n        }\n      }\n      bool ans = true;\n      for(int i = 0;i<n-1;i++){\n        if((a[i] & a[i + 1]) != b[i]){\n          ans = false;\n          break;\n        }\n      }\n      \n\n      if(ans == false){\n        cout<<-1;\n      }else{\n        for(int i=0;i<n;i++){\n          cout<<a[i]<<\" \";\n        }\n      }\n      \n      cout<<endl;\n    }\n\n      }\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1991a",
      "PROBLEM_ID": "1991A",
      "PROBLEM_STATEMENT": "You are given an array $a$ of $n$ integers, where $n$ is odd.\n\nIn one operation, you will remove two adjacent elements from the array $a$, and then concatenate the remaining parts of the array. For example, given the array $[4,7,4,2,9]$, we can obtain the arrays $[4,2,9]$ and $[4,7,9]$ by the operations $[\\underline{4,7}, 4,2,9] \\to [4,2,9]$ and $[4,7,\\underline{4,2},9] \\to [4,7,9]$ respectively. However, we cannot obtain the array $[7,2,9]$ as it requires deleting non-adjacent elements $[\\underline{4},7,\\underline{4},2,9]$.\n\nYou will repeatedly perform this operation until exactly one element remains in $a$.\n\nFind the maximum possible value of the remaining element in $a$.\n\n### Input\n\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 99$; $n$ is odd)\u00a0\u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 100$)\u00a0\u2014 the elements of the array $a$.\n\nNote that there is no bound on the sum of $n$ over all test cases.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the maximum possible value of the remaining element in $a$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n6\n\n3\n\n1 3 2\n\n5\n\n4 7 4 2 9\n\n7\n\n3 1 4 1 5 9 2\n\n```\n\n#### Output #1\n\n```\n6\n2\n9\n5\n```\n\n### Note\n\nIn the first test case, the array $a$ is $[6]$. Since there is only one element, no operations are needed. The maximum possible value of the remaining element is $6$.\n\nIn the second test case, the array $a$ is $[1, 3, 2]$. We can remove the first two elements $[\\underline{1, 3}, 2] \\to [2]$, or remove the last two elements $[1, \\underline{3, 2}] \\to [1]$. Therefore, the maximum possible value of the remaining element is $2$.\n\nIn the third test case, the array $a$ is $[4, 7, 4, 2, 9]$. One way to maximize the remaining element is $[4, \\underline{7, 4}, 2, 9] \\to [\\underline{4, 2}, 9] \\to [9]$. Therefore, the maximum possible value of the remaining element is $9$.\n\nIn the fourth test case, the array $a$ is $[3, 1, 4, 1, 5, 9, 2]$. It can be shown that the maximum possible value of the remaining element is $5$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        int max_val = 0;\n        for (int i = 0; i < n; i += 2) {\n            if (a[i] > max_val) {\n                max_val = a[i];\n            }\n        }\n        cout << max_val << endl;\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1990d",
      "PROBLEM_ID": "1990D",
      "PROBLEM_STATEMENT": "You are given an array $a$ of size $n$.\n\nThere is an $n \\times n$ grid. In the $i$-th row, the first $a_i$ cells are black and the other cells are white. In other words, note $(i,j)$ as the cell in the $i$-th row and $j$-th column, cells $(i,1), (i,2), \\ldots, (i,a_i)$ are black, and cells $(i,a_i+1), \\ldots, (i,n)$ are white.\n\nYou can do the following operations any number of times in any order:\n\n- Dye a $2 \\times 2$ subgrid white;\n- Dye a whole row white. Note you can not dye a whole column white.\n\nFind the minimum number of operations to dye all cells white.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nFor each test case:\n\n- The first line contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the size of the array $a$.\n- The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq n$).\n\nIt's guaranteed that the sum of $n$ over all test cases will not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations to dye all cells white.\n\n### Example\n\n#### Input #1\n\n```\n\n10\n\n1\n\n0\n\n4\n\n2 4 4 2\n\n4\n\n3 2 1 0\n\n3\n\n0 3 0\n\n3\n\n0 1 3\n\n3\n\n3 1 0\n\n4\n\n3 1 0 3\n\n4\n\n0 2 2 2\n\n6\n\n1 3 4 2 0 4\n\n8\n\n2 2 5 2 3 4 2 4\n\n```\n\n#### Output #1\n\n```\n0\n3\n2\n1\n2\n2\n3\n2\n4\n6\n```\n\n### Note\n\nIn the first test case, you don't need to do any operation.\n\nIn the second test case, you can do:\n\n- Dye $(1,1), (1,2), (2,1)$, and $(2,2)$ white;\n- Dye $(2,3), (2,4), (3,3)$, and $(3,4)$ white;\n- Dye $(3,1), (3,2), (4,1)$, and $(4,2)$ white.\n\nIt can be proven $3$ is the minimum number of operations.\n\nIn the third test case, you can do:\n\n- Dye the first row white;\n- Dye $(2,1), (2,2), (3,1)$, and $(3,2)$ white.\n\nIt can be proven $2$ is the minimum number of operations.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n#define m_p make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef long long ll;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937 rnf(2106);\nconst int N = 200005;\n\nint n;\nint a[N];\n\nint dp[N];\nvoid minh(int& x, int y)\n{\n    x = min(x, y);\n}\n\nvoid solv()\n{\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n        cin >> a[i];\n\n    int minu[2] = {N, N};\n    for (int i = 1; i <= n; ++i)\n    {\n        dp[i] = dp[i - 1] + 1;\n        if (a[i] == 0)\n            minh(dp[i], dp[i - 1]);\n        if (a[i] <= 2)\n            minh(dp[i], i + minu[1 - i % 2]);\n\n        if (a[i] <= 2)\n            minh(minu[i % 2], dp[i - 1] - i);\n        else if (a[i] > 4)\n            minu[0] = minu[1] = N;\n    }\n\n    cout << dp[n] << \"\\n\";\n}\n\nint main()\n{\n    #ifdef SOMETHING\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #endif // SOMETHING\n    ios_base::sync_with_stdio(false), cin.tie(0);\n\n    int tt = 1;\n    cin >> tt;\n    while (tt--)\n    {\n        solv();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1990c",
      "PROBLEM_ID": "1990C",
      "PROBLEM_STATEMENT": "We define the $\\operatorname{MAD}$ (Maximum Appearing Duplicate) in an array as the largest number that appears at least twice in the array. Specifically, if there is no number that appears at least twice, the $\\operatorname{MAD}$ value is $0$.\n\nFor example, $\\operatorname{MAD}([1, 2, 1]) = 1$, $\\operatorname{MAD}([2, 2, 3, 3]) = 3$, $\\operatorname{MAD}([1, 2, 3, 4]) = 0$.\n\nYou are given an array $a$ of size $n$. Initially, a variable $sum$ is set to $0$.\n\nThe following process will be executed in a sequential loop until all numbers in $a$ become $0$:\n\n1. Set $sum := sum + \\sum_{i=1}^{n} a_i$;\n2. Let $b$ be an array of size $n$. Set $b_i :=\\ \\operatorname{MAD}([a_1, a_2, \\ldots, a_i])$ for all $1 \\le i \\le n$, and then set $a_i := b_i$ for all $1 \\le i \\le n$.\n\nFind the value of $sum$ after the process.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 2 \\cdot 10^4$)\u00a0\u2014 the number of test cases.\n\nFor each test case:\n\n- The first line contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the size of the array $a$;\n- The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq n$)\u00a0\u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases will not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, output the value of $sum$ in a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n1\n\n3\n\n2 2 3\n\n4\n\n2 1 1 2\n\n4\n\n4 4 4 4\n\n```\n\n#### Output #1\n\n```\n1\n13\n9\n40\n```\n\n### Note\n\nIn the first test case, $a=[1]$ initially.\n\nIn the first loop:\n\n1. Set $sum := sum + a_1 = 0+1=1$;\n2. Set $b_1 :=\\ \\operatorname{MAD}([a_1])=\\ \\operatorname{MAD}([1])=0$, and then set $a_1 := b_1$.\n\nAfter the first loop, $a=[0]$ and the process ends. The value of $sum$ after the process is $1$.\n\nIn the second test case, $a=[2,2,3]$ initially.\n\nAfter the first loop, $a=[0,2,2]$ and $sum=7$.\n\nAfter the second loop, $a=[0,0,2]$ and $sum=11$.\n\nAfter the third loop, $a=[0,0,0]$ and $sum=13$. Then the process ends.\n\nThe value of $sum$ after the process is $13$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n#define m_p make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef long long ll;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937 rnf(2106);\nconst int N = 200005;\n\nint n;\nint a[N];\n\nbool c[N];\nvoid doit()\n{\n    for (int i = 1; i <= n; ++i)\n        c[i] = false;\n    int maxu = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (c[a[i]])\n            maxu = max(maxu, a[i]);\n        c[a[i]] = true;\n        a[i] = maxu;\n    }\n}\n\nvoid solv()\n{\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n        cin >> a[i];\n\n    ll ans = 0;\n    for (int i = 1; i <= n; ++i)\n        ans += a[i];\n    doit();\n    for (int i = 1; i <= n; ++i)\n        ans += a[i];\n    doit();\n\n    for (int i = 1; i <= n; ++i)\n        ans += (n - i + 1) * 1LL * a[i];\n    cout << ans << \"\\n\";\n}\n\nint main()\n{\n    #ifdef SOMETHING\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #endif // SOMETHING\n    ios_base::sync_with_stdio(false), cin.tie(0);\n\n    int tt = 1;\n    cin >> tt;\n    while (tt--)\n    {\n        solv();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1990b",
      "PROBLEM_ID": "1990B",
      "PROBLEM_STATEMENT": "For an array $b$ of size $m$, we define:\n\n- the maximum prefix position of $b$ is the smallest index $i$ that satisfies $b_1+\\ldots+b_i=\\max_{j=1}^{m}(b_1+\\ldots+b_j)$;\n- the maximum suffix position of $b$ is the largest index $i$ that satisfies $b_i+\\ldots+b_m=\\max_{j=1}^{m}(b_j+\\ldots+b_m)$.\n\nYou are given three integers $n$, $x$, and $y$ ($x > y$). Construct an array $a$ of size $n$ satisfying:\n\n- $a_i$ is either $1$ or $-1$ for all $1 \\le i \\le n$;\n- the maximum prefix position of $a$ is $x$;\n- the maximum suffix position of $a$ is $y$.\n\nIf there are multiple arrays that meet the conditions, print any. It can be proven that such an array always exists under the given conditions.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$)\u00a0\u2014 the number of test cases.\n\nFor each test case:\n\n- The only line contains three integers $n$, $x$, and $y$ ($2 \\leq n \\leq 10^5, 1 \\le y \\lt x \\le n)$.\n\nIt is guaranteed that the sum of $n$ over all test cases will not exceed $10^5$.\n\n### Output\n\nFor each test case, output $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ in a new line.\n\n### Example\n\n#### Input #1\n\n```\n\n3\n\n2 2 1\n\n4 4 3\n\n6 5 1\n\n```\n\n#### Output #1\n\n```\n1 1\n1 -1 1 1\n1 1 -1 1 1 -1```\n\n### Note\n\nIn the second test case,\n\n- $i=x=4$ is the smallest index that satisfies $a_1+\\ldots +a_i=\\max_{j=1}^{n}(a_1+\\ldots+a_j)=2$;\n- $i=y=3$ is the greatest index that satisfies $a_i+\\ldots +a_n=\\max_{j=1}^{n}(a_j+\\ldots+a_n)=2$.\n\nThus, the array $a=[1,-1,1,1]$ is considered correct.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Not strictly needed for this problem, but good practice to include if using numeric algorithms\n\n// Function to handle a single test case\nvoid solve() {\n    int n; // Size of the array\n    int x; // Required maximum prefix position\n    int y; // Required maximum suffix position\n    \n    // Read input values for n, x, y for the current test case\n    std::cin >> n >> x >> y;\n    \n    // Create a vector 'a' of size n to store the array elements.\n    // We will populate this vector according to the construction logic.\n    // It's initially filled with default values (0 for int), but all elements relevant to the logic will be overwritten.\n    std::vector<int> a(n);\n    \n    // The problem statement uses 1-based indexing for positions x and y (from 1 to n).\n    // C++ vectors use 0-based indexing (from 0 to n-1).\n    // It's convenient to convert x and y to 0-based indices for array access.\n    // Position k in 1-based indexing corresponds to index k-1 in 0-based indexing.\n    int x_idx = x - 1; // 0-based index corresponding to position x\n    int y_idx = y - 1; // 0-based index corresponding to position y\n\n    // --- Construction Logic ---\n    // The construction strategy aims to satisfy both prefix and suffix conditions simultaneously.\n    // It involves setting a block of 1s between y and x, and alternating patterns outside this block.\n\n    // Part 1: Set elements from position y to x (inclusive) to 1.\n    // In 0-based indexing, this corresponds to indices from y_idx to x_idx.\n    // This block of 1s ensures that the prefix sum increases steadily from index y_idx to x_idx, helping make P_x the maximum.\n    // Similarly, it ensures that suffix sums (when considered right-to-left) increase steadily from x_idx down to y_idx, helping make S_y the maximum.\n    for (int i = y_idx; i <= x_idx; ++i) {\n        a[i] = 1;\n    }\n    \n    // Part 2: Set elements before position y (indices 0 to y_idx-1).\n    // The required pattern for this segment is an alternating sequence of 1s and -1s,\n    // specifically designed such that it ends with -1 at index y_idx-1 (position y-1).\n    // The pattern is ..., 1, -1.\n    // This check handles the edge case where y = 1 (y_idx = 0), which means this segment is empty.\n    if (y_idx > 0) { \n        // Set the element at index y_idx-1 (which corresponds to position y-1) to -1.\n        // This is the rightmost element of this segment.\n        a[y_idx - 1] = -1; \n        \n        // Fill the remaining elements to the left (indices from y_idx-2 down to 0)\n        // using the alternating pattern rule: a[i] = -a[i+1].\n        for (int i = y_idx - 2; i >= 0; --i) {\n            // Each element is the negative of the element immediately to its right.\n            // This propagates the alternating pattern leftwards.\n            a[i] = -a[i + 1];\n        }\n    }\n\n    // Part 3: Set elements after position x (indices x_idx+1 to n-1).\n    // The required pattern for this segment is an alternating sequence of -1s and 1s,\n    // specifically designed such that it starts with -1 at index x_idx+1 (position x+1).\n    // The pattern is -1, 1, -1, 1, ...\n    // This check handles the edge case where x = n (x_idx = n-1), which means this segment is empty.\n    if (x_idx < n - 1) { \n        // Set the element at index x_idx+1 (which corresponds to position x+1) to -1.\n        // This is the leftmost element of this segment.\n        a[x_idx + 1] = -1; \n        \n        // Fill the remaining elements to the right (indices from x_idx+2 up to n-1)\n        // using the alternating pattern rule: a[i] = -a[i-1].\n        for (int i = x_idx + 2; i < n; ++i) {\n            // Each element is the negative of the element immediately to its left.\n            // This propagates the alternating pattern rightwards.\n            a[i] = -a[i - 1];\n        }\n    }\n    \n    // --- Output ---\n    // Print the elements of the constructed array 'a'.\n    // Elements should be separated by spaces.\n    for (int i = 0; i < n; ++i) {\n        std::cout << a[i] << (i == n - 1 ? \"\" : \" \"); // Print space after element unless it's the last one.\n    }\n    // Print a newline character at the end of the output for this test case, as required by standard competitive programming formats.\n    std::cout << std::endl;\n}\n\n// Main function - the entry point of the program\nint main() {\n    // Optimize standard input/output streams for faster execution.\n    // This is a common optimization in competitive programming.\n    std::ios_base::sync_with_stdio(false); // Untie C++ standard streams from C standard streams.\n    std::cin.tie(NULL); // Untie cin from cout.\n    \n    // Read the number of test cases.\n    int t;\n    std::cin >> t;\n    // Loop through each test case and call the solve function to process it.\n    while (t--) {\n        solve();\n    }\n    \n    // Return 0 to indicate successful program execution.\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1990a",
      "PROBLEM_ID": "1990A",
      "PROBLEM_STATEMENT": "Alice and Bob are playing a game in an array $a$ of size $n$.\n\nThey take turns to do operations, with Alice starting first. The player who can not operate will lose. At first, a variable $mx$ is set to $0$.\n\nIn one operation, a player can do:\n\n- Choose an index $i$ ($1 \\le i \\le n$) such that $a_{i} \\geq mx$ and set $mx$ to $a_{i}$. Then, set $a_{i}$ to $0$.\n\nDetermine whether Alice has a winning strategy.\n\n### Input\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^3$)\u00a0\u2014 the number of test cases.\n\nFor each test case:\n\n- The first line contains an integer $n$ ($2 \\leq n \\leq 50$)\u00a0\u2014 the size of the array.\n- The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq n$)\u00a0\u2014 the elements of the array.\n\n### Output\n\nFor each test case, if Alice has a winning strategy, output \"YES\". Otherwise, output \"NO\".\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n2 1\n\n2\n\n1 1\n\n3\n\n3 3 3\n\n4\n\n3 3 4 4\n\n4\n\n1 2 2 2\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nNO\nYES\n```\n\n### Note\n\nIn the first test case, Alice can choose $i=1$ since $a_1=2 \\ge mx=0$.\n\nAfter Alice's operation, $a=[0,1]$ and $mx=2$. Bob can not do any operation. Alice wins.\n\nIn the second test case, Alice doesn't have a winning strategy.\n\nFor example, if Alice chooses $i=1$, after Alice's operation: $a=[0,1]$ and $mx=1$. Then, Bob can choose $i=2$ since $a_2=1 \\ge mx=1$. After Bob's operation: $a=[0,0]$ and $mx=1$. Alice can not do any operation. Bob wins.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\nusing namespace std;\n#define m_p make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef long long ll;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937 rnf(2106);\nconst int N = 55;\n\nint n;\nint q[N];\n\nvoid solv()\n{\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n        q[i] = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        int x;\n        cin >> x;\n        ++q[x];\n    }\n\n    for (int i = 1; i <= n; ++i)\n    {\n        if (q[i] % 2 == 1)\n        {\n            cout << \"YES\\n\";\n            return;\n        }\n    }\n    cout << \"NO\\n\";\n}\n\nint main()\n{\n    #ifdef SOMETHING\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #endif // SOMETHING\n    ios_base::sync_with_stdio(false), cin.tie(0);\n\n    int tt = 1;\n    cin >> tt;\n    while (tt--)\n    {\n        solv();\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1988c",
      "PROBLEM_ID": "1988C",
      "PROBLEM_STATEMENT": "You are given a positive integer $n$. Find the longest sequence of positive integers $a=[a_1,a_2,\\ldots,a_k]$ that satisfies the following conditions, and print the sequence:\n\n- $a_i\\le n$ for all $1\\le i\\le k$.\n- $a$ is strictly increasing. That is, $a_i>a_{i-1}$ for all $2\\le i\\le k$.\n- $a_i\\,|\\,a_{i-1}=n$ for all $2\\le i\\le k$, where $|$ denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). Description of the test cases follows.\n\nThe only line of each test case contains one integer $n$ ($1\\le n\\le 10^{18}$).\n\nIt's guaranteed that the sum of lengths of the longest valid sequences does not exceed $5\\cdot 10^5$.\n\n### Output\n\nFor each testcase, print two lines. In the first line, print the length of your constructed sequence, $k$. In the second line, print $k$ positive integers, denoting the sequence. If there are multiple longest sequences, you can print any of them.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1\n\n3\n\n14\n\n23\n\n```\n\n#### Output #1\n\n```\n1\n1\n3\n1 2 3\n4\n4 10 12 14\n5\n7 18 21 22 23```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\nll T;\nstack <ll> s;\n\nll lowbit(ll x){\n    return x & -x;\n}\n\nsigned main(){\n    cin >> T;\n    while(T--){\n        ll n;\n        cin >> n;\n        ll m = n;\n        ll k = 1;\n        while(m){\n            if(n - lowbit(m) > 0){\n                s.push(n - lowbit(m));\n                k++;\n            }\n            m -= lowbit(m);\n        }\n        cout << k << endl;\n        while(!s.empty()){\n            cout << s.top() << ' ';\n            s.pop();\n        }\n        cout << n << endl;\n    }\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1988b",
      "PROBLEM_ID": "1988B",
      "PROBLEM_STATEMENT": "You are given a sequence $[a_1,\\ldots,a_n]$ where each element $a_i$ is either $0$ or $1$. You can apply several (possibly zero) operations to the sequence. In each operation, you select two integers $1\\le l\\le r\\le |a|$ (where $|a|$ is the current length of $a$) and replace $[a_l,\\ldots,a_r]$ with a single element $x$, where $x$ is the majority of $[a_l,\\ldots,a_r]$.\n\nHere, the majority of a sequence consisting of $0$ and $1$ is defined as follows: suppose there are $c_0$ zeros and $c_1$ ones in the sequence, respectively.\n\n- If $c_0\\ge c_1$, the majority is $0$.\n- If $c_0<c_1$, the majority is $1$.\n\nFor example, suppose $a=[1,0,0,0,1,1]$. If we select $l=1,r=2$, the resulting sequence will be $[0,0,0,1,1]$. If we select $l=4,r=6$, the resulting sequence will be $[1,0,0,1]$.\n\nDetermine if you can make $a=[1]$ with a finite number of operations.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 4\\cdot 10^4$). Description of the test cases follows.\n\nThe first line of each testcase contains one integer $n$ ($1\\le n\\le 2\\cdot 10^5$).\n\nThe second line of each testcase contains a string consisting of $0$ and $1$, describing the sequence $a$.\n\nIt's guaranteed that the sum of $n$ over all testcases does not exceed $2\\cdot 10^5$.\n\n### Output\n\nFor each testcase, if it's possible to make $a=[1]$, print YES. Otherwise, print NO. You can output the answer in any case (upper or lower). For example, the strings yEs, yes, Yes, and YES will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n1\n\n0\n\n1\n\n1\n\n2\n\n01\n\n9\n\n100000001\n\n9\n\n000011000\n\n```\n\n#### Output #1\n\n```\nNo\nYes\nNo\nYes\nNo\n```\n\n### Note\n\nIn the fourth testcase of the example, initially $a=[1,0,0,0,0,0,0,0,1]$. A valid sequence of operations is:\n\n1. Select $l=2,r=8$ and apply the operation. $a$ becomes $[1,0,1]$.\n2. Select $l=1,r=3$ and apply the operation. $a$ becomes $[1]$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\nlong long t,n,l,y;\nstring s;\nint main(){\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n;\n\t\tcin>>s;\n\t\ts='$'+s;\n\t\tl=y=0;\n\t\tfor(long long i=1;i<=n;i++){\n\t\t\tif(s[i]=='1') y++;\n\t\t\telse if(s[i]=='0' && s[i-1]!='0') l++;\n\t\t}\n\t\tif(l>=y) cout<<\"NO\"<<'\n';\n\t\telse cout<<\"YES\"<<'\n';\n\t}\n\treturn 0;\n}\n",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1988a",
      "PROBLEM_ID": "1988A",
      "PROBLEM_STATEMENT": "A multiset is a set of numbers in which there can be equal elements, and the order of the numbers does not matter. For example, $\\{2,2,4\\}$ is a multiset.\n\nYou have a multiset $S$. Initially, the multiset contains only one positive integer $n$. That is, $S=\\{n\\}$. Additionally, there is a given positive integer $k$.\n\nIn one operation, you can select any positive integer $u$ in $S$ and remove one copy of $u$ from $S$. Then, insert no more than $k$ positive integers into $S$ so that the sum of all inserted integers is equal to $u$.\n\nFind the minimum number of operations to make $S$ contain $n$ ones.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). Description of the test cases follows.\n\nThe only line of each testcase contains two integers $n,k$ ($1\\le n\\le 1000,2\\le k\\le 1000$).\n\n### Output\n\nFor each testcase, print one integer, which is the required answer.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n1 5\n\n5 2\n\n6 3\n\n16 4\n\n```\n\n#### Output #1\n\n```\n0\n4\n3\n5\n```\n\n### Note\n\nFor the first test case, initially $S=\\{1\\}$, already satisfying the requirement. Therefore, we need zero operations.\n\nFor the second test case, initially $S=\\{5\\}$. We can apply the following operations:\n\n- Select $u=5$, remove $u$ from $S$, and insert $2,3$ into $S$. Now, $S=\\{2,3\\}$.\n- Select $u=2$, remove $u$ from $S$, and insert $1,1$ into $S$. Now, $S=\\{1,1,3\\}$.\n- Select $u=3$, remove $u$ from $S$, and insert $1,2$ into $S$. Now, $S=\\{1,1,1,2\\}$.\n- Select $u=2$, remove $u$ from $S$, and insert $1,1$ into $S$. Now, $S=\\{1,1,1,1,1\\}$.\n\nUsing $4$ operations in total, we achieve the goal.\n\nFor the third test case, initially $S=\\{6\\}$. We can apply the following operations:\n\n- Select $u=6$, remove $u$ from $S$, and insert $1,2,3$ into $S$. Now, $S=\\{1,2,3\\}$.\n- Select $u=2$, remove $u$ from $S$, and insert $1,1$ into $S$. Now, $S=\\{1,1,1,3\\}$.\n- Select $u=3$, remove $u$ from $S$, and insert $1,1,1$ into $S$. Now, $S=\\{1,1,1,1,1,1\\}$.\n\nUsing $3$ operations in total, we achieve the goal.\n\nFor the fourth test case, initially $S=\\{16\\}$. We can apply the following operations:\n\n- Select $u=16$, remove $u$ from $S$, and insert $4,4,4,4$ into $S$. Now, $S=\\{4,4,4,4\\}$.\n- Repeat for $4$ times: select $u=4$, remove $u$ from $S$, and insert $1,1,1,1$ into $S$.\n\nUsing $5$ operations in total, we achieve the goal.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n\nint main() {\n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        int n, k;\n        std::cin >> n >> k;\n        \n        if (n == 1) {\n            std::cout << 0 << std::endl;\n        } else {\n            // Compute ceiling of (n-1)/(k-1) using integer division\n            std::cout << (n - 1 + (k - 2)) / (k - 1) << std::endl;\n        }\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1983g",
      "PROBLEM_ID": "1983G",
      "PROBLEM_STATEMENT": "You are given a tree with $n$ nodes numbered from $1$ to $n$, along with an array of size $n$. The value of $i$-th node is $a_{i}$. There are $q$ queries. In each query, you are given 2 nodes numbered as $x$ and $y$.\n\nConsider the path from the node numbered as $x$ to the node numbered as $y$. Let the path be represented by $x = p_0, p_1, p_2, \\ldots, p_r = y$, where $p_i$ are the intermediate nodes. Compute the sum of $a_{p_i}\\oplus i$ for each $i$ such that $0 \\le i \\le r$ where $\\oplus$ is the [XOR](https://en.wikipedia.org/wiki/Exclusive_or) operator.\n\nMore formally, compute \n\n$$\\sum_{i =0}^{r} a_{p_i}\\oplus i$$\n\nInput\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. Each test case contains several sets of input data.\n\nThe first line of each set of input data contains a single integer $n$ ($1 \\le n \\le 5 \\cdot 10^5$)\u00a0\u2014 the number of nodes.\n\nThe next $n-1$ lines of each set of input data contain $2$ integers, $u$ and $v$ representing an edge between the node numbered $u$ and the node numbered $v$. It is guaranteed that $u \\ne v$ and that the edges form a tree.\n\nThe next line of each set of input data contains $n$ integers, $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 5 \\cdot 10^5$)\u00a0\u2014 values of the nodes.\n\nThe next line contains a single integer $q$ ($1 \\le q \\le 10^5$)\u00a0\u2014 the number of queries.\n\nThe next $q$ lines describe the queries. The $i$-th query contains $2$ integers $x$ and $y$ ($1 \\le x,y \\le n$) denoting the starting and the ending node of the path.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$ and sum of $q$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each query, output a single number\u00a0\u2014 the sum from the problem statement.\n\n### Example\n\n#### Input #1\n\n```\n\n1\n\n4\n\n1 2\n\n2 3\n\n3 4\n\n2 3 6 5\n\n3\n\n1 4\n\n3 4\n\n1 1\n\n```\n\n#### Output #1\n\n```\n14\n10\n2\n```",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 5e5+5;\nconst int MAXL = 20;\nconst int QMAX = 1e5+5;\nint n,q,b[MAX];\nvector<int>g[MAX];\nvector<array<int,3>>qinfo(QMAX);\nvector<long long>ans(QMAX,0);\nint up[MAX][MAXL],depth[MAX];\nint pf[MAX], dp[MAX];\nint u_split[QMAX][MAXL+1], v_split[QMAX][MAXL+1], v_end[QMAX][MAXL+1]{};\n\nvoid dfs(int a,int p,int d) {\n    up[a][0]=p;\n    depth[a]=d;\n    for(int j=1;j<MAXL;j++) {\n        up[a][j]=up[up[a][j-1]][j-1];\n    }\n    for(int i=0;i<g[a].size();i++) {\n        if(g[a][i]!=p) {\n            dfs(g[a][i],a,d+1);\n        }\n    }\n}\n// no of nodes in path [u..v] lca is lc\nint get_length(int u,int v,int lc) {\n    return depth[u]+depth[v]-2*depth[lc]+1;\n}\n\nint get_kth(int a,int k) {\n    int curr=a;\n    for(int i=0;i<MAXL;i++) {\n        if((k>>i)&1) {\n            curr=up[curr][i];\n        }\n    }\n    return curr;\n}\n\nint lca(int a,int b) {\n    if(depth[b]<depth[a]) {\n        swap(a,b);\n    }\n    b=get_kth(b,depth[b]-depth[a]);\n    if(a==b) {\n        return a;\n    }\n    for(int j=MAXL-1;j>=0;j--) {\n        if(up[a][j]!=up[b][j]) {\n            a=up[a][j],b=up[b][j];\n        }\n    }\n    return up[a][0];\n}\n\nint get_sum(int u, int v, int lc, int k){\n    return pf[u] + pf[v] -2*pf[lc] + ((b[lc]>>k)&1);\n}\n\nvoid calc_dp_pf(int a, int p, int k){\n    pf[a] = pf[p] + ((b[a]>>k)&1);\n    int next = up[a][k];\n    if(depth[a]>(1<<k)) dp[a]=depth[next]-dp[next]+pf[a]-pf[next];\n    else dp[a] = pf[a];\n    for(int i=0;i<g[a].size();i++) {\n        if(g[a][i]!=p) {\n            calc_dp_pf(g[a][i],a,k);\n        }\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin>>t;\n    dp[0] = 0;\n    pf[0] = 0;\n    while(t--) {\n        int n,q;\n        cin>>n;\n        for(int i=0;i<n-1;i++) {\n            int a,b;\n            cin>>a>>b;\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        for(int i=1;i<=n;i++) {\n            cin>>b[i];\n        }\n        dfs(1,0,1);\n        cin>>q;\n        for(int i=0;i<q;i++) {\n            int u,v;\n            cin>>u>>v;\n            qinfo[i] = {u,v,lca(u,v)};\n            ans[i] = 0;\n        }\n        for(int i=0;i<q;i++){\n            int u = qinfo[i][0], v = qinfo[i][1], lc = qinfo[i][2];\n            v_end[i][0] = v;\n            if(v == lc) v_end[i][0] = 0;\n            for(int j=1;j<MAXL;j++){\n                if(v_end[i][j-1] != 0 && (get_length(u, v_end[i][j-1], lc) & ((1 << j) - 1))){\n                    v_end[i][j] = up[v_end[i][j-1]][j-1];\n                    if(depth[v_end[i][j]] < depth[lc]) v_end[i][j] = 0;\n                }\n                else v_end[i][j] = v_end[i][j-1];\n            }\n            v_split[i][MAXL] = v;\n            u_split[i][MAXL] = u;\n            for(int j=MAXL-1;j>=0;j--){\n                if(depth[u_split[i][j+1]] - (1<<j) >= depth[lc]) u_split[i][j] = up[u_split[i][j+1]][j];\n                else u_split[i][j] = u_split[i][j+1];\n\n                if(v_end[i][j] && v_end[i][j+1] == 0) v_split[i][j] = v_end[i][j];\n                else if(depth[v_split[i][j+1]] - (1<<j) >= depth[lc]) v_split[i][j] = up[v_split[i][j+1]][j];\n                else v_split[i][j] = v_split[i][j+1];\n            }\n        }\n        \n        for(int j=0;j<MAXL;j++) {\n            calc_dp_pf(1,0,j);\n            for(int i=0;i<q;i++) {\n                long long temp = 0;\n                \n                int u = qinfo[i][0], v = qinfo[i][1], lc = qinfo[i][2];\n                int us = u_split[i][j], vs = v_split[i][j], vend = v_end[i][j];\n                int center = get_sum(us, vs, lc, j);\n\n                if(((depth[u] - depth[us]) >> j) & 1){\n                    center = get_length(us, vs, lc) - center;\n                    temp += dp[u] - depth[us] + dp[us];\n                }else temp += dp[u] - dp[us];\n                temp += center;\n\n                if(vend){\n                    if((get_length(u,vend,lc) >> j) & 1){\n                        temp += depth[v] - depth[vend] - pf[v] + pf[vend];\n                        if(((depth[vend] - depth[vs]) >> j) & 1) temp += dp[vend] - depth[vs] + dp[vs];\n                        else temp += dp[vend] - dp[vs];\n                    }else{\n                        temp += pf[v] - pf[vend];\n                        if(((depth[vend] - depth[vs]) >> j) & 1) temp += depth[vend] - dp[vend] - dp[vs];\n                        else temp += depth[vend] - dp[vend] - depth[vs] + dp[vs];\n                    }\n                    \n                }\n                ans[i] += temp << j;\n\n            }\n        }\n        for(int i=0;i<q;i++) {\n            cout<<ans[i]<<\"\\n\";\n        }\n        for(int i=1;i<=n;i++) {\n            g[i].clear();\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1983f",
      "PROBLEM_ID": "1983F",
      "PROBLEM_STATEMENT": "You have an array of non-negative integers $a_1, a_2, \\ldots, a_n$.\n\nThe value of a sub-array of length $\\ge 2$, $a[l, r] = [a_l, a_{l+1}, \\ldots, a_r]$ is the minimum value of $a_i \\oplus a_j$ such that $l \\le i < j \\le r$, where $\\oplus$ is the xor (exclusive-or) operator.\n\nYou have to find the $k$-th smallest value over all sub-arrays of length $\\ge 2$.\n\n### Input\n\nThe first line of the input contains multiple test cases $t$ ($1 \\le t \\le 2 \\cdot 10^4$).\n\nThe first line of each test case contains integer numbers $n$ and $k$ ($2 \\le n \\le 10^5$, $1 \\le k \\le \\frac{n\\cdot(n-1)}{2}$).\n\nThe second line of the input contains $n$ non-negative integer numbers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the array itself.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nPrint the $k$-th smallest value obtained over all subarrays of length at least $2$.\n\n### Example\n\n#### Input #1\n\n```\n\n4\n\n5 2\n\n1 2 3 4 5\n\n2 1\n\n4 3\n\n4 6\n\n1 2 4 8\n\n5 9\n\n1 2 3 4 5\n\n```\n\n#### Output #1\n\n```\n1\n7\n12\n3\n```\n\n### Note\n\nIn the first testcase, we have subarrays with their smallest exclusive-or pair as:\n\n$[1,2]: 3$\n\n$[2,3]: 1$\n\n$[3,4]: 7$\n\n$[4,5]: 1$\n\n$[1,2,3]: 1$\n\n$[2,3,4]: 1$\n\n$[3,4,5]: 1$\n\n$[1,2,3,4]: 1$\n\n$[2,3,4,5]: 1$\n\n$[1,2,3,4,5]: 1$\n\nThe sorted order would be: $1, 1, 1, 1, 1, 1, 1, 1, 3, 7$. Therefore, the second smallest element would be $1$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <bits/stdc++.h>\n\n#define endl \"\\n\"\nusing namespace std;\n\nint ch[3000042][2]{}, mx[3000042]{};\nint nc = 1;\nvoid insert(int root,int val,int idx){\n    int curr=root;\n    for(int i=29;i>=0;i--){\n        int lr = ((val&(1<<i)) != 0);\n        \n        if(!ch[curr][lr]){\n            nc++;\n            mx[nc]=idx;\n            ch[curr][lr]=nc;\n        }\n\n        mx[curr]=max(mx[curr],idx);\n        curr=ch[curr][lr];\n    }\n\n    mx[curr]=max(mx[curr],idx);\n}\n \nint query(int root,int mid,int val){\n    int curr=root;\n    int idx=-1;\n\n    for(int i=29;i>=0;i--){\n        if(!curr)return idx;\n \n        //check out with 1\n        if((val&(1<<i)) && (mid&(1<<i))){\n            if(ch[curr][1])idx=max(idx,mx[ch[curr][1]]);\n            curr=ch[curr][0];\n        }\n        else if((val&(1<<i))){\n            curr=ch[curr][1];\n        }\n        else if((mid&(1<<i))){\n            if(ch[curr][0])idx=max(idx,mx[ch[curr][0]]);\n            curr=ch[curr][1];\n        }\n        else{\n            curr=ch[curr][0];\n        }\n    }\n \n    if(curr)idx=max(idx,mx[curr]);\n\n    return idx;\n}\n \n\nint v[100069]{};\nint32_t main(){ \n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        long long k;\n        cin >> n >> k;\n        for(int i=0;i<n;i++){\n            cin >> v[i];\n        }\n \n        int l=0,r=(1<<30)-1,fin;\n        while(l<=r){\n            int mid=l+(r-l)/2;\n \n            int left=-1;\n            long long ans=0;\n            nc = 1;\n            int root = nc;\n            for(int i=0;i<n;i++){\n                left=max(left,query(root,mid,v[i]));\n                ans+=((long long)left+1);\n                insert(root,v[i],i);\n            }\n\n            for(int i=0;i<=nc;i++){\n                ch[i][0] = 0;\n                ch[i][1] = 0;\n                mx[i] = 0;\n            }\n\n            if(ans<k){\n                l=mid+1;\n            }\n            else{\n                fin=mid;\n                r=mid-1;\n            }\n        }\n \n        cout << fin << endl;\n    }\n \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1983e",
      "PROBLEM_ID": "1983E",
      "PROBLEM_STATEMENT": "Alice and Bob are playing a game. There are $n$ balls, out of which $k$ are special. Each ball has a value associated with it.\n\nThe players play turn by turn. In each turn, the player randomly picks a ball and adds the value of the ball to their score, which is $0$ at the beginning of the game. The selected ball is removed from the game. If the ball was special, the same player takes the next turn if at least one ball is remaining. If the ball picked was not special, the next player plays their turn.\n\nThey play this game until no balls are remaining in the game. Alice plays first.\n\nFind the expected score that both the players have at the end of the game modulo $10^9+7$.\n\nFormally, let $M = 10^9+7$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\n### Input\n\nThere are multiple test cases. The first line of the input contains an integer $t$, the number of test cases ($1 \\le t \\le 2 \\cdot 10^5$).\n\nEach test case description is on a new line. The first line of the test case contains two integers $n$ and $k$ in the respective order separated by a space ($1 \\le k \\le n \\le 4 \\cdot 10^5$).\n\nThe second line of the test case contains $n$ integers: $v_1, v_2, \\ldots, v_n$, the value for each ball separated by spaces. The first $k$ balls are special ($1 \\le v_i \\le 10^7$).\n\nThe sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\n### Output\n\nOutput two integers per test case in a new line, the expected score of Alice and the expected score of Bob modulo $10^9+7$.\n\n### Examples\n\n#### Input #1\n\n```\n\n1\n\n5 2\n\n10 20 5 15 25\n\n```\n\n#### Output #1\n\n```\n45 30\n```\n\n#### Input #2\n\n```\n\n5\n\n1 1\n\n732507\n\n2 2\n\n5817860 5398510\n\n5 1\n\n2122894 4951549 2750585 7821535 3214167\n\n8 4\n\n1405323 5069867 6883092 6972029 328406 2478975 7628890 9973340\n\n4 2\n\n9662050 3566134 3996473 9872255\n\n```\n\n#### Output #2\n\n```\n732507 0\n11216370 0\n810642660 210218077\n722402997 318336932\n349086489 678010430\n```\n\n#### Input #3\n\n```\n\n5\n\n3 3\n\n1095611 8219204 7773462\n\n2 1\n\n8176490 2774103\n\n3 1\n\n9178636 5138057 3367761\n\n12 9\n\n7597698 6843019 2298534 1522386 4969588 1340345 3967362 9152890 6689668 9986080 4745473 7407325\n\n10 5\n\n6986368 2397882 5804127 6980694 3740836 3215836 5195724 3179261 4136769 4544231\n\n```\n\n#### Output #3\n\n```\n17088277 0\n6862348 4088245\n677038671 340645790\n36949997 29570371\n725118051 321063684\n```\n\n### Note\n\nIn the first test case, Alice's expected score is $45$, and Bob's is $30$ at the end of the game.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "medium",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\n#define int long long\n\nconst int mod = 1e9 + 7;\n\nint power(int a, int b) {\n    int ans = 1;\n    while (b) {\n        if (b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nint inline inv(int x) { return power(x, mod - 2); }\n\nvoid solve() {\n    int N, K;\n    std::cin >> N >> K;\n\n    std::vector<int> values(N);\n    int avg_special_value = 0, avg_normal_value = 0;\n    for (int i = 0; i < N; i++) {\n        std::cin >> values[i];\n        if (i < K)\n            avg_special_value += values[i];\n        else\n            avg_normal_value += values[i];\n    }\n\n    int total_score = (avg_normal_value + avg_special_value) % mod;\n\n    avg_normal_value %= mod;\n    avg_special_value %= mod;\n\n    avg_special_value = (avg_special_value * inv(K)) % mod;\n    avg_normal_value = (avg_normal_value * inv(N - K)) % mod;\n\n    int count_normal_balls = (N - K + 1) / 2;\n    int expected_special_balls =\n        (((((N - K + 2) / 2) * K) % mod) * inv(N - K + 1)) % mod;\n\n    int expected_alice_score = (count_normal_balls * avg_normal_value +\n                                expected_special_balls * avg_special_value) %\n                               mod;\n\n    int expected_bob_score =\n        ((total_score - expected_alice_score) % mod + mod) % mod;\n\n    std::cout << expected_alice_score << \" \" << expected_bob_score << \"\\n\";\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1983d",
      "PROBLEM_ID": "1983D",
      "PROBLEM_STATEMENT": "Given two arrays of distinct positive integers $a$ and $b$ of length $n$, we would like to make both the arrays the same. Two arrays $x$ and $y$ of length $k$ are said to be the same when for all $1 \\le i \\le k$, $x_i = y_i$.\n\nNow in one move, you can choose some index $l$ and $r$ in $a$ ($l \\le r$) and swap $a_l$ and $a_r$, then choose some $p$ and $q$ ($p \\le q$) in $b$ such that $r-l=q-p$ and swap $b_p$ and $b_q$.\n\nIs it possible to make both arrays the same?\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2 \\cdot 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$)\u00a0\u2014 the length of the arrays $a$ and $b$.\n\nThe second line of each test case contains $n$ distinct integers $a_1,a_2,a_3,\\ldots,a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$)\u00a0\u2014 the integers in the array $a$.\n\nThe third line of each test case contains $n$ distinct integers $b_1,b_2,b_3,\\ldots,b_n$ ($1 \\le b_i \\le 2 \\cdot 10^5$)\u00a0\u2014 the integers in the array $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n### Output\n\nFor each testcase, print \"YES\" if the arrays $a$ and $b$ can be made the same. Otherwise, print \"NO\". can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n6\n\n4\n\n1 2 3 4\n\n1 2 3 4\n\n5\n\n1 3 4 2 5\n\n7 1 2 5 4\n\n4\n\n1 2 3 4\n\n4 3 2 1\n\n3\n\n1 2 3\n\n1 3 2\n\n5\n\n1 5 7 1000 4\n\n4 1 7 5 1000\n\n3\n\n1 4 2\n\n1 3 2\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nYES\nNO\nNO\nNO\n```\n\n### Note\n\nIn the first testcase, you don't need to perform any operations since the arrays are same.\n\nIn the second testcase, it can be proven there exists no way to make the arrays same.\n\nIn the third testcase, one of the ways to make the arrays same is to first choose $l=1$, $r=3$, $p=1$, $q=3$ then choose $l=1$, $r=2$, $p=3$, $q=4$.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <map>\n#include <vector> // Included again for clarity, not strictly necessary\n\n/**\n * @brief Calculates the parity of a permutation represented by array P.\n * \n * The permutation P is defined such that P[i] is the 0-based index (rank) in the sorted unique element list\n * corresponding to the element originally at index i in the input array.\n * This function computes the number of cycles in the permutation P using cycle decomposition.\n * The parity of a permutation is determined by the number of cycles. Specifically, parity is (-1)^(N - num_cycles).\n * \n * @param P The permutation array where P[i] indicates the target position based on sorted value rank.\n * @param N The size of the permutation (length of the array).\n * @return int Returns 0 if the permutation is even, 1 if it's odd.\n */\nint calculate_parity(const std::vector<int>& P, int N) {\n    // Base case: An empty permutation (N=0) is considered even. Although N >= 1 per problem statement.\n    if (N == 0) return 0; \n\n    // Keep track of visited elements during cycle traversal\n    std::vector<bool> visited(N, false);\n    int num_cycles = 0; // Counter for the number of cycles found\n\n    // Iterate through each index to start cycle detection if not already visited\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            num_cycles++; // Found a new cycle\n            int current = i;\n            // Traverse the cycle starting from index i until we return to an already visited node\n            while (!visited[current]) {\n                visited[current] = true; // Mark the current node as visited\n                current = P[current]; // Move to the next element in the cycle based on permutation P\n            }\n        }\n    }\n    \n    // The parity of a permutation is (-1)^(N - num_cycles).\n    // If N - num_cycles is even, the permutation is even (parity +1). We return 0.\n    // If N - num_cycles is odd, the permutation is odd (parity -1). We return 1.\n    return (N - num_cycles) % 2;\n}\n\nint main() {\n    // Optimize standard I/O operations for faster execution\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t; // Number of test cases\n    std::cin >> t;\n    while (t--) {\n        int n; // Length of the arrays a and b\n        std::cin >> n;\n        \n        // Declare vectors to store arrays a and b, and copies for sorting/processing\n        std::vector<int> a(n), b(n);\n        std::vector<int> a_copy(n), b_copy(n); \n        \n        // Read elements of array a and create a copy\n        for (int i = 0; i < n; ++i) {\n            std::cin >> a[i];\n            a_copy[i] = a[i];\n        }\n        // Read elements of array b and create a copy\n        for (int i = 0; i < n; ++i) {\n            std::cin >> b[i];\n            b_copy[i] = b[i];\n        }\n\n        // Sort the copies of arrays a and b to check if they contain the same set of elements\n        std::sort(a_copy.begin(), a_copy.end());\n        std::sort(b_copy.begin(), b_copy.end());\n\n        // Check if the sorted arrays are identical. If not, the sets of elements differ.\n        bool sets_equal = true;\n        for (int i = 0; i < n; ++i) {\n            if (a_copy[i] != b_copy[i]) {\n                sets_equal = false;\n                break;\n            }\n        }\n\n        // If the sets of elements are different, it's impossible to make the arrays identical.\n        if (!sets_equal) {\n            std::cout << \"NO\\n\";\n            continue; // Skip to the next test case\n        }\n\n        // If the sets are equal, we proceed to check the permutation parities.\n        // First step is to map each unique value to its rank (0-based index) in the sorted list.\n        std::map<int, int> val_to_idx;\n        for (int i = 0; i < n; ++i) {\n           // Use a_copy (which is sorted and identical to sorted b_copy) to build the map\n           val_to_idx[a_copy[i]] = i; \n        }\n\n        // Construct the permutation array Pa corresponding to array a.\n        // Pa[i] = rank of element a[i]. This defines the permutation structure for array a.\n        std::vector<int> Pa(n);\n        for (int i = 0; i < n; ++i) {\n            Pa[i] = val_to_idx[a[i]];\n        }\n        \n        // Construct the permutation array Pb corresponding to array b, similarly.\n        std::vector<int> Pb(n);\n        for (int i = 0; i < n; ++i) {\n            Pb[i] = val_to_idx[b[i]];\n        }\n\n        // Calculate the parity of each permutation using the cycle decomposition method.\n        int parity_a = calculate_parity(Pa, n);\n        int parity_b = calculate_parity(Pb, n);\n\n        // The problem constraints allow making the arrays identical if and only if\n        // both arrays contain the same set of elements and their corresponding permutations have the same parity.\n        if (parity_a == parity_b) {\n            std::cout << \"YES\\n\"; // Parities match, possible\n        } else {\n            std::cout << \"NO\\n\"; // Parities differ, impossible\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1983c",
      "PROBLEM_ID": "1983C",
      "PROBLEM_STATEMENT": "Alice, Bob and Charlie want to share a rectangular cake cut into $n$ pieces. Each person considers every piece to be worth a different value. The $i$-th piece is considered to be of value $a_i$ by Alice, $b_i$ by Bob and $c_i$ by Charlie.\n\nThe sum over all $a_i$, all $b_i$ and all $c_i$ individually is the same, equal to $tot$.\n\nGiven the values of each piece of the cake for each person, you need to give each person a contiguous slice of cake. In other words, the indices at the left and right ends of these subarrays (the slices given to each person) can be represented as $(l_a, r_a)$, $(l_b, r_b)$ and $(l_c, r_c)$ respectively for Alice, Bob and Charlie. The division needs to satisfy the following constraints:\n\n- No piece is assigned to more than one person, i.e., no two subarrays among $[l_a,\\ldots,r_a]$, $[l_b, \\ldots, r_b]$ and $[l_c, \\ldots, r_c]$ intersect.\n- $ \\sum_{i = l_a}^{r_a} a_i, \\sum_{i = l_b}^{r_b} b_i, \\sum_{i = l_c}^{r_c} c_i \\geq \\lceil \\frac{tot}{3} \\rceil$.\n\nHere, the notation $\\lceil \\frac{a}{b} \\rceil$ represents ceiling division. It is defined as the smallest integer greater than or equal to the exact division of $a$ by $b$. In other words, it rounds up the division result to the nearest integer. For instance $\\lceil \\frac{10}{3} \\rceil = 4$ and $\\lceil \\frac{15}{3} \\rceil = 5$.\n\n### Input\n\nThe first line contains an integer $t$, the number of testcases, ($1 \\le t \\le 10^4$)\n\nFor each testcase:\n\nThe first line contains the integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$).\n\nThe following three lines contain $n$ integers each:\n\nOne line with $n$ integers $a_1, a_2, \\ldots, a_n$ represents the values for Alice ($1 \\le a_i \\le 10^6$).\n\nThe next line with $n$ integers $b_1, b_2, \\ldots, b_n$ represents the values for Bob ($1 \\le b_i \\le 10^6$).\n\nThe next line with $n$ integers $c_1, c_2, \\ldots, c_n$ represents the values for Charlie ($1 \\le c_i \\le 10^6$).\n\nIt is guaranteed that $ \\sum_{i = 1}^{n} a_i = \\sum_{i = 1}^{n} b_i = \\sum_{i = 1}^{n} c_i$.\n\nThe sum of $n$ over all testcases does not exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each testcase, output $-1$ if the required condition is impossible.\n\nOtherwise, output six numbers \u2013 $l_a, r_a, l_b, r_b, l_c, r_c$, the respective starting and ending indices ($1$-indexed) of the subarrays for Alice, Bob and Charlie, respectively.\n\n### Example\n\n#### Input #1\n\n```\n\n10\n\n5\n\n5 1 1 1 1\n\n1 1 5 1 1\n\n1 1 1 1 5\n\n6\n\n1 2 3 4 5 6\n\n5 6 1 2 3 4\n\n3 4 5 6 1 2\n\n4\n\n4 4 4 4\n\n4 4 4 4\n\n4 4 4 4\n\n5\n\n5 10 5 2 10\n\n9 6 9 7 1\n\n10 7 10 2 3\n\n3\n\n4 5 2\n\n6 1 4\n\n1 8 2\n\n3\n\n10 4 10\n\n8 7 9\n\n10 4 10\n\n7\n\n57113 65383 19795 53580 74452 3879 23255\n\n12917 16782 89147 93107 27365 15044 43095\n\n33518 63581 33565 34112 46774 44151 41756\n\n6\n\n6 3 1 8 7 1\n\n10 2 6 2 2 4\n\n10 9 2 1 2 2\n\n5\n\n5 5 4 5 5\n\n1 6 3 8 6\n\n2 4 1 9 8\n\n10\n\n1 1 1 1 1001 1 1 1001 1 1\n\n1 1 1 1 1 1 2001 1 1 1\n\n1 1 1 1 1 1001 1 1 1 1001\n\n```\n\n#### Output #1\n\n```\n1 1 2 3 4 5\n5 6 1 2 3 4\n-1\n-1\n1 1 3 3 2 2\n-1\n1 2 3 4 5 7\n3 6 1 1 2 2\n1 2 3 4 5 5\n1 5 6 7 8 10\n```\n\n### Note\n\nIn the first testcase, the sum of either of the three arrays is $9$. Each person needs a cake slice corresponding to a subarray with a total value of at least $\\lceil \\frac{9}{3} \\rceil = 3$.\n\nIf we assign the subarray ($1$,$1$) to Alice, its total value to her is $5$, which is $\\ge 3$; the subarray ($2$,$3$) to Bob, its total value to him is $1 + 5 = 6$, which is $\\ge 3$; and the subarray ($4$,$5$) to Charlie, its total value to him $1 + 5 = 6$, which is also $\\ge 3$. Each person gets their own separate pieces of the cake, and no piece is common to two or more people.\n\nIt can be shown that for the third test case, it is not possible to give slices of the cake in a way that satisfies the given constraints.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <numeric> // Required for accumulate\n#include <array>   // Required for array\n#include <algorithm> // Required for next_permutation and max\n\nusing namespace std;\n\n// Define long long for potentially large sums\ntypedef long long ll;\n\n// Function to compute the minimum end point `r` for each starting point `l` such that the sum of values in p[l..r] >= K.\n// Indices are 1-based. `p` is 0-indexed internally.\n// Returns a vector `end_P` where `end_P[l]` stores the minimum `r`.\n// If no such `r` exists (i.e., cannot reach sum K even using all elements up to n), stores `n + 1`.\nvector<int> compute_end_points(int n, const vector<ll>& p, ll K) {\n    // `end_P` stores results for indices 1 to n. `end_P[0]` is unused.\n    vector<int> end_P(n + 1); \n    ll current_sum = 0;\n    // `r` is a 0-based index pointing *after* the last element included in the current window sum.\n    // The window being considered is effectively [l-1, r-1] in 0-based indices.\n    int r = 0; \n    \n    // Iterate through all possible 1-based start indices `l` from 1 to n.\n    for (int l = 1; l <= n; ++l) { \n        // When moving from start `l-1` to `l`, the element `p[l-2]` (0-based index) is removed from the left side of the window.\n        // Adjust the `current_sum` accordingly. This only happens for l > 1.\n        if (l > 1) {\n            current_sum -= p[l - 2];\n        }\n        \n        // Ensure `r` is at least `l-1`. This handles cases where the window becomes empty or invalid\n        // after removing `p[l-2]`, ensuring `r` doesn't lag behind `l`.\n        // If `r < l-1`, it means the previous window ended before the current `l` starts. Reset `r` to `l-1`.\n        r = max(r, l - 1); \n\n        // Expand the window to the right by adding elements `p[r]` (0-based index)\n        // until the `current_sum` reaches `K` or we run out of elements (`r` reaches `n`).\n        while (r < n && current_sum < K) {\n             current_sum += p[r]; // Add element at index `r`\n             r++; // Advance `r` to point after the newly added element.\n        }\n\n        // After the loop, the window considered is [l-1, r-1] (0-based). Check if the sum condition is met.\n        if (current_sum >= K) {\n            // If sum >= K, the minimum valid end point for start `l` is `r`. Store it (1-based).\n            end_P[l] = r; \n        } else {\n            // If `r` reached `n` and `current_sum` is still less than `K`, it's impossible to reach K starting from `l`.\n            // Use `n + 1` as a sentinel value to indicate impossibility.\n            end_P[l] = n + 1; \n        }\n    }\n    return end_P;\n}\n\n// Function to compute the next valid starting index `l` for each possible starting requirement `k`.\n// Returns a vector `next_valid_start` where `next_valid_start[k]` is the minimum `l >= k` such that `end_P[l]` is valid (i.e., `end_P[l] <= n`).\n// Uses 1-based indexing for `k` and return value `l`. Uses `n + 1` as sentinel for impossibility.\nvector<int> compute_next_valid_start(int n, const vector<int>& end_P) {\n    // The vector needs size n+2 because we access index n+1. Index 0 is unused.\n    vector<int> next_valid_start(n + 2); \n    // Base case for the backward iteration: If we need to start at or after n+1, it's impossible.\n    next_valid_start[n + 1] = n + 1; \n    \n    // Iterate backwards from `k = n` down to 1.\n    for (int k = n; k >= 1; --k) {\n        // Check if starting at index `k` results in a valid interval (ends at or before `n`).\n        if (end_P[k] <= n) { \n            // If yes, then `k` itself is the minimum valid start index >= `k`.\n            next_valid_start[k] = k; \n        } else { \n            // If starting at `k` is not valid, then the minimum valid start index >= `k`\n            // must be the same as the minimum valid start index >= `k+1`.\n            // This propagates the `n+1` sentinel backwards if no valid start is found.\n            next_valid_start[k] = next_valid_start[k + 1];\n        }\n    }\n    return next_valid_start;\n}\n\nint main() {\n    // Optimize standard I/O operations for speed.\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        int n; // Number of cake pieces\n        cin >> n;\n        // Vectors to store values for Alice, Bob, Charlie\n        vector<ll> a(n), b(n), c(n);\n        ll tot = 0; // Total value of the cake (same for all three)\n        \n        // Read Alice's values and compute total sum.\n        for (int i = 0; i < n; ++i) { cin >> a[i]; tot += a[i]; } \n        // Read Bob's values.\n        for (int i = 0; i < n; ++i) cin >> b[i];\n        // Read Charlie's values.\n        for (int i = 0; i < n; ++i) cin >> c[i];\n\n        // Calculate the required minimum value K using ceiling division.\n        ll K = (tot + 2) / 3; // Equivalent to ceil(tot / 3.0) for positive tot.\n\n        // Group the value arrays into a vector of vectors for easier iteration.\n        vector<vector<ll>> p = {a, b, c};\n        // Precompute `end_P[person_idx][l]` values.\n        vector<vector<int>> end_P(3); \n        // Precompute `next_valid_start_P[person_idx][k]` values.\n        vector<vector<int>> next_valid_start_P(3); \n\n        // Perform precomputations for each person (0: Alice, 1: Bob, 2: Charlie).\n        for (int i = 0; i < 3; ++i) {\n            end_P[i] = compute_end_points(n, p[i], K);\n            next_valid_start_P[i] = compute_next_valid_start(n, end_P[i]);\n        }\n\n        // Store the final answer intervals {la, ra, lb, rb, lc, rc}. Initialize with -1.\n        array<int, 6> final_ans = {-1, -1, -1, -1, -1, -1}; \n        bool found = false; // Flag to indicate if a solution is found.\n\n        // Define the order of persons using indices (0: Alice, 1: Bob, 2: Charlie).\n        vector<int> P_indices = {0, 1, 2}; \n\n        // Iterate through all 6 permutations of (0, 1, 2).\n        do {\n            int p1_idx = P_indices[0]; // Index of the first person in the current permutation.\n            int p2_idx = P_indices[1]; // Index of the second person.\n            int p3_idx = P_indices[2]; // Index of the third person.\n\n            // Try all possible start positions `l1` for the first person `P1`.\n            for (int l1 = 1; l1 <= n; ++l1) {\n                // Find the minimum end point `r1` for `P1` starting at `l1`.\n                int r1 = end_P[p1_idx][l1];\n                // If the interval for `P1` is invalid (ends after n), continue to next `l1`.\n                if (r1 > n) continue; \n\n                // Determine the required start index `l2_start_k` for the second person `P2`.\n                int l2_start_k = r1 + 1;\n                // If `P1` ends at `n`, `P2` cannot start. Check if `l2_start_k` is valid.\n                if (l2_start_k > n) continue; \n\n                // Find the minimum valid start index `l2` for `P2`, starting from `l2_start_k`.\n                int l2 = next_valid_start_P[p2_idx][l2_start_k];\n                // If no valid start `l2` is found within bounds, continue to next `l1`.\n                if (l2 > n) continue; \n                \n                // Find the end point `r2` for `P2` starting at `l2`.\n                int r2 = end_P[p2_idx][l2];\n                // This check `if (r2 > n)` is technically redundant because `next_valid_start_P` ensures `l2` leads to a valid `r2 <= n`.\n                // However, it doesn't hurt to keep it for clarity or safety.\n\n                // Determine the required start index `l3_start_k` for the third person `P3`.\n                int l3_start_k = r2 + 1;\n                // If `P2` ends at `n`, `P3` cannot start. Check if `l3_start_k` is valid.\n                 if (l3_start_k > n) continue;\n\n                // Find the minimum valid start index `l3` for `P3`, starting from `l3_start_k`.\n                int l3 = next_valid_start_P[p3_idx][l3_start_k];\n                // If no valid start `l3` is found within bounds, continue to next `l1`.\n                if (l3 > n) continue;\n\n                // Find the end point `r3` for `P3` starting at `l3`.\n                int r3 = end_P[p3_idx][l3];\n                // Check if the interval for `P3` ends within bounds. This check IS necessary.\n                if (r3 > n) continue; \n                \n                // If we reach here, we found a valid assignment of disjoint intervals for (P1, P2, P3).\n                // Store the intervals {l, r} in `final_ans` based on the original person indices (0:A, 1:B, 2:C).\n                final_ans[p1_idx * 2] = l1;\n                final_ans[p1_idx * 2 + 1] = r1;\n                final_ans[p2_idx * 2] = l2;\n                final_ans[p2_idx * 2 + 1] = r2;\n                final_ans[p3_idx * 2] = l3;\n                final_ans[p3_idx * 2 + 1] = r3;\n                \n                found = true; // Set the found flag.\n                goto end_loops; // Use goto to break out of nested loops and permutation iteration efficiently.\n            }\n\n        // Continue generating permutations only if a solution hasn't been found yet.\n        } while (!found && next_permutation(P_indices.begin(), P_indices.end()));\n\n    end_loops: // Label for the goto statement.\n\n        if (found) {\n            // If a solution was found, print the intervals for Alice, Bob, Charlie.\n            cout << final_ans[0] << \" \" << final_ans[1] << \" \" << final_ans[2] << \" \" << final_ans[3] << \" \" << final_ans[4] << \" \" << final_ans[5] << \"\\n\";\n        } else {\n            // If no solution was found after checking all permutations and start positions.\n            cout << -1 << \"\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1983b",
      "PROBLEM_ID": "1983B",
      "PROBLEM_STATEMENT": "You are given two grids of numbers $a$ and $b$, with $n$ rows and $m$ columns. All the values in the grid are $0$, $1$ or $2$.\n\nYou can perform the following operation on $a$ any number of times:\n\n- Pick any subrectangle in the grid with length and width $\\ge 2$. You are allowed to choose the entire grid as a subrectangle.\n- The subrectangle has four corners. Take any pair of diagonally opposite corners of the chosen subrectangle and add $1$ to their values modulo $3$.\n- For the pair of corners not picked, add $2$ to their values modulo $3$.\n\nNote that the operation only changes the values of the corners of the picked subrectangle.\n\nIs it possible to convert the grid $a$ into grid $b$ by applying the above operation any number of times (possibly zero)?\n\n### Input\n\nThe first line contains an integer $t$, the number of testcases ($1 \\le t \\le 250$).\n\nFor each testcase:\n\nThe first line contains two integers $n$ and $m$, the number of rows and columns in the grid ($2 \\le n,m \\le 500$).\n\nEach of the next n lines contain m characters \u2014 the $j$-th character of the $i$-th line represents $a_{i,j}$.\n\nEach of the next n lines contain m characters \u2014 the $j$-th character of the $i$-th line represents $b_{i,j}$ ($0 \\le a_{i,j}, b_{i,j} \\le 2$).\n\nIt is guaranteed that the sum of $n$ over all test cases and the sum of $m$ over all test cases do not exceed $500$.\n\n### Output\n\nFor each test case print \"YES\" (without quotes) if it is possible to convert grid $a$ into grid $b$ and \"NO\" (without quotes) otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n### Example\n\n#### Input #1\n\n```\n\n7\n\n3 3\n\n000\n\n000\n\n000\n\n111\n\n111\n\n111\n\n4 4\n\n0000\n\n0000\n\n0000\n\n0000\n\n2100\n\n1200\n\n0012\n\n0021\n\n4 4\n\n1020\n\n1200\n\n1210\n\n0000\n\n0000\n\n1200\n\n2200\n\n0000\n\n3 3\n\n012\n\n012\n\n012\n\n010\n\n111\n\n011\n\n8 8\n\n00000000\n\n00000000\n\n00000000\n\n00000000\n\n00000000\n\n00000000\n\n00000000\n\n10000000\n\n00000000\n\n01200000\n\n02010000\n\n00102000\n\n00020100\n\n00001020\n\n00000210\n\n10000000\n\n2 7\n\n0000000\n\n0000000\n\n2220111\n\n0111222\n\n2 7\n\n0000000\n\n0100010\n\n2220111\n\n1210202\n\n```\n\n#### Output #1\n\n```\nYES\nYES\nYES\nNO\nYES\nNO\nYES\n```\n\n### Note\n\nIn the first testcase, grid $a$ can be converted into $b$ in the following manner:\n\n$\\begin{matrix}\\fbox{0} & 0 & \\fbox{0}\\\\ 0 & 0 & 0\\\\ \\fbox{0} & 0 & \\fbox{0}\\end{matrix} \\Rightarrow \\begin{matrix}1 & 0 & 2\\\\ 0 & \\fbox{0} & \\fbox{0}\\\\ 2 & \\fbox{0} & \\fbox{1}\\end{matrix} \\Rightarrow \\begin{matrix}1 & 0 & 2\\\\ \\fbox{0} & \\fbox{1} & 2\\\\ \\fbox{2} & \\fbox{2} & 2\\end{matrix} \\Rightarrow \\begin{matrix}1 & \\fbox{0} & \\fbox{2}\\\\ 1 & 0 & 2\\\\ 1 & \\fbox{0} & \\fbox{2}\\end{matrix} \\Rightarrow \\begin{matrix}1 & 1 & 1\\\\ 1 & \\fbox{0} & \\fbox{2}\\\\ 1 & \\fbox{2} & \\fbox{0}\\end{matrix} \\Rightarrow \\begin{matrix}1 & 1 & 1\\\\ 1 & 1 & 1\\\\ 1 & 1 & 1\\end{matrix}$\n\nHere, in each operation, the top-right and bottom-left corners highlighted by a box are incremented by $2$ modulo $3$, while the top-left and bottom-right corners are incremented by $1$ modulo $3$.\n\nIn the fourth testcase, it can be proven that it is not possible to convert grid $a$ into grid $b$ using the above-mentioned operations any number of times.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n#include <string>\n// #include <numeric> // Not strictly necessary for this implementation\n\nusing namespace std;\n\n/**\n * @brief Computes x modulo 3, ensuring the result is non-negative (in {0, 1, 2}).\n * \n * Standard C++ % operator behavior with negative numbers can be tricky or implementation-defined.\n * This function guarantees a result in the range [0, 2], consistent with mathematical modulo.\n * The expression (x % 3 + 3) % 3 works robustly for both positive and negative integers x.\n * \n * @param x The integer to compute modulo 3.\n * @return int The value of x modulo 3, guaranteed to be in {0, 1, 2}.\n */\nint mod3(int x) {\n    // Example: if x = -1, x % 3 might be -1. (-1 + 3) % 3 = 2 % 3 = 2.\n    // Example: if x = -2, x % 3 might be -2. (-2 + 3) % 3 = 1 % 3 = 1.\n    // For non-negative x, it behaves like standard x % 3.\n    return (x % 3 + 3) % 3;\n}\n\nint main() {\n    // Use fast I/O to speed up input reading, especially for large test cases.\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; // Number of test cases\n    cin >> t;\n    while (t--) {\n        int n, m; // Grid dimensions: n rows, m columns\n        cin >> n >> m;\n\n        // Declare grids a and b using vectors of vectors.\n        // Initialize with size n x m.\n        vector<vector<int>> a(n, vector<int>(m));\n        vector<vector<int>> b(n, vector<int>(m));\n        \n        // Read grid a from input\n        for (int i = 0; i < n; ++i) {\n            string row_str;\n            cin >> row_str; // Read the i-th row as a string\n            for (int j = 0; j < m; ++j) {\n                // Convert character '0', '1', '2' to integer 0, 1, 2\n                a[i][j] = row_str[j] - '0'; \n            }\n        }\n\n        // Read grid b from input\n        for (int i = 0; i < n; ++i) {\n            string row_str;\n            cin >> row_str; // Read the i-th row as a string\n            for (int j = 0; j < m; ++j) {\n                b[i][j] = row_str[j] - '0';\n            }\n        }\n\n        // Compute the difference grid d. d[i][j] = (b[i][j] - a[i][j]) mod 3.\n        // This represents the net change required at each cell modulo 3 to transform grid a into grid b.\n        vector<vector<int>> d(n, vector<int>(m));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                // Compute difference modulo 3 using the safe mod3 function\n                d[i][j] = mod3(b[i][j] - a[i][j]);\n            }\n        }\n\n        // The transformation is possible if and only if the sum of elements in each row\n        // and each column of the difference grid `d` is congruent to 0 modulo 3.\n        // This is because each operation preserves the row sums and column sums modulo 3.\n        \n        bool possible = true; // Initialize flag: assume possible until a condition fails\n\n        // Check Condition 1: Row sums must be 0 mod 3.\n        for (int i = 0; i < n; ++i) {\n            int row_sum = 0;\n            for (int j = 0; j < m; ++j) {\n                row_sum += d[i][j];\n            }\n            // Check if the row sum is divisible by 3.\n            if (mod3(row_sum) != 0) {\n                possible = false; // Condition failed for this row\n                break; // No need to check further rows or columns\n            }\n        }\n\n        // Check Condition 2: Column sums must be 0 mod 3. Only proceed if row sums were okay.\n        if (possible) { \n            for (int j = 0; j < m; ++j) {\n                int col_sum = 0;\n                for (int i = 0; i < n; ++i) {\n                    col_sum += d[i][j];\n                }\n                // Check if the column sum is divisible by 3.\n                if (mod3(col_sum) != 0) {\n                    possible = false; // Condition failed for this column\n                    break; // No need to check further columns\n                }\n            }\n        }\n\n        // Output the final answer based on whether both necessary conditions hold.\n        // Since these conditions are also sufficient, this determines possibility.\n        if (possible) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    },
    {
      "TASK_NAME": "lcbpro-1983a",
      "PROBLEM_ID": "1983A",
      "PROBLEM_STATEMENT": "An array of integers $a_1,a_2,\\cdots,a_n$ is beautiful subject to an integer $k$ if it satisfies the following:\n\n- The sum of $a_{j}$ over all $j$ such that $j$ is a multiple of $k$ and $1 \\le j \\le n $, itself, is a multiple of $k$.\n- More formally, if $\\sum_{k | j} a_{j}$ is divisible by $k$ for all $1 \\le j \\le n$ then the array $a$ is beautiful subject to $k$. Here, the notation ${k|j}$ means $k$ divides $j$, that is, $j$ is a multiple of $k$.\n\nGiven $n$, find an array of positive nonzero integers, with each element less than or equal to $10^5$ that is beautiful subject to all $1 \\le k \\le n$.\n\nIt can be shown that an answer always exists.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first and only line of each test case contains a single integer $n$ ($1 \\le n \\le 100$)\u00a0\u2014 the size of the array.\n\n### Output\n\nFor each test case, print the required array as described in the problem statement.\n\n### Example\n\n#### Input #1\n\n```\n3\n3\n6\n7\n```\n\n#### Output #1\n\n```\n4 22 18\n10 6 15 32 125 54\n23 18 27 36 5 66 7```\n\n### Note\n\nIn the second test case, when $n = 6$, for all integers $k$ such that $1 \\le k \\le 6$, let $S$ be the set of all indices of the array that are divisible by $k$.\n\n- When $k = 1$, $S = \\{1, 2, 3,4,5,6\\}$ meaning $a_1+a_2+a_3+a_4+a_5+a_6=242$ must be divisible by $1$.\n- When $k = 2$, $S = \\{2,4,6\\}$ meaning $a_2+a_4+a_6=92$ must be divisible by $2$.\n- When $k = 3$, $S = \\{3,6\\}$ meaning $a_3+a_6=69$ must divisible by $3$.\n- When $k = 4$, $S = \\{4\\}$ meaning $a_4=32$ must divisible by $4$.\n- When $k = 5$, $S = \\{5\\}$ meaning $a_5=125$ must divisible by $5$.\n- When $k = 6$, $S = \\{6\\}$ meaning $a_6=54$ must divisible by $6$.\n\nThe array $a = [10, 6, 15, 32, 125, 54]$ satisfies all of the above conditions. Hence, $a$ is a valid array.",
      "BASE_URL": "http://38.80.122.117:8081",
      "LANGUAGE": "cpp",
      "CODE_PATH": "/app/main.cpp",
      "TIMEOUT_SECS": "120",
      "AUTHOR_EMAIL": "shz060@ucsd.edu",
      "DIFFICULTY": "easy",
      "AGENT_TIMEOUT": 300,
      "TEST_TIMEOUT": 180,
      "SOLUTION_CODE": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> solve(int n) {\n    vector<int> a(n, 1); // Initialize the array with 1s\n    \n    for (int k = n; k >= 1; k--) {\n        int sum = 0;\n        for (int j = k; j <= n; j += k) {\n            sum += a[j - 1]; // Adjust for 0-indexed array\n        }\n        \n        int remainder = sum % k;\n        if (remainder != 0) {\n            a[k - 1] += (k - remainder); // Adjust a_k to make sum divisible by k\n        }\n    }\n    \n    return a;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<int> result = solve(n);\n        \n        for (int i = 0; i < n; i++) {\n            cout << result[i] << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
      "SOLUTION_SCRIPT": "#!/bin/bash\\necho \\\"Oracle solution script\\\""
    }
  ]
}