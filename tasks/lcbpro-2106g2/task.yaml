author: LiveCodeBench Pro Team
author_email: shz060@ucsd.edu
difficulty: medium
instruction: "LiveCodeBench Pro (Mini) - external judge.\n\nThe agent must create\
  \ a C++17 solution file at /app/main.cpp.\nThis task does not include local test\
  \ cases. Instead, the test harness:\n  1) POSTs the code to the external judge (/submit)\
  \ to get a sid,\n  2) polls GET /result/{sid}?short=1 until status == \"done\",\n\
  \  3) passes only if the judge returns passed == true.\n\nEnvironment variables\
  \ (overridable at runtime):\n  - BASE_URL: judge base URL (default http://38.80.122.117:8081)\n\
  \  - PID: problem id (default 2106G2)\n  - LANG: language (default cpp)\n  - CODE_PATH:\
  \ path to code (default /app/main.cpp)\n  - JUDGE_TIMEOUT_SECS: poll timeout seconds\
  \ (default 120)\n\nThis is the Hard Version of the problem. The only difference\
  \ between the two versions is that in the Hard Version the tree may be of any shape.\n\
  \nThis problem is interactive.\n\nBaudelaire is very rich, so he bought a tree of\
  \ size $n$, rooted at some arbitrary node. Additionally, every node has a value\
  \ of $1$ or $-1$.\n\nCow the Nerd saw the tree and fell in love with it. However,\
  \ computer science doesn't pay him enough, so he can't afford to buy it. Baudelaire\
  \ decided to play a game with Cow the Nerd, and if he won, he would gift him the\
  \ tree.\n\nCow the Nerd does not know which node is the root, and he doesn't know\
  \ the values of the nodes either. However, he can ask Baudelaire queries of two\
  \ types:\n\n- $1$ $k$ $u_1$ $u_2$ $...$ $u_k$: Let $f(u)$ be the sum of the values\
  \ of all nodes in the path from the root of the tree to node $u$. Cow the Nerd may\
  \ choose an integer $k$ $(1 \\le k \\le n)$ and $k$ nodes $u_1, u_2, ..., u_k$,\
  \ and he will receive the value $f(u_1) + f(u_2) + ... + f(u_k)$.\n- $2$ $u$: Baudelaire\
  \ will toggle the value of node $u$. Specifically, if the value of $u$ is $1$, it\
  \ will become $-1$, and vice versa.\n\nCow the Nerd wins if he guesses the value\
  \ of every node correctly (the values of the final tree, after performing the queries)\
  \ within $n + 200$ total queries. Can you help him win?\n\n### Input\n\nThe first\
  \ line of the input contains a single integer $t$ $(1 \\le t \\le 100)$, the number\
  \ of test cases.\n\nThe first line of each test case contains a single integer $n$\
  \ $(2 \\le n \\le 10^3)$, the size of the tree.\n\nEach of the next $n-1$ lines\
  \ contains two integers $u$ and $v$ $(1 \\le u, v \\le n, u \\neq v)$, denoting\
  \ an edge between nodes $u$ and $v$ in the tree.\n\nIt is guaranteed that the sum\
  \ of $n$ over all test cases does not exceed $10^3$ and that each graph provided\
  \ is a valid tree.\n\n### Interaction\n\nTo ask a query of type $1$, output a line\
  \ in the following format (without the quotes):\n\n- \"? 1 k $u_1$ $u_2$ $...$ $u_k$\"\
  , ($1 \\le k, u_i \\le n$)\n\nThe jury will return a single integer, $f(u_1) + f(u_2)\
  \ + ... + f(u_k)$.\n\nTo ask a query of type $2$, output a line in the following\
  \ format:\n\n- \"? 2 $u$\" ($1 \\le u \\le n$)\n\nThe jury will toggle the value\
  \ of node $u$: if its value is $1$, it will become $-1$ and vice versa.\n\nWhen\
  \ you have found the answer, output a single line in the following format:\n\n-\
  \ \"! $v_1, v_2, ..., v_n$\" ($v_i = 1$ or $v_i = -1$, and $v_i$ is the value of\
  \ node $i$ after performing the queries)\n\nAfter that, proceed to process the next\
  \ test case or terminate the program if it was the last test case. Printing the\
  \ answer does not count as a query.\n\nThe interactor is not adaptive, meaning that\
  \ the values of the tree are known before the participant asks the queries.\n\n\
  If your program makes more than $n + 200$ queries, your program should immediately\
  \ terminate to receive the verdict Wrong Answer. Otherwise, you can get an arbitrary\
  \ verdict because your solution will continue to read from a closed stream.\n\n\
  After printing a query do not forget to output the end of line and flush the output.\
  \ Otherwise, you may get the Idleness Limit Exceeded verdict. To do this, use:\n\
  \n- fflush(stdout) or cout.flush() in C++\n- System.out.flush() in Java;\n- flush(output)\
  \ in Pascal;\n- stdout.flush() in Python;\n- see the documentation for other languages.\n\
  \nHacks\n\nFor hacks, use the following format.\n\nThe first line should contain\
  \ a single integer $t$ $(1 \\le t \\le 100)$ -- the number of test cases.\n\nThe\
  \ first line of each test case must contain exactly two integers $n$ and $root$\
  \ $(2 \\le n \\le 10^3, 1 \\le root \\le n)$ -- the size of the tree and the root\
  \ of the tree.\n\nThe second line of each test case must contain exactly $n$ integers\
  \ $a_1, a_2, ..., a_n$ $(|a_i| = 1)$ -- where $a_i$ is the value of node $i$.\n\n\
  Each of the following $n-1$ lines must contain exactly two integers $u$ and $v$\
  \ $(1 \\le u, v \\le n)$ -- denoting an edge of the tree between nodes $u$ and $v$.\n\
  \nThe sum of $n$ over all test cases must not exceed $10^3$ and every graph provided\
  \ must be a valid tree.\n\n### Example\n\n#### Input #1\n\n```\n3\n4\n1 4\n4 2\n\
  2 3\n\n1\n\n-1\n\n-5\n\n-5\n\n2\n1 2\n\n2\n\n7\n1 2\n2 7\n7 3\n7 4\n7 5\n7 6\n\n\
  -1\n\n```\n\n#### Output #1\n\n```\n\n? 1 3 1 2 4\n\n? 1 2 3 1\n\n? 2 4\n? 1 3 1\
  \ 2 4\n\n? 1 2 3 1\n\n! -1 -1 -1 -1\n\n? 1 1 1\n\n! 1 1\n\n? 1 1 1\n\n! -1 1 1 1\
  \ 1 1 -1```\n\n### Note\n\nIn the first example, the root of the tree is node $4$\
  \ and the values are: $[-1, -1, -1, 1]$ (the $i$-th value is the value of node $i$).\n\
  \nInitially, $f(1) = 0, f(2) = 0, f(3) = -1, f(4) = 1$. Therefore, the answer to\
  \ our first query is $f(1) + f(2) + f(4) = 1$, and of the second query is $f(3)\
  \ + f(1) = -1$.\n\nAfter toggling the value of node $4$, the values are $[-1, -1,\
  \ -1, -1]$. In addition, $f(1) = -2, f(2) = -2, f(3) = -3, f(4) = -1$. Therefore,\
  \ $f(1) + f(2) + f(4) = -5$ and $f(3) + f(1) = -5$.\n\nWe answer that the final\
  \ values of the nodes are $[-1, -1, -1, -1]$, which is correct. Notice that we report\
  \ the values of the nodes after the changes, and not before.\n\nIn the second example,\
  \ the root of the tree is $2$ and the initial values are $[1, 1]$.\n\nIn the last\
  \ example, the root of the tree is $1$ and the initial values are $[-1, 1, 1, 1,\
  \ 1, 1, -1]$.\n\nNote that this is just an explanation of how the queries work,\
  \ and it is not supposed to use any specific strategy to solve the problem."
max_agent_timeout_sec: 300
max_test_timeout_sec: 180
tags: []
