author: LiveCodeBench Pro Team
author_email: shz060@ucsd.edu
difficulty: medium
instruction: "LiveCodeBench Pro (Mini) - external judge.\n\nThe agent must create\
  \ a C++17 solution file at /app/main.cpp.\nThis task does not include local test\
  \ cases. Instead, the test harness:\n  1) POSTs the code to the external judge (/submit)\
  \ to get a sid,\n  2) polls GET /result/{sid}?short=1 until status == \"done\",\n\
  \  3) passes only if the judge returns passed == true.\n\nEnvironment variables\
  \ (overridable at runtime):\n  - BASE_URL: judge base URL (default http://38.80.122.117:8081)\n\
  \  - PID: problem id (default 1990E1)\n  - LANG: language (default cpp)\n  - CODE_PATH:\
  \ path to code (default /app/main.cpp)\n  - JUDGE_TIMEOUT_SECS: poll timeout seconds\
  \ (default 120)\n\nThis is the easy version of the problem. The only difference\
  \ is the limit on the number of queries.\n\nThis is an interactive problem.\n\n\
  You are given a tree of $n$ nodes with node $1$ as its root node.\n\nThere is a\
  \ hidden mole in one of the nodes. To find its position, you can pick an integer\
  \ $x$ ($1 \\le x \\le n$) to make an inquiry to the jury. Next, the jury will return\
  \ $1$ when the mole is in subtree $x$. Otherwise, the judge will return $0$. If\
  \ the judge returns $0$ and the mole is not in root node $1$, the mole will move\
  \ to the parent node of the node it is currently on.\n\nUse at most $300$ operations\
  \ to find the current node where the mole is located.\n\n### Input\n\nEach test\
  \ contains multiple test cases. The first line contains the number of test cases\
  \ $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\n### Interaction\n\
  \nThe first line of each test case contains one integer $n$ ($2 \\le n \\le 5000$).\n\
  \nThe following $n-1$ lines describe the edges of the tree. Each line contains two\
  \ space-separated integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$), indicating\
  \ an edge between nodes $u_i$ and $v_i$.\n\nIt is guaranteed that the input data\
  \ represents a tree.\n\nThe interactor in this task is not adaptive. In other words,\
  \ the node where the mole is located at first is fixed in every test case and does\
  \ not change during the interaction.\n\nTo ask a query, you need to pick a vertex\
  \ $x$ ($1 \\le x \\le n$) and print the line of the following form:\n\n- \"? x\"\
  \n\nAfter that, you receive:\n\n- $0$ if the mole is not in subtree $x$;\n- $1$\
  \ if the mole is in subtree $x$.\n\nYou can make at most $300$ queries of this form\
  \ for each test case.\n\nNext, if your program has found the current node where\
  \ the mole is located, print the line of the following form:\n\n- \"! x\"\n\nNote\
  \ that this line is not considered a query and is not taken into account when counting\
  \ the number of queries asked.\n\nAfter this, proceed to the next test case.\n\n\
  If you make more than $300$ queries during an interaction, your program must terminate\
  \ immediately, and you will receive the Wrong Answer verdict. Otherwise, you can\
  \ get an arbitrary verdict because your solution will continue to read from a closed\
  \ stream.\n\nAfter printing a query or the answer for a test case, do not forget\
  \ to output the end of line and flush the output. Otherwise, you will get the verdict\
  \ Idleness Limit Exceeded. To do this, use:\n\n- fflush(stdout) or cout.flush()\
  \ in C++;\n- System.out.flush() in Java;\n- flush(output) in Pascal;\n- stdout.flush()\
  \ in Python;\n- see the documentation for other languages.\n\nHacks\n\nTo hack,\
  \ follow the test format below.\n\nThe first line contains the number of test cases\
  \ $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first\
  \ line of each test case contains two integers $n$ and $x$ ($2 \\le n \\le 5000$,\
  \ $1 \\le x \\le n$)Â -- the size of the tree and the initial position of the mole.\n\
  \nThe following $n-1$ lines describe the edges of the tree. Each line contains two\
  \ space-separated integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$), indicating\
  \ an edge between nodes $u_i$ and $v_i$.\n\nThe input data must represent a tree.\n\
  \n### Example\n\n#### Input #1\n\n```\n2\n2\n1 2\n\n1\n\n6\n1 2\n1 3\n1 4\n4 5\n\
  5 6\n\n0\n\n0\n\n1```\n\n#### Output #1\n\n```\n\n? 2\n\n! 2\n\n? 2\n\n? 6\n\n?\
  \ 4\n\n! 4\n```\n\n### Note\n\nIn the first test case, the mole is in node $2$ initially.\n\
  \nFor the query \"? 2\", the jury returns $1$ because the mole is in subtree $2$.\
  \ After this query, the mole does not move.\n\nThe answer $2$ is the current node\
  \ where the mole is located, so the answer is considered correct.\n\nIn the second\
  \ test case, the mole is in node $6$ initially.\n\nFor the query \"? 2\", the jury\
  \ returns $0$ because the mole is not in subtree $2$. After this query, the mole\
  \ moves from node $6$ to node $5$.\n\nFor the query \"? 6\", the jury returns $0$\
  \ because the mole is not in subtree $6$. After this query, the mole moves from\
  \ node $5$ to node $4$.\n\nFor the query \"? 4\", the jury returns $1$ because the\
  \ mole is in subtree $4$. After this query, the mole does not move.\n\nThe answer\
  \ $4$ is the current node where the mole is located, so the answer is considered\
  \ correct.\n\nPlease note that the example is only for understanding the statement,\
  \ and the queries in the example do not guarantee to determine the unique position\
  \ of the mole."
max_agent_timeout_sec: 300
max_test_timeout_sec: 180
tags: []
