author: LiveCodeBench Pro Team
author_email: shz060@ucsd.edu
difficulty: medium
instruction: "LiveCodeBench Pro (Mini) - external judge.\n\nThe agent must create\
  \ a C++17 solution file at /app/main.cpp.\nThis task does not include local test\
  \ cases. Instead, the test harness:\n  1) POSTs the code to the external judge (/submit)\
  \ to get a sid,\n  2) polls GET /result/{sid}?short=1 until status == \"done\",\n\
  \  3) passes only if the judge returns passed == true.\n\nEnvironment variables\
  \ (overridable at runtime):\n  - BASE_URL: judge base URL (default http://38.80.122.117:8081)\n\
  \  - PID: problem id (default 2035F)\n  - LANG: language (default cpp)\n  - CODE_PATH:\
  \ path to code (default /app/main.cpp)\n  - JUDGE_TIMEOUT_SECS: poll timeout seconds\
  \ (default 120)\n\nThis really says a lot about our society.\n\nOne day, a turtle\
  \ gives you a tree with $n$ nodes rooted at node $x$. Each node has an initial nonnegative\
  \ value; the $i$-th node has starting value $a_i$.\n\nYou want to make the values\
  \ of all nodes equal to $0$. To do so, you will perform a series of operations on\
  \ the tree, where each operation will be performed on a certain node. Define an\
  \ operation on node $u$ as choosing a single node in $u$'s subtree$^{\\text{∗}}$\
  \ and incrementing or decrementing its value by $1$. The order in which operations\
  \ are performed on nodes is as follows:\n\n- For $1 \\le i \\le n$, the $i$-th operation\
  \ will be performed on node $i$.\n- For $i > n$, the $i$-th operation will be performed\
  \ on the same node as operation $i - n$.\n\nMore formally, the $i$-th operation\
  \ will be performed on the $(((i - 1) \\bmod n) + 1)$-th node.$^{\\text{†}}$\n\n\
  Note that you cannot skip over operations; that is, you cannot perform the $i$-th\
  \ operation without first performing operations $1, 2, \\ldots, i - 1$.\n\nFind\
  \ the minimum number of operations you must perform before you can make the values\
  \ of all nodes equal to $0$, assuming you pick operations optimally. If it's impossible\
  \ to make the values of all nodes equal to $0$ after finite operations, output $-1$.\n\
  \n$^{\\text{∗}}$The subtree of a node $u$ is the set of nodes for which $u$ lies\
  \ on the shortest path from this node to the root, including $u$ itself.\n\n$^{\\\
  text{†}}$Here, $a \\bmod b$ denotes the remainder from dividing $a$ by $b$.\n\n\
  ### Input\n\nThe first line contains a single integer $t$ ($1\\le t\\le 100$) --\
  \ the number of test cases.\n\nThe first line of each test case contains two integers\
  \ $n$ and $x$ ($1 \\le n \\le 2000$, $1 \\le x \\le n$) -- the number of nodes and\
  \ the root of the tree.\n\nThe second line of each test case contains $n$ integers\
  \ $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) -- the starting value of each\
  \ node.\n\nEach of the next $n - 1$ lines of each test case contains two integers\
  \ $u$ and $v$ ($1 \\le u, v \\le n$, $u \\neq v$) representing an undirected edge\
  \ from $u$ to $v$. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed\
  \ that the sum of $n$ over all test cases does not exceed $2000$.\n\n### Output\n\
  \nFor each test case, output a single integer denoting the minimum amount of operations\
  \ needed to make all nodes $0$. If it's impossible to make all nodes $0$, output\
  \ $-1$.\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2 1\n\n1 2\n\n1 2\n\n3 2\n\
  \n2 1 3\n\n2 1\n\n3 2\n\n4 1\n\n1 1 0 1\n\n1 2\n\n2 3\n\n1 4\n\n12 6\n\n14 4 5 6\
  \ 12 9 5 11 6 2 1 12\n\n3 9\n\n10 6\n\n6 12\n\n4 3\n\n3 1\n\n5 11\n\n9 7\n\n5 6\n\
  \n1 8\n\n2 8\n\n5 1\n\n1 1\n\n0\n\n```\n\n#### Output #1\n\n```\n3\n6\n5\n145\n\
  0\n```\n\n### Note\n\nIn the first test case, you can make the following valid sequence\
  \ of operations:\n\n- For operation $1$, decrease the value of node $1$. This is\
  \ valid because $(((1 - 1) \\bmod n) + 1) = 1$, and node $1$ is in the subtree of\
  \ node $1$.\n- For operation $2$, decrease the value of node $2$. This is valid\
  \ because $(((2 - 1) \\bmod n) + 1) = 2$, and node $2$ is in the subtree of node\
  \ $2$.\n- For operation $3$, decrease the value of node $2$. This is valid because\
  \ $(((3 - 1) \\bmod n) + 1) = 1$, and node $2$ is in the subtree of node $1$."
max_agent_timeout_sec: 300
max_test_timeout_sec: 180
tags: []
