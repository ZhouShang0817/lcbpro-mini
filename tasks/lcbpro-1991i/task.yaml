author: LiveCodeBench Pro Team
author_email: shz060@ucsd.edu
difficulty: hard
instruction: "LiveCodeBench Pro (Mini) - external judge.\n\nThe agent must create\
  \ a C++17 solution file at /app/main.cpp.\nThis task does not include local test\
  \ cases. Instead, the test harness:\n  1) POSTs the code to the external judge (/submit)\
  \ to get a sid,\n  2) polls GET /result/{sid}?short=1 until status == \"done\",\n\
  \  3) passes only if the judge returns passed == true.\n\nEnvironment variables\
  \ (overridable at runtime):\n  - BASE_URL: judge base URL (default http://38.80.122.117:8081)\n\
  \  - PID: problem id (default 1991I)\n  - LANG: language (default cpp)\n  - CODE_PATH:\
  \ path to code (default /app/main.cpp)\n  - JUDGE_TIMEOUT_SECS: poll timeout seconds\
  \ (default 120)\n\nThis is an interactive problem.\n\nYou are given a grid with\
  \ $n$ rows and $m$ columns. You need to fill each cell with a unique integer from\
  \ $1$ to $n \\cdot m$.\n\nAfter filling the grid, you will play a game on this grid\
  \ against the interactor. Players take turns selecting one of the previously unselected\
  \ cells from the grid, with the interactor going first.\n\nOn the first turn, the\
  \ interactor can choose any cell from the grid. After that, any chosen cell must\
  \ be orthogonally adjacent to at least one previously selected cell. Two cells are\
  \ considered orthogonally adjacent if they share an edge. The game continues until\
  \ all cells have been selected.\n\nYour goal is to let the sum of numbers in the\
  \ cells selected by you be strictly less than the sum of numbers in the cells selected\
  \ by the interactor.\n\n### Input\n\nEach test contains multiple test cases. The\
  \ first line contains a single integer $t$ ($1 \\le t \\le 100$) -- the number of\
  \ test cases. The description of test cases follows.\n\nThe only line of each test\
  \ case contains two integers $n$ and $m$ ($4 \\le n, m \\le 10$) -- the number of\
  \ rows and columns in the grid.\n\n### Interaction\n\nFirst, output $n$ lines, each\
  \ containing $m$ integers, representing the integers that you filled in the grid.\
  \ Each integer from $1$ to $n \\cdot m$ should appear exactly once.\n\nThen, the\
  \ game begins. The interactor and you take turns outputting coordinates to select\
  \ a cell for $n \\times m$ turns, with the interactor starting first.\n\nOn each\
  \ player's (either you or the interactor) turn, the player will output two integers\
  \ $i$ and $j$ ($1 \\le i \\le n$, $1 \\le j \\le m$), denoting that the player has\
  \ selected the cell on the $i$-th row and $j$-th column. This cell should not have\
  \ been selected in a previous round. Additionally, if it is not the first turn,\
  \ the cell must be orthogonally adjacent to at least one previously selected cell.\n\
  \nIf any of your outputs are invalid, the jury will output \"-1\" and you will receive\
  \ a Wrong Answer verdict.\n\nAt the end of all $n \\cdot m$ turns, if the sum of\
  \ numbers in the cells selected by you is not strictly less than the sum of numbers\
  \ in the cells selected by the interactor, the jury will output \"-1\" and you will\
  \ receive a Wrong Answer verdict.\n\nIf your program has received a Wrong Answer\
  \ verdict, it must terminate immediately. Otherwise, you may receive an arbitrary\
  \ verdict because your solution might be reading from a closed stream.\n\nAfter\
  \ outputting, do not forget to output end of line and flush the output. Otherwise,\
  \ you will get Idleness limit exceeded. To do this, use:\n\n- fflush(stdout) or\
  \ cout.flush() in C++;\n- System.out.flush() in Java;\n- flush(output) in Pascal;\n\
  - stdout.flush() in Python;\n- see documentation for other languages.\n\nIn this\
  \ problem, hacks are disabled.\n\n### Example\n\n#### Input #1\n\n```\n1\n4 4\n\n\
  3 4\n\n4 4\n\n4 2\n\n4 1\n\n1 4\n\n1 2\n\n2 2\n\n2 1\n\n```\n\n#### Output #1\n\n\
  ```\n\n2 3 4 10\n12 6 11 15\n5 13 16 8\n9 7 1 14\n\n2 4\n\n4 3\n\n3 3\n\n3 1\n\n\
  1 3\n\n1 1\n\n2 3\n\n3 2```\n\n### Note\n\nNote that this is an example game and\
  \ does not necessarily represent the optimal strategy for both players.\n\nFirst,\
  \ we fill a $4 \\times 4$ grid with unique integers from $1$ to $16$ in the following\
  \ way:\n\n$2\n\n$$3$$\n\n4\n\n$$10$$\n\n12\n\n$$6$$\n\n11\n\n$$15$$\n\n5\n\n$$13$$\n\
  \n16\n\n$$8$$\n\n9\n\n$$7$$\n\n1$$14$\n\nNext, the game begins.\n\n1. The interactor\
  \ first selects $(3, 4)$, which is the number $8$. For this selection, the interactor\
  \ could choose any number. From the next selection onwards, each chosen number has\
  \ to be adjacent to any previously selected number.\n2. We select $(2, 4)$, which\
  \ is the number $15$, adjacent to $(3, 4)$.\n3. The interactor selects $(4, 4)$,\
  \ which is the number $14$, adjacent to $(3, 4)$.\n4. We select $(4, 3)$, which\
  \ is the number $1$, adjacent to $(4, 4)$.\n5. $\\ldots$\n6. This is continued until\
  \ all numbers are selected.\n\nIn the end, the numbers we selected were $[15, 1,\
  \ 16, 5, 4, 2, 11, 13]$, and the numbers selected by the interactor were $[8, 14,\
  \ 7, 9, 10, 3, 6, 12]$. The sum of the numbers we selected is $67$, which is less\
  \ than the sum of the numbers selected by the interactor $69$. Therefore, we have\
  \ won this game."
max_agent_timeout_sec: 300
max_test_timeout_sec: 180
tags: []
